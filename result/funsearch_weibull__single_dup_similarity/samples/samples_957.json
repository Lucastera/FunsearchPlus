{"sample_order": 957, "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n                if available_bins:\n                    for idx in range(len(available_bins)):\n                        prev_sum = sum(bins[:available_bins[idx]])\n                        curr_sum = sum(bins[:available_bins[idx+1]]) if (idx+1) < len(available_bins) else sum(bins)\n                        priorities[available_bins[idx]] = (item - prev_sum) / (curr_sum - prev_sum)\n                else:\n                    priority_sum = 0\n                    for j in range(i, len(bins)):\n                        if bins[j] >= item:\n                            priorities[j] = 0.8\n                            priority_sum += 0.8\n                            if priority_sum == 2.0:\n                                break\n                    if priority_sum < 2.0:\n                        max_idx = np.argmax(bins)\n                        if priorities[max_idx] == 0:\n                            priorities[max_idx] = 1.0\n                            priority_sum += 1.0\n\n    return priorities\n\n", "score": -2067.0}