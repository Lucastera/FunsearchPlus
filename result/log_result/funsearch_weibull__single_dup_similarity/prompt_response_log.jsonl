{"timestamp": "2025-04-27 05:15:52", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 0.8:\n            priorities[i] = 3\n        elif ratios[i] >= 0.5:\n            priorities[i] = 2\n        else:\n            priorities[i] = 1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:15:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = bins[i] - item\n        else:\n            priorities[i] = (item - bins[i]) * 2\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:15:56", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    # Handling special case when item is larger than all bin capacities\n    if item >= np.sum(bins):\n        priorities.fill(-np.inf)\n        return priorities\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + remaining_capacity)\n        else:\n            priorities[i] = -np.inf\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:15:58", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    \n    priorities = np.zeros_like(bins)\n    for i, ratio in enumerate(ratios):\n        if ratio >= 1:\n            priorities[i] = -log_ratios[i]\n        else:\n            priorities[i] = -np.exp(-log_ratios[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:16:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 0.8:\n            priorities[i] = 3\n        elif ratios[i] >= 0.5:\n            priorities[i] = 2\n        else:\n            priorities[i] = 1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 0.8:\n            priorities[i] = 3\n        elif ratios[i] >= 0.5:\n            priorities[i] = 2\n        else:\n            priorities[i] = 1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 0.9:\n            priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            priorities[i] = 2\n        elif ratios[i] >= 0.4:\n            priorities[i] = 1\n        else:\n            priorities[i] = 0\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:16:09", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 0.8:\n            priorities[i] = 3\n        elif ratios[i] >= 0.5:\n            priorities[i] = 2\n        else:\n            priorities[i] = 1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 0.8:\n            priorities[i] = 3\n        elif ratios[i] >= 0.5:\n            priorities[i] = 2\n        else:\n            priorities[i] = 1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 0.9:\n            priorities[i] = 4\n        elif ratios[i] >= 0.7:\n            priorities[i] = 3\n        elif ratios[i] >= 0.5:\n            priorities[i] = 2\n        elif ratios[i] >= 0.3:\n            priorities[i] = 1\n        else:\n            priorities[i] = 0\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:16:11", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 0.8:\n            priorities[i] = 3\n        elif ratios[i] >= 0.5:\n            priorities[i] = 2\n        else:\n            priorities[i] = 1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 0.8:\n            priorities[i] = 3\n        elif ratios[i] >= 0.5:\n            priorities[i] = 2\n        else:\n            priorities[i] = 1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 0.8:\n            priorities[i] = 3\n        elif ratios[i] >= 0.5:\n            priorities[i] = 2\n        else:\n            if bins[i] >= 0.9 * item:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:16:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 0.8:\n            priorities[i] = 3\n        elif ratios[i] >= 0.5:\n            priorities[i] = 2\n        else:\n            priorities[i] = 1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 0.8:\n            priorities[i] = 3\n        elif ratios[i] >= 0.5:\n            priorities[i] = 2\n        else:\n            priorities[i] = 1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 0.8:\n            priorities[i] = 3\n        elif ratios[i] >= 0.5:\n            priorities[i] = 2\n        else:\n            priorities[i] = 1\n\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = 0\n        elif bins[i] == item:\n            priorities[i] = 4\n        else:\n            priorities[i] += 1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:16:15", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = 1 / (bins[i] - item + 1)\n        else:\n            priorities[i] = -1 / (item - bins[i] + 1)\n            \n        if bins[i] < 0:\n            priorities[i] = 0\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:16:17", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = np.log(item / bins[i])\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:16:18", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:16:20", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    for bin_capacity in bins:\n        if bin_capacity >= item:\n            priority = 1.0\n        else:\n            priority = item / bin_capacity\n        priorities.append(priority)\n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:16:25", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:16:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_space = bins[i] - item\n            if remaining_space <= 0:\n                priorities[i] = 0.0\n            else:\n                priorities[i] = np.exp(-item / remaining_space)\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:16:29", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_space = bin_capacity - item\n            if remaining_space > 0:\n                priorities[i] = np.log(1 + item / remaining_space)\n            else:\n                priorities[i] = np.inf\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:16:31", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] > 0.5:\n            priorities[i] = np.log(ratios[i]) + 0.5\n        elif ratios[i] > 0.2:\n            priorities[i] = np.log(ratios[i]) + 0.3\n        else:\n            priorities[i] = np.log(ratios[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:16:39", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = -((item - bins[i]) / bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:16:41", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = -1\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:16:43", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            priorities[i] = item / bins[i]\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:16:45", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_space = bins[i] - item\n            utilization = item / bins[i]\n            penalty = utilization * remaining_space\n            priorities[i] = 1.0 - penalty\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:16:49", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= 0.2 * bins[i]:\n            priorities[i] = item / bins[i]\n        elif item > 0.2 * bins[i] and item <= 0.5 * bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        elif item > 0.5 * bins[i] and item <= 0.8 * bins[i]:\n            priorities[i] = np.cbrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i]) + 1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:16:52", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]/2:\n            priorities[i] = np.sqrt(item / bins[i])\n        elif item > bins[i]/2 and item <= 2*bins[i]/3:\n            priorities[i] = np.log(item / bins[i])\n        else:\n            priorities[i] = item / bins[i] + np.sqrt(item / bins[i]) + np.log(item / bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:16:55", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        elif item > bins[i] and item <= 2 * bins[i]:\n            priorities[i] = np.power(item / bins[i], 1.5)\n        elif item > 2 * bins[i] and item <= 3 * bins[i]:\n            priorities[i] = np.power(item / bins[i], 2)\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:16:59", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/4:\n            priorities[i] = np.exp(item / bins[i])\n        elif item > bins[i]/4 and item <= bins[i]/2:\n            priorities[i] = np.cbrt(item / bins[i])\n        elif item > bins[i]/2 and item <= 3 * bins[i]/4:\n            priorities[i] = np.tan(item / bins[i])\n        else:\n            priorities[i] = np.sin(item / bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:17:02", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            priorities[i] = 1 - (bin_capacity / item)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:17:05", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1 / (bin_capacity - item + 1)\n        else:\n            priorities[i] = -1 / (item - bin_capacity + 1)\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:17:08", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "import numpy as np\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item < bins[i] * 0.5:\n            priorities[i] = 1 / (bins[i] - item)\n        elif item >= bins[i] * 0.5 and item < bins[i] * 0.8:\n            priorities[i] = 0.5 / (bins[i] - item)\n        else:\n            priorities[i] = 0.1 / (bins[i] - item)\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:17:10", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = -np.log(item / bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:17:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            priorities[i] = item / bins[i]\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:17:16", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:17:19", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= 0:\n            priorities[i] = np.inf\n        elif item > bins[i]:\n            priorities[i] = -np.inf\n        else:\n            ratios = item / bins[i]\n            log_ratios = np.log(ratios)\n            priorities[i] = -log_ratios\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:17:20", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for idx, bin_capacity in enumerate(bins):\n        if item <= bin_capacity / 2:\n            priorities[idx] = 0.5\n        elif item <= bin_capacity:\n            priorities[idx] = 1\n        else:\n            priorities[idx] = np.log(item / bin_capacity)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:17:25", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 0.8:\n            priorities[i] = 3\n        elif ratios[i] >= 0.5:\n            priorities[i] = 2\n        else:\n            priorities[i] = 1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 0.8:\n            priorities[i] = 3\n        elif ratios[i] >= 0.5:\n            priorities[i] = 2\n        else:\n            priorities[i] = 1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.5:\n            if item < 5:\n                priorities[i] = 1\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:17:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 0.8:\n            priorities[i] = 3\n        elif ratios[i] >= 0.5:\n            priorities[i] = 2\n        else:\n            priorities[i] = 1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 0.8:\n            priorities[i] = 3\n        elif ratios[i] >= 0.5:\n            priorities[i] = 2\n        else:\n            priorities[i] = 1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 0.8:\n            priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            priorities[i] = 2\n        elif ratios[i] >= 0.4:\n            priorities[i] = 1\n        else:\n            priorities[i] = 0\n    \n    total_capacity = np.sum(bins)\n    avg_capacity = total_capacity / len(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] > 1.2 * avg_capacity:\n            priorities[i] += 1\n        elif bins[i] < 0.8 * avg_capacity:\n            priorities[i] -= 1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:17:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 0.8:\n            priorities[i] = 3\n        elif ratios[i] >= 0.5:\n            priorities[i] = 2\n        else:\n            priorities[i] = 1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 0.8:\n            priorities[i] = 3\n        elif ratios[i] >= 0.5:\n            priorities[i] = 2\n        else:\n            priorities[i] = 1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 0.8:\n            priorities[i] = 3\n        elif ratios[i] >= 0.5:\n            priorities[i] = 2\n        elif bins[i] == 0:\n            priorities[i] = 0\n        else:\n            priorities[i] = 1\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] -= 1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:17:32", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 0.8:\n            priorities[i] = 3\n        elif ratios[i] >= 0.5:\n            priorities[i] = 2\n        else:\n            priorities[i] = 1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 0.8:\n            priorities[i] = 3\n        elif ratios[i] >= 0.5:\n            priorities[i] = 2\n        else:\n            priorities[i] = 1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 0.8:\n            priorities[i] = 3\n        elif ratios[i] >= 0.5:\n            priorities[i] = 2\n        elif ratios[i] >= 0.3:\n            priorities[i] = 1\n        else:\n            priorities[i] = 0\n            \n        if bins[i] < 0.2 * item:\n            priorities[i] = -1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:17:38", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]*0.75:\n            priorities[i] = np.sqrt(item / bins[i])\n        elif item > bins[i]*0.75 and item <= bins[i]:\n            priorities[i] = np.cbrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:17:41", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]/2:\n            priorities[i] = np.sqrt(item / bins[i])\n        elif item > bins[i]/2 and item <= 2 * bins[i]/3:\n            priorities[i] = np.square(item / bins[i])\n        elif item > 2 * bins[i]/3 and item <= bins[i]:\n            priorities[i] = np.cbrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i]) / np.log(10)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:17:43", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/4:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/4 and item <= bins[i]/2:\n            priorities[i] = np.sqrt(item / bins[i])\n        elif item > bins[i]/2 and item <= bins[i]*3/4:\n            priorities[i] = item / bins[i] * 1.5\n        else:\n            priorities[i] = np.log(item / bins[i]) * 2\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:17:46", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]/4:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/4 and item <= bins[i]/2:\n            priorities[i] = np.sqrt(item / bins[i])\n        elif item > bins[i]/2 and item <= 3*bins[i]/4:\n            priorities[i] = np.log(item / bins[i])\n        else:\n            priorities[i] = item / (2 * bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:17:47", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "import numpy as np\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    size_diffs = bins - item\n    size_diffs[size_diffs < 0] = np.inf\n    sorted_indices = np.argsort(size_diffs)\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_idx in enumerate(sorted_indices):\n        priorities[bin_idx] = i + 1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:17:49", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i] / 2:\n            priorities[i] = 1.0\n        elif item <= bins[i]:\n            priorities[i] = 0.7\n        elif item <= bins[i] * 2:\n            priorities[i] = 0.4\n        else:\n            priorities[i] = 0.1\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:17:51", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = bins[i] / item\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:17:53", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1 / (bins[i] - item + 1)\n        else:\n            priorities[i] = -1\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:18:02", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.5:\n            priorities[i] = ratio\n        elif ratio >= 0.5 and ratio < 1.0:\n            priorities[i] = -np.log(ratio)\n        else:\n            priorities[i] = -np.log(ratio) * 2\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:18:04", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            priorities[i] = (remaining_space / bins[i]) ** 2\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:18:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:18:08", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == 0:\n            priorities[i] = 0\n        else:\n            priorities[i] = item / bins[i]\n    \n    max_priority = max(priorities)\n    if max_priority != 0:\n        priorities = [p / max_priority for p in priorities]\n    \n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:18:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n        if priorities[i] <= 0.3:\n            priorities[i] *= 1.5\n        elif priorities[i] > 0.3 and priorities[i] <= 0.7:\n            priorities[i] *= 2\n        else:\n            priorities[i] *= 3\n        \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:18:16", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = item - bins[i]\n        elif bins[i] == min_capacity:\n            priorities[i] = bins[i] - item\n        else:\n            priorities[i] = abs(item - bins[i]) / (max_capacity - min_capacity)\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:18:18", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Further improved version of `priority_v1`.\n    Now considering additional factors for priority calculation.\n    \"\"\"\n    \n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n    \n    # Add an additional factor based on bin capacity ratio\n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        priorities[i] += 0.5 * (max_bin_capacity - bins[i])  # Adjust priority based on capacity ratio\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:18:20", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n            \n        if bins[i] < item / 2:\n            priorities[i] *= 1.5\n        else:\n            priorities[i] *= 1.2\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:18:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 0.8:\n            priorities[i] = 3\n        elif ratios[i] >= 0.5:\n            priorities[i] = 2\n        else:\n            priorities[i] = 1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.5:\n            if item < 5:\n                priorities[i] = 1\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.5:\n            if item < 5:\n                priorities[i] = 1\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:18:32", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 0.8:\n            priorities[i] = 3\n        elif ratios[i] >= 0.5:\n            priorities[i] = 2\n        else:\n            priorities[i] = 1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.5:\n            if item < 5:\n                priorities[i] = 1\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.5:\n            if item < 5:\n                priorities[i] = 1\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                if item > 5:\n                    priorities[i] = 2\n                else:\n                    for j in range(i):\n                        if bins[j] > 3:\n                            priorities[i] += 1\n                        else:\n                            priorities[i] += 0.5\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:18:34", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 0.8:\n            priorities[i] = 3\n        elif ratios[i] >= 0.5:\n            priorities[i] = 2\n        else:\n            priorities[i] = 1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.5:\n            if item < 5:\n                priorities[i] = 1\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:18:37", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 0.8:\n            priorities[i] = 3\n        elif ratios[i] >= 0.5:\n            priorities[i] = 2\n        else:\n            priorities[i] = 1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.5:\n            if item < 5:\n                priorities[i] = 1\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and item % 2 == 0:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.5:\n            if item < 5:\n                priorities[i] = 1\n            elif bins[i] > 10:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            elif item % 3 == 0:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:18:42", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n\n    for bin_capacity in bins:\n        if item > bin_capacity:\n            priority = 0\n        else:\n            remaining_capacity = bin_capacity - item\n            priority = 1 / remaining_capacity\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:18:45", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] > 0:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = np.inf\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:18:46", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            priorities[i] = -1 * (item - bin_capacity)\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:18:49", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            priority = (bin_capacity - item) / bin_capacity\n        else:\n            priority = -1\n        priorities.append(priority)\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:18:51", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % 2 == 0:\n                priority = 1 / (bin_capacity - item + 1)\n            else:\n                priority = 2 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:18:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % 2 == 0:\n                priority = 1 / (bin_capacity - item + 2)\n            else:\n                priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:18:56", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        if i % 2 == 0:\n            priority *= 2\n        else:\n            priority /= 2\n        priorities.append(priority)\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:18:59", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            priority = 1 / (bin_capacity - item + 1)\n            if bin_capacity > 2 * item:\n                priority *= 1.5\n        else:\n            priority = -1\n        priorities.append(priority)\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:19:02", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= 0 or bins[i] <= 0:\n            priorities[i] = 0\n        elif item <= bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = bins[i] / item\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:19:04", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            remaining_space = bins[i] - item\n            ratio = remaining_space / bins[i]\n            if ratio > 0.5:\n                priorities[i] = 1 / ratio\n            else:\n                priorities[i] = -np.log(ratio)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:19:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:19:08", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = bins[i] / item\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:19:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(matrix: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(matrix)\n    \n    rows, cols = matrix.shape\n    \n    for i in range(rows):\n        for j in range(cols):\n            if i % 2 == 0:\n                result[i, j] = matrix[i, j] * 2\n            else:\n                result[i, j] = matrix[i, j] / 2\n                \n            if j % 2 == 0:\n                result[i, j] = result[i, j] + 5\n            else:\n                result[i, j] = result[i, j] - 5\n                \n            if result[i, j] < 0:\n                result[i, j] = 0\n            elif result[i, j] > 10:\n                result[i, j] = 10\n                \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:19:16", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(input_list: list) -> int:\n    total_sum = 0\n    \n    for i in range(len(input_list)):\n        if input_list[i] % 2 == 0:\n            total_sum += input_list[i]\n        else:\n            total_sum -= input_list[i]\n    \n    if total_sum > 100:\n        return total_sum // 2\n    elif total_sum < -100:\n        return total_sum * 2\n    else:\n        return total_sum + 50", "strategy": []}
{"timestamp": "2025-04-27 05:19:18", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_function(data: np.ndarray, threshold: float) -> np.ndarray:\n    result = np.zeros(len(data))\n    \n    for i in range(len(data)):\n        if data[i] < threshold:\n            result[i] = data[i] ** 2\n        elif data[i] >= threshold and data[i] < threshold * 2:\n            result[i] = data[i] ** 0.5\n        else:\n            result[i] = threshold / data[i]\n    \n    return result\n```", "strategy": []}
{"timestamp": "2025-04-27 05:19:20", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(input_list: list) -> list:\n    output_list = []\n\n    for i in range(len(input_list)):\n        if i % 2 == 0:\n            if input_list[i] % 2 == 0:\n                output_list.append(input_list[i] * 2)\n            else:\n                output_list.append(input_list[i] + 5)\n        else:\n            if input_list[i] % 2 == 0:\n                output_list.append(input_list[i] + 10)\n            else:\n                output_list.append(input_list[i] * 3)\n\n    return output_list", "strategy": []}
{"timestamp": "2025-04-27 05:19:24", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]*2/3:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:19:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        elif item > bins[i] and item <= bins[i]*2:\n            priorities[i] = np.power(item / bins[i], 3)\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:19:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/4:\n            priorities[i] = np.power(item / bins[i], 2)\n        elif item > bins[i]/4 and item <= bins[i]/2:\n            priorities[i] = np.cbrt(item / bins[i])\n        elif item > bins[i]/2 and item <= 3*bins[i]/4:\n            priorities[i] = np.square(np.sqrt(item / bins[i]))\n        else:\n            priorities[i] = np.exp(item / bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:19:32", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            if item % 2 == 0:\n                priorities[i] = np.log(item / bins[i]) + np.sin(item)\n            else:\n                priorities[i] = np.log(item / bins[i]) - np.cos(item)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:19:37", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Further improved version of `priority_v1`.\n    Now considering additional factors for priority calculation.\n    \"\"\"\n    \n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n    \n    # Add an additional factor based on bin capacity ratio\n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        priorities[i] += 0.5 * (max_bin_capacity - bins[i])  # Adjust priority based on capacity ratio\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = item - bins[i]\n        elif bins[i] == min_capacity:\n            priorities[i] = bins[i] - item\n        else:\n            priorities[i] = abs(item - bins[i]) / (max_capacity - min_capacity)\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Further improved version of `priority_v1`.\n    Now considering multiple factors for priority calculation.\n    \"\"\"\n\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n    avg_capacity = np.mean(bins)\n    total_capacity = np.sum(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = abs(item - bins[i]) / (avg_capacity - min_capacity)\n        elif bins[i] == min_capacity:\n            priorities[i] = abs(item - bins[i]) / (avg_capacity - max_capacity)\n        else:\n            priorities[i] = (item - bins[i]) / total_capacity\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:19:39", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Further improved version of `priority_v1`.\n    Now considering additional factors for priority calculation.\n    \"\"\"\n    \n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n    \n    # Add an additional factor based on bin capacity ratio\n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        priorities[i] += 0.5 * (max_bin_capacity - bins[i])  # Adjust priority based on capacity ratio\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = item - bins[i]\n        elif bins[i] == min_capacity:\n            priorities[i] = bins[i] - item\n        else:\n            priorities[i] = abs(item - bins[i]) / (max_capacity - min_capacity)\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    total_capacity = np.sum(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = item - bins[i]\n        elif bins[i] == min_capacity:\n            priorities[i] = bins[i] - item\n        else:\n            priorities[i] = (item - bins[i]) / total_capacity\n            if item > max_capacity:\n                priorities[i] *= 1.5\n            elif item < min_capacity:\n                priorities[i] *= 0.75\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:19:42", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Further improved version of `priority_v1`.\n    Now considering additional factors for priority calculation.\n    \"\"\"\n    \n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n    \n    # Add an additional factor based on bin capacity ratio\n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        priorities[i] += 0.5 * (max_bin_capacity - bins[i])  # Adjust priority based on capacity ratio\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = item - bins[i]\n        elif bins[i] == min_capacity:\n            priorities[i] = bins[i] - item\n        else:\n            priorities[i] = abs(item - bins[i]) / (max_capacity - min_capacity)\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Further improved version of `priority_v1`.\n    Now considering additional factors for priority calculation.\n    \"\"\"\n\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = item - bins[i]\n        elif bins[i] == min_capacity:\n            priorities[i] = bins[i] - item\n        else:\n            priority_factor1 = abs(item - bins[i]) / (max_capacity - min_capacity)\n            priority_factor2 = 0.3 * bins[i]  # Additional factor based on bin capacity\n            priorities[i] = priority_factor1 + priority_factor2\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:19:44", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Further improved version of `priority_v1`.\n    Now considering additional factors for priority calculation.\n    \"\"\"\n    \n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n    \n    # Add an additional factor based on bin capacity ratio\n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        priorities[i] += 0.5 * (max_bin_capacity - bins[i])  # Adjust priority based on capacity ratio\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = item - bins[i]\n        elif bins[i] == min_capacity:\n            priorities[i] = bins[i] - item\n        else:\n            priorities[i] = abs(item - bins[i]) / (max_capacity - min_capacity)\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "import numpy as np\n\n\ndef priority_v3(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = 1.5 * (item - bins[i]) if item > bins[i] else (item - bins[i])\n        elif bins[i] == min_capacity:\n            priorities[i] = 1.5 * (bins[i] - item) if bins[i] > item else (bins[i] - item)\n        else:\n            priorities[i] = abs(item - bins[i]) / (max_capacity - min_capacity)\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:19:49", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    size_diffs = bins - item\n    size_diffs[size_diffs < 0] = np.inf\n    sorted_indices = np.argsort(size_diffs)\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_idx in enumerate(sorted_indices):\n        priorities[bin_idx] = i + 1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros(data.shape)\n\n    for i in range(data.shape[0]):\n        for j in range(data.shape[1]):\n            if data[i, j] < 0:\n                result[i, j] = 0\n            elif data[i, j] % 2 == 0:\n                result[i, j] = data[i, j] * 2\n            else:\n                result[i, j] = data[i, j] * 3\n\n    return result\n```", "strategy": []}
{"timestamp": "2025-04-27 05:19:51", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    size_diffs = bins - item\n    size_diffs[size_diffs < 0] = np.inf\n    sorted_indices = np.argsort(size_diffs)\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_idx in enumerate(sorted_indices):\n        priorities[bin_idx] = i + 1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    for i, bin_capacity in enumerate(bins):\n        if item > bin_capacity:\n            priorities[i] = np.inf\n        else:\n            priority_score = 0\n            remaining_capacity = bin_capacity - item\n            for j, other_bin_capacity in enumerate(bins):\n                if i != j and other_bin_capacity >= item:\n                    priority_score += 1\n            priorities[i] = priority_score\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:19:53", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    size_diffs = bins - item\n    size_diffs[size_diffs < 0] = np.inf\n    sorted_indices = np.argsort(size_diffs)\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_idx in enumerate(sorted_indices):\n        priorities[bin_idx] = i + 1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    sorted_bins = np.argsort(bins)\n    \n    for i, bin_idx in enumerate(sorted_bins):\n        remaining_capacity = bins[bin_idx] - item\n        if remaining_capacity >= 0:\n            priorities[bin_idx] = i + 1\n        else:\n            for j in range(i, len(bins)):\n                if bins[sorted_bins[j]] >= item:\n                    priorities[sorted_bins[j]] = j + 1\n                    break\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:19:55", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    size_diffs = bins - item\n    size_diffs[size_diffs < 0] = np.inf\n    sorted_indices = np.argsort(size_diffs)\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_idx in enumerate(sorted_indices):\n        priorities[bin_idx] = i + 1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    if item <= 0:\n        return priorities\n    \n    for i, bin_size in enumerate(bins):\n        if item <= bin_size:\n            priorities[i] = bin_size / item\n        else:\n            priorities[i] = 0.5 * bin_size / item\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:20:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.25:\n                priorities[i] = 1/ratios\n            elif ratios < 0.5:\n                priorities[i] = 2 * np.log(ratios)\n            elif ratios < 0.75:\n                priorities[i] = np.log(ratios) + 1\n            else:\n                priorities[i] = np.log(ratios) * 2\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:20:37", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if item % bins[i] == 0:\n                priorities[i] = 0.5\n            elif ratios < 0.5:\n                priorities[i] = 1 / (ratios * 0.5)\n            else:\n                priorities[i] = np.log10(ratios) if np.log10(ratios) > 1 else 1\n            \n            if bins[i] % 2 == 0:\n                priorities[i] *= 2\n            elif bins[i] % 3 == 0:\n                priorities[i] /= 2\n            else:\n                priorities[i] = max(priorities[i], 1)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:20:43", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            if item < 0.2 * bins[i]:\n                priorities[i] = 5\n            elif item < 0.4 * bins[i]:\n                priorities[i] = 4\n            elif item < 0.6 * bins[i]:\n                priorities[i] = 3\n            elif item < 0.8 * bins[i]:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:20:45", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.2:\n                priorities[i] = 1 / ratios\n            elif ratios >= 0.2 and ratios < 0.5:\n                priorities[i] = 2 / ratios\n            elif ratios >= 0.5 and ratios < 0.8:\n                priorities[i] = 3 / ratios\n            else:\n                priorities[i] = np.log(ratios) + np.sqrt(ratios)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:20:52", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(input_data: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(input_data)\n    \n    for i in range(len(input_data)):\n        if input_data[i] % 2 == 0:\n            result[i] = input_data[i] ** 2\n        elif input_data[i] % 3 == 0:\n           result[i] = input_data[i] * 3\n        else:\n           result[i] = input_data[i] + 10\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:20:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def process_data(data: np.ndarray) -> np.ndarray:\n    result = np.zeros(data.shape)\n    \n    for i in range(data.shape[0]):\n        for j in range(data.shape[1]):\n            if data[i, j] < 0:\n                result[i, j] = 0\n            elif data[i, j] >= 0 and data[i, j] < 10:\n                result[i, j] = data[i, j] * 2\n            else:\n                result[i, j] = data[i, j] ** 2\n            \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:20:56", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(input_data: np.ndarray) -> np.ndarray:\n    result = np.zeros(len(input_data))\n    \n    for i in range(len(input_data)):\n        if input_data[i] < 0:\n            result[i] = -input_data[i]\n        else:\n            temp = input_data[i]\n            for j in range(1, int(temp)+1):\n                if temp % j == 0:\n                    result[i] += j\n                \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:20:59", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray, threshold: float) -> np.ndarray:\n    result = np.zeros_like(data)\n    \n    for i in range(len(data)):\n        if data[i] < threshold:\n            result[i] = data[i] ** 2\n        else:\n            count = 0\n            for j in range(1, data[i] + 1):\n                if data[i] % j == 0:\n                    count += 1\n            result[i] = count\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:21:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Further improved version of `priority_v1`.\n    Now considering additional factors for priority calculation.\n    \"\"\"\n    \n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n    \n    # Add an additional factor based on bin capacity ratio\n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        priorities[i] += 0.5 * (max_bin_capacity - bins[i])  # Adjust priority based on capacity ratio\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even further improved version of `priority_v1`.\n    Now adding more complexity to priority calculation.\n    \"\"\"\n    \n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = (bins[i] - item) ** 2  # Square the difference for more complexity\n    \n    # Add an additional factor based on even-odd index of bins\n    for i in range(len(bins)):\n        if i % 2 == 0:\n            priorities[i] *= 1.5  # Increase priority for even index bins\n        else:\n            priorities[i] *= 0.5  # Decrease priority for odd index bins\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:21:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Further improved version of `priority_v1`.\n    Now considering additional factors for priority calculation.\n    \"\"\"\n    \n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n    \n    # Add an additional factor based on bin capacity ratio\n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        priorities[i] += 0.5 * (max_bin_capacity - bins[i])  # Adjust priority based on capacity ratio\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n    \n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        if bins[i] == max_bin_capacity:\n            priorities[i] += 1.5 * max_bin_capacity  # Increase priority for bins with max capacity\n        elif bins[i] <= 0.5 * max_bin_capacity:\n            priorities[i] -= 0.3 * bins[i]  # Decrease priority for bins with very low capacity\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:21:09", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Further improved version of `priority_v1`.\n    Now considering additional factors for priority calculation.\n    \"\"\"\n    \n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n    \n    # Add an additional factor based on bin capacity ratio\n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        priorities[i] += 0.5 * (max_bin_capacity - bins[i])  # Adjust priority based on capacity ratio\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even further improved version of `priority_v1`.\n    Introducing more complex logic for priority calculation.\n    \"\"\"\n    \n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 3 * (item - bins[i])  # Triple the priority\n        else:\n            priorities[i] = 1.5 * bins[i] - item\n    \n    # Add an additional factor based on bin position\n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        priorities[i] += 0.2 * i  # Adjust priority based on bin position\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:21:11", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Further improved version of `priority_v1`.\n    Now considering additional factors for priority calculation.\n    \"\"\"\n    \n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n    \n    # Add an additional factor based on bin capacity ratio\n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        priorities[i] += 0.5 * (max_bin_capacity - bins[i])  # Adjust priority based on capacity ratio\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n        \n        if bins[i] < 0.5 * item:\n            priorities[i] *= 1.5  # Increase priority for bins with low capacity\n        elif bins[i] > 1.5 * item:\n            priorities[i] *= 0.5  # Decrease priority for bins with high capacity\n        else:\n            priorities[i] *= 1.0  # Keep priority unchanged\n        \n        if i % 2 == 0:\n            priorities[i] += 2  # Add additional priority for even-indexed bins\n        else:\n            priorities[i] -= 1  # Reduce priority for odd-indexed bins\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:21:18", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = np.log(item / bins[i])\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:21:20", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = 1 - item / bins[i]\n        else:\n            priorities[i] = 0\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:21:21", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 1:\n            priorities[i] = -np.log(ratios[i])\n        else:\n            priorities[i] = (1 / ratios[i]) - 1\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:21:23", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = -1\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:21:25", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % 2 == 0:\n                priority = 1 / (bin_capacity - item + 1)\n            else:\n                priority = 1 / (bin_capacity - item + 2)\n        else:\n            priority = -1\n        priorities.append(priority)\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:21:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:21:29", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            priority = 1 / (bin_capacity - item + 1)\n            if priority > 0.5:\n                priority *= 1.5\n            elif priority <= 0.1:\n                priority *= 0.1\n        else:\n            priority = -1\n        priorities.append(priority)\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:21:32", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity < 2 * item:\n                priority = 1 / (bin_capacity + item)\n            else:\n                priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:21:37", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            elif item > 5:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            elif bins[i] < 5:\n                priorities[i] = 1\n            else:\n                priorities[i] = 2\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:21:40", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    for i in range(len(bins)):\n        if item % 2 == 0:\n            priorities[i] += 1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:21:43", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                if item < 5:\n                    priorities[i] = 1\n                else:\n                    for j in range(len(bins)):\n                        if bins[j] > 10:\n                            priorities[i] = 3\n                            break\n                    else:\n                        priorities[i] = 2\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:21:46", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n                \n        if item % 2 == 0:\n            priorities[i] += 1\n        else:\n            priorities[i] -= 1\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:21:48", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/4:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/4 and item <= bins[i]/2:\n            priorities[i] = np.sqrt(item / bins[i])\n        elif item > bins[i]/2 and item <= 3*bins[i]/4:\n            priorities[i] = np.power(item / bins[i], 2)\n        else:\n            priorities[i] = np.log(item / bins[i]) + 0.5\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:21:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]/2:\n            priorities[i] = np.sqrt(item / bins[i])\n        elif item > bins[i]/2 and item <= 2 * bins[i]/3:\n            priorities[i] = np.exp(item / bins[i])\n        elif item > 2 * bins[i]/3 and item <= bins[i]:\n            priorities[i] = np.log(item / bins[i])\n        else:\n            priorities[i] = np.cbrt(item / bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:21:53", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/4:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/4 and item <= bins[i]/2:\n            priorities[i] = np.sqrt(item / bins[i])\n        elif item > bins[i]/2 and item <= bins[i]*3/4:\n            priorities[i] = np.cbrt(item / bins[i])\n        else:\n            priorities[i] = np.log10(item / bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:21:55", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def custom_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]*2/3:\n            priorities[i] = np.sqrt(item / bins[i])\n        elif item > bins[i]*2/3 and item <= bins[i]:\n            priorities[i] = np.power(item / bins[i], 1.5)\n        else:\n            priorities[i] = np.log(item / bins[i]) + bins[i]/item\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:21:58", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.2:\n                priorities[i] = 1 / ratios\n            elif 0.2 <= ratios < 0.5:\n                priorities[i] = 2 / ratios\n            elif 0.5 <= ratios < 0.8:\n                priorities[i] = 3 / ratios\n            else:\n                priorities[i] = np.sqrt(ratios)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:22:00", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1` with additional logic.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.2:\n                priorities[i] = 1/ratios\n            elif ratios >= 0.2 and ratios < 0.5:\n                priorities[i] = np.sqrt(ratios)\n            elif ratios >= 0.5 and ratios < 0.8:\n                priorities[i] = np.cbrt(ratios)\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:22:02", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.25:\n                priorities[i] = 1 / ratios\n            elif ratios < 0.5:\n                priorities[i] = 2 / ratios\n            else:\n                priorities[i] = np.log(ratios) + np.sqrt(ratios)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:22:05", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.25:\n                priorities[i] = 1 / ratios\n            elif ratios >= 0.25 and ratios < 0.5:\n                priorities[i] = 2 / ratios\n            elif ratios >= 0.5 and ratios < 0.75:\n                priorities[i] = 3 / ratios\n            elif ratios >= 0.75 and ratios < 1.0:\n                priorities[i] = 4 / ratios\n            else:\n                priorities[i] = np.log(ratios) + 5\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:22:07", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            priorities[i] = 1 - (bin_capacity / item)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            priorities[i] = 1 - (bin_capacity / item)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            if item == bin_capacity:\n                priorities[i] = 0.5\n            else:\n                priorities[i] = (item + bin_capacity) / (2 * item)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:22:10", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            priorities[i] = 1 - (bin_capacity / item)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            priorities[i] = 1 - (bin_capacity / item)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:22:12", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            priorities[i] = 1 - (bin_capacity / item)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            priorities[i] = 1 - (bin_capacity / item)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == 0:\n            priorities[i] = 0\n        elif item < bin_capacity/2:\n            priorities[i] = item / bin_capacity\n        elif item >= bin_capacity/2 and item < bin_capacity:\n            priorities[i] = (item - bin_capacity/2) / (bin_capacity/2)\n        else:\n            priorities[i] = 1 - (bin_capacity / item)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:22:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            priorities[i] = 1 - (bin_capacity / item)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            priorities[i] = 1 - (bin_capacity / item)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == 0:\n            priorities[i] = 0\n        elif item < bin_capacity * 0.5:\n            priorities[i] = item / bin_capacity * 0.5\n        elif item >= bin_capacity * 0.8:\n            priorities[i] = 1 - (bin_capacity / item) * 0.8\n        else:\n            priorities[i] = (item + bin_capacity) / (item * bin_capacity)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:22:21", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Updated version of `priority_v1` with more complex logic.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                if item > 2 * bin_capacity:\n                    priorities[i] = 0.0\n                else:\n                    priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity)) + (i * 0.1)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:22:24", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Further improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n\n    # Additional check for special conditions\n    if sum(bins) < item:\n        priorities = np.full(len(bins), 0.0)\n    elif all(bin_capacity >= item for bin_capacity in bins):\n        priorities = np.full(len(bins), 1.0)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:22:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = []\n                for k, capacity in enumerate(bins):\n                    if capacity >= item:\n                        available_bins.append(k)\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        priorities[available_bins[idx]] = (item - bins[available_bins[idx-1]]) / (bins[available_bins[idx]] - bins[available_bins[idx-1]])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:22:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                extra_capacity_needed = item - remaining_capacity\n                feasible_bins = [bins[k] for k in range(i) if bins[k] >= extra_capacity_needed]\n                if feasible_bins:\n                    min_feasible_bin = min(feasible_bins)\n                    min_feasible_bin_index = bins.index(min_feasible_bin)\n                    min_extra_capacity = min_feasible_bin - extra_capacity_needed\n                    priorities[i] = 1 - (min_extra_capacity / (bin_capacity - remaining_capacity))\n                    priorities[min_feasible_bin_index] = 1.0\n                else:\n                    priorities[i] = 0.0\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:22:36", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(matrix: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(matrix)\n    \n    for i in range(matrix.shape[0]):\n        for j in range(matrix.shape[1]):\n            if matrix[i, j] % 2 == 0:\n                result[i, j] = matrix[i, j] * 2\n            elif matrix[i, j] % 3 == 0:\n                result[i, j] = matrix[i, j] * 3\n            else:\n                result[i, j] = matrix[i, j]\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:22:38", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(input_array: np.ndarray, threshold: float) -> np.ndarray:\n    output_array = np.zeros(len(input_array))\n    \n    for i in range(len(input_array)):\n        sum_val = 0\n        for j in range(i, len(input_array)):\n            if input_array[j] > threshold:\n                sum_val += input_array[j]\n            else:\n                sum_val -= input_array[j]\n        \n        output_array[i] = sum_val\n    \n    return output_array", "strategy": []}
{"timestamp": "2025-04-27 05:22:40", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros(len(data))\n    \n    for i in range(len(data)):\n        if data[i] % 2 == 0:\n            result[i] = data[i] ** 2\n        else:\n            if data[i] > 0:\n                result[i] = data[i] * 3\n            else:\n                result[i] = data[i] + 10\n                \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:22:42", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    output = np.zeros(data.shape)\n\n    for i in range(data.shape[0]):\n        for j in range(data.shape[1]):\n            if data[i, j] % 2 == 0:\n                output[i, j] = data[i, j] * 2\n            elif data[i, j] % 3 == 0:\n                output[i, j] = data[i, j] * 3\n            else:\n                output[i, j] = data[i, j]\n\n    return output", "strategy": []}
{"timestamp": "2025-04-27 05:22:46", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = 1 / (bins[i] - item + 1)\n        else:\n            priorities[i] = 0\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:22:48", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= 0:\n            priorities[i] = np.inf\n        elif item > bins[i]:\n            priorities[i] = -np.inf\n        else:\n            priorities[i] = item / bins[i]\n    \n    priorities = np.where(priorities == np.inf, np.max(priorities) + 1, priorities)\n    priorities = np.where(priorities == -np.inf, np.min(priorities) - 1, priorities)\n    \n    return priorities\n", "strategy": []}
{"timestamp": "2025-04-27 05:22:49", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = np.exp(item - bins[i])\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:22:51", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:22:55", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.25:\n                priorities[i] = 1/ratios\n            elif ratios >= 0.25 and ratios < 0.5:\n                priorities[i] = np.sqrt(ratios)\n            elif ratios >= 0.5 and ratios < 0.75:\n                priorities[i] = np.cbrt(ratios)\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:22:57", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            if item % 2 == 0:\n                priorities[i] = item * 2\n            else:\n                priorities[i] = item / 2\n                \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:23:00", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.25:\n                priorities[i] = 1.5 / ratios\n            elif ratios < 0.5:\n                priorities[i] = 1 / ratios\n            elif ratios < 0.75:\n                priorities[i] = 0.75 / ratios\n            else:\n                priorities[i] = np.log(ratios) * (1 + (ratios - 0.75))\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:23:02", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            if item < 0.3 * bins[i]:\n                priorities[i] = 3 * np.log(bins[i]/item)\n            elif item < 0.6 * bins[i]:\n                priorities[i] = 1.5 * np.log(bins[i]/item)\n            else:\n                priorities[i] = np.log(bins[i]/item)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:23:05", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    # Calculate remaining capacities of each bin after adding the item\n    remaining_capacities = bins - item\n    \n    # Calculate utilization ratios of each bin\n    ratios = remaining_capacities / bins\n    \n    # Initialize priorities array\n    priorities = np.zeros_like(bins)\n    \n    # Assign priorities based on utilization ratios\n    for i, ratio in enumerate(ratios):\n        if ratio >= 0.75:\n            priorities[i] = 3\n        elif ratio >= 0.5:\n            priorities[i] = 2\n        elif ratio >= 0.25:\n            priorities[i] = 1\n        else:\n            priorities[i] = 0\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:23:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(items: np.ndarray, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for item in items:\n        ratios = item / bins\n        log_ratios = np.log(ratios)\n        priorities += -log_ratios\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:23:08", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "import numpy as np\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i] - item\n            utilization_ratio = item / bins[i]\n            priorities[i] = 1.0 / (1.0 + np.exp(utilization_ratio)) * remaining_capacity\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:23:10", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n    \n    for ratio in ratios:\n        if ratio < 0.5:\n            priority = 1 / (1 + np.exp(-10*(ratio-0.25)))\n        elif ratio >= 0.5 and ratio < 1:\n            priority = 1 / (1 + np.exp(-5*(ratio-0.75)))\n        else:\n            priority = -np.log(ratio)\n        \n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:23:17", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(matrix: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(matrix)\n    \n    for i in range(matrix.shape[0]):\n        for j in range(matrix.shape[1]):\n            if matrix[i][j] % 2 == 0:\n                result[i][j] = matrix[i][j] * 2\n            else:\n                result[i][j] = matrix[i][j] * 3\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:23:19", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(arr: np.ndarray) -> np.ndarray:\n    result = np.zeros(len(arr))\n    for i in range(len(arr)):\n        if arr[i] % 2 == 0:\n            result[i] = arr[i] * 2\n        elif arr[i] % 3 == 0:\n            result[i] = arr[i] * 3\n        else:\n            result[i] = arr[i] * 4\n            \n    for i in range(1, len(result)):\n        if result[i] < result[i - 1]:\n            result[i] = result[i - 1] + 1\n            \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:23:21", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(matrix: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(matrix)\n\n    for i in range(matrix.shape[0]):\n        for j in range(matrix.shape[1]):\n            if matrix[i, j] % 2 == 0:\n                result[i, j] = matrix[i, j] * 2\n            else:\n                result[i, j] = matrix[i, j] + 1\n\n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:23:24", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(matrix: np.ndarray, threshold: float) -> np.ndarray:\n    result = np.zeros(matrix.shape)\n    \n    for i in range(matrix.shape[0]):\n        for j in range(matrix.shape[1]):\n            if matrix[i, j] >= threshold:\n                result[i, j] = matrix[i, j] * 2\n            else:\n                result[i, j] = matrix[i, j] / 2\n                \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:23:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = []\n                for k, capacity in enumerate(bins):\n                    if capacity >= item:\n                        available_bins.append(k)\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        priorities[available_bins[idx]] = (item - bins[available_bins[idx-1]]) / (bins[available_bins[idx]] - bins[available_bins[idx-1]])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of the priority function.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        priorities[available_bins[idx]] = (item - bins[available_bins[idx-1]]) / (bins[available_bins[idx]] - bins[available_bins[idx-1])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:23:31", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = []\n                for k, capacity in enumerate(bins):\n                    if capacity >= item:\n                        available_bins.append(k)\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        priorities[available_bins[idx]] = (item - bins[available_bins[idx-1]]) / (bins[available_bins[idx]] - bins[available_bins[idx-1]])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = []\n                for k, capacity in enumerate(bins):\n                    if capacity >= item:\n                        available_bins.append(k)\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        priorities[available_bins[idx]] = (item - bins[available_bins[idx-1]]) / (bins[available_bins[idx]] - bins[available_bins[idx-1])\n                else:\n                    min_difference = min([c - item for c in bins if c > item])\n                    for idx, capacity in enumerate(bins):\n                        if capacity - item == min_difference:\n                            priorities[idx] = 1.0\n                            break\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:23:34", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = []\n                for k, capacity in enumerate(bins):\n                    if capacity >= item:\n                        available_bins.append(k)\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        priorities[available_bins[idx]] = (item - bins[available_bins[idx-1]]) / (bins[available_bins[idx]] - bins[available_bins[idx-1]])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n                \n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        priorities[available_bins[idx]] = (item - bins[available_bins[idx-1]]) / (bins[available_bins[idx]] - bins[available_bins[idx-1])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:23:38", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = []\n                for k, capacity in enumerate(bins):\n                    if capacity >= item:\n                        available_bins.append(k)\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        priorities[available_bins[idx]] = (item - bins[available_bins[idx-1]]) / (bins[available_bins[idx]] - bins[available_bins[idx-1]])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n\n    max_capacity = max(bins)\n    max_capacity_idx = np.argmax(bins)\n\n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        prev_bin_capacity = bins[available_bins[idx-1]]\n                        curr_bin_capacity = bins[available_bins[idx]]\n                        priorities[available_bins[idx]] = (item - prev_bin_capacity) / (curr_bin_capacity - prev_bin_capacity)\n                else:\n                    priorities[max_capacity_idx] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:23:42", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = item - bins[i]\n        elif bins[i] == min_capacity:\n            priorities[i] = bins[i] - item\n        else:\n            priorities[i] = abs(item - bins[i]) / (max_capacity - min_capacity)\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = item - bins[i]\n        elif bins[i] == min_capacity:\n            priorities[i] = bins[i] - item\n        else:\n            priorities[i] = abs(item - bins[i]) / (max_capacity - min_capacity)\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n    avg_capacity = np.mean(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = item - bins[i]\n        elif bins[i] == min_capacity:\n            priorities[i] = bins[i] - item\n        elif bins[i] > avg_capacity:\n            priorities[i] = abs(item - bins[i]) / (max_capacity - avg_capacity)\n        else:\n            priorities[i] = abs(item - bins[i]) / (avg_capacity - min_capacity)\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:23:45", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = item - bins[i]\n        elif bins[i] == min_capacity:\n            priorities[i] = bins[i] - item\n        else:\n            priorities[i] = abs(item - bins[i]) / (max_capacity - min_capacity)\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = item - bins[i]\n        elif bins[i] == min_capacity:\n            priorities[i] = bins[i] - item\n        else:\n            priorities[i] = abs(item - bins[i]) / (max_capacity - min_capacity)\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = item - bins[i]\n        elif bins[i] == min_capacity:\n            priorities[i] = bins[i] - item\n        else:\n            if item > bins[i]:\n                priorities[i] = 2 * (item - bins[i]) / (max_capacity - min_capacity)\n            else:\n                priorities[i] = (max_capacity - item) * 1.5 / (max_capacity - min_capacity)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:23:47", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = item - bins[i]\n        elif bins[i] == min_capacity:\n            priorities[i] = bins[i] - item\n        else:\n            priorities[i] = abs(item - bins[i]) / (max_capacity - min_capacity)\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = item - bins[i]\n        elif bins[i] == min_capacity:\n            priorities[i] = bins[i] - item\n        else:\n            priorities[i] = abs(item - bins[i]) / (max_capacity - min_capacity)\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = item - bins[i]\n        elif bins[i] == min_capacity:\n            priorities[i] = bins[i] - item\n        else:\n            if item < bins[i]:\n                priorities[i] = abs(item - bins[i]) / (max_capacity - min_capacity)\n            else:\n                priorities[i] = (item - bins[i]) * (max_capacity - min_capacity)\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:23:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = item - bins[i]\n        elif bins[i] == min_capacity:\n            priorities[i] = bins[i] - item\n        else:\n            priorities[i] = abs(item - bins[i]) / (max_capacity - min_capacity)\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = item - bins[i]\n        elif bins[i] == min_capacity:\n            priorities[i] = bins[i] - item\n        else:\n            priorities[i] = abs(item - bins[i]) / (max_capacity - min_capacity)\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n    avg_capacity = np.mean(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = item - bins[i]\n        elif bins[i] == min_capacity:\n            priorities[i] = bins[i] - item\n        elif bins[i] == avg_capacity:\n            priorities[i] = abs(item - bins[i]) / (max_capacity - min_capacity) + 0.5\n        else:\n            priorities[i] = abs(item - bins[i]) / (max_capacity - min_capacity)\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:23:52", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n    \n    for ratio in ratios:\n        if ratio < 0.5:\n            priority = 1 / (1 + np.exp(-10*(ratio-0.25)))\n        elif ratio >= 0.5 and ratio < 1:\n            priority = 1 / (1 + np.exp(-5*(ratio-0.75)))\n        else:\n            priority = -np.log(ratio)\n        \n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n    \n    for ratio in ratios:\n        if ratio < 0.5:\n            priority = 1 / (1 + np.exp(-10*(ratio-0.25)))\n        elif ratio >= 0.5 and ratio < 1:\n            priority = 1 / (1 + np.exp(-5*(ratio-0.75)))\n        else:\n            priority = -np.log(ratio)\n        \n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = np.sin(10*ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.tan(ratio)\n        else:\n            priority = np.sqrt(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:23:55", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n    \n    for ratio in ratios:\n        if ratio < 0.5:\n            priority = 1 / (1 + np.exp(-10*(ratio-0.25)))\n        elif ratio >= 0.5 and ratio < 1:\n            priority = 1 / (1 + np.exp(-5*(ratio-0.75)))\n        else:\n            priority = -np.log(ratio)\n        \n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n    \n    for ratio in ratios:\n        if ratio < 0.5:\n            priority = 1 / (1 + np.exp(-10*(ratio-0.25)))\n        elif ratio >= 0.5 and ratio < 1:\n            priority = 1 / (1 + np.exp(-5*(ratio-0.75)))\n        else:\n            priority = -np.log(ratio)\n        \n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n    \n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = 1 / (1 + np.exp(-15*(ratio-0.15)))\n        elif ratio >= 0.3 and ratio < 0.7:\n            priority = 1 / (1 + np.exp(-5*(ratio-0.5)))\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = 1 / (1 + np.exp(-3*(ratio-0.8)))\n        else:\n            priority = -np.log(ratio)\n        \n        priorities.append(priority)\n    \n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:23:57", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n    \n    for ratio in ratios:\n        if ratio < 0.5:\n            priority = 1 / (1 + np.exp(-10*(ratio-0.25)))\n        elif ratio >= 0.5 and ratio < 1:\n            priority = 1 / (1 + np.exp(-5*(ratio-0.75)))\n        else:\n            priority = -np.log(ratio)\n        \n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n    \n    for ratio in ratios:\n        if ratio < 0.5:\n            priority = 1 / (1 + np.exp(-10*(ratio-0.25)))\n        elif ratio >= 0.5 and ratio < 1:\n            priority = 1 / (1 + np.exp(-5*(ratio-0.75)))\n        else:\n            priority = -np.log(ratio)\n        \n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n    \n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = 1 / (1 + np.exp(-15*(ratio-0.1)))\n        elif ratio >= 0.2 and ratio < 0.5:\n            priority = 1 / (1 + np.exp(-8*(ratio-0.35)))\n        elif ratio >= 0.5 and ratio < 0.8:\n            priority = 1 / (1 + np.exp(-10*(ratio-0.65)))\n        else:\n            priority = -np.log(ratio)\n        \n        priorities.append(priority)\n    \n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:24:00", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n    \n    for ratio in ratios:\n        if ratio < 0.5:\n            priority = 1 / (1 + np.exp(-10*(ratio-0.25)))\n        elif ratio >= 0.5 and ratio < 1:\n            priority = 1 / (1 + np.exp(-5*(ratio-0.75)))\n        else:\n            priority = -np.log(ratio)\n        \n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n    \n    for ratio in ratios:\n        if ratio < 0.5:\n            priority = 1 / (1 + np.exp(-10*(ratio-0.25)))\n        elif ratio >= 0.5 and ratio < 1:\n            priority = 1 / (1 + np.exp(-5*(ratio-0.75)))\n        else:\n            priority = -np.log(ratio)\n        \n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = 1 / (1 + np.exp(-10*(ratio-0.1)))\n        elif ratio >= 0.2 and ratio < 0.5:\n            priority = 1 / (1 + np.exp(-7*(ratio-0.35)))\n        elif ratio >= 0.5 and ratio < 0.8:\n            priority = 1 / (1 + np.exp(-5*(ratio-0.65)))\n        else:\n            priority = -np.log(ratio) ** 2\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:24:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = np.sin(10*ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.tan(ratio)\n        else:\n            priority = np.sqrt(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = np.sin(10*ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.tan(ratio)\n        else:\n            priority = np.sqrt(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(15*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(7*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.tan(3*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.sqrt(ratio)\n        else:\n            priority = np.log(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:24:08", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = np.sin(10*ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.tan(ratio)\n        else:\n            priority = np.sqrt(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = np.sin(10*ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.tan(ratio)\n        else:\n            priority = np.sqrt(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.cosh(2*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.arccos(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.arctan(ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(3*ratio)\n        else:\n            priority = np.abs(np.log(ratio))\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:24:11", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = np.sin(10*ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.tan(ratio)\n        else:\n            priority = np.sqrt(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = np.sin(10*ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.tan(ratio)\n        else:\n            priority = np.sqrt(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "import math\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = math.cos(10*ratio)\n        elif ratio >= 0.2 and ratio < 0.5:\n            priority = math.exp(ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = math.log10(ratio)\n        else:\n            priority = math.sin(5*ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:24:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = np.sin(10*ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.tan(ratio)\n        else:\n            priority = np.sqrt(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = np.sin(10*ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.tan(ratio)\n        else:\n            priority = np.sqrt(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(8*ratio) + np.cos(3*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.sin(5*ratio) * np.cos(2*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.tan(ratio) * np.sqrt(ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cos(ratio) + np.tan(ratio)\n        else:\n            priority = np.sqrt(ratio) * np.exp(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:24:22", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(8*ratio) + np.cos(3*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.sin(5*ratio) * np.cos(2*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.tan(ratio) * np.sqrt(ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cos(ratio) + np.tan(ratio)\n        else:\n            priority = np.sqrt(ratio) * np.exp(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(8*ratio) + np.cos(3*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.sin(5*ratio) * np.cos(2*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.tan(ratio) * np.sqrt(ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cos(ratio) + np.tan(ratio)\n        else:\n            priority = np.sqrt(ratio) * np.exp(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(10*ratio) + np.cos(5*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.sin(7*ratio) * np.cos(4*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.tan(2*ratio) * np.sqrt(2*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cos(3*ratio) + np.tan(2*ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sqrt(3*ratio) * np.exp(2*ratio)\n        else:\n            priority = np.log(ratio) * np.tanh(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:24:26", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(8*ratio) + np.cos(3*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.sin(5*ratio) * np.cos(2*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.tan(ratio) * np.sqrt(ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cos(ratio) + np.tan(ratio)\n        else:\n            priority = np.sqrt(ratio) * np.exp(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(8*ratio) + np.cos(3*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.sin(5*ratio) * np.cos(2*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.tan(ratio) * np.sqrt(ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cos(ratio) + np.tan(ratio)\n        else:\n            priority = np.sqrt(ratio) * np.exp(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(10*ratio) + np.cos(5*ratio)\n        elif ratio >= 0.1 and ratio < 0.2:\n            priority = np.sin(7*ratio) * np.cos(4*ratio)\n        elif ratio >= 0.2 and ratio < 0.3:\n            priority = np.tan(ratio) * np.sqrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.4:\n            priority = np.cos(ratio) + np.tan(ratio)\n        elif ratio >= 0.4 and ratio < 0.5:\n            priority = np.log(ratio) * np.exp(ratio)\n        elif ratio >= 0.5 and ratio < 0.6:\n            priority = np.cosh(ratio) + np.sinh(ratio)\n        elif ratio >= 0.6 and ratio < 0.7:\n            priority = np.tanh(ratio) * np.arctan(ratio)\n        elif ratio >= 0.7 and ratio < 0.8:\n            priority = np.arcsin(ratio) * np.arccos(ratio)\n        elif ratio >= 0.8 and ratio < 0.9:\n            priority = np.arctan(ratio) + np.arcsinh(ratio)\n        else:\n            priority = np.tanh(ratio) * np.cosh(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:24:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(8*ratio) + np.cos(3*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.sin(5*ratio) * np.cos(2*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.tan(ratio) * np.sqrt(ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cos(ratio) + np.tan(ratio)\n        else:\n            priority = np.sqrt(ratio) * np.exp(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(8*ratio) + np.cos(3*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.sin(5*ratio) * np.cos(2*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.tan(ratio) * np.sqrt(ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cos(ratio) + np.tan(ratio)\n        else:\n            priority = np.sqrt(ratio) * np.exp(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(8*ratio) + np.cos(3*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.sin(5*ratio) * np.cos(2*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.tan(ratio) * np.sqrt(ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cos(ratio) + np.tan(ratio)\n        else:\n            priority = np.sqrt(ratio) * np.exp(ratio)\n\n        if priority > 5:\n            priority *= 1.5\n        elif priority > 3:\n            priority *= 1.2\n        else:\n            priority *= 0.8\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:24:31", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(8*ratio) + np.cos(3*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.sin(5*ratio) * np.cos(2*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.tan(ratio) * np.sqrt(ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cos(ratio) + np.tan(ratio)\n        else:\n            priority = np.sqrt(ratio) * np.exp(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(8*ratio) + np.cos(3*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.sin(5*ratio) * np.cos(2*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.tan(ratio) * np.sqrt(ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cos(ratio) + np.tan(ratio)\n        else:\n            priority = np.sqrt(ratio) * np.exp(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(8*ratio) - np.cos(3*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.sin(5*ratio) * np.cos(2*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.tan(ratio) * np.sqrt(ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.log(ratio) + np.tan(ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sinh(ratio) - np.cosh(ratio)\n        else:\n            priority = np.sqrt(ratio) * np.exp(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:24:39", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = 1.0 / item\n        else:\n            priorities[i] = 0.0\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:24:40", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            priorities[i] = item - bins[i]\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:24:42", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = bins[i] - item\n        else:\n            priorities[i] = item - bins[i]\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:24:44", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        ratio = item / bins[i]\n        if ratio >= 1:\n            priorities[i] = 0\n        else:\n            priority = 1 / (1 + np.exp(-10*(ratio-0.5)))\n            priorities[i] = priority\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:24:47", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.25:\n                priorities[i] = 1 / ratios\n            elif ratios < 0.75:\n                priorities[i] = np.sqrt(ratios)\n            elif ratios < 1:\n                priorities[i] = np.cbrt(ratios)\n            else:\n                priorities[i] = np.log(ratios)\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:24:49", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.25:\n                priorities[i] = 2/ratios\n            elif ratios < 0.5:\n                priorities[i] = 1/ratios\n            elif ratios < 0.75:\n                priorities[i] = 0.5/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:24:52", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.25:\n                priorities[i] = 1/ratios\n            elif ratios >= 0.25 and ratios < 0.5:\n                priorities[i] = np.power(ratios, 2)\n            elif ratios >= 0.5 and ratios < 0.75:\n                priorities[i] = np.power(ratios, 3)\n            else:\n                priorities[i] = np.log(ratios) * np.sqrt(ratios)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:24:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.2:\n                priorities[i] = 1/ratios\n            elif ratios < 0.5:\n                priorities[i] = 2/(ratios + 0.5)\n            else:\n                priorities[i] = np.log(ratios) + np.sqrt(ratios)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:24:58", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            elif item < 5:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            elif bins[i] < 5:\n                priorities[i] = 1\n            else:\n                priorities[i] = 2\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:25:00", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15:\n                priorities[i] = 6\n            elif item > 10:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:25:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            priorities[i] = 4 if item > 10 and bins[i] > 5 else 3\n        elif ratios[i] >= 0.6:\n            priorities[i] = 2 if item < 2 else 3\n        else:\n            priorities[i] = 0 if bins[i] < 2 else 1\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:25:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.7:\n            if item < 5:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] < 3:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:25:08", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_function(data: np.ndarray, threshold: float) -> np.ndarray:\n    results = []\n    \n    for i in range(len(data)):\n        if data[i] > threshold:\n            result = 2 * data[i]\n        else:\n            result = data[i] / 2\n        \n        for j in range(1, 5):\n            if result < j:\n                result *= j\n            else:\n                result /= j\n        \n        results.append(result)\n    \n    return np.array(results)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:25:10", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros(len(data))\n\n    for i in range(len(data)):\n        if data[i] > 0:\n            result[i] = data[i] + 5\n        elif data[i] < 0:\n            result[i] = data[i] - 5\n        else:\n            result[i] = data[i]\n    \n    for i in range(1, len(data)):\n        if data[i] > data[i-1]:\n            result[i] += 10\n        elif data[i] < data[i-1]:\n            result[i] -= 10\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:25:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(matrix: np.ndarray) -> np.ndarray:\n    rows, cols = matrix.shape\n    result = np.zeros((rows, cols))\n\n    for i in range(rows):\n        for j in range(cols):\n            if matrix[i][j] % 2 == 0:\n                result[i][j] = matrix[i][j] ** 2\n            elif matrix[i][j] % 3 == 0:\n                result[i][j] = matrix[i][j] ** 3\n            else:\n                result[i][j] = matrix[i][j] * 2\n\n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:25:15", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(matrix: np.ndarray) -> np.ndarray:\n    rows, cols = matrix.shape\n    result = np.zeros((rows, cols))\n\n    for i in range(rows):\n        for j in range(cols):\n            if matrix[i, j] % 2 == 0:\n                result[i, j] = matrix[i, j] ** 2\n            elif matrix[i, j] % 3 == 0:\n                result[i, j] = matrix[i, j] ** 3\n            else:\n                result[i, j] = matrix[i, j]\n\n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:25:18", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if priority < 0.9:\n                    priority += 0.2\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:25:20", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            \n            if priority > 0.5:\n                priorities[i] = priority * 1.5\n            elif priority < 0.3:\n                priorities[i] = priority * 0.75\n            else:\n                priorities[i] = priority\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:25:23", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if priority < 0.5:\n                    priority += 0.2\n                elif priority >= 0.5 and priority < 0.8:\n                    priority += 0.1\n                else:\n                    priority += 0.05\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:25:25", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            if priority > 0.5:\n                priorities[i] = 0.5\n            else:\n                priorities[i] = priority\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:25:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    sorted_bins = np.argsort(bins)\n    \n    for i, bin_idx in enumerate(sorted_bins):\n        remaining_capacity = bins[bin_idx] - item\n        if remaining_capacity >= 0:\n            priorities[bin_idx] = i + 1\n        else:\n            for j in range(i, len(bins)):\n                if bins[sorted_bins[j]] >= item:\n                    priorities[sorted_bins[j]] = j + 1\n                    break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    sorted_bins = np.argsort(bins)\n\n    for i, bin_idx in enumerate(sorted_bins):\n        remaining_capacity = bins[bin_idx] - item\n        if remaining_capacity >= 0:\n            priorities[bin_idx] = i + 1\n        else:\n            min_capacity = float('inf')\n            min_capacity_idx = -1\n            for j in range(i, len(bins)):\n                if bins[sorted_bins[j]] >= item:\n                    current_capacity = bins[sorted_bins[j]] - item\n                    if current_capacity < min_capacity:\n                        min_capacity = current_capacity\n                        min_capacity_idx = sorted_bins[j]\n            \n            if min_capacity_idx != -1:\n                priorities[min_capacity_idx] = i + 1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:25:31", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    sorted_bins = np.argsort(bins)\n    \n    for i, bin_idx in enumerate(sorted_bins):\n        remaining_capacity = bins[bin_idx] - item\n        if remaining_capacity >= 0:\n            priorities[bin_idx] = i + 1\n        else:\n            for j in range(i, len(bins)):\n                if bins[sorted_bins[j]] >= item:\n                    priorities[sorted_bins[j]] = j + 1\n                    break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    sorted_bins = np.argsort(bins)\n\n    for i in range(len(sorted_bins)):\n        bin_idx = sorted_bins[i]\n        remaining_capacity = bins[bin_idx] - item\n        if remaining_capacity >= 0:\n            priorities[bin_idx] = i + 1\n        else:\n            for j in range(i, len(bins)):\n                if bins[sorted_bins[j]] >= item:\n                    priorities[sorted_bins[j]] = j + 1\n                    break\n            else:\n                remaining_items = []\n                for k in range(i, len(bins)):\n                    if bins[sorted_bins[k]] < item:\n                        remaining_items.append(sorted_bins[k])\n                sorted_remaining_items = sorted(remaining_items, key=lambda x: bins[x], reverse=True)\n                for idx in range(len(sorted_remaining_items)):\n                    if bins[sorted_remaining_items[idx]] >= item:\n                        priorities[sorted_remaining_items[idx]] = i + 1\n                        break\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:25:33", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    sorted_bins = np.argsort(bins)\n    \n    for i, bin_idx in enumerate(sorted_bins):\n        remaining_capacity = bins[bin_idx] - item\n        if remaining_capacity >= 0:\n            priorities[bin_idx] = i + 1\n        else:\n            for j in range(i, len(bins)):\n                if bins[sorted_bins[j]] >= item:\n                    priorities[sorted_bins[j]] = j + 1\n                    break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    sorted_bins = np.argsort(bins)\n    \n    for i, bin_idx in enumerate(sorted_bins):\n        remaining_capacity = bins[bin_idx] - item\n        \n        if remaining_capacity >= 0:\n            priorities[bin_idx] = i + 1\n        else:\n            for j in range(i, len(bins)):\n                if bins[sorted_bins[j]] >= item:\n                    priorities[sorted_bins[j]] = j + 1\n                    break\n            else:\n                min_capacity = min(bins)\n                min_capacity_idx = np.where(bins == min_capacity)[0]\n                priorities[min_capacity_idx[0]] = np.max(priorities) + 1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:25:36", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    sorted_bins = np.argsort(bins)\n    \n    for i, bin_idx in enumerate(sorted_bins):\n        remaining_capacity = bins[bin_idx] - item\n        if remaining_capacity >= 0:\n            priorities[bin_idx] = i + 1\n        else:\n            for j in range(i, len(bins)):\n                if bins[sorted_bins[j]] >= item:\n                    priorities[sorted_bins[j]] = j + 1\n                    break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:25:47", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(8*ratio) + np.cos(3*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.sin(5*ratio) * np.cos(2*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.tan(ratio) * np.sqrt(ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cos(ratio) + np.tan(ratio)\n        else:\n            priority = np.sqrt(ratio) * np.exp(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(8*ratio) + np.cos(3*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.sin(5*ratio) * np.cos(2*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.tan(ratio) * np.sqrt(ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cos(ratio) + np.tan(ratio)\n        else:\n            priority = np.sqrt(ratio) * np.exp(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(10*ratio) + np.cos(4*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.sin(6*ratio) * np.cos(3*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.tan(ratio) * np.sqrt(ratio) * np.log(ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cos(ratio) + np.tan(ratio) + np.exp(ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sqrt(ratio) * np.exp(ratio) * np.sin(ratio)\n        else:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:25:51", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(8*ratio) + np.cos(3*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.sin(5*ratio) * np.cos(2*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.tan(ratio) * np.sqrt(ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cos(ratio) + np.tan(ratio)\n        else:\n            priority = np.sqrt(ratio) * np.exp(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(8*ratio) + np.cos(3*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.sin(5*ratio) * np.cos(2*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.tan(ratio) * np.sqrt(ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cos(ratio) + np.tan(ratio)\n        else:\n            priority = np.sqrt(ratio) * np.exp(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(10*ratio) + np.cos(5*ratio) - np.tan(2*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(3*ratio) * np.tan(ratio) + np.sin(4*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:25:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(8*ratio) + np.cos(3*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.sin(5*ratio) * np.cos(2*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.tan(ratio) * np.sqrt(ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cos(ratio) + np.tan(ratio)\n        else:\n            priority = np.sqrt(ratio) * np.exp(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(8*ratio) + np.cos(3*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.sin(5*ratio) * np.cos(2*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.tan(ratio) * np.sqrt(ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cos(ratio) + np.tan(ratio)\n        else:\n            priority = np.sqrt(ratio) * np.exp(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        priority = 0\n        if ratio < 0.1:\n            for i in range(1, 6):\n                priority += np.sin(i*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            for i in range(1, 6):\n                priority += np.cos(i*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            for i in range(1, 6):\n                priority += np.tan(i*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            for i in range(1, 6):\n                priority += np.sqrt(i*ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            for i in range(1, 6):\n                priority += np.exp(i*ratio)\n        else:\n            priority = np.sum(np.arange(1, 6)*ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:25:57", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(8*ratio) + np.cos(3*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.sin(5*ratio) * np.cos(2*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.tan(ratio) * np.sqrt(ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cos(ratio) + np.tan(ratio)\n        else:\n            priority = np.sqrt(ratio) * np.exp(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(8*ratio) + np.cos(3*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.sin(5*ratio) * np.cos(2*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.tan(ratio) * np.sqrt(ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cos(ratio) + np.tan(ratio)\n        else:\n            priority = np.sqrt(ratio) * np.exp(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(10*ratio) + np.cos(5*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.sin(6*ratio) * np.cos(4*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.tan(ratio) * np.sqrt(ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cos(ratio) + np.tan(ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sqrt(ratio) * np.exp(ratio)\n        else:\n            priority = np.sin(ratio) + np.cos(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:26:12", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                max_divisor = 0\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        max_divisor = i\n                if max_divisor != 0:\n                    priority = 1 / (bin_capacity - item + max_divisor)\n                else:\n                    priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:26:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                found_divisor = False\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        found_divisor = True\n                        break\n                if not found_divisor:\n                    priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:26:17", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                prime_factors = []\n                for i in range(2, int(bin_capacity/2) + 1):\n                    while bin_capacity % i == 0:\n                        prime_factors.append(i)\n                        bin_capacity //= i\n                \n                if len(prime_factors) > 0:\n                    priority = sum(prime_factors) / item\n                else:\n                    priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:26:19", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n            \n        if priority <= 1:\n            priority *= 1.5\n        elif priority > 1 and priority <= 2:\n            priority *= 2\n        else:\n            priority *= 0.5\n        \n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:26:38", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.25:\n                priorities[i] = 1/(ratios ** 2)\n            elif ratios < 0.5:\n                priorities[i] = 1/ratios\n            elif ratios < 1:\n                priorities[i] = np.log(ratios)\n            elif ratios < 2:\n                priorities[i] = np.sqrt(ratios)\n            else:\n                priorities[i] = np.cbrt(ratios)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:26:41", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:26:44", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.25:\n                priorities[i] = 1/ratios\n            elif 0.25 <= ratios < 0.5:\n                priorities[i] = 2 * np.log(ratios)\n            elif 0.5 <= ratios < 0.75:\n                priorities[i] = np.sqrt(1/ratios)\n            else:\n                priorities[i] = np.cbrt(np.log(ratios) + np.exp(ratios))\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:26:46", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            ratios = item / bins[i]\n            if ratios < 0.5:\n                priorities[i] = 1/ratios\n            else:\n                priorities[i] = np.log(ratios)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        elif item == bins[i]:\n            priorities[i] = 0\n        else:\n            if item < 0.2 * bins[i]:\n                priorities[i] = bins[i] - item\n            elif 0.2 * bins[i] <= item < 0.5 * bins[i]:\n                priorities[i] = (bins[i] - item) * 0.8\n            elif 0.5 * bins[i] <= item < 0.8 * bins[i]:\n                priorities[i] = (bins[i] - item) * 0.5\n            else:\n                priorities[i] = (bins[i] - item) * 0.2\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:26:52", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization <= 0.5:\n                    priorities[i] = 2\n                elif 0.5 < utilization <= 0.8:\n                    priorities[i] = 3\n                else:\n                    remaining_ratio = left_capacity / item\n                    if remaining_ratio < 0.4:\n                        priorities[i] = np.sqrt(item * remaining_ratio)\n                    elif 0.4 <= remaining_ratio < 0.7:\n                        priorities[i] = np.log(item * remaining_ratio)\n                    else:\n                        priorities[i] = np.exp(item * remaining_ratio)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:26:56", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.5:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.5 <= utilization < 0.8:\n                    ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * ratio) + 3\n                else:\n                    ratio = left_capacity / item\n                    priorities[i] = np.log(item * ratio) + 4\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:26:58", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "import numpy as np\n\n\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.5:\n                    priorities[i] = 2 * item / bins[i]\n                elif 0.5 <= utilization < 0.8:\n                    priorities[i] = 3 * item / bins[i] + bins[i] / item\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:27:01", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.6:\n                    priorities[i] = 2\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 3\n                else:\n                    remaining_ratio = left_capacity / item\n                    if remaining_ratio < 0.25:\n                        priorities[i] = np.sqrt(item * remaining_ratio)\n                    else:\n                        priorities[i] = 4\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:27:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.5:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.5 <= utilization < 0.8:\n                    priorities[i] = 3\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:27:09", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even further improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                if item % 2 == 0:\n                    utilization = item / bins[i]\n                    if utilization < 0.2:\n                        priorities[i] = 1 / (1 - utilization)\n                    elif 0.2 <= utilization < 0.6:\n                        priorities[i] = 3\n                    elif 0.6 <= utilization < 0.8:\n                        priorities[i] = 5\n                    else:\n                        priorities[i] = np.sqrt(item * (left_capacity / item))\n                else:\n                    utilization = item / bins[i]\n                    if utilization < 0.3:\n                        priorities[i] = 1 / (1 - utilization)\n                    elif 0.3 <= utilization <= 0.7:\n                        priorities[i] = 4\n                    else:\n                        priorities[i] = np.cbrt(item * (left_capacity / item))\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:27:12", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.5:\n                    priorities[i] = 2 / utilization\n                elif 0.5 <= utilization < 0.8:\n                    priorities[i] = 3 * utilization\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:27:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.5:\n                    priorities[i] = 2\n                elif 0.5 <= utilization < 0.8:\n                    priorities[i] = 3\n                else:\n                    priorities[i] = np.sqrt(item * left_capacity)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:27:19", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Enhanced version of `priority_v1` with additional logic.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            elif item > bin_capacity + max(bins): \n                priorities[i] = 0.0\n            else:\n                temp = item - remaining_capacity\n                for j in range(i+1, len(bins)):\n                    if item <= bins[j]:\n                        priorities[j] = 1.0 - (temp / bins[j])\n                        break\n                if priorities[i] == 0:\n                    for j in range(i+1, len(bins)):\n                        if item <= bins[j] + max(bins):\n                            priorities[j] = 1.0 - (temp / (bins[j] + max(bins)))\n                            break\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:27:22", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                ratio = (item - remaining_capacity) / (bins[i] - remaining_capacity)\n                if ratio > 0.5:\n                    priorities[i] = 1 - ratio\n                else:\n                    priorities[i] = 0.5 * ratio\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:27:25", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    priorities[i] = 0.5\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:27:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of the priority function.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                excess_capacity = item - remaining_capacity\n                capacity_left = bins[i] - remaining_capacity\n                \n                if excess_capacity < capacity_left * 0.25:\n                    priorities[i] = 0.8\n                elif excess_capacity < capacity_left * 0.5:\n                    priorities[i] = 0.6\n                elif excess_capacity < capacity_left * 0.75:\n                    priorities[i] = 0.4\n                else:\n                    priorities[i] = 0.2\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:27:34", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.5:\n                    priorities[i] = 2 / utilization\n                elif 0.5 <= utilization < 0.8:\n                    priorities[i] = 3 * utilization\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:27:36", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(data)\n    \n    for i in range(len(data)):\n        if data[i] % 2 == 0:\n            result[i] = data[i] * 2\n        else:\n            total = 0\n            for j in range(1, data[i] + 1):\n                if data[i] % j == 0:\n                    total += j\n            result[i] = total\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:27:39", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.5:\n                    priorities[i] = 1.5 / (1 - utilization)\n                elif 0.5 <= utilization < 0.8:\n                    priorities[i] = 2.5 / (1 - utilization)\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:27:41", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.5:\n                    priorities[i] = 3\n                elif 0.5 <= utilization < 0.8:\n                    priorities[i] = 5\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:27:44", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif 0.7 <= ratios[i] < 0.9:\n            if item > 8:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif 0.4 <= ratios[i] < 0.7:\n            if item < 4:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 3:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:27:47", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.4:\n            if item < 5 and bins[i] > 3:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:27:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.4:\n            if item < 5:\n                priorities[i] = 1\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:27:53", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                if bins[i] < 2:\n                    priorities[i] = 1\n                else:\n                    priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:27:58", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < item * 0.5:\n                    priority += 0.2\n                elif remaining_capacity < item * 0.8:\n                    priority += 0.1\n                else:\n                    priority += 0.05\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:28:01", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            if priority > 0.5:\n                priorities[i] = priority * 1.2\n            elif priority <= 0.2:\n                priorities[i] = priority * 0.8\n            else:\n                priorities[i] = priority\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:28:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if item < 10:\n                    priority += 0.2\n                elif item >= 10 and item < 20:\n                    priority += 0.3\n                else:\n                    priority += 0.5\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:28:05", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] < item/2:\n            priorities[i] = 0.5\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.2\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:28:07", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(input_data: np.ndarray) -> np.ndarray:\n    output_data = np.zeros(len(input_data))\n    \n    for i in range(len(input_data)):\n        if input_data[i] % 2 == 0:\n            temp_sum = 0\n            for j in range(1, input_data[i]+1):\n                if j % 2 == 0:\n                    temp_sum += j\n            output_data[i] = temp_sum\n        else:\n            output_data[i] = input_data[i] * 2\n    \n    return output_data", "strategy": []}
{"timestamp": "2025-04-27 05:28:10", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros(len(data))\n    \n    for i in range(len(data)):\n        if data[i] % 2 == 0:\n            result[i] = data[i] * 2\n        elif data[i] % 3 == 0:\n            result[i] = data[i] / 3\n        else:\n            result[i] = data[i] ** 2\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:28:12", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray, target: int) -> int:\n    total = 0\n    \n    for i in range(len(data)):\n        if data[i] == target:\n            total += 1\n        elif data[i] < target:\n            total += data[i]\n        else:\n            total -= data[i]\n    \n    if total < 0:\n        total = abs(total)\n    \n    return total", "strategy": []}
{"timestamp": "2025-04-27 05:28:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    results = np.zeros(len(data))\n    \n    for i in range(len(data)):\n        if data[i] % 2 == 0:\n            results[i] = data[i] * 2\n        else:\n            results[i] = data[i] * 3\n    \n    for i in range(1, len(data)):\n        if data[i] > data[i-1]:\n            results[i] += data[i-1]\n        else:\n            results[i] -= data[i-1]\n    \n    return results", "strategy": []}
{"timestamp": "2025-04-27 05:28:18", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.4:\n            if item < 5 and bins[i] > 3:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.4:\n            if item < 5 and bins[i] > 3:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.4:\n            if item < 5 and bins[i] > 3:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:28:22", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.4:\n            if item < 5 and bins[i] > 3:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.4:\n            if item < 5 and bins[i] > 3:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.4:\n            if item < 5 and bins[i] > 3:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    for j in range(len(bins)):\n        if priorities[j] == 5 and bins[j] == 5:\n            priorities[j] = 7\n        elif priorities[j] == 3 or priorities[j] == 4:\n            if item > 7:\n                priorities[j] = 4\n            else:\n                priorities[j] = 3\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:28:25", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.4:\n            if item < 5 and bins[i] > 3:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.4:\n            if item < 5 and bins[i] > 3:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.4:\n            if item < 5 and bins[i] > 3:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n        if item % 2 == 0:\n            priorities[i] += 1\n        \n        if item < 5 and bins[i] > 5:\n            priorities[i] += 2\n\n        if ratios[i] < 0.7:\n            priorities[i] *= 2\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:28:29", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.4:\n            if item < 5 and bins[i] > 3:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.4:\n            if item < 5 and bins[i] > 3:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.4:\n            if item < 5 and bins[i] > 3:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.2:\n            if item < 8 and bins[i] > 6:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:28:32", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:28:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            if priority > 0.5:\n                priorities[i] = priority * 2\n            else:\n                priorities[i] = priority / 2\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:28:37", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            if priority > 0.5:\n                priorities[i] = priority * 1.2\n            else:\n                priorities[i] = priority * 0.8\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:28:40", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.5 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.8 * item:\n                    priority += 0.15\n                else:\n                    priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:28:43", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(matrix: np.ndarray, vector: np.ndarray) -> np.ndarray:\n    result = np.zeros((matrix.shape[0],))\n\n    for i in range(matrix.shape[0]):\n        temp = 0\n        for j in range(matrix.shape[1]):\n            if matrix[i][j] > 0:\n                temp += matrix[i][j] * vector[j]\n            else:\n                temp -= matrix[i][j] * vector[j]\n\n        result[i] = temp\n\n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:28:45", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(matrix: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(matrix)\n    \n    for i in range(matrix.shape[0]):\n        for j in range(matrix.shape[1]):\n            if matrix[i, j] % 2 == 0:\n                result[i, j] = matrix[i, j] * 2\n            else:\n                result[i, j] = matrix[i, j] + 1\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:28:48", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(input_data: dict) -> list:\n    result = []\n    \n    for key, value in input_data.items():\n        if isinstance(value, list):\n            new_list = []\n            for item in value:\n                if isinstance(item, int):\n                    new_list.append(item ** 2)\n                elif isinstance(item, float):\n                    new_list.append(item * 2)\n                else:\n                    new_list.append(item)\n            result.append(new_list)\n        elif isinstance(value, dict):\n            new_dict = {}\n            for k, v in value.items():\n                if isinstance(v, str):\n                    new_dict[k] = v.upper()\n                elif isinstance(v, bool):\n                    new_dict[k] = not v\n                else:\n                    new_dict[k] = v\n            result.append(new_dict)\n        else:\n            result.append(value)\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:28:53", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(matrix: np.ndarray) -> np.ndarray:\n    result = np.zeros(matrix.shape)\n    \n    for i in range(matrix.shape[0]):\n        for j in range(matrix.shape[1]):\n            if matrix[i, j] % 2 == 0:\n                result[i, j] = matrix[i, j] * 2\n            else:\n                result[i, j] = matrix[i, j] + 1\n\n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:28:58", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.4:\n            if item < 5:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:29:01", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"More complex version of `priority_v1`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.4:\n            if item < 5:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:29:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item % 2 == 0:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:29:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                if item % 2 == 0:\n                    priorities[i] = 1\n                elif item % 3 == 0:\n                    priorities[i] = 2\n                else:\n                    priorities[i] = 3\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:29:09", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(10*ratio) + np.cos(5*ratio) - np.tan(2*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(3*ratio) * np.tan(ratio) + np.sin(4*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(10*ratio) + np.cos(5*ratio) - np.tan(2*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(3*ratio) * np.tan(ratio) + np.sin(4*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(10*ratio) + np.cos(5*ratio) - np.tan(2*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(3*ratio) * np.tan(ratio) + np.sin(4*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            if ratio % 2 == 0:\n                priority = np.cosh(ratio) * np.arctan(ratio)\n            else:\n                priority = np.tanh(ratio) * np.exp(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:29:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(10*ratio) + np.cos(5*ratio) - np.tan(2*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(3*ratio) * np.tan(ratio) + np.sin(4*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(10*ratio) + np.cos(5*ratio) - np.tan(2*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(3*ratio) * np.tan(ratio) + np.sin(4*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.log(np.exp(ratio)) * np.arctan(np.tan(ratio))\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.sin(np.cos(ratio)) + np.tan(np.sin(ratio))\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.arcsinh(ratio) * np.arccos(ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.sqrt(np.cosh(ratio) * np.sinh(ratio))\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.tan(ratio) * np.cosh(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) - np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:29:16", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(10*ratio) + np.cos(5*ratio) - np.tan(2*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(3*ratio) * np.tan(ratio) + np.sin(4*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(10*ratio) + np.cos(5*ratio) - np.tan(2*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(3*ratio) * np.tan(ratio) + np.sin(4*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(10*ratio) * np.cos(5*ratio) - np.tan(2*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.log(3*ratio) * np.exp(ratio) + np.sqrt(5*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.arcsin(ratio) * np.arccos(ratio) - np.arctan(ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) + np.tanh(ratio)\n        else:\n            priority = np.tan(ratio) * np.cos(ratio) - np.sin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:29:19", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(10*ratio) + np.cos(5*ratio) - np.tan(2*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(3*ratio) * np.tan(ratio) + np.sin(4*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(10*ratio) + np.cos(5*ratio) - np.tan(2*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(3*ratio) * np.tan(ratio) + np.sin(4*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(10*ratio) + np.cos(5*ratio) - np.tan(2*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(3*ratio) * np.tan(ratio) + np.sin(4*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        if priority < 0:\n            priority = -priority\n        else:\n            priority = priority ** 2\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:29:22", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n\n            if priorities[i] > 0.5:\n                priorities[i] = priorities[i] - 0.1\n                for j in range(i + 1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.8\n                    else:\n                        remaining_capacity = bins[j]\n                        while remaining_capacity < item:\n                            priority += 0.15\n                            remaining_capacity += bins[j]\n                        priorities[j] = priority\n                        \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:29:25", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= 2*item:\n            priorities[i] = 1.0\n        elif bins[i] >= item:\n            priorities[i] = 0.5\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.2\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:29:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if bin_capacity >= 2 * item:\n            priorities[i] = 1.0\n        elif bin_capacity >= item:\n            priorities[i] = 0.8\n        else:\n            remaining_capacity = bin_capacity\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.2\n                remaining_capacity += bin_capacity\n            priorities[i] = priority\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:29:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            if priority >= 1.0:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = priority + 0.1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:29:33", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n    \n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        if bins[i] == max_bin_capacity:\n            priorities[i] += 1.5 * max_bin_capacity  # Increase priority for bins with max capacity\n        elif bins[i] <= 0.5 * max_bin_capacity:\n            priorities[i] -= 0.3 * bins[i]  # Decrease priority for bins with very low capacity\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n            if bins[i] <= 0.3 * max_bin_capacity:\n                priorities[i] += 1.2 * bins[i]  # Increase priority for bins with very low capacity\n        else:\n            priorities[i] = bins[i] - item\n            if bins[i] >= 0.7 * max_bin_capacity:\n                priorities[i] -= 1.1 * (bins[i] - item)  # Decrease priority for bins with high capacity\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:29:36", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n    \n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        if bins[i] == max_bin_capacity:\n            priorities[i] += 1.5 * max_bin_capacity  # Increase priority for bins with max capacity\n        elif bins[i] <= 0.5 * max_bin_capacity:\n            priorities[i] -= 0.3 * bins[i]  # Decrease priority for bins with very low capacity\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 3 * (item - bins[i])  # Triple the priority\n        else:\n            priorities[i] = bins[i] - item\n    \n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] == max_bin_capacity:\n            priorities[i] += 2 * max_bin_capacity  # Increase priority for bins with max capacity\n        elif bins[i] == min_bin_capacity:\n            priorities[i] += 0.5 * min_bin_capacity  # Increase priority for bins with min capacity\n        elif bins[i] <= 0.5 * max_bin_capacity:\n            priorities[i] -= 0.4 * bins[i]  # Decrease priority for bins with very low capacity\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:29:39", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n    \n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        if bins[i] == max_bin_capacity:\n            priorities[i] += 1.5 * max_bin_capacity  # Increase priority for bins with max capacity\n        elif bins[i] <= 0.5 * max_bin_capacity:\n            priorities[i] -= 0.3 * bins[i]  # Decrease priority for bins with very low capacity\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n        \n        if bins[i] == max_bin_capacity:\n            priorities[i] += 1.5 * max_bin_capacity  # Increase priority for bins with max capacity\n        elif bins[i] <= 0.5 * max_bin_capacity:\n            priorities[i] -= 0.3 * bins[i]  # Decrease priority for bins with very low capacity\n        \n        for j in range(len(bins)):\n            if j != i:\n                diff = abs(bins[j] - bins[i])\n                priorities[j] -= 0.2 * diff  # Penalize bins with large capacity difference\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:29:43", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n    \n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        if bins[i] == max_bin_capacity:\n            priorities[i] += 1.5 * max_bin_capacity  # Increase priority for bins with max capacity\n        elif bins[i] <= 0.5 * max_bin_capacity:\n            priorities[i] -= 0.3 * bins[i]  # Decrease priority for bins with very low capacity\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 3 * (item - bins[i])  # Triple the priority\n        else:\n            priorities[i] = bins[i] - item\n        \n        if i % 2 == 0:\n            priorities[i] += 0.5 * bins[i]  # Increase priority for even indexed bins\n        else:\n            priorities[i] -= 0.3 * bins[i]  # Decrease priority for odd indexed bins\n    \n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n    for i in range(len(bins)):\n        if bins[i] == max_bin_capacity:\n            priorities[i] += 1.5 * max_bin_capacity  # Increase priority for bins with max capacity\n        elif bins[i] == min_bin_capacity:\n            priorities[i] -= 1.2 * min_bin_capacity  # Decrease priority for bins with min capacity\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:29:52", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = []\n                for k, capacity in enumerate(bins):\n                    if capacity >= item:\n                        available_bins.append(k)\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        priorities[available_bins[idx]] = (item - bins[available_bins[idx-1]]) / (bins[available_bins[idx]] - bins[available_bins[idx-1]])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = []\n                for k, capacity in enumerate(bins):\n                    if capacity >= item:\n                        available_bins.append(k)\n                if available_bins:\n                    for idx in range(len(available_bins)):\n                        priority_sum = 0\n                        for m in range(idx + 1):\n                            priority_sum += bins[available_bins[m]]\n                        priorities[available_bins[idx]] = (item - priority_sum + bins[available_bins[idx]]) / (bins[available_bins[idx]] - priority_sum + bins[available_bins[idx]])\n                else:\n                    for idx, capacity in enumerate(bins):\n                        if capacity < item:\n                            priorities[idx] = (item - capacity) / item\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:29:56", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = []\n                for k, capacity in enumerate(bins):\n                    if capacity >= item:\n                        available_bins.append(k)\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        priorities[available_bins[idx]] = (item - bins[available_bins[idx-1]]) / (bins[available_bins[idx]] - bins[available_bins[idx-1]])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even further improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = []\n                for k, capacity in enumerate(bins):\n                    if capacity >= item:\n                        available_bins.append(k)\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        priorities[available_bins[idx]] = (item - bins[available_bins[idx-1]]) / (bins[available_bins[idx]] - bins[available_bins[idx-1])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:29:59", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = []\n                for k, capacity in enumerate(bins):\n                    if capacity >= item:\n                        available_bins.append(k)\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        priorities[available_bins[idx]] = (item - bins[available_bins[idx-1]]) / (bins[available_bins[idx]] - bins[available_bins[idx-1]])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = []\n                for k, capacity in enumerate(bins):\n                    if capacity >= item:\n                        available_bins.append(k)\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        priorities[available_bins[idx]] = (item - bins[available_bins[idx-1]]) / (bins[available_bins[idx]] - bins[available_bins[idx-1])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:30:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = []\n                for k, capacity in enumerate(bins):\n                    if capacity >= item:\n                        available_bins.append(k)\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        priorities[available_bins[idx]] = (item - bins[available_bins[idx-1]]) / (bins[available_bins[idx]] - bins[available_bins[idx-1]])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                max_gap = -1\n                max_gap_idx = -1\n                for j, cap in enumerate(bins):\n                    if cap >= item:\n                        gap = cap - item\n                        if gap > max_gap:\n                            max_gap = gap\n                            max_gap_idx = j\n                if max_gap_idx >= 0:\n                    priorities[max_gap_idx] = 1.0\n                    for k in range(max_gap_idx+1, len(bins)):\n                        gap_diff = bins[k] - bins[k-1]\n                        if gap_diff >= item:\n                            priorities[k] = 0.0\n                        else:\n                            priorities[k] = (item - gap_diff) / (bins[k] - bins[k-1])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:30:08", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.4:\n            if item < 5 and bins[i] > 3:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if item > 20:\n            priorities[i] = 7\n        elif bins[i] < 1:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            if remaining_space > 10:\n                priorities[i] = 5\n            elif remaining_space >= 5:\n                priorities[i] = 4\n            elif remaining_space >= 3:\n                priorities[i] = 3\n            elif remaining_space >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:30:11", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.4:\n            if item < 5 and bins[i] > 3:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.4:\n            if item < 5 and bins[i] > 3:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    for j in range(len(bins)):\n        if priorities[j] == 5:\n            if ratios[j] > 1.0:\n                priorities[j] = 7\n        elif priorities[j] == 4:\n            if item > 8 and bins[j] > 4:\n                priorities[j] = 5\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:30:15", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.4:\n            if item < 5 and bins[i] > 3:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.4:\n            if item < 5 and bins[i] > 3:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n        # Additional conditions for increasing priority\n        if item % 2 == 0 and bins[i] % 2 == 0:\n            priorities[i] += 1\n        if item * bins[i] > 100:\n            priorities[i] += 2\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:30:18", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.4:\n            if item < 5 and bins[i] > 3:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.4:\n            if item < 5 and bins[i] > 3:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.2:\n            if item < 8 and bins[i] > 6:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:30:22", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    if left_capacity > item * 0.5:\n                        priorities[i] = np.sqrt(item * left_capacity)\n                    else:\n                        priorities[i] = item / left_capacity + np.log(left_capacity)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:30:25", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.5:\n                    priorities[i] = 2\n                elif 0.5 <= utilization < 0.8:\n                    priorities[i] = np.log(item) * 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:30:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 2.5\n                else:\n                    remaining_ratio = left_capacity / item\n                    if remaining_ratio < 0.2:\n                        priorities[i] = np.sqrt(item * remaining_ratio)\n                    elif remaining_ratio >= 0.2:\n                        priorities[i] = np.log(item * remaining_ratio)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:30:31", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Another improved version with more complex logic.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.5:\n                    priorities[i] = 2\n                elif 0.5 <= utilization < 0.8:\n                    priorities[i] = 3\n                else:\n                    remaining_ratio = left_capacity / item\n                    if left_capacity < 0.2 * item:\n                        priorities[i] = np.sqrt(item * remaining_ratio)\n                    elif left_capacity < 0.5 * item:\n                        priorities[i] = np.cbrt(item * remaining_ratio)\n                    else:\n                        priorities[i] = 5\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:30:34", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]/2:\n            priorities[i] = np.sqrt(item / bins[i])\n        elif item > bins[i]/2 and item <= 2*bins[i]/3:\n            priorities[i] = item ** 2 / bins[i]\n        else:\n            priorities[i] = np.log(item / bins[i]) + 1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:30:36", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/4:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/4 and item <= bins[i]/2:\n            priorities[i] = np.sqrt(item / bins[i])\n        elif item > bins[i]/2 and item <= 3*bins[i]/4:\n            priorities[i] = np.square(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:30:39", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]/2:\n            priorities[i] = np.sqrt(item / bins[i])\n        elif item > bins[i]/2 and item <= 2 * bins[i]/3:\n            priorities[i] = np.cbrt(item / bins[i])\n        elif item > 2 * bins[i]/3 and item <= bins[i]:\n            priorities[i] = (item / bins[i]) ** 0.25\n        else:\n            priorities[i] = np.log(item / bins[i]) + np.sin(item / bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:30:42", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/4:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/4 and item <= bins[i]/2:\n            priorities[i] = np.sqrt(item / bins[i])\n        elif item > bins[i]/2 and item <= 3*bins[i]/4:\n            priorities[i] = np.square(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:30:45", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:30:47", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        max_priority = max(priorities)\n                        if max_priority > 0:\n                            priorities[i] = max_priority + 1\n                        else:\n                            priorities[i] = -1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:30:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\n```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        highest_priority = -1\n                        highest_priority_idx = -1\n                        for k in range(i, j):\n                            if priorities[k] == -1:\n                                continue\n                            if priorities[k] > highest_priority:\n                                highest_priority = priorities[k]\n                                highest_priority_idx = k\n                        if highest_priority > 1:\n                            priorities[highest_priority_idx] = 1\n                            priorities[j] = (j - highest_priority_idx) + 1\n                        else:\n                            priorities[i] = -1\n                            break\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:30:53", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        max_capacity = max(bins)\n                        idx_max_capacity = np.argmax(bins)\n                        priorities[idx_max_capacity] = 10\n                        break\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:30:59", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(data)\n    \n    for i in range(len(data)):\n        if data[i] % 2 == 0:\n            result[i] = data[i] * 2\n        else:\n            temp = 1\n            for j in range(1, data[i] + 1):\n                temp *= j\n            result[i] = temp\n            \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:31:01", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros(len(data))\n    \n    for i in range(len(data)):\n        if data[i] % 2 == 0:\n            result[i] = data[i] * 2\n        else:\n            result[i] = data[i] ** 2\n            \n        if i > 0:\n            result[i] += result[i-1]\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:31:02", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(input_list: list) -> list:\n    output_list = []\n    \n    for item in input_list:\n        if item % 2 == 0:\n            output_list.append(item * 2)\n        else:\n            output_list.append(item // 2)\n    \n    return output_list", "strategy": []}
{"timestamp": "2025-04-27 05:31:04", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_function(input_data):\n    result = []\n    \n    for data in input_data:\n        if data % 2 == 0:\n            if data < 10:\n                result.append(data * 2)\n            else:\n                result.append(data * 3)\n        else:\n            if data < 5:\n                result.append(data + 5)\n            else:\n                result.append(data + 10)\n    \n    return result\n```", "strategy": []}
{"timestamp": "2025-04-27 05:31:09", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(10*ratio) + np.cos(5*ratio) - np.tan(2*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(3*ratio) * np.tan(ratio) + np.sin(4*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(10*ratio) + np.cos(5*ratio) - np.tan(2*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(3*ratio) * np.tan(ratio) + np.sin(4*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(10*ratio) + np.cos(5*ratio) - np.tan(2*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(3*ratio) * np.tan(ratio) + np.sin(4*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        if priority > 10:\n            priorities.append(priority * 2)\n        else:\n            priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:31:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(10*ratio) + np.cos(5*ratio) - np.tan(2*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(3*ratio) * np.tan(ratio) + np.sin(4*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(10*ratio) + np.cos(5*ratio) - np.tan(2*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(3*ratio) * np.tan(ratio) + np.sin(4*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(10*ratio) + np.cos(5*ratio) - np.tan(2*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(3*ratio) * np.tan(ratio) + np.sin(4*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        # Add complexity with more operations based on ratio\n        if ratio < 0.2:\n            priority *= 2\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.power(priority, 2)\n        elif ratio >= 0.8:\n            priority = np.log1p(priority)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:31:16", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(10*ratio) + np.cos(5*ratio) - np.tan(2*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(3*ratio) * np.tan(ratio) + np.sin(4*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(10*ratio) + np.cos(5*ratio) - np.tan(2*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(3*ratio) * np.tan(ratio) + np.sin(4*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(10*ratio) + np.cos(5*ratio) - np.tan(2*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(3*ratio) * np.tan(ratio) + np.sin(4*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        for i in range(1, 6):\n            priority *= np.exp(i*ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:31:19", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(10*ratio) + np.cos(5*ratio) - np.tan(2*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(3*ratio) * np.tan(ratio) + np.sin(4*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(10*ratio) + np.cos(5*ratio) - np.tan(2*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(3*ratio) * np.tan(ratio) + np.sin(4*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:31:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        highest_priority = -1\n                        highest_priority_idx = -1\n                        for k in range(i, j):\n                            if priorities[k] == -1:\n                                continue\n                            if priorities[k] > highest_priority:\n                                highest_priority = priorities[k]\n                                highest_priority_idx = k\n                        if highest_priority > 1:\n                            priorities[highest_priority_idx] = 1\n                            priorities[j] = (j - highest_priority_idx) + 1\n                        else:\n                            priorities[i] = -1\n                            break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        highest_priority = -1\n                        highest_priority_idx = -1\n                        for k in range(i, j):\n                            if priorities[k] == -1:\n                                continue\n                            if priorities[k] > highest_priority:\n                                highest_priority = priorities[k]\n                                highest_priority_idx = k\n                        if highest_priority > 1:\n                            priorities[highest_priority_idx] = 1\n                            priorities[j] = (j - highest_priority_idx) + 1\n                        else:\n                            priorities[i] = -1\n                            break\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        highest_priority = -1\n                        highest_priority_idx = -1\n                        for k in range(i, j):\n                            if priorities[k] == -1:\n                                continue\n                            if priorities[k] > highest_priority:\n                                highest_priority = priorities[k]\n                                highest_priority_idx = k\n                        if highest_priority > 1:\n                            priorities[highest_priority_idx] = 1\n                            priorities[j] = (j - highest_priority_idx) + 1\n                        else:\n                            priorities[i] = -1\n                            break\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:31:32", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        highest_priority = -1\n                        highest_priority_idx = -1\n                        for k in range(i, j):\n                            if priorities[k] == -1:\n                                continue\n                            if priorities[k] > highest_priority:\n                                highest_priority = priorities[k]\n                                highest_priority_idx = k\n                        if highest_priority > 1:\n                            priorities[highest_priority_idx] = 1\n                            priorities[j] = (j - highest_priority_idx) + 1\n                        else:\n                            priorities[i] = -1\n                            break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        highest_priority = -1\n                        highest_priority_idx = -1\n                        for k in range(i, j):\n                            if priorities[k] == -1:\n                                continue\n                            if priorities[k] > highest_priority:\n                                highest_priority = priorities[k]\n                                highest_priority_idx = k\n                        if highest_priority > 1:\n                            priorities[highest_priority_idx] = 1\n                            priorities[j] = (j - highest_priority_idx) + 1\n                        else:\n                            priorities[i] = -1\n                            break\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        highest_priority = -1\n                        highest_priority_idx = -1\n                        for k in range(i, j):\n                            if priorities[k] == -1:\n                                continue\n                            if priorities[k] > highest_priority:\n                                highest_priority = priorities[k]\n                                highest_priority_idx = k\n                        if highest_priority > 1:\n                            priorities[highest_priority_idx] = 1\n                            priorities[j] = (j - highest_priority_idx) + 1\n                        else:\n                            priorities[i] = -1\n                            break\n    \n    priorities_copy = np.copy(priorities)\n    \n    for i in range(len(bins)):\n        if priorities_copy[i] == -1:\n            for j in range(len(bins)):\n                if priorities_copy[j] == 0:\n                    priorities[j] = 1\n                    break\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:31:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        highest_priority = -1\n                        highest_priority_idx = -1\n                        for k in range(i, j):\n                            if priorities[k] == -1:\n                                continue\n                            if priorities[k] > highest_priority:\n                                highest_priority = priorities[k]\n                                highest_priority_idx = k\n                        if highest_priority > 1:\n                            priorities[highest_priority_idx] = 1\n                            priorities[j] = (j - highest_priority_idx) + 1\n                        else:\n                            priorities[i] = -1\n                            break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        highest_priority = -1\n                        highest_priority_idx = -1\n                        for k in range(i, j):\n                            if priorities[k] == -1:\n                                continue\n                            if priorities[k] > highest_priority:\n                                highest_priority = priorities[k]\n                                highest_priority_idx = k\n                        if highest_priority > 1:\n                            priorities[highest_priority_idx] = 1\n                            priorities[j] = (j - highest_priority_idx) + 1\n                        else:\n                            priorities[i] = -1\n                            break\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        highest_priority = -1\n                        highest_priority_idx = -1\n                        for k in range(i, j):\n                            if priorities[k] == -1:\n                                continue\n                            if priorities[k] > highest_priority:\n                                highest_priority = priorities[k]\n                                highest_priority_idx = k\n                        if highest_priority > 1:\n                            priorities[highest_priority_idx] = 1\n                            priorities[j] = (j - highest_priority_idx) + 1\n                        else:\n                            priorities[i] = -1\n                            break\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:31:38", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        highest_priority = -1\n                        highest_priority_idx = -1\n                        for k in range(i, j):\n                            if priorities[k] == -1:\n                                continue\n                            if priorities[k] > highest_priority:\n                                highest_priority = priorities[k]\n                                highest_priority_idx = k\n                        if highest_priority > 1:\n                            priorities[highest_priority_idx] = 1\n                            priorities[j] = (j - highest_priority_idx) + 1\n                        else:\n                            priorities[i] = -1\n                            break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        highest_priority = -1\n                        highest_priority_idx = -1\n                        for k in range(i, j):\n                            if priorities[k] == -1:\n                                continue\n                            if priorities[k] > highest_priority:\n                                highest_priority = priorities[k]\n                                highest_priority_idx = k\n                        if highest_priority > 1:\n                            priorities[highest_priority_idx] = 1\n                            priorities[j] = (j - highest_priority_idx) + 1\n                        else:\n                            priorities[i] = -1\n                            break\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        has_priority = False\n                        for k in range(i, j):\n                            if priorities[k] > 0:\n                                has_priority = True\n                                break\n                        if has_priority:\n                            max_priority = max(priorities[i:j])\n                            max_priority_idx = i + np.argmax(priorities[i:j])\n                            priorities[max_priority_idx] = 1\n                            priorities[j] = (j - max_priority_idx) + 1\n                        else:\n                            priorities[i] = -1\n                            break\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:31:43", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.4:\n            if item < 5 and bins[i] > 3:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.4:\n            if item < 5 and bins[i] > 3:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:31:46", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.4:\n            if item < 5 and bins[i] > 3:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.4:\n            if item < 5 and bins[i] > 3:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 15 and bins[i] <= 10:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif 0.6 <= ratios[i] <= 0.9:\n            if item > 5 and bins[i] > 5:\n                priorities[i] = 4\n            elif bins[i] <= 5:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if item < 5 and bins[i] > 3:\n                priorities[i] = 2\n            elif bins[i] <= 3:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:31:49", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.4:\n            if item < 5 and bins[i] > 3:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.4:\n            if item < 5 and bins[i] > 3:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.4:\n            if item < 5 and bins[i] > 3:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:31:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.4:\n            if item < 5 and bins[i] > 3:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.4:\n            if item < 5 and bins[i] > 3:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.6:\n            if item < 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.4:\n            if item < 5 and bins[i] > 3:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] < 2:\n                priorities[i] = 0\n            else:\n                priorities[i] = 1\n\n    for j in range(len(bins)):\n        if priorities[j] == 0:\n            priorities[j] = priorities[j] + 1\n        elif priorities[j] == 1:\n            priorities[j] = priorities[j] + 2\n        elif priorities[j] == 2:\n            priorities[j] = priorities[j] + 3\n        elif priorities[j] == 3:\n            priorities[j] = priorities[j] + 2\n        elif priorities[j] == 4:\n            priorities[j] = priorities[j] + 1\n        else:\n            priorities[j] = priorities[j] + 1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:32:04", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    remaining_capacity = bins[j]\n                    priority = 0.0\n                    while remaining_capacity < item:\n                        priority += 0.2\n                        remaining_capacity += bins[j]\n                    if priority > 0.7:\n                        priorities[j] = 0.8\n                    elif priority < 0.4:\n                        priorities[j] = 0.6\n                    else:\n                        priorities[j] = 0.7\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:32:07", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 2.0\n            elif priority < 0.3:\n                priorities[i] *= 0.5\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.8\n                else:\n                    priorities[j] = 0.6\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:32:10", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n            \n            if i % 2 == 0:\n                priorities[i] *= 1.2\n            else:\n                priorities[i] *= 0.9\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:32:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n                    \n            if sum(priorities) < 1.0:\n                priorities = priorities / sum(priorities)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:32:17", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n\n    max_capacity = max(bins)\n    max_capacity_idx = np.argmax(bins)\n\n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        prev_bin_capacity = bins[available_bins[idx-1]]\n                        curr_bin_capacity = bins[available_bins[idx]]\n                        priorities[available_bins[idx]] = (item - prev_bin_capacity) / (curr_bin_capacity - prev_bin_capacity)\n                else:\n                    priorities[max_capacity_idx] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    sum_priorities = sum(priorities)\n    if sum_priorities > 1.0:\n        priorities = priorities / sum_priorities\n    \n    max_priority_idx = np.argmax(priorities)\n    max_priority = priorities[max_priority_idx]\n    for k, priority in enumerate(priorities):\n        if k != max_priority_idx and priority == max_priority:\n            priorities[k] -= 0.1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:32:20", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n\n    max_capacity = max(bins)\n    max_capacity_idx = np.argmax(bins)\n\n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        prev_bin_capacity = bins[available_bins[idx-1]]\n                        curr_bin_capacity = bins[available_bins[idx]]\n                        priorities[available_bins[idx]] = (item - prev_bin_capacity) / (curr_bin_capacity - prev_bin_capacity)\n                else:\n                    priorities[max_capacity_idx] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of prioritizing items into bins.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    max_capacity = max(bins)\n    max_capacity_idx = np.argmax(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        prev_bin_capacity = bins[available_bins[idx-1]]\n                        curr_bin_capacity = bins[available_bins[idx]]\n                        priorities[available_bins[idx]] = (item - prev_bin_capacity) / (curr_bin_capacity - prev_bin_capacity)\n                else:\n                    priorities[max_capacity_idx] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:32:24", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n\n    max_capacity = max(bins)\n    max_capacity_idx = np.argmax(bins)\n\n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        prev_bin_capacity = bins[available_bins[idx-1]]\n                        curr_bin_capacity = bins[available_bins[idx]]\n                        priorities[available_bins[idx]] = (item - prev_bin_capacity) / (curr_bin_capacity - prev_bin_capacity)\n                else:\n                    priorities[max_capacity_idx] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = [k for k, capacity in enumerate(bins) if capacity >= item and k != i]\n                if available_bins:\n                    for idx in available_bins:\n                        cum_capacity = sum(bins[:idx])\n                        if item <= cum_capacity + bins[idx]:\n                            priorities[idx] = 1 - ((item - cum_capacity) / bins[idx])\n                            break\n                    else:\n                        max_idx = np.argmax([p for p in priorities])\n                        priorities[max_idx] = 1 - ((item - remaining_capacity) / (bins[max_idx] - remaining_capacity))\n                else:\n                    max_idx = np.argmax([p for p in priorities])\n                    priorities[max_idx] = 1 - ((item - remaining_capacity) / (bins[max_idx] - remaining_capacity))\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:32:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n\n    max_capacity = max(bins)\n    max_capacity_idx = np.argmax(bins)\n\n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        prev_bin_capacity = bins[available_bins[idx-1]]\n                        curr_bin_capacity = bins[available_bins[idx]]\n                        priorities[available_bins[idx]] = (item - prev_bin_capacity) / (curr_bin_capacity - prev_bin_capacity)\n                else:\n                    priorities[max_capacity_idx] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority score for each bin based on item size and bin capacities.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    max_capacity = max(bins)\n    max_capacity_idx = np.argmax(bins)\n    \n    for i in range(len(bins)):\n        if item == bins[i]:\n            priorities[i] = 1.0\n        elif item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            remaining_capacity = bins[i]\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        prev_bin_capacity = bins[available_bins[idx-1]]\n                        curr_bin_capacity = bins[available_bins[idx]]\n                        priorities[available_bins[idx]] = (item - prev_bin_capacity) / (curr_bin_capacity - prev_bin_capacity)\n                else:\n                    priorities[max_capacity_idx] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:32:32", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(matrix: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(matrix)\n\n    for i in range(matrix.shape[0]):\n        for j in range(matrix.shape[1]):\n            if matrix[i, j] % 2 == 0:\n                result[i, j] = 2 * matrix[i, j]\n            else:\n                if matrix[i, j] > 5:\n                    result[i, j] = matrix[i, j] ** 2\n                else:\n                    result[i, j] = matrix[i, j] + 10\n\n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:32:34", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> int:\n    result = 0\n    \n    for i in range(len(data)):\n        if data[i] % 2 == 0:\n            result += data[i] * 2\n        elif data[i] % 3 == 0:\n            result -= data[i] * 3\n        else:\n            result += data[i] * 1\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:32:36", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(input_list: list) -> int:\n    output = 0\n    \n    for i in range(len(input_list)):\n        if input_list[i] % 2 == 0:\n            output += input_list[i] ** 2\n        else:\n            output -= input_list[i] * 2\n            \n    if output > 100:\n        output = output // 2\n    elif output < -100:\n        output = output * 3\n    \n    return output", "strategy": []}
{"timestamp": "2025-04-27 05:32:38", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(data)\n    \n    for i in range(len(data)):\n        if data[i] % 2 == 0:\n            result[i] = data[i] * 2\n        else:\n            temp = data[i]\n            while temp > 10:\n                temp -= 5\n            result[i] = temp\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:32:43", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 2.0\n            elif 0.4 <= priority <= 0.7:\n                priorities[i] *= 1.5\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.8\n                else:\n                    priorities[j] = 0.4\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:32:45", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.4\n                else:\n                    priority += 0.6\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 1.8\n            elif priority < 0.4:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.7\n                else:\n                    priorities[j] = 0.4\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:32:48", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif 0.3 <= priority <= 0.5:\n                priorities[i] *= 1.2\n            else:\n                priorities[i] *= 0.8\n            \n            if i % 2 == 0:\n                priorities[i] *= 1.2\n            else:\n                priorities[i] *= 0.9\n                \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:32:51", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 2.0\n            elif priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:32:56", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            elif bin_capacity % 2 == 0:\n                priority = 1 / (bin_capacity - item + 2)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:32:59", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        for j in range(3, int(bin_capacity/3)):\n                            if bin_capacity % j == 0:\n                                priority = 1 / (bin_capacity - item + j)\n                                break\n                            else:\n                                priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:33:02", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        if bin_capacity % 3 == 0:\n                            priority = 1.5 / (bin_capacity - item + 2)\n                        else:\n                            priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:33:05", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            elif bin_capacity % item == 1:\n                priority = 5 / (bin_capacity - item + 2)\n            else:\n                found_divisor = False\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        found_divisor = True\n                        break\n                if not found_divisor:\n                    priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:33:08", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Enhanced version of `priority_v1` with additional logic.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            elif item > bin_capacity + max(bins): \n                priorities[i] = 0.0\n            else:\n                temp = item - remaining_capacity\n                for j in range(i+1, len(bins)):\n                    if item <= bins[j]:\n                        priorities[j] = 1.0 - (temp / bins[j])\n                        break\n                if priorities[i] == 0:\n                    for j in range(i+1, len(bins)):\n                        if item <= bins[j] + max(bins):\n                            priorities[j] = 1.0 - (temp / (bins[j] + max(bins)))\n                            break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = []\n                for k, capacity in enumerate(bins):\n                    if capacity >= item:\n                        available_bins.append(k)\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        priorities[available_bins[idx]] = (item - bins[available_bins[idx-1]]) / (bins[available_bins[idx]] - bins[available_bins[idx-1]])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = np.sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                total_available_capacity = remaining_capacity\n                for j in range(i+1, len(bins)):\n                    total_available_capacity += bins[j]\n                    if item <= total_available_capacity:\n                        for k in range(i, j):\n                            priorities[k] = (total_available_capacity - item) / (total_available_capacity - bins[i])\n                        break\n                    elif item > total_available_capacity and j == len(bins) - 1:\n                        for k in range(i, j+1):\n                            priorities[k] = 0.0\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:33:11", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Enhanced version of `priority_v1` with additional logic.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            elif item > bin_capacity + max(bins): \n                priorities[i] = 0.0\n            else:\n                temp = item - remaining_capacity\n                for j in range(i+1, len(bins)):\n                    if item <= bins[j]:\n                        priorities[j] = 1.0 - (temp / bins[j])\n                        break\n                if priorities[i] == 0:\n                    for j in range(i+1, len(bins)):\n                        if item <= bins[j] + max(bins):\n                            priorities[j] = 1.0 - (temp / (bins[j] + max(bins)))\n                            break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = []\n                for k, capacity in enumerate(bins):\n                    if capacity >= item:\n                        available_bins.append(k)\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        priorities[available_bins[idx]] = (item - bins[available_bins[idx-1]]) / (bins[available_bins[idx]] - bins[available_bins[idx-1]])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            elif item > bin_capacity + max(bins): \n                priorities[i] = 0.0\n            else:\n                temp = item - remaining_capacity\n                for j in range(i+1, len(bins)):\n                    if item <= bins[j]:\n                        priorities[j] = 1.0 - (temp / bins[j])\n                        break\n                if priorities[i] == 0:\n                    for j in range(i+1, len(bins)):\n                        if item <= bins[j] + max(bins):\n                            priorities[j] = 1.0 - (temp / (bins[j] + max(bins)))\n                            break\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:33:15", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Enhanced version of `priority_v1` with additional logic.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            elif item > bin_capacity + max(bins): \n                priorities[i] = 0.0\n            else:\n                temp = item - remaining_capacity\n                for j in range(i+1, len(bins)):\n                    if item <= bins[j]:\n                        priorities[j] = 1.0 - (temp / bins[j])\n                        break\n                if priorities[i] == 0:\n                    for j in range(i+1, len(bins)):\n                        if item <= bins[j] + max(bins):\n                            priorities[j] = 1.0 - (temp / (bins[j] + max(bins)))\n                            break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = []\n                for k, capacity in enumerate(bins):\n                    if capacity >= item:\n                        available_bins.append(k)\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        priorities[available_bins[idx]] = (item - bins[available_bins[idx-1]]) / (bins[available_bins[idx]] - bins[available_bins[idx-1]])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity - sum(bins[:i])\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                min_diff = float('inf')\n                target_bin = -1\n                for j in range(i, len(bins)):\n                    diff = bins[j] - item\n                    if diff >= 0 and diff < min_diff:\n                        min_diff = diff\n                        target_bin = j\n                if target_bin != -1:\n                    priorities[target_bin] = 1.0 - (min_diff / item)\n                else:\n                    max_cap = max(bins)\n                    for j, capacity in enumerate(bins):\n                        if capacity == max_cap:\n                            priorities[j] = 1.0 - (capacity - item) / capacity\n    \n    return priorities\n```  ", "strategy": []}
{"timestamp": "2025-04-27 05:33:18", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Enhanced version of `priority_v1` with additional logic.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            elif item > bin_capacity + max(bins): \n                priorities[i] = 0.0\n            else:\n                temp = item - remaining_capacity\n                for j in range(i+1, len(bins)):\n                    if item <= bins[j]:\n                        priorities[j] = 1.0 - (temp / bins[j])\n                        break\n                if priorities[i] == 0:\n                    for j in range(i+1, len(bins)):\n                        if item <= bins[j] + max(bins):\n                            priorities[j] = 1.0 - (temp / (bins[j] + max(bins)))\n                            break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = []\n                for k, capacity in enumerate(bins):\n                    if capacity >= item:\n                        available_bins.append(k)\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        priorities[available_bins[idx]] = (item - bins[available_bins[idx-1]]) / (bins[available_bins[idx]] - bins[available_bins[idx-1]])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity - sum(bins[:i])\n            if remaining_capacity >= item:\n                priorities[i] = 1.0\n            else:\n                available_bins = []\n                for k, capacity in enumerate(bins):\n                    if capacity >= item:\n                        available_bins.append(k)\n                \n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        priorities[available_bins[idx]] = (item - bins[available_bins[idx-1]]) / (bins[available_bins[idx]] - bins[available_bins[idx-1])\n                else:\n                    last_bin = bins[i] - sum(bins[:i])\n                    if last_bin >= item:\n                        priorities[i] = 1.0\n                    else:\n                        max_capacity = max(bins)\n                        max_index = np.argmax(bins)\n                        priorities[max_index] = 1 - ((item - last_bin) / (max_capacity - last_bin))\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:33:26", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.3:\n            if item > 1 and bins[i] > 0.5:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n        else:\n            priorities[i] = 0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:33:32", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.8:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 7\n            elif item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 4\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 3\n            elif item > 1 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:33:36", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    max_priority = np.max(priorities)\n    for i in range(len(bins)):\n        if priorities[i] == max_priority:\n            priorities[i] += 1\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:33:38", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 5\n        else:\n            if item > 10:\n                priorities[i] = 4\n            elif item > 5:\n                priorities[i] = 3\n            elif item > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:33:42", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n\n    max_capacity = max(bins)\n    max_capacity_idx = np.argmax(bins)\n\n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        prev_bin_capacity = bins[available_bins[idx-1]]\n                        curr_bin_capacity = bins[available_bins[idx]]\n                        priorities[available_bins[idx]] = (item - prev_bin_capacity) / (curr_bin_capacity - prev_bin_capacity)\n                else:\n                    priorities[max_capacity_idx] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Enhanced version of `priority_v1` with additional logic.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            elif item > bin_capacity + max(bins): \n                priorities[i] = 0.0\n            else:\n                temp = item - remaining_capacity\n                for j in range(i+1, len(bins)):\n                    if item <= bins[j]:\n                        priorities[j] = 1.0 - (temp / bins[j])\n                        break\n                if priorities[i] == 0:\n                    for j in range(i+1, len(bins)):\n                        if item <= bins[j] + max(bins):\n                            priorities[j] = 1.0 - (temp / (bins[j] + max(bins)))\n                            break\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            elif item > bin_capacity + max(bins): \n                priorities[i] = 0.0\n            else:\n                temp = item - remaining_capacity\n                for j in range(i+1, len(bins)):\n                    if item <= bins[j]:\n                        priorities[j] = 1.0 - (temp / bins[j])\n                        break\n                if priorities[i] == 0:\n                    for j in range(i+1, len(bins)):\n                        if item <= bins[j] + max(bins):\n                            priorities[j] = 1.0 - (temp / (bins[j] + max(bins)))\n                            break\n                if priorities[i] == 0:\n                    for j in range(len(bins)-1, i-1, -1):\n                        if item <= bins[j]:\n                            priorities[j] = 1.0 - (temp / bins[j])\n                            break\n                            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:33:46", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n\n    max_capacity = max(bins)\n    max_capacity_idx = np.argmax(bins)\n\n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        prev_bin_capacity = bins[available_bins[idx-1]]\n                        curr_bin_capacity = bins[available_bins[idx]]\n                        priorities[available_bins[idx]] = (item - prev_bin_capacity) / (curr_bin_capacity - prev_bin_capacity)\n                else:\n                    priorities[max_capacity_idx] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Enhanced version of `priority_v1` with additional logic.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            elif item > bin_capacity + max(bins): \n                priorities[i] = 0.0\n            else:\n                temp = item - remaining_capacity\n                for j in range(i+1, len(bins)):\n                    if item <= bins[j]:\n                        priorities[j] = 1.0 - (temp / bins[j])\n                        break\n                if priorities[i] == 0:\n                    for j in range(i+1, len(bins)):\n                        if item <= bins[j] + max(bins):\n                            priorities[j] = 1.0 - (temp / (bins[j] + max(bins)))\n                            break\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            elif item > bin_capacity + max(bins): \n                priorities[i] = 0.0\n            else:\n                temp = item - remaining_capacity\n                for j in range(i+1, len(bins)):\n                    if item <= bins[j]:\n                        priorities[j] = 1.0 - (temp / bins[j])\n                        break\n                if priorities[i] == 0:\n                    for j in range(i+1, len(bins)):\n                        if item <= bins[j] + max(bins):\n                            priorities[j] = 1.0 - (temp / (bins[j] + max(bins)))\n                            break\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:33:49", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n\n    max_capacity = max(bins)\n    max_capacity_idx = np.argmax(bins)\n\n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        prev_bin_capacity = bins[available_bins[idx-1]]\n                        curr_bin_capacity = bins[available_bins[idx]]\n                        priorities[available_bins[idx]] = (item - prev_bin_capacity) / (curr_bin_capacity - prev_bin_capacity)\n                else:\n                    priorities[max_capacity_idx] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Enhanced version of `priority_v1` with additional logic.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            elif item > bin_capacity + max(bins): \n                priorities[i] = 0.0\n            else:\n                temp = item - remaining_capacity\n                for j in range(i+1, len(bins)):\n                    if item <= bins[j]:\n                        priorities[j] = 1.0 - (temp / bins[j])\n                        break\n                if priorities[i] == 0:\n                    for j in range(i+1, len(bins)):\n                        if item <= bins[j] + max(bins):\n                            priorities[j] = 1.0 - (temp / (bins[j] + max(bins)))\n                            break\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            elif item > bin_capacity + max(bins): \n                priorities[i] = 0.0\n            else:\n                temp = item - remaining_capacity\n                for j in range(i+1, len(bins)):\n                    if item <= bins[j]:\n                        priorities[j] = 1.0 - (temp / bins[j])\n                        break\n                if priorities[i] == 0:\n                    for j in range(i+1, len(bins)):\n                        if item <= bins[j] + max(bins):\n                            priorities[j] = 1.0 - (temp / (bins[j] + max(bins)))\n                            break\n                if priorities[i] == 0:\n                    for j in range(len(bins)-1, i-1, -1):\n                        if item <= bins[j] and priorities[j] == 0:\n                            priorities[j] = 1.0 - (temp / bins[j])\n                            break\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:33:52", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n\n    max_capacity = max(bins)\n    max_capacity_idx = np.argmax(bins)\n\n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        prev_bin_capacity = bins[available_bins[idx-1]]\n                        curr_bin_capacity = bins[available_bins[idx]]\n                        priorities[available_bins[idx]] = (item - prev_bin_capacity) / (curr_bin_capacity - prev_bin_capacity)\n                else:\n                    priorities[max_capacity_idx] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Enhanced version of `priority_v1` with additional logic.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            elif item > bin_capacity + max(bins): \n                priorities[i] = 0.0\n            else:\n                temp = item - remaining_capacity\n                for j in range(i+1, len(bins)):\n                    if item <= bins[j]:\n                        priorities[j] = 1.0 - (temp / bins[j])\n                        break\n                if priorities[i] == 0:\n                    for j in range(i+1, len(bins)):\n                        if item <= bins[j] + max(bins):\n                            priorities[j] = 1.0 - (temp / (bins[j] + max(bins)))\n                            break\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            elif item > bin_capacity + max(bins):\n                priorities[i] = 0.0\n            else:\n                temp = item - remaining_capacity\n                for j in range(i+1, len(bins)):\n                    if item <= bins[j]:\n                        priorities[j] = 1.0 - (temp / bins[j])\n                        break\n                if priorities[i] == 0:\n                    for j in range(i+1, len(bins)):\n                        if item <= bins[j] + max(bins):\n                            priorities[j] = 1.0 - (temp / (bins[j] + max(bins)))\n                            break\n                if priorities[i] == 0:\n                    tmp = 0\n                    for k in range(i+1, len(bins)):\n                        tmp += bins[k]\n                        if tmp >= item:\n                            priorities[k] = 1.0 - ((tmp - item) / bins[k])\n                            break\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:33:56", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1:\n            priorities[i] = 7\n        elif ratios[i] > 0.9:\n            priorities[i] = 6\n        elif ratios[i] > 0.8:\n            priorities[i] = 5\n        elif ratios[i] > 0.7:\n            priorities[i] = 4\n        elif ratios[i] > 0.6:\n            priorities[i] = 3\n        elif ratios[i] > 0.5:\n            priorities[i] = 2\n        else:\n            priorities[i] = 1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:34:01", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] >= 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] >= 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                if item < 2:\n                    if ratios[i] <= 0.3:\n                        priorities[i] = 0\n                    else:\n                        priorities[i] = 1\n                else:\n                    for j in range(1, int(item)+1):\n                        if bins[i] < j:\n                            priorities[i] = j - 1\n                            break\n            else:\n                priorities[i] = 0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:34:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n        if ratios[i] < 0.3 or bins[i] < 2:\n            priorities[i] -= 1\n        elif 0.3 <= ratios[i] < 0.5 and item < 5:\n            priorities[i] += 1\n        elif 0.5 <= ratios[i] < 0.7 and item < 8:\n            priorities[i] += 2\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:34:09", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 8\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 7\n            else:\n                priorities[i] = 6\n        elif ratios[i] >= 0.8:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 6\n            elif item > 5 and bins[i] > 4:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.6:\n            if item > 3 and bins[i] > 2:\n                priorities[i] = 4\n            elif item > 2 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.4:\n            if item > 1 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:34:22", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    for j in range(len(bins)):\n        if ratios[j] <= 0.2:\n            if item < 3 and bins[j] <= 5:\n                priorities[j] += 1\n            else:\n                priorities[j] += 0.5\n\n        if item <= 5 and bins[j] >= 8:\n            priorities[j] += 2\n\n        if item <= 3 and bins[j] >= 10:\n            priorities[j] += 3\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:34:26", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    for j in range(len(bins)):\n        if priorities[j] == 4:\n            priorities[j] += 1\n        elif priorities[j] == 3:\n            priorities[j] += 2\n        elif priorities[j] == 2:\n            priorities[j] += 3\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:34:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n        \n        if bins[i] < item:\n            priorities[i] = 0\n        \n        if item % 2 == 0 and bins[i] % 2 == 0:\n            priorities[i] *= 2\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:34:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    # Additional complex logic\n    for i in range(len(bins)):\n        if priorities[i] == 4:\n            priorities[i] += np.sqrt(item)  # Adjust priority based on item size\n        elif priorities[i] == 3:\n            priorities[i] += np.log(item)  # Adjust priority based on item size\n        elif priorities[i] == 2:\n            priorities[i] *= np.log(bins[i])  # Adjust priority based on bin capacity\n        else:\n            priorities[i] -= 1\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:34:40", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                max_gap = -1\n                max_gap_idx = -1\n                for j, cap in enumerate(bins):\n                    if cap >= item:\n                        gap = cap - item\n                        if gap > max_gap:\n                            max_gap = gap\n                            max_gap_idx = j\n                if max_gap_idx >= 0:\n                    priorities[max_gap_idx] = 1.0\n                    for k in range(max_gap_idx+1, len(bins)):\n                        gap_diff = bins[k] - bins[k-1]\n                        if gap_diff >= item:\n                            priorities[k] = 0.0\n                        else:\n                            priorities[k] = (item - gap_diff) / (bins[k] - bins[k-1])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n\n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                max_gap = -1\n                max_gap_idx = -1\n                for j, cap in enumerate(bins):\n                    if cap >= item:\n                        gap = cap - item\n                        if gap > max_gap:\n                            max_gap = gap\n                            max_gap_idx = j\n                if max_gap_idx >= 0:\n                    priorities[max_gap_idx] = 1.0\n                    for k in range(max_gap_idx + 1, len(bins)):\n                        gap_diff = bins[k] - bins[k - 1]\n                        if gap_diff >= item:\n                            priorities[k] = 0.0\n                        else:\n                            priorities[k] = (item - gap_diff) / (bins[k] - bins[k - 1])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:34:43", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                max_gap = -1\n                max_gap_idx = -1\n                for j, cap in enumerate(bins):\n                    if cap >= item:\n                        gap = cap - item\n                        if gap > max_gap:\n                            max_gap = gap\n                            max_gap_idx = j\n                if max_gap_idx >= 0:\n                    priorities[max_gap_idx] = 1.0\n                    for k in range(max_gap_idx+1, len(bins)):\n                        gap_diff = bins[k] - bins[k-1]\n                        if gap_diff >= item:\n                            priorities[k] = 0.0\n                        else:\n                            priorities[k] = (item - gap_diff) / (bins[k] - bins[k-1])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    max_capacity = max(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                max_gap = -1\n                max_gap_idx = -1\n                for j, cap in enumerate(bins):\n                    if cap >= item:\n                        gap = cap - item\n                        if gap > max_gap:\n                            max_gap = gap\n                            max_gap_idx = j\n                if max_gap_idx >= 0:\n                    priorities[max_gap_idx] = 1.0\n                    for k in range(max_gap_idx+1, len(bins)):\n                        gap_diff = bins[k] - bins[k-1]\n                        if gap_diff >= item:\n                            priorities[k] = 0.0\n                        else:\n                            priorities[k] = (item - gap_diff) / (bins[k] - bins[k-1])\n                else:\n                    max_index = np.argmax(bins)\n                    if max_index == i:\n                        priorities[i] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n                    else:\n                        priorities[i] = 0.1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:34:47", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                max_gap = -1\n                max_gap_idx = -1\n                for j, cap in enumerate(bins):\n                    if cap >= item:\n                        gap = cap - item\n                        if gap > max_gap:\n                            max_gap = gap\n                            max_gap_idx = j\n                if max_gap_idx >= 0:\n                    priorities[max_gap_idx] = 1.0\n                    for k in range(max_gap_idx+1, len(bins)):\n                        gap_diff = bins[k] - bins[k-1]\n                        if gap_diff >= item:\n                            priorities[k] = 0.0\n                        else:\n                            priorities[k] = (item - gap_diff) / (bins[k] - bins[k-1])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                max_gap = -1\n                max_gap_idx = -1\n                for j, cap in enumerate(bins):\n                    if cap >= item:\n                        gap = cap - item\n                        if gap > max_gap:\n                            max_gap = gap\n                            max_gap_idx = j\n                if max_gap_idx >= 0:\n                    priorities[max_gap_idx] = 1.0\n                    for k in range(max_gap_idx+1, len(bins)):\n                        gap_diff = bins[k] - bins[k-1]\n                        if gap_diff >= item:\n                            priorities[k] = 0.0\n                        else:\n                            priorities[k] = (item - gap_diff) / (bins[k] - bins[k-1])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:34:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                max_gap = -1\n                max_gap_idx = -1\n                for j, cap in enumerate(bins):\n                    if cap >= item:\n                        gap = cap - item\n                        if gap > max_gap:\n                            max_gap = gap\n                            max_gap_idx = j\n                if max_gap_idx >= 0:\n                    priorities[max_gap_idx] = 1.0\n                    for k in range(max_gap_idx+1, len(bins)):\n                        gap_diff = bins[k] - bins[k-1]\n                        if gap_diff >= item:\n                            priorities[k] = 0.0\n                        else:\n                            priorities[k] = (item - gap_diff) / (bins[k] - bins[k-1])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                max_gap = -1\n                max_gap_idx = -1\n                for j, cap in enumerate(bins):\n                    if cap >= item:\n                        gap = cap - item\n                        if gap > max_gap:\n                            max_gap = gap\n                            max_gap_idx = j\n                if max_gap_idx >= 0:\n                    priorities[max_gap_idx] = 1.0\n                    for k in range(max_gap_idx+1, len(bins)):\n                        gap_diff = bins[k] - bins[k-1]\n                        if gap_diff >= item:\n                            priorities[k] = 0.0\n                        else:\n                            priorities[k] = (item - gap_diff) / (bins[k] - bins[k-1])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:34:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n            \n        if priority < 0:\n            priorities.append(priority)\n        else:\n            update_priority = priority + (bin_capacity / item)\n            priorities.append(update_priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:34:56", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 3 / (bin_capacity - item + 2)\n            else:\n                for i in range(2, int(bin_capacity/3)):\n                    if bin_capacity % i == 0:\n                        priority = 2 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 2)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:34:59", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        num_divisors = 0\n                        for j in range(1, bin_capacity + 1):\n                            if bin_capacity % j == 0:\n                                num_divisors += 1\n                        priority = num_divisors / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:35:02", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        add = 0\n                        for j in range(2, int(bin_capacity/3)):\n                            if bin_capacity % j == 0:\n                                priority = 0.5 / (bin_capacity - item + j)\n                                add = 1\n                                break\n                        if add == 0:\n                            priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:35:05", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n        \n        if bins[i] < 0.5 * item:\n            priorities[i] *= 1.5  # Increase priority for bins with low capacity\n        elif bins[i] > 1.5 * item:\n            priorities[i] *= 0.5  # Decrease priority for bins with high capacity\n        else:\n            priorities[i] *= 1.0  # Keep priority unchanged\n        \n        if i % 2 == 0:\n            priorities[i] += 2  # Add additional priority for even-indexed bins\n        else:\n            priorities[i] -= 1  # Reduce priority for odd-indexed bins\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n            if bins[i] <= 0.3 * max_bin_capacity:\n                priorities[i] += 1.2 * bins[i]  # Increase priority for bins with very low capacity\n        else:\n            priorities[i] = bins[i] - item\n            if bins[i] >= 0.7 * max_bin_capacity:\n                priorities[i] -= 1.1 * (bins[i] - item)  # Decrease priority for bins with high capacity\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])\n            if bins[i] <= 0.3 * max_bin_capacity:\n                priorities[i] += 1.2 * bins[i]\n        else:\n            priorities[i] = bins[i] - item\n            if bins[i] >= 0.7 * max_bin_capacity:\n                priorities[i] -= 1.1 * (bins[i] - item)\n        \n        if item < 0.5 * max_bin_capacity:\n            priorities[i] *= 1.2\n        else:\n            priorities[i] *= 0.8\n        \n        if item % 2 == 0:\n            priorities[i] += 3\n        else:\n            priorities[i] -= 2\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:35:08", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n        \n        if bins[i] < 0.5 * item:\n            priorities[i] *= 1.5  # Increase priority for bins with low capacity\n        elif bins[i] > 1.5 * item:\n            priorities[i] *= 0.5  # Decrease priority for bins with high capacity\n        else:\n            priorities[i] *= 1.0  # Keep priority unchanged\n        \n        if i % 2 == 0:\n            priorities[i] += 2  # Add additional priority for even-indexed bins\n        else:\n            priorities[i] -= 1  # Reduce priority for odd-indexed bins\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n            if bins[i] <= 0.3 * max_bin_capacity:\n                priorities[i] += 1.2 * bins[i]  # Increase priority for bins with very low capacity\n        else:\n            priorities[i] = bins[i] - item\n            if bins[i] >= 0.7 * max_bin_capacity:\n                priorities[i] -= 1.1 * (bins[i] - item)  # Decrease priority for bins with high capacity\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more advanced version of priority calculation.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n            if bins[i] <= 0.3 * max_bin_capacity:\n                priorities[i] += 1.2 * bins[i]  # Increase priority for bins with very low capacity\n        else:\n            priorities[i] = bins[i] - item\n            if bins[i] >= 0.7 * max_bin_capacity:\n                priorities[i] -= 1.1 * (bins[i] - item)  # Decrease priority for bins with high capacity\n        \n        if i % 3 == 0:\n            priorities[i] += 3.5  # Add extra priority every 3rd bin\n        elif i % 5 == 0:\n            priorities[i] -= 2.0  # Reduce priority every 5th bin\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:35:12", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n        \n        if bins[i] < 0.5 * item:\n            priorities[i] *= 1.5  # Increase priority for bins with low capacity\n        elif bins[i] > 1.5 * item:\n            priorities[i] *= 0.5  # Decrease priority for bins with high capacity\n        else:\n            priorities[i] *= 1.0  # Keep priority unchanged\n        \n        if i % 2 == 0:\n            priorities[i] += 2  # Add additional priority for even-indexed bins\n        else:\n            priorities[i] -= 1  # Reduce priority for odd-indexed bins\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n            if bins[i] <= 0.3 * max_bin_capacity:\n                priorities[i] += 1.2 * bins[i]  # Increase priority for bins with very low capacity\n        else:\n            priorities[i] = bins[i] - item\n            if bins[i] >= 0.7 * max_bin_capacity:\n                priorities[i] -= 1.1 * (bins[i] - item)  # Decrease priority for bins with high capacity\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])\n            if bins[i] <= 0.3 * max_bin_capacity:\n                priorities[i] += 1.2 * bins[i]\n            if i % 3 == 0:\n                priorities[i] += 2.3  # Additional priority for every 3rd bin\n            elif i % 3 == 1:\n                priorities[i] -= 1.3  # Reduced priority for every 3rd bin\n            \n        else:\n            priorities[i] = bins[i] - item\n            if bins[i] >= 0.7 * max_bin_capacity:\n                priorities[i] -= 1.1 * (bins[i] - item)\n            if i % 4 == 0:\n                priorities[i] -= 1.5  # Reduced priority for every 4th bin\n            elif i % 4 == 1:\n                priorities[i] += 0.5  # Increased priority for every 4th bin\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:35:15", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n        \n        if bins[i] < 0.5 * item:\n            priorities[i] *= 1.5  # Increase priority for bins with low capacity\n        elif bins[i] > 1.5 * item:\n            priorities[i] *= 0.5  # Decrease priority for bins with high capacity\n        else:\n            priorities[i] *= 1.0  # Keep priority unchanged\n        \n        if i % 2 == 0:\n            priorities[i] += 2  # Add additional priority for even-indexed bins\n        else:\n            priorities[i] -= 1  # Reduce priority for odd-indexed bins\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n            if bins[i] <= 0.3 * max_bin_capacity:\n                priorities[i] += 1.2 * bins[i]  # Increase priority for bins with very low capacity\n        else:\n            priorities[i] = bins[i] - item\n            if bins[i] >= 0.7 * max_bin_capacity:\n                priorities[i] -= 1.1 * (bins[i] - item)  # Decrease priority for bins with high capacity\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            if bins[i] < 0.5 * max_bin_capacity:\n                priorities[i] = 2 * (item - bins[i]) + 1.5 * bins[i]\n            else:\n                priorities[i] = 2 * (item - bins[i])\n        else:\n            priorities[i] = bins[i] - item\n            if bins[i] > 0.8 * min_bin_capacity:\n                priorities[i] -= 1.2 * (bins[i] - item)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:35:22", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]/2:\n            priorities[i] = np.sqrt(item / bins[i])\n        elif item > bins[i]/2 and item <= bins[i]*0.75:\n            priorities[i] = np.cbrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:35:24", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]*2/3:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.exp(item / bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:35:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/4:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/4 and item <= bins[i]/2:\n            priorities[i] = np.sqrt(item / bins[i])\n        elif item > bins[i]/2 and item <= 3 * bins[i]/4:\n            priorities[i] = np.cbrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:35:29", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/4:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/4 and item <= bins[i]/2:\n            priorities[i] = np.sqrt(item / bins[i])\n        elif item > bins[i]/2 and item <= 3 * bins[i] / 4:\n            priorities[i] = np.square(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:35:32", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity - sum(bins[:i])\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                min_diff = float('inf')\n                target_bin = -1\n                for j in range(i, len(bins)):\n                    diff = bins[j] - item\n                    if diff >= 0 and diff < min_diff:\n                        min_diff = diff\n                        target_bin = j\n                if target_bin != -1:\n                    priorities[target_bin] = 1.0 - (min_diff / item)\n                else:\n                    max_cap = max(bins)\n                    for j, capacity in enumerate(bins):\n                        if capacity == max_cap:\n                            priorities[j] = 1.0 - (capacity - item) / capacity\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more improved version of the priority function.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                excess_capacity = item - remaining_capacity\n                capacity_left = bins[i] - remaining_capacity\n                \n                if excess_capacity < capacity_left * 0.25:\n                    priorities[i] = 0.8\n                elif excess_capacity < capacity_left * 0.5:\n                    priorities[i] = 0.6\n                elif excess_capacity < capacity_left * 0.75:\n                    priorities[i] = 0.4\n                else:\n                    priorities[i] = 0.2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                excess_capacity = item - remaining_capacity\n                capacity_left = bins[i] - remaining_capacity\n                \n                if excess_capacity < capacity_left * 0.1:\n                    priorities[i] = 0.9\n                elif excess_capacity < capacity_left * 0.2:\n                    priorities[i] = 0.8\n                elif excess_capacity < capacity_left * 0.3:\n                    priorities[i] = 0.7\n                elif excess_capacity < capacity_left * 0.4:\n                    priorities[i] = 0.6\n                elif excess_capacity < capacity_left * 0.5:\n                    priorities[i] = 0.5\n                elif excess_capacity < capacity_left * 0.6:\n                    priorities[i] = 0.4\n                elif excess_capacity < capacity_left * 0.7:\n                    priorities[i] = 0.3\n                elif excess_capacity < capacity_left * 0.8:\n                    priorities[i] = 0.2\n                else:\n                    priorities[i] = 0.1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:35:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity - sum(bins[:i])\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                min_diff = float('inf')\n                target_bin = -1\n                for j in range(i, len(bins)):\n                    diff = bins[j] - item\n                    if diff >= 0 and diff < min_diff:\n                        min_diff = diff\n                        target_bin = j\n                if target_bin != -1:\n                    priorities[target_bin] = 1.0 - (min_diff / item)\n                else:\n                    max_cap = max(bins)\n                    for j, capacity in enumerate(bins):\n                        if capacity == max_cap:\n                            priorities[j] = 1.0 - (capacity - item) / capacity\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more improved version of the priority function.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                excess_capacity = item - remaining_capacity\n                capacity_left = bins[i] - remaining_capacity\n                \n                if excess_capacity < capacity_left * 0.25:\n                    priorities[i] = 0.8\n                elif excess_capacity < capacity_left * 0.5:\n                    priorities[i] = 0.6\n                elif excess_capacity < capacity_left * 0.75:\n                    priorities[i] = 0.4\n                else:\n                    priorities[i] = 0.2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                excess_capacity = item - remaining_capacity\n                capacity_left = bins[i] - remaining_capacity\n                \n                if excess_capacity < capacity_left * 0.2:\n                    priorities[i] = 0.9\n                elif excess_capacity < capacity_left * 0.4:\n                    priorities[i] = 0.7\n                elif excess_capacity < capacity_left * 0.6:\n                    priorities[i] = 0.5\n                elif excess_capacity < capacity_left * 0.8:\n                    priorities[i] = 0.3\n                else:\n                    priorities[i] = 0.1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:35:39", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity - sum(bins[:i])\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                min_diff = float('inf')\n                target_bin = -1\n                for j in range(i, len(bins)):\n                    diff = bins[j] - item\n                    if diff >= 0 and diff < min_diff:\n                        min_diff = diff\n                        target_bin = j\n                if target_bin != -1:\n                    priorities[target_bin] = 1.0 - (min_diff / item)\n                else:\n                    max_cap = max(bins)\n                    for j, capacity in enumerate(bins):\n                        if capacity == max_cap:\n                            priorities[j] = 1.0 - (capacity - item) / capacity\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more improved version of the priority function.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                excess_capacity = item - remaining_capacity\n                capacity_left = bins[i] - remaining_capacity\n                \n                if excess_capacity < capacity_left * 0.25:\n                    priorities[i] = 0.8\n                elif excess_capacity < capacity_left * 0.5:\n                    priorities[i] = 0.6\n                elif excess_capacity < capacity_left * 0.75:\n                    priorities[i] = 0.4\n                else:\n                    priorities[i] = 0.2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                excess_capacity = item - remaining_capacity\n                capacity_left = bins[i] - remaining_capacity\n                \n                if excess_capacity < capacity_left * 0.1:\n                    priorities[i] = 0.9\n                elif excess_capacity < capacity_left * 0.3:\n                    priorities[i] = 0.7\n                elif excess_capacity < capacity_left * 0.5:\n                    priorities[i] = 0.5\n                elif excess_capacity < capacity_left * 0.7:\n                    priorities[i] = 0.3\n                else:\n                    priorities[i] = 0.1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:35:41", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity - sum(bins[:i])\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                min_diff = float('inf')\n                target_bin = -1\n                for j in range(i, len(bins)):\n                    diff = bins[j] - item\n                    if diff >= 0 and diff < min_diff:\n                        min_diff = diff\n                        target_bin = j\n                if target_bin != -1:\n                    priorities[target_bin] = 1.0 - (min_diff / item)\n                else:\n                    max_cap = max(bins)\n                    for j, capacity in enumerate(bins):\n                        if capacity == max_cap:\n                            priorities[j] = 1.0 - (capacity - item) / capacity\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more improved version of the priority function.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                excess_capacity = item - remaining_capacity\n                capacity_left = bins[i] - remaining_capacity\n                \n                if excess_capacity < capacity_left * 0.25:\n                    priorities[i] = 0.8\n                elif excess_capacity < capacity_left * 0.5:\n                    priorities[i] = 0.6\n                elif excess_capacity < capacity_left * 0.75:\n                    priorities[i] = 0.4\n                else:\n                    priorities[i] = 0.2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                excess_capacity = item - remaining_capacity\n                capacity_left = bins[i] - remaining_capacity\n                \n                if excess_capacity < capacity_left * 0.25:\n                    priorities[i] = 0.8\n                elif excess_capacity < capacity_left * 0.5:\n                    priorities[i] = 0.6\n                elif excess_capacity < capacity_left * 0.75:\n                    priorities[i] = 0.4\n                else:\n                    priorities[i] = 0.2\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:35:45", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:35:48", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                max_divisor = -1\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        max_divisor = max(max_divisor, i)\n                \n                if max_divisor != -1:\n                    priority = 1 / (bin_capacity - item + max_divisor)\n                else:\n                    priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:35:51", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                divisors = [i for i in range(2, int(bin_capacity/2)+1) if bin_capacity % i == 0]\n                if len(divisors) > 0:\n                    priority = 1 / (bin_capacity - item + min(divisors))\n                else:\n                    priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:35:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                temp_priority = 0\n                for j in range(2, int(bin_capacity/2)):\n                    if bin_capacity % j == 0:\n                        temp_priority = 1 / (bin_capacity - item + j)\n                        break\n                if temp_priority == 0:\n                    priority = 1 / (bin_capacity - item + 1)\n                else:\n                    priority = temp_priority\n        else:\n            priority = -1\n        if i % 2 == 0:\n            priorities.append(priority * 1.5)\n        else:\n            priorities.append(priority * 0.5)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:35:58", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.8:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.7:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 5\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] >= 0.5:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 4\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.3:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:36:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    for j in range(len(bins)):\n        if priorities[j] == 0:\n            if item > 1 and bins[j] > 1:\n                priorities[j] = 1\n        elif priorities[j] == 1:\n            if item > 2 and bins[j] > 2:\n                priorities[j] = 2\n        elif priorities[j] == 2:\n            if item > 3 and bins[j] > 3:\n                priorities[j] = 3\n        elif priorities[j] == 3:\n            if item > 5 and bins[j] > 5:\n                priorities[j] = 4\n        elif priorities[j] == 4:\n            if item > 8 and bins[j] > 8:\n                priorities[j] = 5\n        elif priorities[j] == 5:\n            if item > 10 and bins[j] > 10:\n                priorities[j] = 6\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:36:08", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.5:\n            priorities[i] = priorities[i] * 1.5\n        elif ratios[i] <= 0.2:\n            priorities[i] = priorities[i] * 0.5\n        else:\n            priorities[i] = priorities[i]\n\n    return priorities\n\n    for i in range(len(bins)):\n        if item > 20 and bins[i] > 15:\n            priorities[i] = priorities[i] + 3\n        elif item > 15 and bins[i] > 12:\n            priorities[i] = priorities[i] + 2\n        else:\n            priorities[i] = priorities[i]\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:36:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    for i in range(len(bins)):\n        if priorities[i] == 6:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 7\n        elif priorities[i] == 5:\n            if item > 12 and bins[i] > 10:\n                priorities[i] = 6\n        elif priorities[i] == 4:\n            if item > 8 and bins[i] > 6:\n                priorities[i] = 5\n        elif priorities[i] == 3:\n            if item > 5 and bins[i] > 4:\n                priorities[i] = 4\n        elif priorities[i] == 2:\n            if item > 3 and bins[i] > 2:\n                priorities[i] = 3\n        elif priorities[i] == 1:\n            if item > 1 and bins[i] > 1:\n                priorities[i] = 2\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:36:20", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = []\n                for k, capacity in enumerate(bins):\n                    if capacity >= item:\n                        available_bins.append(k)\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        priorities[available_bins[idx]] = (item - bins[available_bins[idx-1]]) / (bins[available_bins[idx]] - bins[available_bins[idx-1]])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n\n    max_capacity = max(bins)\n    max_capacity_idx = np.argmax(bins)\n\n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        prev_bin_capacity = bins[available_bins[idx-1]]\n                        curr_bin_capacity = bins[available_bins[idx]]\n                        priorities[available_bins[idx]] = (item - prev_bin_capacity) / (curr_bin_capacity - prev_bin_capacity)\n                else:\n                    priorities[max_capacity_idx] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n\n    max_capacity = max(bins)\n    max_capacity_idx = np.argmax(bins)\n\n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        prev_bin_capacity = bins[available_bins[idx-1]]\n                        curr_bin_capacity = bins[available_bins[idx]]\n                        priorities[available_bins[idx]] = (item - prev_bin_capacity) / (curr_bin_capacity - prev_bin_capacity)\n                else:\n                    priorities[max_capacity_idx] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:36:23", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = []\n                for k, capacity in enumerate(bins):\n                    if capacity >= item:\n                        available_bins.append(k)\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        priorities[available_bins[idx]] = (item - bins[available_bins[idx-1]]) / (bins[available_bins[idx]] - bins[available_bins[idx-1]])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n\n    max_capacity = max(bins)\n    max_capacity_idx = np.argmax(bins)\n\n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        prev_bin_capacity = bins[available_bins[idx-1]]\n                        curr_bin_capacity = bins[available_bins[idx]]\n                        priorities[available_bins[idx]] = (item - prev_bin_capacity) / (curr_bin_capacity - prev_bin_capacity)\n                else:\n                    priorities[max_capacity_idx] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    max_capacity = max(bins)\n    max_capacity_idx = np.argmax(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        remaining_capacity = bin_capacity - sum(bins[:i])\n        \n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        elif item <= remaining_capacity:\n            priorities[i] = 1.0\n        else:\n            available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n            if available_bins:\n                priorities[available_bins[0]] = 1.0\n                for idx in range(1, len(available_bins)):\n                    prev_bin_capacity = bins[available_bins[idx-1]]\n                    curr_bin_capacity = bins[available_bins[idx]]\n                    priorities[available_bins[idx]] = (item - prev_bin_capacity) / (curr_bin_capacity - prev_bin_capacity)\n            else:\n                priorities[max_capacity_idx] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:36:26", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = []\n                for k, capacity in enumerate(bins):\n                    if capacity >= item:\n                        available_bins.append(k)\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        priorities[available_bins[idx]] = (item - bins[available_bins[idx-1]]) / (bins[available_bins[idx]] - bins[available_bins[idx-1]])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n\n    max_capacity = max(bins)\n    max_capacity_idx = np.argmax(bins)\n\n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        prev_bin_capacity = bins[available_bins[idx-1]]\n                        curr_bin_capacity = bins[available_bins[idx]]\n                        priorities[available_bins[idx]] = (item - prev_bin_capacity) / (curr_bin_capacity - prev_bin_capacity)\n                else:\n                    priorities[max_capacity_idx] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n\n    max_capacity = max(bins)\n    max_capacity_idx = np.argmax(bins)\n\n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        prev_bin_capacity = bins[available_bins[idx-1]]\n                        curr_bin_capacity = bins[available_bins[idx]]\n                        priorities[available_bins[idx]] = (item - prev_bin_capacity) / (curr_bin_capacity - prev_bin_capacity)\n                else:\n                    total_capacity = sum(bins)\n                    for idx, capacity in enumerate(bins):\n                        priorities[idx] = capacity / total_capacity\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:36:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = []\n                for k, capacity in enumerate(bins):\n                    if capacity >= item:\n                        available_bins.append(k)\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        priorities[available_bins[idx]] = (item - bins[available_bins[idx-1]]) / (bins[available_bins[idx]] - bins[available_bins[idx-1]])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n\n    max_capacity = max(bins)\n    max_capacity_idx = np.argmax(bins)\n\n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        prev_bin_capacity = bins[available_bins[idx-1]]\n                        curr_bin_capacity = bins[available_bins[idx]]\n                        priorities[available_bins[idx]] = (item - prev_bin_capacity) / (curr_bin_capacity - prev_bin_capacity)\n                else:\n                    priorities[max_capacity_idx] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros(len(bins))\n\n    max_capacity = max(bins)\n    max_capacity_idx = np.argmax(bins)\n\n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        prev_bin_capacity = bins[available_bins[idx-1]]\n                        curr_bin_capacity = bins[available_bins[idx]]\n                        priorities[available_bins[idx]] = (item - prev_bin_capacity) / (curr_bin_capacity - prev_bin_capacity)\n                else:\n                    non_full_bins = [k for k, capacity in enumerate(bins) if capacity > sum(bins)]\n                    if non_full_bins:\n                        selected_bin = min(non_full_bins, key=lambda x: abs(bins[x] - item))\n                        bin_diff = abs(bins[selected_bin] - item)\n                        priorities[selected_bin] = item / bin_diff\n                    else:\n                        priorities[max_capacity_idx] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:36:34", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.4\n                else:\n                    priority += 0.6\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 1.8\n            elif priority < 0.4:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.7\n                else:\n                    priorities[j] = 0.4\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.1\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.8 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 2.0\n            elif priority < 0.4:\n                priorities[i] *= 0.6\n            else:\n                priorities[i] *= 1.5\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.8\n                else:\n                    priorities[j] = 0.3\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:36:37", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.4\n                else:\n                    priority += 0.6\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 1.8\n            elif priority < 0.4:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.7\n                else:\n                    priorities[j] = 0.4\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.1 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.4 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.8\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 2.0\n            elif priority < 0.3:\n                priorities[i] *= 0.5\n            else:\n                priorities[i] *= 1.3\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.6\n                else:\n                    priorities[j] = 0.3\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:36:40", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.4\n                else:\n                    priority += 0.6\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 1.8\n            elif priority < 0.4:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.7\n                else:\n                    priorities[j] = 0.4\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\n\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        remaining_capacity = bins[i]\n        priority = 0.0\n        while remaining_capacity < item:\n            if remaining_capacity < 0.2 * item:\n                priority += 0.1\n            elif remaining_capacity < 0.5 * item:\n                priority += 0.3\n            elif remaining_capacity < 0.8 * item:\n                priority += 0.5\n            else:\n                priority += 0.7\n            remaining_capacity += bins[i]\n        priorities[i] = priority\n        \n        if priority > 0.6:\n            priorities[i] *= 2.0\n        elif priority < 0.4:\n            priorities[i] *= 0.6\n        else:\n            priorities[i] *= 1.5\n        \n        for j in range(i+1, len(bins)):\n            if bins[j] >= item:\n                priorities[j] = 0.8\n            else:\n                priorities[j] = 0.5\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:36:43", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.4\n                else:\n                    priority += 0.6\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 1.8\n            elif priority < 0.4:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.7\n                else:\n                    priorities[j] = 0.4\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.1 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.3 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 2.0\n            elif priority < 0.4:\n                priorities[i] *= 0.6\n            else:\n                priorities[i] *= 1.3\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.8\n                else:\n                    priorities[j] = 0.3\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:36:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        highest_priority = -1\n                        highest_priority_idx = -1\n                        for k in range(i, j):\n                            if priorities[k] == -1:\n                                continue\n                            if priorities[k] > highest_priority:\n                                highest_priority = priorities[k]\n                                highest_priority_idx = k\n                        if highest_priority > 1:\n                            priorities[highest_priority_idx] = 1\n                            priorities[j] = (j - highest_priority_idx) + 1\n                        else:\n                            priorities[i] = -1\n                            break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        highest_priority = -1\n                        highest_priority_idx = -1\n                        for k in range(i, j):\n                            if priorities[k] == -1:\n                                continue\n                            if priorities[k] > highest_priority:\n                                highest_priority = priorities[k]\n                                highest_priority_idx = k\n                        if highest_priority > 1:\n                            priorities[highest_priority_idx] = 1\n                            priorities[j] = (j - highest_priority_idx) + 1\n                        else:\n                            priorities[i] = -1\n                            break\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:36:55", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        highest_priority = -1\n                        highest_priority_idx = -1\n                        for k in range(i, j):\n                            if priorities[k] == -1:\n                                continue\n                            if priorities[k] > highest_priority:\n                                highest_priority = priorities[k]\n                                highest_priority_idx = k\n                        if highest_priority > 1:\n                            priorities[highest_priority_idx] = 1\n                            priorities[j] = (j - highest_priority_idx) + 1\n                        else:\n                            priorities[i] = -1\n                            break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        highest_priority = -1\n                        highest_priority_idx = -1\n                        for k in range(i, j):\n                            if priorities[k] == -1:\n                                continue\n                            if priorities[k] > highest_priority:\n                                highest_priority = priorities[k]\n                                highest_priority_idx = k\n                        if highest_priority > 1:\n                            priorities[highest_priority_idx] = 1\n                            priorities[j] = (j - highest_priority_idx) + 1\n                        else:\n                            lowest_capacity = float('inf')\n                            lowest_capacity_idx = -1\n                            for k in range(i, j+1):\n                                if bins[k] < lowest_capacity and priorities[k] == 0:\n                                    lowest_capacity = bins[k]\n                                    lowest_capacity_idx = k\n                            if lowest_capacity < item:\n                                priorities[lowest_capacity_idx] = -1\n                            else:\n                                priorities[lowest_capacity_idx] = 1\n                                priorities[j] = (j - lowest_capacity_idx) + 1\n                            break\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:36:58", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        highest_priority = -1\n                        highest_priority_idx = -1\n                        for k in range(i, j):\n                            if priorities[k] == -1:\n                                continue\n                            if priorities[k] > highest_priority:\n                                highest_priority = priorities[k]\n                                highest_priority_idx = k\n                        if highest_priority > 1:\n                            priorities[highest_priority_idx] = 1\n                            priorities[j] = (j - highest_priority_idx) + 1\n                        else:\n                            priorities[i] = -1\n                            break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            consecutive_bins = 1\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + consecutive_bins\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + consecutive_bins\n                        break\n                    elif j == len(bins) - 1:\n                        available_bins = [k for k in range(i, j) if priorities[k] == 0]\n                        if available_bins:\n                            bin_to_use = available_bins[0]\n                            priorities[bin_to_use] = 1\n                            priorities[j] = (j - bin_to_use) + 1\n                        else:\n                            priorities[i] = -1\n                            break\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:37:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        highest_priority = -1\n                        highest_priority_idx = -1\n                        for k in range(i, j):\n                            if priorities[k] == -1:\n                                continue\n                            if priorities[k] > highest_priority:\n                                highest_priority = priorities[k]\n                                highest_priority_idx = k\n                        if highest_priority > 1:\n                            priorities[highest_priority_idx] = 1\n                            priorities[j] = (j - highest_priority_idx) + 1\n                        else:\n                            priorities[i] = -1\n                            break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        highest_priority = -1\n                        highest_priority_idx = -1\n                        for k in range(i, j):\n                            if priorities[k] == -1:\n                                continue\n                            if priorities[k] > highest_priority:\n                                highest_priority = priorities[k]\n                                highest_priority_idx = k\n                        if highest_priority > 1:\n                            priorities[highest_priority_idx] = 1\n                            priorities[j] = (j - highest_priority_idx) + 1\n                        else:\n                            priorities[i] = -1\n                            break\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:37:07", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = item - bins[i]\n        elif bins[i] == min_capacity:\n            priorities[i] = bins[i] - item\n        else:\n            priorities[i] = abs(item - bins[i]) / (max_capacity - min_capacity)\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Further improved version of `priority_v1`.\n    Now considering additional factors for priority calculation.\n    \"\"\"\n    \n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n    \n    # Add an additional factor based on bin capacity ratio\n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        priorities[i] += 0.5 * (max_bin_capacity - bins[i])  # Adjust priority based on capacity ratio\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        elif bins[i] == min_capacity:\n            priorities[i] = bins[i] - item\n        else:\n            priorities[i] = abs(item - bins[i]) / (max_capacity - min_capacity)\n\n    # Add an additional factor based on the bin position and capacity ratio\n    for i in range(len(bins)):\n        if i % 2 == 0:\n            priorities[i] += 0.3 * (max_capacity - bins[i])  # Adjust priority based on even index\n        else:\n            priorities[i] += 0.5 * (max_capacity - bins[i])  # Adjust priority based on odd index\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:37:09", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = item - bins[i]\n        elif bins[i] == min_capacity:\n            priorities[i] = bins[i] - item\n        else:\n            priorities[i] = abs(item - bins[i]) / (max_capacity - min_capacity)\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Further improved version of `priority_v1`.\n    Now considering additional factors for priority calculation.\n    \"\"\"\n    \n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n    \n    # Add an additional factor based on bin capacity ratio\n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        priorities[i] += 0.5 * (max_bin_capacity - bins[i])  # Adjust priority based on capacity ratio\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    \n    # Calculate the sum of bin capacities\n    total_capacity = np.sum(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 3 * (item - bins[i])  # Triple the priority\n        else:\n            priorities[i] = bins[i] - item\n            \n        # Add an additional factor based on capacity distribution\n        capacity_ratio = bins[i] / total_capacity\n        if capacity_ratio >= 0.5:\n            priorities[i] += 0.3 * (capacity_ratio - 0.5) * total_capacity\n        \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:37:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = item - bins[i]\n        elif bins[i] == min_capacity:\n            priorities[i] = bins[i] - item\n        else:\n            priorities[i] = abs(item - bins[i]) / (max_capacity - min_capacity)\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Further improved version of `priority_v1`.\n    Now considering additional factors for priority calculation.\n    \"\"\"\n    \n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n    \n    # Add an additional factor based on bin capacity ratio\n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        priorities[i] += 0.5 * (max_bin_capacity - bins[i])  # Adjust priority based on capacity ratio\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Further improved version of `priority_v1`.\n    Now considering additional factors for priority calculation.\n    \"\"\"\n    \n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n    \n    # Add an additional factor based on bin capacity ratio\n    for i in range(len(bins)):\n        normalized_capacity = (bins[i] - min_capacity) / (max_capacity - min_capacity)\n        if normalized_capacity < 0.5:\n            priorities[i] += 0.3 * (0.5 - normalized_capacity)  # Adjust priority based on capacity ratio\n        else:\n            priorities[i] += 0.2 * (normalized_capacity - 0.5)  # Adjust priority based on capacity ratio\n        \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:37:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = item - bins[i]\n        elif bins[i] == min_capacity:\n            priorities[i] = bins[i] - item\n        else:\n            priorities[i] = abs(item - bins[i]) / (max_capacity - min_capacity)\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Further improved version of `priority_v1`.\n    Now considering additional factors for priority calculation.\n    \"\"\"\n    \n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n    \n    # Add an additional factor based on bin capacity ratio\n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        priorities[i] += 0.5 * (max_bin_capacity - bins[i])  # Adjust priority based on capacity ratio\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = bins[i] - item\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n            priorities[i] = abs(item - remaining_capacity) * 2\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:37:24", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.exp(ratio) * np.log(ratio) - np.arctan(ratio) + np.sqrt(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:37:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(5*ratio) * np.cosh(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.tan(2*ratio) + np.exp(1.5*ratio) - np.log(0.5*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.cosh(ratio) * np.sin(2*ratio) + np.sqrt(2*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.arccos(ratio) + np.arcsin(0.5*ratio) - np.arctan(0.75*ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sinh(ratio) * np.cosh(ratio) * np.tanh(ratio)\n        else:\n            priority = np.sin(2*ratio) + np.cos(1.5*ratio) + np.tan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:37:31", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n            if priority < 0:\n                priority *= 2\n            else:\n                priority /= 2\n        elif ratio >= 0.2 and ratio < 0.5:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n            for i in range(1, 4):\n                priority += np.power(ratio, i)\n        elif ratio >= 0.5 and ratio < 0.8:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n            priority = max(priority, 0)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n            priority = min(priority, 0.5)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:37:34", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        if priority > 10:\n            priority += 5\n        elif priority < 5:\n            priority -= 2\n        else:\n            priority *= 2\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:37:47", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros(data.shape)\n    \n    for i in range(data.shape[0]):\n        for j in range(data.shape[1]):\n            if data[i, j] % 2 == 0:\n                result[i, j] = data[i, j] * 2\n            elif data[i, j] % 3 == 0:\n                result[i, j] = data[i, j] * 3\n            else:\n                result[i, j] = data[i, j] ** 2\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:37:49", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros(len(data))\n    \n    for i in range(len(data)):\n        if data[i] % 2 == 0:\n            result[i] = data[i] * 2\n        else:\n            result[i] = data[i] / 2\n            \n        if data[i] > 10:\n            result[i] += 10\n        else:\n            result[i] -= 5\n            \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:37:52", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(matrix: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(matrix)\n    \n    for i in range(matrix.shape[0]):\n        for j in range(matrix.shape[1]):\n            if matrix[i, j] >= 0:\n                result[i, j] = matrix[i, j] ** 2\n            else:\n                if matrix[i, j] % 2 == 0:\n                    result[i, j] = matrix[i, j] * 3\n                else:\n                    result[i, j] = matrix[i, j] // 2\n\n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:37:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray, threshold: int) -> np.ndarray:\n    result = np.zeros(data.shape)\n    \n    for i in range(data.shape[0]):\n        for j in range(data.shape[1]):\n            if data[i][j] < threshold:\n                result[i][j] = data[i][j] * 2\n            else:\n                result[i][j] = data[i][j] / 2\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:37:56", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n\n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n\n        elif item > bin_capacity * 0.75:\n            priority = 0.5\n        elif item > bin_capacity * 0.5:\n            priority = 0.3\n        else:\n            priority = 0.1\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:37:59", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nfrom math import sqrt\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                factors = [i for i in range(2, int(sqrt(bin_capacity)) + 1) if bin_capacity % i == 0]\n                if factors:\n                    priority = 1 / (bin_capacity - item + factors[0])\n                else:\n                    priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:38:01", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        for j in range(3, int(bin_capacity/3)):\n                            if bin_capacity % j == 0:\n                                priority = 1 / (bin_capacity - item + j)\n                                break\n                            else:\n                                priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:38:04", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            for i in range(int(item), bin_capacity + 1):\n                if bin_capacity % i == 0:\n                    priority = 1 / (bin_capacity - item + i)\n                    break\n                else:\n                    priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:38:07", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        \n        if priority > 1:\n            priority *= 1.5\n        elif priority >= 0.5:\n            priority *= 1.2\n        else:\n            priority *= 0.8\n        \n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:38:10", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        \n        if priority < 0.5:\n            priority -= 0.1\n        elif priority < 1:\n            priority += 0.2\n        else:\n            priority += 0.1\n        \n        priorities.append(priority)\n    \n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:38:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                found_divisible = False\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        found_divisible = True\n                        break\n                if not found_divisible:\n                    priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:38:16", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        priority = -1\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                if priority == -1:\n                    for j in range(int(bin_capacity/2), bin_capacity+1):\n                        if bin_capacity % j == 0:\n                            priority = 0.5 / (bin_capacity - item + j)\n                            break\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:38:18", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/4:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/4 and item <= bins[i]/2:\n            priorities[i] = np.sqrt(item / bins[i])\n        elif item > bins[i]/2 and item <= 3*bins[i]/4:\n            priorities[i] = np.cbrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i]) + 0.5\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:38:21", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if item % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:38:23", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i] / 3:\n            priorities[i] = item / bins[i]\n        elif item > bins[i] / 3 and item <= bins[i] / 2:\n            priorities[i] = np.sqrt(item / bins[i])\n        elif item > bins[i] / 2 and item <= 2 * bins[i] / 3:\n            priorities[i] = np.log(item / bins[i])\n        else:\n            priorities[i] = np.sin(item / bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:38:34", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]/4:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/4 and item <= bins[i]/2:\n            priorities[i] = np.sqrt(item / bins[i])\n        elif item > bins[i]/2 and item <= bins[i]*3/4:\n            priorities[i] = np.cbrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:38:39", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    priorities[i] = 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more improved version of the priority function.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                excess_capacity = item - remaining_capacity\n                capacity_left = bins[i] - remaining_capacity\n                \n                if excess_capacity < capacity_left * 0.25:\n                    priorities[i] = 0.8\n                elif excess_capacity < capacity_left * 0.5:\n                    priorities[i] = 0.6\n                elif excess_capacity < capacity_left * 0.75:\n                    priorities[i] = 0.4\n                else:\n                    priorities[i] = 0.2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                excess_capacity = item - remaining_capacity\n                capacity_left = bins[i] - remaining_capacity\n                \n                if excess_capacity < capacity_left * 0.2:\n                    priorities[i] = 0.9\n                elif excess_capacity < capacity_left * 0.4:\n                    priorities[i] = 0.7\n                elif excess_capacity < capacity_left * 0.6:\n                    priorities[i] = 0.5\n                elif excess_capacity < capacity_left * 0.8:\n                    priorities[i] = 0.3\n                else:\n                    priorities[i] = 0.1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:38:43", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    priorities[i] = 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more improved version of the priority function.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                excess_capacity = item - remaining_capacity\n                capacity_left = bins[i] - remaining_capacity\n                \n                if excess_capacity < capacity_left * 0.25:\n                    priorities[i] = 0.8\n                elif excess_capacity < capacity_left * 0.5:\n                    priorities[i] = 0.6\n                elif excess_capacity < capacity_left * 0.75:\n                    priorities[i] = 0.4\n                else:\n                    priorities[i] = 0.2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                excess_capacity = item - remaining_capacity\n                capacity_left = bins[i] - remaining_capacity\n                \n                if excess_capacity < capacity_left * 0.25:\n                    priorities[i] = 0.8\n                elif excess_capacity < capacity_left * 0.5:\n                    priorities[i] = 0.6\n                elif excess_capacity < capacity_left * 0.75:\n                    priorities[i] = 0.4\n                else:\n                    priorities[i] = 0.2\n                if priorities[i] < 0.5 and i % 2 == 0:\n                    priorities[i] = 0.1\n                elif priorities[i] < 0.5 and i % 2 != 0:\n                    priorities[i] = 0.3\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:38:46", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    priorities[i] = 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more improved version of the priority function.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                excess_capacity = item - remaining_capacity\n                capacity_left = bins[i] - remaining_capacity\n                \n                if excess_capacity < capacity_left * 0.25:\n                    priorities[i] = 0.8\n                elif excess_capacity < capacity_left * 0.5:\n                    priorities[i] = 0.6\n                elif excess_capacity < capacity_left * 0.75:\n                    priorities[i] = 0.4\n                else:\n                    priorities[i] = 0.2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                excess_capacity = item - remaining_capacity\n                capacity_left = bins[i] - remaining_capacity\n                \n                if excess_capacity < capacity_left * 0.1:\n                    priorities[i] = 0.9\n                elif excess_capacity < capacity_left * 0.3:\n                    priorities[i] = 0.7\n                elif excess_capacity < capacity_left * 0.5:\n                    priorities[i] = 0.5\n                elif excess_capacity < capacity_left * 0.7:\n                    priorities[i] = 0.3\n                else:\n                    priorities[i] = 0.1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:38:49", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    priorities[i] = 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more improved version of the priority function.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                excess_capacity = item - remaining_capacity\n                capacity_left = bins[i] - remaining_capacity\n                \n                if excess_capacity < capacity_left * 0.25:\n                    priorities[i] = 0.8\n                elif excess_capacity < capacity_left * 0.5:\n                    priorities[i] = 0.6\n                elif excess_capacity < capacity_left * 0.75:\n                    priorities[i] = 0.4\n                else:\n                    priorities[i] = 0.2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of the priority function with advanced logic.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                excess_capacity = item - remaining_capacity\n                capacity_left = bins[i] - remaining_capacity\n                \n                if excess_capacity < capacity_left * 0.2:\n                    priorities[i] = 0.9\n                elif excess_capacity < capacity_left * 0.4:\n                    priorities[i] = 0.7\n                elif excess_capacity < capacity_left * 0.6:\n                    priorities[i] = 0.5\n                elif excess_capacity < capacity_left * 0.8:\n                    priorities[i] = 0.3\n                else:\n                    priorities[i] = 0.1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:38:53", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def calculate_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:38:56", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"More advanced version of `priority_v1`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.cos(5*ratio) + np.sin(3*ratio) / np.tan(1.2*ratio)\n        else:\n            for i in range(1, int(ratio*10)+1):\n                if i % 2 == 0:\n                    priority += np.cos(i*ratio) - np.sin(i*ratio) + np.tan(i*ratio)\n                else:\n                    priority += np.sin(i*ratio) - np.cos(i*ratio) + np.tanh(i*ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:39:00", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Advanced version of priority calculation.\"\"\"\n    priorities = []\n\n    for idx, bin_capacity in enumerate(bins):\n        ratio = item / bin_capacity\n\n        if ratio < 0.1:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n            # Additional complex calculation\n            for i in range(10):\n                priority *= np.sin(i*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n            # Additional complex calculation\n            priority = np.log(np.abs(priority))\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n            # Additional complex calculation\n            priority = priority ** 2\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n            # Additional complex calculation\n            priority = np.sqrt(np.abs(priority))\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:39:04", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.log(np.exp(ratio)) + np.sqrt(np.tan(ratio)) - np.cos(np.sin(ratio))\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.sinh(2*ratio) * np.cosh(1.5*ratio) - np.tanh(0.5*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.tanh(ratio) * np.arctan(ratio) + np.arcsinh(ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.arcsin(np.cos(ratio)) * np.arctan(np.sinh(ratio)) - np.arccos(np.tanh(ratio))\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(np.exp(ratio)) * np.cosh(np.log(ratio)) / np.arcsinh(np.sqrt(ratio))\n        else:\n            priority = np.cos(np.sinh(ratio)) / np.tan(np.arccos(ratio)) + np.arcsin(np.arccos(ratio))\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:39:26", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if item % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Another improved version of priority function\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]/2:\n            priorities[i] = np.sqrt(item / bins[i])\n        elif item > bins[i]/2 and item <= bins[i]*2/3:\n            if item % 2 == 0:\n                priorities[i] = np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 1/4)\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:39:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if item % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]/4:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/4 and item <= bins[i]*3/4:\n            if item % 3 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            elif item % 3 == 1:\n                priorities[i] = np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 1/4)\n        else:\n            if bins[i] % 4 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            elif bins[i] % 4 == 1:\n                priorities[i] = np.log10(item / bins[i])\n            elif bins[i] % 4 == 2:\n                priorities[i] = np.log1p(item / bins[i])\n            else:\n                priorities[i] = np.exp(item / bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:39:33", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if item % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"More sophisticated version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/4:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        elif item > bins[i]/4 and item <= bins[i]/2:\n            if item % 2 == 0 and bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i])\n        elif item > bins[i]/2 and item <= 3 * bins[i]/4:\n            if item % 2 != 0:\n                priorities[i] = np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log10(item / bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:39:36", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if item % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        elif item > bins[i]/2 and item <= 2 * bins[i]/3:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i])\n        else:\n            priorities[i] = np.sin(item / bins[i]) + np.cos(item / bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:39:45", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:39:48", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n        # Additional criteria\n        if item % 2 == 0:\n            if priorities[i] >= 3:\n                priorities[i] += 1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:39:53", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 10\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 9\n            else:\n                priorities[i] = 8\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 7\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 4\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:39:57", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0\n        elif bins[i] < item:\n            priorities[i] = 0\n        elif item < 1 and bins[i] >= 1:\n            priorities[i] = 1\n        else:\n            priorities[i] += 1\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:40:00", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                found_divisor = False\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        found_divisor = True\n                        break\n                if not found_divisor:\n                    priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:40:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 3 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/3)):\n                    if bin_capacity % i == 0:\n                        priority = 2 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 2)\n        else:\n            if bin_capacity % (item * 2) == 0:\n                priority = -2\n            else:\n                priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:40:07", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                found = False\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        found = True\n                        break\n                if not found:\n                    priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:40:09", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            elif bin_capacity % item == 1:\n                priority = 1 / (bin_capacity - item + 2)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            if bin_capacity % item == 0:\n                priority = 1 / (item - bin_capacity + 1)\n            else:\n                priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:40:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        if i % 2 == 0:\n                            priority = 0.5 / (bin_capacity - item + i)\n                        else:\n                            priority = 0.25 / (bin_capacity - item + i)\n        else:\n            if bin_capacity % item == 0:\n                priority = -2\n            else:\n                priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:40:16", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                if item <= 0.5 * bin_capacity:\n                    for i in range(2, int(bin_capacity/2)):\n                        if bin_capacity % i == 0:\n                            priority = 1 / (bin_capacity - item + i)\n                            break\n                        else:\n                            priority = 1 / (bin_capacity - item + 1)\n                else:\n                    for i in range(2, int(bin_capacity)):\n                        if bin_capacity % i == 0 and i > item:\n                            priority = 1.5 / (bin_capacity - item + i)\n                            break\n                        else:\n                            priority = 1.5 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:40:19", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            if item % bin_capacity == 0:\n                priority = 1.5\n            else:\n                priority = 0.5\n        priorities.append(priority)\n    \n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:40:22", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        if bin_capacity % 2 == 0:\n                            priority = 1.5 / (bin_capacity - item + 2)\n                        else:\n                            for j in range(3, int(bin_capacity/3)):\n                                if bin_capacity % j == 0:\n                                    priority = 1 / (bin_capacity - item + j)\n                                    break\n                                else:\n                                    priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:40:24", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n                        if sum(priorities) == 0:\n                            priorities = np.divide(1, range(1, len(bins)+1))\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:40:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            selected_bin = False\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    selected_bin = True\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        selected_bin = True\n                        break\n            if not selected_bin:\n                min_capacity = min(bins[i:])\n                if min_capacity >= item:\n                    min_index = i + np.argmin(bins[i:])\n                    priorities[min_index] = (min_index - i) + 1\n                else:\n                    priorities[i] = -1\n                \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:40:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    max_priority = max(priorities)\n    if max_priority != -1:\n        for k in range(len(priorities)):\n            if priorities[k] == max_priority:\n                priorities[k] = 2 * max_priority\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:40:33", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    if item <= 0:\n        return priorities\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    max_priority = max(priorities)\n    for k in range(len(priorities)):\n        if priorities[k] == max_priority:\n            priorities[k] *= 1.5\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:40:37", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Enhanced version of `priority_v1` with additional logic.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            elif item > bin_capacity + max(bins): \n                priorities[i] = 0.0\n            else:\n                temp = item - remaining_capacity\n                for j in range(i+1, len(bins)):\n                    if item <= bins[j]:\n                        priorities[j] = 1.0 - (temp / bins[j])\n                        break\n                if priorities[i] == 0:\n                    for j in range(i+1, len(bins)):\n                        if item <= bins[j] + max(bins):\n                            priorities[j] = 1.0 - (temp / (bins[j] + max(bins)))\n                            break\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            elif item > bin_capacity + max(bins): \n                priorities[i] = 0.0\n            else:\n                temp = item - remaining_capacity\n                for j in range(i+1, len(bins)):\n                    if item <= bins[j]:\n                        priorities[j] = 1.0 - (temp / bins[j])\n                        break\n                if priorities[i] == 0:\n                    for j in range(i+1, len(bins)):\n                        if item <= bins[j] + max(bins):\n                            priorities[j] = 1.0 - (temp / (bins[j] + max(bins)))\n                            break\n                if priorities[i] < 0.5:\n                    for j in range(i-1, -1, -1):\n                        if item <= bins[j] + max(bins):\n                            priorities[j] = 1.0 - (temp / (bins[j] + max(bins)))\n                            break\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:40:42", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Enhanced version of `priority_v1` with additional logic.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            elif item > bin_capacity + max(bins): \n                priorities[i] = 0.0\n            else:\n                temp = item - remaining_capacity\n                for j in range(i+1, len(bins)):\n                    if item <= bins[j]:\n                        priorities[j] = 1.0 - (temp / bins[j])\n                        break\n                if priorities[i] == 0:\n                    for j in range(i+1, len(bins)):\n                        if item <= bins[j] + max(bins):\n                            priorities[j] = 1.0 - (temp / (bins[j] + max(bins)))\n                            break\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            elif item > bin_capacity + max(bins):\n                priorities[i] = 0.0\n            else:\n                temp = item - remaining_capacity\n                for j in range(i+1, len(bins)):\n                    if item <= bins[j]:\n                        priorities[j] = 1.0 - (temp / bins[j])\n                        break\n                if priorities[i] == 0:\n                    for j in range(i+1, len(bins)):\n                        if item <= bins[j] + max(bins):\n                            priorities[j] = 1.0 - (temp / (bins[j] + max(bins)))\n                            break\n                if priorities[i] == 0:\n                    for j in range(len(bins)-1, i, -1):\n                        if item <= bins[j]:\n                            priorities[j] = 1.0 - (temp / bins[j])\n                            break\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:40:46", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Enhanced version of `priority_v1` with additional logic.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            elif item > bin_capacity + max(bins): \n                priorities[i] = 0.0\n            else:\n                temp = item - remaining_capacity\n                for j in range(i+1, len(bins)):\n                    if item <= bins[j]:\n                        priorities[j] = 1.0 - (temp / bins[j])\n                        break\n                if priorities[i] == 0:\n                    for j in range(i+1, len(bins)):\n                        if item <= bins[j] + max(bins):\n                            priorities[j] = 1.0 - (temp / (bins[j] + max(bins)))\n                            break\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Advanced version of `priority_v1`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            elif item > bin_capacity + max(bins): \n                priorities[i] = 0.0\n            else:\n                temp = item - remaining_capacity\n                for j in range(i+1, len(bins)):\n                    if item <= bins[j]:\n                        priorities[j] = 1.0 - (temp / bins[j])\n                        break\n                if priorities[i] == 0:\n                    for j in range(i+1, len(bins)):\n                        if item <= bins[j] + max(bins):\n                            priorities[j] = 1.0 - (temp / (bins[j] + max(bins)))\n                            break\n                if priorities[i] == 0:\n                    total_bin_capacity = sum(bins)\n                    if item <= total_bin_capacity:\n                        priorities[i] = 1 - ((item - remaining_capacity) / (total_bin_capacity - remaining_capacity))\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:40:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Enhanced version of `priority_v1` with additional logic.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            elif item > bin_capacity + max(bins): \n                priorities[i] = 0.0\n            else:\n                temp = item - remaining_capacity\n                for j in range(i+1, len(bins)):\n                    if item <= bins[j]:\n                        priorities[j] = 1.0 - (temp / bins[j])\n                        break\n                if priorities[i] == 0:\n                    for j in range(i+1, len(bins)):\n                        if item <= bins[j] + max(bins):\n                            priorities[j] = 1.0 - (temp / (bins[j] + max(bins)))\n                            break\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more enhanced version of `priority` with complex logic.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            elif item > bin_capacity + max(bins): \n                priorities[i] = 0.0\n            else:\n                temp = item - remaining_capacity\n                for j in range(i+1, len(bins)):\n                    if item <= bins[j]:\n                        priorities[j] = 1.0 - (temp / bins[j])\n                        break\n                if priorities[i] == 0:\n                    for j in range(i+1, len(bins)):\n                        if item <= bins[j] + max(bins):\n                            priorities[j] = 1.0 - (temp / (bins[j] + max(bins)))\n                            break\n                    if priorities[i] == 0:\n                        priorities[i] = max(priorities) * 0.95\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:40:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 or bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:40:58", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    for j in range(len(bins)):\n        if priorities[j] == 0:\n            if bins[j] == 0:\n                priorities[j] = -1\n            else:\n                priorities[j] = -2\n        elif priorities[j] == 1:\n            priorities[j] += ratios[j] * 0.5\n        else:\n            priorities[j] += ratios[j] * priorities[j]\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:41:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    for i in range(len(bins)):\n        if priorities[i] == 4:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 8\n        elif priorities[i] == 3:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 7\n        elif priorities[i] == 2:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 6\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:41:08", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n    \n    for j in range(len(bins)):\n        if priorities[j] == 5:\n            priorities[j] = 7\n        elif priorities[j] == 4:\n            priorities[j] = 6\n        elif priorities[j] == 3:\n            priorities[j] = 5\n        elif priorities[j] == 2:\n            priorities[j] = 4\n        elif priorities[j] == 1:\n            priorities[j] = 3\n        elif priorities[j] == 0:\n            priorities[j] = 2\n        else:\n            priorities[j] = 1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:41:11", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.5 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.8 * item:\n                    priority += 0.2\n                else:\n                    priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:41:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priorities[i] > 0.5:\n                priorities[i] = priorities[i] * 1.5\n            else:\n                priorities[i] = priorities[i] * 0.5\n                \n            if item % 2 == 0:\n                priorities[i] = priorities[i] + 0.2\n            else:\n                priorities[i] = priorities[i] - 0.2\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:41:17", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i]\n        priority = 0.0\n        \n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            \n            if priority > 0.5:\n                priorities[i] = priority * 1.5\n            elif priority < 0.3:\n                priorities[i] = priority * 0.8\n            else:\n                priorities[i] = priority\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:41:19", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if priority < 0.5:\n                    priority += 0.2\n                elif priority >= 0.5 and priority < 1.0:\n                    priority += 0.3\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:41:24", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n\n    max_capacity = max(bins)\n    min_capacity = min(bins)\n\n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    for k in range(i, j):\n                        if bins[k] >= item:\n                            priorities[k] = (j - i) + 1\n                            break\n                    else:\n                        priorities[i] = -1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:41:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    for k in range(i, len(bins)):\n                        if bins[k] >= item:\n                            priorities[k] = (k - i) + 1\n                            break\n                    break\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:41:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    max_priority = max(priorities)\n    min_priority = min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == 0:\n            priorities[i] = 0.5\n        elif priorities[i] == max_priority:\n            priorities[i] = 2\n        elif priorities[i] == min_priority:\n            priorities[i] = 0.1\n        else:\n            priorities[i] = priorities[i] * 1.5\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:41:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:41:38", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(input_list: list) -> list:\n    output_list = []\n    \n    for item in input_list:\n        if item % 2 == 0:\n            temp_list = []\n            for i in range(1, item + 1):\n                if i % 2 != 0:\n                    if i % 3 == 0:\n                        temp_list.append(i)\n            output_list.append(temp_list)\n        else:\n            output_list.append([item])\n    \n    return output_list", "strategy": []}
{"timestamp": "2025-04-27 05:41:40", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(data)\n    \n    for i in range(len(data)):\n        if data[i] % 2 == 0:\n            result[i] = data[i] ** 2\n        elif data[i] % 3 == 0:\n            result[i] = data[i] ** 3\n        else:\n            temp = 1\n            for j in range(1, data[i] + 1):\n                temp *= j\n            result[i] = temp\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:41:43", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros(len(data))\n\n    for i in range(len(data)):\n        if data[i] % 2 == 0:\n            result[i] = data[i] * 2\n        else:\n            for j in range(data[i]):\n                if j % 2 == 0:\n                    result[i] += j\n                else:\n                    result[i] -= j\n\n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:41:44", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros(len(data))\n    \n    for i in range(len(data)):\n        if data[i] % 2 == 0:\n            result[i] = data[i] * 2\n        else:\n            temp = data[i]\n            for j in range(data[i]):\n                temp -= 1\n                if temp == 0:\n                    break\n            result[i] = temp\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:41:49", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.4\n                else:\n                    priority += 0.6\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 1.8\n            elif priority < 0.4:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.7\n                else:\n                    priorities[j] = 0.4\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.15 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.4 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 2.0\n            elif priority < 0.5:\n                priorities[i] *= 0.6\n            else:\n                priorities[i] *= 1.3\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.8\n                else:\n                    priorities[j] = 0.6\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:41:53", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.4\n                else:\n                    priority += 0.6\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 1.8\n            elif priority < 0.4:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.7\n                else:\n                    priorities[j] = 0.4\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.1\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.7 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.6\n            elif priority < 0.3:\n                priorities[i] *= 0.9\n            else:\n                priorities[i] *= 1.1\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.8\n                else:\n                    priorities[j] = 0.6\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:41:56", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.4\n                else:\n                    priority += 0.6\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 1.8\n            elif priority < 0.4:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.7\n                else:\n                    priorities[j] = 0.4\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Another improved version of priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] >= 0.5 * item:\n            priorities[i] = 0.8\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.3 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.7 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.6\n            elif priority < 0.4:\n                priorities[i] *= 0.6\n            else:\n                priorities[i] *= 1.1\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.6\n                elif bins[j] >= 0.3 * item:\n                    priorities[j] = 0.4\n                else:\n                    priorities[j] = 0.2\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:42:00", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.4\n                else:\n                    priority += 0.6\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 1.8\n            elif priority < 0.4:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.7\n                else:\n                    priorities[j] = 0.4\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.8\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 2.0\n            elif priority < 0.4:\n                priorities[i] *= 0.6\n            else:\n                priorities[i] *= 1.5\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.8\n                else:\n                    if item - bins[j] < 0.3 * item:\n                        priorities[j] = 0.5\n                    else:\n                        priorities[j] = 0.3\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:42:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if item % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if item % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            if item % 3 == 0:\n                priorities[i] = np.sqrt(np.log(item / bins[i]))\n            else:\n                priorities[i] = np.cbrt(np.log10(item / bins[i]))\n        elif item > bins[i]/3 and item <= bins[i]*2/3:\n            if item % 2 == 0:\n                priorities[i] = np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.sqrt(item / bins[i])\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(np.sqrt(item / bins[i]))\n            else:\n                priorities[i] = np.log10(np.cbrt(item / bins[i]))\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:42:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if item % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if item % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        elif item > bins[i]/3 and item <= bins[i]*2/3:\n            if item % 2 == 0:\n                priorities[i] = np.log(item / bins[i])\n            else:\n                priorities[i] = np.log1p(item / bins[i])\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.exp(item / bins[i])\n            else:\n                priorities[i] = np.expm1(item / bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:42:09", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if item % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if item % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            priorities[i] = np.sin(item / bins[i])\n        elif item > bins[i]/3 and item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i]) + np.cos(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i]) - np.tan(item / bins[i])\n        elif item > bins[i]/2 and item <= 2 * bins[i]/3:\n            priorities[i] = np.tanh(item / bins[i])\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.arctan(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i]) - np.arcsin(item / bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:42:12", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if item % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if item % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/4:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/4 and item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        elif item > bins[i]/2 and item <= 3 * bins[i]/4:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i])\n        else:\n            if item % 2 == 0:\n                priorities[i] = np.sqrt(np.log2(item / bins[i]))\n            else:\n                priorities[i] = np.cbrt(np.log10(item / bins[i]))\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:42:22", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    if remaining_ratio < 0.1:\n                        priorities[i] = np.power((1 - utilization), 2)\n                    elif 0.1 <= remaining_ratio < 0.5:\n                        priorities[i] = np.log(item * remaining_ratio)\n                    else:\n                        priorities[i] = np.cbrt(item * remaining_ratio)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:42:25", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.5:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = remaining_capacity / item\n                    if remaining_ratio > 0.8:\n                        priorities[i] = np.log(item * remaining_ratio) * np.sqrt(item)\n                    else:\n                        priorities[i] = np.sin(np.pi * utilization) * item\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:42:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"An advanced version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization <= 0.6:\n                    priorities[i] = 2\n                elif 0.6 < utilization <= 0.8:\n                    priorities[i] = 3\n                else:\n                    remaining_ratio = left_capacity / item\n                    if remaining_ratio > 0.5:\n                        priorities[i] = np.power(item * remaining_ratio, 3)\n                    else:\n                        priorities[i] = np.log(item * remaining_ratio)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:42:31", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v3(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.5:\n                    priorities[i] = 2 / (utilization)\n                elif 0.5 <= utilization < 0.8:\n                    priorities[i] = 3 * (1 - utilization)\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:42:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(matrix: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(matrix)\n    \n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            if matrix[i][j] % 2 == 0:\n                result[i][j] = matrix[i][j] * 2\n            elif matrix[i][j] % 3 == 0:\n                result[i][j] = matrix[i][j] * 3\n            else:\n                result[i][j] = matrix[i][j] ** 2\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:42:37", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros(data.shape[0])\n    \n    for i in range(data.shape[0]):\n        if i % 2 == 0:\n            for j in range(data.shape[1]):\n                if data[i][j] > 0:\n                    result[i] += data[i][j]\n        else:\n            for j in range(data.shape[1]):\n                if data[i][j] < 0:\n                    result[i] += np.abs(data[i][j])**2\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:42:39", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros(len(data))\n    \n    for i in range(len(data)):\n        if data[i] % 2 == 0:\n            result[i] = data[i] * 2\n        else:\n            result[i] = data[i] + 1\n            \n        if i > 0 and data[i] > data[i-1]:\n            result[i] *= 3\n            \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:42:41", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio_1 = item / bins[i]\n        ratio_2 = bins[i] / item\n        \n        if remaining_capacity >= 0:\n            if ratio_1 > 0.5:\n                priorities[i] = 1 / (1 + np.exp(-ratio_1))\n            else:\n                priorities[i] = 1 / (1 + np.exp(-ratio_2))\n        else:\n            if ratio_1 > 0.8:\n                priorities[i] = -np.log(np.abs(ratio_1))\n            else:\n                priorities[i] = -np.log(np.abs(ratio_2))\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:42:48", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n            \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n            elif priorities[i] < 0.5:\n                priorities[i] = 0.5\n            else:\n                priorities[i] = priorities[i]\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:42:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n            \n            if i % 2 == 0:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.3\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:42:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    remaining_space = max_capacity - bins[j]\n                    if remaining_space >= item:\n                        priorities[j] = 0.7\n                    else:\n                        priorities[j] = 0.3\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:42:56", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            \n            if priority > 0.5:\n                priorities[i] = 0.8\n            elif priority < 0.3:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.7\n                \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 1.0\n                else:\n                    remaining_capacity = bins[j]\n                    priority = 0.0\n                    while remaining_capacity < item:\n                        priority += 0.2\n                        remaining_capacity += bins[j]\n                    priorities[j] = priority * 0.9\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:43:02", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])\n            if bins[i] <= 0.3 * max_bin_capacity:\n                priorities[i] += 1.2 * bins[i]\n            if i % 3 == 0:\n                priorities[i] += 2.3  # Additional priority for every 3rd bin\n            elif i % 3 == 1:\n                priorities[i] -= 1.3  # Reduced priority for every 3rd bin\n            \n        else:\n            priorities[i] = bins[i] - item\n            if bins[i] >= 0.7 * max_bin_capacity:\n                priorities[i] -= 1.1 * (bins[i] - item)\n            if i % 4 == 0:\n                priorities[i] -= 1.5  # Reduced priority for every 4th bin\n            elif i % 4 == 1:\n                priorities[i] += 0.5  # Increased priority for every 4th bin\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2.5 * (item - bins[i])\n            if bins[i] <= 0.3 * max_bin_capacity:\n                priorities[i] += 1.4 * bins[i]\n            if i % 3 == 0:\n                priorities[i] += 2.5\n            elif i % 3 == 1:\n                priorities[i] -= 1.4\n            \n            if i % 5 == 0:\n                priorities[i] *= 1.2\n            elif i % 5 == 1:\n                priorities[i] /= 1.2\n        else:\n            priorities[i] = 1.5 * bins[i] - item\n            if bins[i] >= 0.7 * max_bin_capacity:\n                priorities[i] -= 1.3 * (bins[i] - item)\n            if i % 4 == 0:\n                priorities[i] -= 1.7\n            elif i % 4 == 1:\n                priorities[i] += 1.1\n            \n            if i % 6 == 0:\n                priorities[i] *= 1.3\n            elif i % 6 == 1:\n                priorities[i] /= 1.3\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:43:08", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])\n            if bins[i] <= 0.3 * max_bin_capacity:\n                priorities[i] += 1.2 * bins[i]\n            if i % 3 == 0:\n                priorities[i] += 2.3  # Additional priority for every 3rd bin\n            elif i % 3 == 1:\n                priorities[i] -= 1.3  # Reduced priority for every 3rd bin\n            \n        else:\n            priorities[i] = bins[i] - item\n            if bins[i] >= 0.7 * max_bin_capacity:\n                priorities[i] -= 1.1 * (bins[i] - item)\n            if i % 4 == 0:\n                priorities[i] -= 1.5  # Reduced priority for every 4th bin\n            elif i % 4 == 1:\n                priorities[i] += 0.5  # Increased priority for every 4th bin\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])\n            if bins[i] <= 0.3 * max_bin_capacity:\n                priorities[i] += 1.2 * bins[i]\n            if i % 3 == 0:\n                priorities[i] += 2.3  # Additional priority for every 3rd bin\n            elif i % 3 == 1:\n                priorities[i] -= 1.3  # Reduced priority for every 3rd bin\n            if bins[i] >= 0.8 * max_bin_capacity:\n                priorities[i] += 3.5  # Extra high priority for bins close to full\n            if bins[i] < 0.1 * max_bin_capacity:\n                priorities[i] -= 2.7  # Reduced priority for nearly empty bins\n        else:\n            priorities[i] = (bins[i] - item) * 1.5  # Higher priority for not completely filling bins\n            if bins[i] >= 0.7 * max_bin_capacity:\n                priorities[i] -= 1.1 * (bins[i] - item)\n            if i % 4 == 0:\n                priorities[i] -= 1.5  # Reduced priority for every 4th bin\n            elif i % 4 == 1:\n                priorities[i] += 0.5  # Increased priority for every 4th bin\n            if bins[i] < 0.3 * max_bin_capacity:\n                priorities[i] -= 0.8  # Lower priority for bins with plenty of space\n                if i % 2 == 0:\n                    priorities[i] += 1.2  # Slightly increased priority for every other bin with plenty of space\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:43:11", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])\n            if bins[i] <= 0.3 * max_bin_capacity:\n                priorities[i] += 1.2 * bins[i]\n            if i % 3 == 0:\n                priorities[i] += 2.3  # Additional priority for every 3rd bin\n            elif i % 3 == 1:\n                priorities[i] -= 1.3  # Reduced priority for every 3rd bin\n            \n        else:\n            priorities[i] = bins[i] - item\n            if bins[i] >= 0.7 * max_bin_capacity:\n                priorities[i] -= 1.1 * (bins[i] - item)\n            if i % 4 == 0:\n                priorities[i] -= 1.5  # Reduced priority for every 4th bin\n            elif i % 4 == 1:\n                priorities[i] += 0.5  # Increased priority for every 4th bin\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if item > 1.1 * bins[i]:\n            priorities[i] = 3 * (item - bins[i])\n            if bins[i] <= 0.25 * max_bin_capacity:\n                priorities[i] += 1.5 * bins[i]\n            else:\n                priorities[i] -= 1\n                \n        elif item > bins[i] and item <= 1.1 * bins[i]:\n            priorities[i] = 2 * (item - bins[i])\n            if bins[i] >= 0.8 * max_bin_capacity:\n                priorities[i] -= 0.8 * (item - bins[i])\n            else:\n                priorities[i] += 0.5 * bins[i]\n        else:\n            priorities[i] = bins[i] - item\n            if bins[i] >= 0.7 * max_bin_capacity:\n                priorities[i] -= 1.2 * (bins[i] - item)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:43:15", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])\n            if bins[i] <= 0.3 * max_bin_capacity:\n                priorities[i] += 1.2 * bins[i]\n            if i % 3 == 0:\n                priorities[i] += 2.3  # Additional priority for every 3rd bin\n            elif i % 3 == 1:\n                priorities[i] -= 1.3  # Reduced priority for every 3rd bin\n            \n        else:\n            priorities[i] = bins[i] - item\n            if bins[i] >= 0.7 * max_bin_capacity:\n                priorities[i] -= 1.1 * (bins[i] - item)\n            if i % 4 == 0:\n                priorities[i] -= 1.5  # Reduced priority for every 4th bin\n            elif i % 4 == 1:\n                priorities[i] += 0.5  # Increased priority for every 4th bin\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 1.5 * (item - bins[i])\n            if bins[i] <= 0.4 * max_bin_capacity:\n                priorities[i] += 1.3 * bins[i]\n            if i % 2 == 0:\n                priorities[i] += 2.7  # Additional priority for every even-indexed bin\n            elif i % 3 == 1:\n                priorities[i] -= 1.7  # Reduced priority for every odd-indexed bin\n            \n        else:\n            priorities[i] = 0.8 * (bins[i] - item)\n            if bins[i] >= 0.6 * max_bin_capacity:\n                priorities[i] -= 1.2 * (bins[i] - item)\n            if i % 5 == 0:\n                priorities[i] -= 1.8  # Reduced priority for every 5th bin\n            elif i % 5 == 1:\n                priorities[i] += 0.8  # Increased priority for every 5th bin\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:43:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.4\n                else:\n                    priority += 0.6\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 1.8\n            elif priority < 0.4:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.7\n                else:\n                    priorities[j] = 0.4\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.4\n                else:\n                    priority += 0.6\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 1.8\n            elif priority < 0.4:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.7\n                else:\n                    priorities[j] = 0.4\n                    \n    # Additional complexity\n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    if max_priority - min_priority > 0.6:\n        for k in range(len(priorities)):\n            if priorities[k] == max_priority:\n                priorities[k] *= 1.5\n            elif priorities[k] == min_priority:\n                priorities[k] *= 0.5\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:43:33", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.4\n                else:\n                    priority += 0.6\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 1.8\n            elif priority < 0.4:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.7\n                else:\n                    priorities[j] = 0.4\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.4\n                else:\n                    priority += 0.6\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 1.8\n            elif priority < 0.4:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.7\n                else:\n                    if item > 1.2 * bins[j]:\n                        priorities[j] = 0.3\n                    else:\n                        priorities[j] = 0.6\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:43:36", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.4\n                else:\n                    priority += 0.6\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 1.8\n            elif priority < 0.4:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.7\n                else:\n                    priorities[j] = 0.4\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.3 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.8\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 2.0\n            elif priority < 0.5:\n                priorities[i] *= 0.6\n            else:\n                priorities[i] *= 1.5\n            \n            if i % 2 == 0:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.8\n                    else:\n                        priorities[j] = 0.5\n            else:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.6\n                    else:\n                        priorities[j] = 0.3\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:43:40", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.4\n                else:\n                    priority += 0.6\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 1.8\n            elif priority < 0.4:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.7\n                else:\n                    priorities[j] = 0.4\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.1 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.3 * item:\n                    priority += 0.5\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.7\n                else:\n                    priority += 0.9\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 2.0\n            elif priority < 0.5:\n                priorities[i] *= 0.6\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.8\n                else:\n                    priorities[j] = 0.5\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:43:44", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(input_array: np.ndarray) -> np.ndarray:\n    result = np.zeros(len(input_array))\n    \n    for i in range(len(input_array)):\n        if input_array[i] % 2 == 0:\n            result[i] = input_array[i] * 2\n        else:\n            result[i] = input_array[i] / 2\n            \n        if input_array[i] > 10:\n            result[i] -= 5\n        elif input_array[i] < 5:\n            result[i] += 10\n        \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:43:46", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(matrix: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(matrix)\n    \n    for i in range(matrix.shape[0]):\n        for j in range(matrix.shape[1]):\n            if matrix[i, j] % 2 == 0:\n                result[i, j] = matrix[i, j] * 2\n            elif matrix[i, j] % 3 == 0:\n                result[i, j] = matrix[i, j] * 3\n            else:\n                result[i, j] = matrix[i, j] * 4\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:43:48", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros(data.shape)\n\n    for i in range(data.shape[0]):\n        for j in range(data.shape[1]):\n            if data[i][j] % 2 == 0:\n                result[i][j] = data[i][j] * 2\n            elif data[i][j] % 3 == 0:\n                result[i][j] = data[i][j] * 3\n            else:\n                result[i][j] = data[i][j]\n\n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:43:51", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros(len(data))\n    \n    for i in range(len(data)):\n        if data[i] % 2 == 0:\n            result[i] = data[i] ** 2\n        else:\n            result[i] = data[i] * 2\n    \n    for j in range(1, len(data)):\n        if data[j] > data[j-1]:\n            result[j] += result[j-1]\n        else:\n            result[j] -= result[j-1]\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:43:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.25:\n                    priorities[i] = (1 - utilization) * np.log(item)\n                elif 0.25 <= utilization < 0.55:\n                    priorities[i] = 2 * np.sqrt(item)\n                elif 0.55 <= utilization < 0.75:\n                    priorities[i] = np.square(left_capacity) / (2 * item)\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio) + 2\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:43:57", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3 * utilization\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 5\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:44:00", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    if remaining_ratio < 0.2:\n                        priorities[i] = 1.5 * np.sqrt(item * remaining_ratio)\n                    elif 0.2 <= remaining_ratio < 0.5:\n                        priorities[i] = 2.5 * np.sqrt(item * remaining_ratio)\n                    else:\n                        priorities[i] = 3 * np.sqrt(item * remaining_ratio)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:44:02", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(matrix: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(matrix)\n    \n    for i in range(matrix.shape[0]):\n        for j in range(matrix.shape[1]):\n            if matrix[i, j] % 2 == 0:\n                result[i, j] = matrix[i, j] * 2\n            else:\n                if matrix[i, j] < 0:\n                    result[i, j] = matrix[i, j] + 10\n                else:\n                    result[i, j] = matrix[i, j] - 5\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:44:05", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        \n        if priority < 0:\n            priorities.append(priority)\n        elif priority >= 1:\n            priorities.append(1)\n        else:\n            priorities.append(priority)\n    \n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:44:08", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2) + 1):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        divisor_sum = sum([d for d in range(1, i) if i % d == 0])\n                        priority = 1 / (bin_capacity - item + divisor_sum)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:44:11", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                found_divisor = False\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        found_divisor = True\n                        break\n                if not found_divisor:\n                    priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:44:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            if item % bin_capacity == 0:\n                priority = 0\n            else:\n                for i in range(2, int(item/2)):\n                    if item % i == 0:\n                        priority = 1 / (item - bin_capacity + i)\n                        break\n                else:\n                    priority = 1 / (item - bin_capacity + 1)\n        priorities.append(priority)\n    \n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:44:18", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = item - bins[i]\n        elif bins[i] == min_capacity:\n            priorities[i] = bins[i] - item\n        else:\n            priorities[i] = abs(item - bins[i]) / (max_capacity - min_capacity)\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n    range_capacity = max_capacity - min_capacity\n\n    for i, bin_capacity in enumerate(bins):\n        if bin_capacity == max_capacity:\n            priorities[i] = item - bin_capacity\n        elif bin_capacity == min_capacity:\n            priorities[i] = bin_capacity - item\n        else:\n            ratio = (bin_capacity - min_capacity) / range_capacity\n            priorities[i] = abs(item - bin_capacity) / ratio\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:44:21", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = item - bins[i]\n        elif bins[i] == min_capacity:\n            priorities[i] = bins[i] - item\n        else:\n            priorities[i] = abs(item - bins[i]) / (max_capacity - min_capacity)\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    sorted_bins = np.sort(bins)\n    n = len(bins)\n    \n    for i in range(n):\n        if i == 0:\n            priorities[i] = abs(item - sorted_bins[i])\n        elif i == n-1:\n            priorities[i] = abs(item - sorted_bins[i])\n        else:\n            priorities[i] = abs(item - sorted_bins[i]) / (sorted_bins[n-1] - sorted_bins[0])\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:44:23", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = item - bins[i]\n        elif bins[i] == min_capacity:\n            priorities[i] = bins[i] - item\n        else:\n            priorities[i] = abs(item - bins[i]) / (max_capacity - min_capacity)\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n    avg_capacity = np.mean(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = item - bins[i]\n        elif bins[i] == min_capacity:\n            priorities[i] = bins[i] - item\n        elif bins[i] < avg_capacity:\n            priorities[i] = abs(item - bins[i]) / (avg_capacity - min_capacity)\n        else:\n            priorities[i] = abs(item - bins[i]) / (max_capacity - avg_capacity)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:44:25", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = item - bins[i]\n        elif bins[i] == min_capacity:\n            priorities[i] = bins[i] - item\n        else:\n            priorities[i] = abs(item - bins[i]) / (max_capacity - min_capacity)\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    sorted_bins = np.sort(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] == sorted_bins[0]:\n            priorities[i] = 1.0\n        elif bins[i] == sorted_bins[-1]:\n            priorities[i] = 0.5\n        else:\n            priorities[i] = (sorted_bins[i] - sorted_bins[0]) / (sorted_bins[-1] - sorted_bins[0])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:44:36", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        temp_priority = 0\n                        for j in range(1, int(bin_capacity/4)):\n                            if bin_capacity % j == 0:\n                                temp_priority = 2 / (bin_capacity - item + j)\n                                break\n                        if temp_priority != 0:\n                            priority = temp_priority\n                        else:\n                            priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:44:39", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        \n        if bin_capacity > 10 and item > 5:\n            priority *= 1.5\n        elif bin_capacity < 5:\n            priority *= 0.5\n        else:\n            priority *= 1\n        \n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:44:42", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        if item % i == 0:\n                            priority = 1 / (bin_capacity - item + i)\n                            break\n                        else:\n                            priority = 1 / (bin_capacity - item + 1)\n        else:\n            if item % bin_capacity == 0:\n                priority = 0\n            else:\n                priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:44:45", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        for j in range(i):\n                            if (bin_capacity - item) % (i + j) == 0:\n                                priority = 2 / (bin_capacity - item + i)\n                                break\n                            else:\n                                priority = 1 / (bin_capacity - item + j)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:44:48", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization <= 0.5:\n                    priorities[i] = 2\n                elif 0.5 < utilization <= 0.8:\n                    sub_priority = 0\n                    for j in range(1, int(item/2)+1):\n                        if item % j == 0:\n                            sub_priority += j\n                    priorities[i] = sub_priority\n                else:\n                    remaining_ratio = left_capacity / item\n                    sub_priority = 0\n                    for k in range(2, int(item**0.5)+1):\n                        if item % k == 0:\n                            sub_priority += k\n                    priorities[i] = np.sqrt(item * remaining_ratio) + sub_priority\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:44:51", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Another improved version with more complex logic.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization <= 0.5:\n                    priorities[i] = 2\n                elif 0.5 < utilization <= 0.8:\n                    priorities[i] = 3\n                else:\n                    remaining_ratio = left_capacity / item\n                    if remaining_ratio < 0.3:\n                        priorities[i] = np.sqrt(item / remaining_ratio)\n                    else:\n                        priorities[i] = 5 * remaining_ratio\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:44:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Another improved version of the priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    if remaining_ratio < 0.5:\n                        priorities[i] = np.sqrt(item * remaining_ratio)\n                    else:\n                        priorities[i] = 3 * np.sqrt(item * remaining_ratio)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:44:58", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "import numpy as np\n\n\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.5:\n                    priorities[i] = 2 / utilization\n                elif 0.5 <= utilization <= 0.75:\n                    priorities[i] = 3\n                else:\n                    remaining_ratio = left_capacity / item\n                    if remaining_ratio < 0.4:\n                        priorities[i] = np.sqrt(item * remaining_ratio) + 2\n                    else:\n                        priorities[i] = np.sqrt(item * remaining_ratio) - 1\n                        \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:45:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def custom_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros(data.shape)\n    \n    for i in range(data.shape[0]):\n        for j in range(data.shape[1]):\n            if data[i, j] >= 0:\n                result[i, j] = np.sqrt(data[i, j])\n            else:\n                if data[i, j] % 2 == 0:\n                    result[i, j] = np.log(np.abs(data[i, j]))\n                else:\n                    result[i, j] = np.exp(data[i, j])\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:45:05", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            if ratio < -1.5:\n                priorities[i] = np.sqrt(np.abs(ratio))\n            else:\n                priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:45:07", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def sort_and_group(lst):\n    sorted_list = sorted(lst)\n    grouped_dict = {}\n    \n    for num in sorted_list:\n        if num % 2 == 0:\n            key = \"even\"\n        else:\n            key = \"odd\"\n        \n        if key in grouped_dict:\n            grouped_dict[key].append(num)\n        else:\n            grouped_dict[key] = [num]\n    \n    return grouped_dict", "strategy": []}
{"timestamp": "2025-04-27 05:45:09", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def calculate_rolling_average(data: np.ndarray, window_size: int) -> np.ndarray:\n    rolling_avg = np.zeros(len(data) - window_size + 1)\n    \n    for i in range(len(data) - window_size + 1):\n        window_sum = np.sum(data[i:i+window_size])\n        rolling_avg[i] = window_sum / window_size\n        \n        if i > 0:\n            rolling_avg[i] = 0.6 * rolling_avg[i] + 0.4 * rolling_avg[i - 1]\n        \n        if rolling_avg[i] < 0:\n            rolling_avg[i] = np.abs(rolling_avg[i])\n    \n    return rolling_avg", "strategy": []}
{"timestamp": "2025-04-27 05:45:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        if priority < 0:\n            priority = -priority\n        elif priority == 0:\n            priority = np.random.rand()\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:45:17", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        else:\n            if ratio >= 0.2 and ratio < 0.4:\n                priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n            else:\n                if ratio >= 0.4 and ratio < 0.6:\n                    priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n                else:\n                    if ratio >= 0.6 and ratio < 0.8:\n                        priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n                    else:\n                        if ratio >= 0.8 and ratio < 1.0:\n                            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n                        else:\n                            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n                            \n        priorities.append(priority)\n\n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:45:21", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio) - np.sinh(ratio) * np.cosh(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:45:24", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        # Applying some more complex operations based on the priority value\n        if priority < 0:\n            priority = np.abs(priority) * 2\n        elif priority >= 0 and priority < 1:\n            priority = priority ** 3\n        elif priority >= 1 and priority < 2:\n            priority = np.sqrt(priority)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:45:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                can_fit = True\n                cumulative_capacity = 0\n                for k in range(i, j+1):\n                    cumulative_capacity += bins[k]\n                    if cumulative_capacity < item:\n                        can_fit = False\n                        break\n                \n                if can_fit:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:45:31", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    max_priority = max(priorities)\n    \n    for k in range(len(priorities)):\n        if priorities[k] == 0:\n            priorities[k] = max_priority + 1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:45:34", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    min_sum_capacity = sum(bins[i:j+1])\n                    if min_sum_capacity >= item:\n                        priorities[i:j+1] = np.arange(1, j+1-i+2)\n                        break\n                    else:\n                        priorities[i] = -1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:45:38", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            contiguous_bins = 1\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = contiguous_bins + 1\n                    break\n                elif bins[j] < item:\n                    contiguous_bins += 1\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:45:41", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization <= 0.4:\n                    priorities[i] = 2\n                elif 0.4 < utilization <= 0.6:\n                    priorities[i] = 3\n                elif 0.6 < utilization <= 0.8:\n                    priorities[i] = 4\n                else:\n                    priorities[i] = 5\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:45:46", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = np.log(item) * np.log(left_capacity)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 2 * np.sqrt(item)\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 3 * item / left_capacity\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.power(item * remaining_ratio, 1.5)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:45:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.5:\n                    priorities[i] = 2 / (utilization + 0.1)\n                elif 0.5 <= utilization < 0.7:\n                    priorities[i] = 2.5\n                elif 0.7 <= utilization < 0.9:\n                    priorities[i] = 2 * utilization\n                else:\n                    remaining_ratio = left_capacity / item\n                    if remaining_ratio > 0.3:\n                        priorities[i] = np.sqrt(item * remaining_ratio)\n                    else:\n                        priorities[i] = np.power(item, 1.5) * remaining_ratio\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:45:53", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.3:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.3 <= utilization <= 0.7:\n                    priorities[i] = 2\n                else:\n                    remaining_ratio = left_capacity / item\n                    priorities[i] = np.sqrt(item * remaining_ratio)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:46:00", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if item % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if item % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if item % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i])\n    \n    # Additional logic for special cases\n    if item > sum(bins)/len(bins):  # If item is larger than average bin capacity\n        priorities = np.power(priorities, 2)  # Increase priority score by squaring\n    elif item < np.min(bins):  # If item is smaller than the smallest bin\n        priorities = np.multiply(priorities, 1.5)  # Increase priority score by 50%\n    else:\n        priorities = np.divide(priorities, 2)  # Decrease priority score by dividing by 2\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:46:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if item % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if item % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            priorities[i] = np.exp(item / bins[i])\n        elif item > bins[i]/3 and item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = np.sin(item / bins[i])\n            else:\n                priorities[i] = np.cos(item / bins[i])\n        elif item > bins[i]/2 and item <= 2 * bins[i]/3:\n            priorities[i] = np.tan(item / bins[i])\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log1p(item / bins[i])\n            else:\n                priorities[i] = np.expm1(item / bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:46:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if item % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if item % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]/2:\n            if item % 3 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 1/3)\n        elif item > bins[i]/2 and item <= 2*bins[i]/3:\n            if item % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i])\n        else:\n            priorities[i] = np.power(item / bins[i], 2)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:46:09", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if item % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if item % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        elif item > bins[i]/2 and item <= 2*bins[i]/3:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i])\n        else:\n            priorities[i] = np.power(item / bins[i], 2)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:46:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def calculate_distance_matrix(coordinates: np.ndarray) -> np.ndarray:\n    num_points = len(coordinates)\n    distance_matrix = np.zeros((num_points, num_points))\n\n    for i in range(num_points):\n        for j in range(num_points):\n            if i == j:\n                distance_matrix[i, j] = 0\n            else:\n                x1, y1 = coordinates[i]\n                x2, y2 = coordinates[j]\n                distance = np.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n                distance_matrix[i, j] = distance\n\n    return distance_matrix", "strategy": []}
{"timestamp": "2025-04-27 05:46:15", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def calculate_fibonacci_sequence(n: int) -> List[int]:\n    fibonacci_sequence = []\n    \n    if n <= 0:\n        return fibonacci_sequence\n    \n    if n == 1:\n        fibonacci_sequence.append(0)\n        return fibonacci_sequence\n    \n    fibonacci_sequence = [0, 1]\n    \n    for i in range(2, n):\n        next_number = fibonacci_sequence[-1] + fibonacci_sequence[-2]\n        fibonacci_sequence.append(next_number)\n    \n    return fibonacci_sequence", "strategy": []}
{"timestamp": "2025-04-27 05:46:18", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(array: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(array)\n    \n    for i in range(len(array)):\n        if array[i] % 2 == 0:\n            result[i] = array[i] * 2\n        else:\n            result[i] = array[i] * 3\n    \n    for i in range(1, len(array)):\n        if array[i] > array[i-1]:\n            result[i] += array[i-1]\n        else:\n            result[i] -= array[i-1]\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:46:19", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros(data.shape)\n    \n    for i in range(data.shape[0]):\n        for j in range(data.shape[1]):\n            if data[i, j] > 0:\n                result[i, j] = np.sqrt(data[i, j])\n            elif data[i, j] < 0:\n                result[i, j] = np.abs(data[i, j])\n            else:\n                result[i, j] = 0\n                \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:46:24", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/4:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/4 and item <= bins[i]/2:\n            priorities[i] = np.sqrt(item / bins[i])\n        elif item > bins[i]/2 and item <= 3*bins[i]/4:\n            priorities[i] = np.power(item / bins[i], 3)\n        else:\n            priorities[i] = np.log(item / bins[i])\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:46:26", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/4:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/4 and item <= bins[i]/2:\n            priorities[i] = np.sqrt(item / bins[i])\n        elif item > bins[i]/2 and item <= bins[i]*3/4:\n            priorities[i] = np.log(item / bins[i])\n        else:\n            priorities[i] = np.exp(item / bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:46:29", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]*2/3:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            if item % 2 == 0:\n                priorities[i] = np.log(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:46:31", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= 0.1 * bins[i]:\n            priorities[i] = item / bins[i]\n        elif item > 0.1 * bins[i] and item <= 0.5 * bins[i]:\n            priorities[i] = np.power(item / bins[i], 2)\n        elif item > 0.5 * bins[i] and item <= bins[i]:\n            priorities[i] = np.exp(item / bins[i])\n        else:\n            priorities[i] = np.log2(item / bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:46:33", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(data)\n    \n    for i in range(len(data)):\n        if data[i] % 2 == 0:\n            result[i] = data[i] * 2\n        else:\n            if data[i] < 0:\n                result[i] = data[i] + 10\n            else:\n                for j in range(data[i]):\n                    result[i] += j\n                    \n    return result\n```", "strategy": []}
{"timestamp": "2025-04-27 05:46:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(data)\n    \n    for i in range(len(data)):\n        if data[i] < 0:\n            result[i] = data[i] ** 2\n        else:\n            for j in range(1, data[i] + 1):\n                if data[i] % j == 0:\n                    result[i] += j\n                    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:46:38", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n                else:\n                    priorities[i] = 0\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:46:41", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef complex_function(input_data: np.ndarray) -> np.ndarray:\n    output_data = np.zeros_like(input_data)\n    \n    for i in range(len(input_data)):\n        if input_data[i] % 2 == 0:\n            output_data[i] = input_data[i] * 2\n        else:\n            output_data[i] = input_data[i] ** 2\n            \n        if input_data[i] < 0:\n            output_data[i] = 0\n            \n        for j in range(2, int(np.sqrt(input_data[i]))+1):\n            if input_data[i] % j == 0:\n                output_data[i] += j\n                \n    return output_data\n```", "strategy": []}
{"timestamp": "2025-04-27 05:46:45", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.8:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 4\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 3\n            elif bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:46:49", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                if item % 2 == 0:\n                    priorities[i] = 6\n                else:\n                    priorities[i] = 5\n            elif item > 10 and bins[i] > 8:\n                if item % 3 == 0:\n                    priorities[i] = 5\n                else:\n                    priorities[i] = 4\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                if item % 2 == 0:\n                    priorities[i] = 4\n                else:\n                    priorities[i] = 3\n            elif item > 8 and bins[i] > 4:\n                if item % 3 == 0:\n                    priorities[i] = 3\n                else:\n                    priorities[i] = 2\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                if item % 2 == 0:\n                    priorities[i] = 3\n                else:\n                    priorities[i] = 2\n            elif item > 3 and bins[i] > 2:\n                if item % 3 == 0:\n                    priorities[i] = 2\n                else:\n                    priorities[i] = 1\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                if item % 2 == 0:\n                    priorities[i] = 2\n                else:\n                    priorities[i] = 1\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:46:53", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n                \n        # Additional condition\n        if item + 5 > bins[i]:\n            priorities[i] -= 1\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:46:58", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n        # Additional condition\n        if bins[i] == 0:\n            priorities[i] = 0\n        elif item % 2 == 0:\n            priorities[i] += 1\n        elif item % 3 == 0:\n            priorities[i] += 2\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:47:04", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    if min_capacity >= item:\n        priorities[np.argmin(bins)] = 1\n    else:\n        for i in range(len(bins)):\n            if bins[i] >= item:\n                priorities[i] = 1\n            else:\n                remaining_capacity = bins[i]\n                for j in range(i+1, len(bins)):\n                    remaining_capacity += bins[j]\n                    if bins[j] >= item and remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:47:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            current_bin_priority = 1\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                current_bin_priority += 1\n                if bins[j] >= item and remaining_capacity >= item:\n                    if priorities[j] == 0 or current_bin_priority < priorities[j]:\n                        priorities[j] = current_bin_priority\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:47:10", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    min_index = bins.index(min(bins))\n                    if item < min_capacity:\n                        priorities[min_index] = 1\n                    else:\n                        priorities[i] = -1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:47:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    max_priority = np.max(priorities)\n    for k in range(len(priorities)):\n        if priorities[k] == 0:\n            priorities[k] = max_priority + 1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:47:18", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            elif item > 8 and bins[i] > 6:\n                priorities[i] = 4\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            elif item > 6 and bins[i] > 3:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:47:23", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    for i in range(len(bins)):\n        if priorities[i] == 3:\n            priorities[i] += 1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:47:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                if item < 1:\n                    priorities[i] = 1\n                else:\n                    smallest_item = min(item, bins[i])\n                    priorities[i] = smallest_item / bins[i]\n            else:\n                priorities[i] = 0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:47:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif 0.8 <= ratios[i] < 0.9:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif 0.6 <= ratios[i] < 0.8:\n            if item > 4 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 2 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif 0.4 <= ratios[i] < 0.6:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:47:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_function(input_data: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(input_data)\n\n    for i in range(len(input_data)):\n        if input_data[i] % 2 == 0:\n            result[i] = input_data[i] * 2\n        else:\n            temp = input_data[i]\n            while temp > 0:\n                result[i] += temp % 10\n                temp = temp // 10\n\n    return result\n```", "strategy": []}
{"timestamp": "2025-04-27 05:47:38", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v3(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.1:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.1 <= utilization < 0.3:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.3 <= utilization < 0.5:\n                    priorities[i] = 3\n                elif 0.5 <= utilization < 0.7:\n                    priorities[i] = 4 * utilization\n                elif 0.7 <= utilization < 0.9:\n                    priorities[i] = 5 * np.sqrt(utilization)\n                elif 0.9 <= utilization <= 1.0:\n                    priorities[i] = 6 * (1 - np.sqrt(1-utilization))\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:47:40", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: dict) -> list:\n    result = []\n    \n    for key, value in data.items():\n        if isinstance(value, list):\n            sublist = []\n            for item in value:\n                if isinstance(item, dict):\n                    subdict = {}\n                    for k, v in item.items():\n                        if isinstance(v, str):\n                            subdict[k] = v.upper()\n                        elif isinstance(v, int):\n                            subdict[k] = v * 2\n                    sublist.append(subdict)\n                elif isinstance(item, int):\n                    sublist.append(item * 3)\n            result.append(sublist)\n        elif isinstance(value, int):\n            result.append(value)\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:47:43", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n                else:\n                    priorities[i] = 6 * np.log(utilization)  # Additional priority calculation for rare cases\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:47:48", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif 0.8 <= ratios[i] < 0.9:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif 0.6 <= ratios[i] < 0.8:\n            if item > 4 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 2 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif 0.4 <= ratios[i] < 0.6:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0\n        else:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 7\n            elif item > 15 and bins[i] > 12:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            elif item > 8 and bins[i] > 6:\n                priorities[i] = 4\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 3\n            elif item > 4 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:47:52", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif 0.8 <= ratios[i] < 0.9:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif 0.6 <= ratios[i] < 0.8:\n            if item > 4 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 2 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif 0.4 <= ratios[i] < 0.6:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v3(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif 0.8 <= ratios[i] < 0.9:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif 0.6 <= ratios[i] < 0.8:\n            if item > 4 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 2 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif 0.4 <= ratios[i] < 0.6:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:47:56", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif 0.8 <= ratios[i] < 0.9:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif 0.6 <= ratios[i] < 0.8:\n            if item > 4 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 2 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif 0.4 <= ratios[i] < 0.6:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif 0.8 <= ratios[i] < 0.9:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif 0.6 <= ratios[i] < 0.8:\n            if item > 6 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 4 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif 0.4 <= ratios[i] < 0.6:\n            if item > 4 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:48:00", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif 0.8 <= ratios[i] < 0.9:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif 0.6 <= ratios[i] < 0.8:\n            if item > 4 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 2 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif 0.4 <= ratios[i] < 0.6:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif 0.8 <= ratios[i] < 0.9:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif 0.6 <= ratios[i] < 0.8:\n            if item > 4 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 2 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif 0.4 <= ratios[i] < 0.6:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n        # Additional condition for even prioritization\n        if priorities[i] % 2 == 0:\n            priorities[i] += 1\n        # Additional condition for reducing priority by 1\n        if bins[i] % 2 == 0:\n            priorities[i] -= 1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:48:08", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(7*ratio) + np.cos(4*ratio) - np.tan(2*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) ** 2\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio) - ratio\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio) ** 2\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:48:12", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    # Additional complexity\n    for i in range(len(priorities)):\n        if priorities[i] < 0:\n            priorities[i] = 0\n        else:\n            priorities[i] = np.minimum(priorities[i], 10)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:48:15", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(2*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.log(2*ratio) + np.exp(3*ratio) - np.sqrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.sinh(ratio) + np.cosh(ratio) + np.tanh(ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.sin(2*ratio) * np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:48:19", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(7*ratio) + np.cos(4*ratio) - np.tan(2*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(1.5*ratio) * np.log(1.5*ratio) + np.sqrt(ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(1.5*ratio) * np.sinh(1.5*ratio) - np.tanh(1.5*ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(2*ratio) * np.cos(2*ratio) * np.tan(2*ratio)\n        else:\n            priority = np.arcsin(1.5*ratio) + np.arccos(1.5*ratio) + np.arctan(1.5*ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:48:23", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    max_priority = max(priorities)\n    if max_priority == 1:\n        for k in range(len(bins)):\n            if priorities[k] == 1:\n                priorities[k] += 1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:48:25", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            expand = False\n            to_expand = []\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    expand = False\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item and not expand:\n                        to_expand = range(j, len(bins))\n                        expand = True\n                    if expand and len(to_expand) > 0:\n                        index = to_expand.pop(0)\n                        priorities[index] = (index - i) + 1\n                        if len(to_expand) == 0:\n                            break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:48:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    max_priority = max(priorities)\n    \n    if max_priority == 1:\n        return priorities\n    else:\n        for k in range(len(bins)):\n            if priorities[k] == max_priority:\n                priorities[k] += len(bins) - 1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:48:31", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    max_priority = 1\n\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = max_priority\n            max_priority += 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = max_priority\n                    max_priority += 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = max_priority\n                        max_priority += 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:48:36", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if item % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 3 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 3 == 1:\n                priorities[i] = (item + 2) / bins[i]\n            else:\n                priorities[i] = (item + 3) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i]) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i]) + np.log10(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.log2(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:48:40", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if item % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if item % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i])\n        \n        if priorities[i] < 0.1:\n            priorities[i] = 0.1\n        elif priorities[i] > 0.9:\n            priorities[i] = 0.9\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:48:42", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if item % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i] / 3:\n            priorities[i] = item / bins[i]\n        elif item > bins[i] / 3 and item <= bins[i] / 2:\n            priorities[i] = np.sqrt(item / bins[i])\n        elif item > bins[i] / 2 and item <= bins[i]:\n            if item % 3 == 0:\n                priorities[i] = np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.sqrt(item / bins[i])\n        else:\n            if item % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:48:45", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if item % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/4:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/4 and item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        elif item > bins[i]/2 and item <= bins[i]*3/4:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i])\n        else:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.log1p(item / bins[i])\n            else:\n                priorities[i] = np.log1p(np.sqrt(item / bins[i]))\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:48:51", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.cos(5*ratio) + np.sin(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.log(ratio) * np.sqrt(1.5*ratio) + np.exp(0.5*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:48:53", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    result = []\n\n    for i in range(len(data)):\n        if data[i] % 2 == 0:\n            res = np.sum(data[:i+1]) * np.prod(data[i:]) + np.mean(data) - np.std(data)\n        else:\n            res = np.sum(data[:i]) * np.prod(data[i:]) - np.mean(data) + np.std(data)\n\n        if res < 0:\n            result.append(np.abs(res))\n        else:\n            result.append(res)\n\n    return np.array(result)", "strategy": []}
{"timestamp": "2025-04-27 05:48:57", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        if ratio % 0.1 == 0.0:\n            priority = np.abs(priority)\n        else:\n            priority = np.square(priority)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:49:00", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        if priority < -5:\n            priority = np.abs(priority)\n\n        if priority > 10:\n            priority = priority / 2\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:49:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(arr: np.ndarray, k: int) -> np.ndarray:\n    output_arr = np.zeros(len(arr))\n    \n    for i in range(len(arr)):\n        if arr[i] % k == 0:\n            output_arr[i] = arr[i] // k\n        elif arr[i] % k == 1:\n            output_arr[i] = arr[i] * k\n        else:\n            output_arr[i] = arr[i] ** k\n    \n    return output_arr\n", "strategy": []}
{"timestamp": "2025-04-27 05:49:05", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(input_list: list) -> list:\n    output_list = []\n    \n    for i in range(len(input_list)):\n        if i % 2 == 0:\n            temp_list = []\n            for j in range(1, input_list[i] + 1):\n                if j % 2 == 0:\n                    temp_list.append(j * input_list[i])\n            output_list.append(temp_list)\n        else:\n            temp_val = 0\n            for j in range(input_list[i]):\n                temp_val += j\n            output_list.append(temp_val)\n    \n    return output_list", "strategy": []}
{"timestamp": "2025-04-27 05:49:08", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros(len(data))\n\n    for i in range(len(data)):\n        if data[i] % 2 == 0:\n            result[i] = data[i] * 2\n        else:\n            result[i] = data[i] + 1\n\n    for i in range(len(result)):\n        if result[i] < 10:\n            result[i] = result[i] * 3\n        else:\n            result[i] = result[i] // 2\n\n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:49:10", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(input_data: np.ndarray) -> np.ndarray:\n    output_data = np.zeros_like(input_data)\n    \n    for i in range(len(input_data)):\n        if input_data[i] % 2 == 0:\n            output_data[i] = input_data[i] ** 2\n        else:\n            output_data[i] = input_data[i] * 3\n    \n    for i in range(1, len(input_data)-1):\n        if input_data[i-1] < input_data[i] and input_data[i+1] < input_data[i]:\n            output_data[i] = input_data[i] + 10\n    \n    return output_data", "strategy": []}
{"timestamp": "2025-04-27 05:49:15", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if item % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/4:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/4 and item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i])\n        else:\n            total_items = np.sum(bins)\n            priorities[i] = bins[i] / total_items\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:49:17", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if item % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]/1.5:\n            if item % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1/3)\n            else:\n                priorities[i] = np.power(item / bins[i], 1/4)\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i]) ** 2\n            else:\n                priorities[i] = np.log10(item / bins[i]) ** 2\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:49:20", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if item % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]/2:\n            if item % 3 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        elif item > bins[i]/2 and item <= 2 * bins[i]/3:\n            if item % 2 == 0:\n                priorities[i] = np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.square(item / bins[i])\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i])\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:49:23", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if item % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i])\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log2(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if item % 2 == 0:\n                priorities[i] = np.power(item / bins[i], 1/3)\n            else:\n                priorities[i] = np.power(item / bins[i], 1/4)\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.log1p(item / bins[i])\n            else:\n                priorities[i] = np.expm1(item / bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:49:26", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]*2/3:\n            priorities[i] = np.sqrt(item / bins[i])\n        elif item > bins[i]*2/3 and item <= bins[i]:\n            priorities[i] = np.cbrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:49:29", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]*2/3:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n        \n        if item % 2 == 0:\n            priorities[i] *= 1.5\n        else:\n            priorities[i] *= 0.8\n            \n        if i % 2 == 0:\n            priorities[i] += 0.2\n        else:\n            priorities[i] -= 0.1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:49:32", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]/2:\n            priorities[i] = np.sqrt(item / bins[i])\n        elif item > bins[i]/2 and item <= 2*bins[i]/3:\n            priorities[i] = np.log(item / bins[i])\n        elif item > 2*bins[i]/3 and item <= bins[i]:\n            priorities[i] = np.square(np.log(item / bins[i]))\n        else:\n            priorities[i] = np.sqrt(np.log(item / bins[i]))\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:49:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]/2:\n            priorities[i] = np.sqrt(item / bins[i])\n        elif item > bins[i]/2 and item <= 2*bins[i]/3:\n            priorities[i] = item * 2 / bins[i]\n        elif item > 2*bins[i]/3 and item <= bins[i]:\n            priorities[i] = np.sqrt(item * 2 / bins[i])\n        else:\n            priorities[i] = np.log(item * 2 / bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:49:38", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = bins[i] - item\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n            priorities[i] = abs(item - remaining_capacity) * 2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    remaining_bins = len(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = bins[i] - item\n        else:\n            remaining_capacity = 0\n            for j in range(i, len(bins)):\n                remaining_capacity += bins[j]\n            if remaining_capacity >= item * remaining_bins:\n                priorities[i] = (remaining_capacity / remaining_bins) - item\n                remaining_bins -= 1\n            else:\n                priorities[i] = abs(item - remaining_capacity) * (i+1)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:49:40", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = bins[i] - item\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n            priorities[i] = abs(item - remaining_capacity) * 2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = bins[i] - item\n        else:\n            remaining_capacity = sum(bins[i:])\n            diff = item - remaining_capacity\n            if diff >= 0:\n                priorities[i] = diff * 2\n            else:\n                priorities[i] = abs(diff)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:49:42", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = bins[i] - item\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n            priorities[i] = abs(item - remaining_capacity) * 2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] *= 2\n        elif priorities[i] == min_priority:\n            priorities[i] /= 2\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:49:44", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = bins[i] - item\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n            priorities[i] = abs(item - remaining_capacity) * 2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = bins[i] - item\n        elif item < bins[i] * 0.7:\n            priorities[i] = bins[i] - item\n        else:\n            priorities[i] = abs(item - bins[i]) * (i+1)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:49:49", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    priorities[i] = 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more advanced version of priority calculation.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                total_remaining_capacities = sum([cap for cap in bins[i+1:]])\n                if total_remaining_capacities >= item:\n                    priorities[i] = 0.8\n                else:\n                    max_remaining_capacity = max(bins[i+1:])\n                    priorities[i] = 1 - ((item - remaining_capacity) / (max_remaining_capacity - remaining_capacity))\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:49:52", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    priorities[i] = 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items = bins[i+1:]\n                remaining_items_sum = sum(remaining_items)\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    max_possible_fit = sum([cap for cap in bins[i:] if item < cap])\n                    priorities[i] = max_possible_fit / bin_capacity\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:49:55", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    priorities[i] = 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items = [item for index, item in enumerate(bins) if index > i]\n                remaining_items_sum = sum(remaining_items)\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    for rem_item in remaining_items:\n                        if rem_item >= item:\n                            priorities[i] = 0.8\n                            break\n                        else:\n                            priorities[i] = 0.5\n                            break\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:49:59", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    priorities[i] = 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more advanced version of `priority_v1`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                adjustment_factor = 0.8\n                for k in range(i + 1, len(bins)):\n                    adjustment_factor -= 0.1\n                    if adjustment_factor < 0.3:\n                        adjustment_factor = 0.3\n                    if item <= (bin_capacity + sum(bins[i+1:k])):\n                        priorities[i] = adjustment_factor\n                        break\n                    priorities[i] = 0.2\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:50:04", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        if priority < 0.5:\n                            priority *= 2\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n                        if priority > 1:\n                            priority -= 0.5\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:50:07", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                found_divisor = False\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        found_divisor = True\n                        break\n                if not found_divisor:\n                    priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:50:10", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n\n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n                        if priority < 0.5:\n                            priority += 0.5\n        else:\n            priority = -1\n        priorities.append(priority)\n\n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:50:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        if i % 2 == 0:\n                            priority = 1 / (bin_capacity - item + i)\n                        else:\n                            priority = 2 / (bin_capacity - item + i)\n                        break\n                    else:\n                        if bin_capacity % item == 0:\n                            priority = 1 / (bin_capacity - item + 1)\n                        else:\n                            priority = -1\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:50:16", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        if priority < 0:\n            priority = np.abs(priority)\n        elif priority > 10:\n            priority = priority / 2\n        \n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:50:20", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.log(np.exp(ratio)) + np.sqrt(np.square(ratio)) - np.cbrt(np.power(ratio, 3))\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.sin(4*ratio) + np.cos(2*ratio) - np.tan(1.2*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.8*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:50:25", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        if priority < 0:\n            manipulated_priority = priority * 2\n        else:\n            manipulated_priority = priority / 2\n\n        priorities.append(manipulated_priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:50:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        if priority < 0:\n            priorities.append(priority - 0.1)\n        else:\n            priorities.append(priority + 0.1)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:50:31", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    priorities[i] = 0.5\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    if i % 2 == 0:\n                        priorities[i] = 0.8\n                    else:\n                        priorities[i] = 0.7\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:50:34", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    priorities[i] = 0.5\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Further improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity - sum(bins[:i])\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    priorities[i] = 0.7 - (item - remaining_capacity) / (sum(bins[i:]) - remaining_capacity)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:50:37", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    priorities[i] = 0.5\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    partial_sum = 0\n                    for index, bin_item in enumerate(bins):\n                        if index < i:\n                            partial_sum += bin_item\n                            if partial_sum >= item:\n                                priorities[i] = 0.7\n                                break\n                    if partial_sum < item:\n                        priorities[i] = 0.3\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:50:40", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    priorities[i] = 0.5\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    prev_priorities_sum = sum(priorities[:i])\n                    remaining_capacity_items = [(index, item_value) for index, item_value in enumerate(bins) if index > i]\n                    remaining_capacity_items.sort(key=lambda x: x[1])\n                    for index, item_value in remaining_capacity_items:\n                        if item <= remaining_capacity + item_value:\n                            priorities[i] = 0.8 + prev_priorities_sum\n                            break\n                        prev_priorities_sum += 0.05\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:50:49", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n\n    max_capacity = max(bins)\n    min_capacity = min(bins)\n\n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    if remaining_capacity - item >= min_capacity:\n                        priorities[j] = (j - i) + 1\n                    else:\n                        priorities[j] = -1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:50:52", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n            if priorities[i] == -1:\n                priorities[i] = (max(bins) - item) / max(bins)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:50:55", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:50:58", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:51:02", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n\n    max_capacity = max(bins)\n    max_capacity_idx = np.argmax(bins)\n\n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        prev_bin_capacity = bins[available_bins[idx-1]]\n                        curr_bin_capacity = bins[available_bins[idx]]\n                        priorities[available_bins[idx]] = (item - prev_bin_capacity) / (curr_bin_capacity - prev_bin_capacity)\n                else:\n                    priorities[max_capacity_idx] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Enhanced version of `priority_v1` with additional logic.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            elif item > bin_capacity + max(bins): \n                priorities[i] = 0.0\n            else:\n                temp = item - remaining_capacity\n                for j in range(i+1, len(bins)):\n                    if item <= bins[j]:\n                        priorities[j] = 1.0 - (temp / bins[j])\n                        break\n                if priorities[i] == 0:\n                    for j in range(i+1, len(bins)):\n                        if item <= bins[j] + max(bins):\n                            priorities[j] = 1.0 - (temp / (bins[j] + max(bins)))\n                            break\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            elif item > bin_capacity + max(bins): \n                priorities[i] = 0.0\n            else:\n                temp = item - remaining_capacity\n                for j in range(i+1, len(bins)):\n                    if item <= bins[j]:\n                        priorities[j] = 1.0 - (temp / bins[j])\n                        break\n                if priorities[i] == 0:\n                    for j in range(i+1, len(bins)):\n                        if item <= bins[j] + max(bins):\n                            priorities[j] = 1.0 - (temp / (bins[j] + max(bins)))\n                            break\n    \n    for i in range(len(bins)):\n        if priorities[i] == 0.0:\n            priorities[i] = max(bins) / bins[i]\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:51:05", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n\n    max_capacity = max(bins)\n    max_capacity_idx = np.argmax(bins)\n\n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        prev_bin_capacity = bins[available_bins[idx-1]]\n                        curr_bin_capacity = bins[available_bins[idx]]\n                        priorities[available_bins[idx]] = (item - prev_bin_capacity) / (curr_bin_capacity - prev_bin_capacity)\n                else:\n                    priorities[max_capacity_idx] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Enhanced version of `priority_v1` with additional logic.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            elif item > bin_capacity + max(bins): \n                priorities[i] = 0.0\n            else:\n                temp = item - remaining_capacity\n                for j in range(i+1, len(bins)):\n                    if item <= bins[j]:\n                        priorities[j] = 1.0 - (temp / bins[j])\n                        break\n                if priorities[i] == 0:\n                    for j in range(i+1, len(bins)):\n                        if item <= bins[j] + max(bins):\n                            priorities[j] = 1.0 - (temp / (bins[j] + max(bins)))\n                            break\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "import numpy as np\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        prev_bin_capacity = bins[available_bins[idx-1]]\n                        curr_bin_capacity = bins[available_bins[idx]]\n                        priorities[available_bins[idx]] = (item - prev_bin_capacity) / (curr_bin_capacity - prev_bin_capacity)\n                else:\n                    max_capacity = max(bins)\n                    max_capacity_idx = np.argmax(bins)\n                    priorities[max_capacity_idx] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:51:08", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n\n    max_capacity = max(bins)\n    max_capacity_idx = np.argmax(bins)\n\n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        prev_bin_capacity = bins[available_bins[idx-1]]\n                        curr_bin_capacity = bins[available_bins[idx]]\n                        priorities[available_bins[idx]] = (item - prev_bin_capacity) / (curr_bin_capacity - prev_bin_capacity)\n                else:\n                    priorities[max_capacity_idx] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Enhanced version of `priority_v1` with additional logic.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            elif item > bin_capacity + max(bins): \n                priorities[i] = 0.0\n            else:\n                temp = item - remaining_capacity\n                for j in range(i+1, len(bins)):\n                    if item <= bins[j]:\n                        priorities[j] = 1.0 - (temp / bins[j])\n                        break\n                if priorities[i] == 0:\n                    for j in range(i+1, len(bins)):\n                        if item <= bins[j] + max(bins):\n                            priorities[j] = 1.0 - (temp / (bins[j] + max(bins)))\n                            break\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Enhanced version of `priority_v1` with additional logic.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n                if available_bins:\n                    for idx in available_bins:\n                        priorities[idx] = 1.0 - (item - sum(bins[:idx])) / bins[idx]\n                    for j in range(i, len(bins)):\n                        if priorities[j] == 0:\n                            priorities[j] = 1.0 - (item - sum(bins[:j])) / (bins[j] + max(bins))\n                            break\n                else:\n                    for j in range(i, len(bins)):\n                        if item <= bins[j] + max(bins):\n                            priorities[j] = 1.0 - (item - sum(bins[:j])) / (bins[j] + max(bins))\n                            break\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:51:12", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n\n    max_capacity = max(bins)\n    max_capacity_idx = np.argmax(bins)\n\n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        prev_bin_capacity = bins[available_bins[idx-1]]\n                        curr_bin_capacity = bins[available_bins[idx]]\n                        priorities[available_bins[idx]] = (item - prev_bin_capacity) / (curr_bin_capacity - prev_bin_capacity)\n                else:\n                    priorities[max_capacity_idx] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Enhanced version of `priority_v1` with additional logic.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            elif item > bin_capacity + max(bins): \n                priorities[i] = 0.0\n            else:\n                temp = item - remaining_capacity\n                for j in range(i+1, len(bins)):\n                    if item <= bins[j]:\n                        priorities[j] = 1.0 - (temp / bins[j])\n                        break\n                if priorities[i] == 0:\n                    for j in range(i+1, len(bins)):\n                        if item <= bins[j] + max(bins):\n                            priorities[j] = 1.0 - (temp / (bins[j] + max(bins)))\n                            break\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v3(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                temp = item - remaining_capacity\n                for j in range(i+1, len(bins)):\n                    if item <= bins[j]:\n                        priorities[j] = 1.0 - (temp / bins[j])\n                        break\n                if priorities[i] == 0:\n                    for j in range(i+1, len(bins)):\n                        if item <= bins[j] + max(bins):\n                            priorities[j] = 1.0 - (temp / (bins[j] + max(bins)))\n                            break\n                if priorities[i] == 0:\n                    priority_sum = sum(priorities)\n                    if priority_sum == 0:\n                        for k in range(len(bins)):\n                            priorities[k] = 1.0 / len(bins)\n                    else:\n                        for k in range(len(bins)):\n                            priorities[k] = priorities[k] / priority_sum\n                            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:51:19", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:51:22", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority_function(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.sin(5*ratio) - np.exp(ratio) / np.log(ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.sqrt(ratio) * np.log10(ratio) - np.sinh(ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) - np.tanh(ratio) + np.cbrt(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.cosh(ratio) + np.exp(ratio) / np.sqrt(ratio)\n        else:\n            priority = np.tan(ratio) / np.arctan(ratio) - np.arccos(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:51:26", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n            if priority < 0:\n                priority = np.abs(priority)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n            if ratio % 0.1 == 0:\n                priority = np.sqrt(priority)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n            if priority > 10:\n                priority = priority / 2\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n            if priority < -5:\n                priority = -5\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n            if priority == np.inf:\n                priority = 0\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n        \n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:51:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(7*ratio) + np.cos(4*ratio) - np.tan(2*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(1.5*ratio) * np.log(0.5*ratio) + np.sqrt(2*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(0.8*ratio) * np.sinh(0.8*ratio) - np.tanh(0.8*ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(0.9*ratio) * np.cos(0.9*ratio) * np.tan(0.9*ratio)\n        else:\n            priority = np.arcsin(0.9*ratio) + np.arccos(0.9*ratio) + np.arctan(0.9*ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:51:34", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Enhanced version of `priority_v1` with additional logic.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n                if available_bins:\n                    for idx in available_bins:\n                        priorities[idx] = 1.0 - (item - sum(bins[:idx])) / bins[idx]\n                    for j in range(i, len(bins)):\n                        if priorities[j] == 0:\n                            priorities[j] = 1.0 - (item - sum(bins[:j])) / (bins[j] + max(bins))\n                            break\n                else:\n                    for j in range(i, len(bins)):\n                        if item <= bins[j] + max(bins):\n                            priorities[j] = 1.0 - (item - sum(bins[:j])) / (bins[j] + max(bins))\n                            break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    prev_priorities_sum = sum(priorities[:i])\n                    remaining_capacity_items = [(index, item_value) for index, item_value in enumerate(bins) if index > i]\n                    remaining_capacity_items.sort(key=lambda x: x[1])\n                    for index, item_value in remaining_capacity_items:\n                        if item <= remaining_capacity + item_value:\n                            priorities[i] = 0.8 + prev_priorities_sum\n                            break\n                        prev_priorities_sum += 0.05\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def custom_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    prev_priorities_sum = sum(priorities[:i])\n                    remaining_capacity_items = [(index, item_value) for index, item_value in enumerate(bins) if index > i]\n                    remaining_capacity_items.sort(key=lambda x: x[1])\n                    for index, item_value in remaining_capacity_items:\n                        if item <= remaining_capacity + item_value:\n                            priorities[i] = 0.8 + prev_priorities_sum\n                            break\n                        prev_priorities_sum += 0.05\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:51:38", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Enhanced version of `priority_v1` with additional logic.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n                if available_bins:\n                    for idx in available_bins:\n                        priorities[idx] = 1.0 - (item - sum(bins[:idx])) / bins[idx]\n                    for j in range(i, len(bins)):\n                        if priorities[j] == 0:\n                            priorities[j] = 1.0 - (item - sum(bins[:j])) / (bins[j] + max(bins))\n                            break\n                else:\n                    for j in range(i, len(bins)):\n                        if item <= bins[j] + max(bins):\n                            priorities[j] = 1.0 - (item - sum(bins[:j])) / (bins[j] + max(bins))\n                            break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    prev_priorities_sum = sum(priorities[:i])\n                    remaining_capacity_items = [(index, item_value) for index, item_value in enumerate(bins) if index > i]\n                    remaining_capacity_items.sort(key=lambda x: x[1])\n                    for index, item_value in remaining_capacity_items:\n                        if item <= remaining_capacity + item_value:\n                            priorities[i] = 0.8 + prev_priorities_sum\n                            break\n                        prev_priorities_sum += 0.05\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                temp_priorities = []\n                for j in range(i, len(bins)):\n                    if bins[j] > item:\n                        temp_priorities.append(1.0 - (item - sum(bins[:j])) / bins[j])\n                    else:\n                        remaining_items_sum = sum([item for index, item in enumerate(bins) if index > j])\n                        if remaining_items_sum >= item:\n                            temp_priorities.append(0.8)\n                        else:\n                            prev_priorities_sum = sum(priorities[:j])\n                            remaining_capacity_items = [(index, item_value) for index, item_value in enumerate(bins) if index > j]\n                            remaining_capacity_items.sort(key=lambda x: x[1])\n                            for index, item_value in remaining_capacity_items:\n                                if item <= remaining_capacity + item_value:\n                                    temp_priorities.append(0.6 + prev_priorities_sum)\n                                    break\n                                prev_priorities_sum += 0.03\n                if temp_priorities:\n                    max_priority = max(temp_priorities)\n                    max_idxs = [idx for idx, val in enumerate(temp_priorities) if val == max_priority]\n                    for idx in max_idxs:\n                        priorities[idx + i] = max_priority\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:51:42", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Enhanced version of `priority_v1` with additional logic.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n                if available_bins:\n                    for idx in available_bins:\n                        priorities[idx] = 1.0 - (item - sum(bins[:idx])) / bins[idx]\n                    for j in range(i, len(bins)):\n                        if priorities[j] == 0:\n                            priorities[j] = 1.0 - (item - sum(bins[:j])) / (bins[j] + max(bins))\n                            break\n                else:\n                    for j in range(i, len(bins)):\n                        if item <= bins[j] + max(bins):\n                            priorities[j] = 1.0 - (item - sum(bins[:j])) / (bins[j] + max(bins))\n                            break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    prev_priorities_sum = sum(priorities[:i])\n                    remaining_capacity_items = [(index, item_value) for index, item_value in enumerate(bins) if index > i]\n                    remaining_capacity_items.sort(key=lambda x: x[1])\n                    for index, item_value in remaining_capacity_items:\n                        if item <= remaining_capacity + item_value:\n                            priorities[i] = 0.8 + prev_priorities_sum\n                            break\n                        prev_priorities_sum += 0.05\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    prev_priorities_sum = sum(priorities[:i])\n                    remaining_capacity_items = [(index, item_value) for index, item_value in enumerate(bins) if index > i]\n                    remaining_capacity_items.sort(key=lambda x: x[1])\n                    for index, item_value in remaining_capacity_items:\n                        if item <= remaining_capacity + item_value:\n                            priorities[i] = 0.8 + prev_priorities_sum\n                            break\n                        prev_priorities_sum += 0.05\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:51:47", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Enhanced version of `priority_v1` with additional logic.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n                if available_bins:\n                    for idx in available_bins:\n                        priorities[idx] = 1.0 - (item - sum(bins[:idx])) / bins[idx]\n                    for j in range(i, len(bins)):\n                        if priorities[j] == 0:\n                            priorities[j] = 1.0 - (item - sum(bins[:j])) / (bins[j] + max(bins))\n                            break\n                else:\n                    for j in range(i, len(bins)):\n                        if item <= bins[j] + max(bins):\n                            priorities[j] = 1.0 - (item - sum(bins[:j])) / (bins[j] + max(bins))\n                            break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    prev_priorities_sum = sum(priorities[:i])\n                    remaining_capacity_items = [(index, item_value) for index, item_value in enumerate(bins) if index > i]\n                    remaining_capacity_items.sort(key=lambda x: x[1])\n                    for index, item_value in remaining_capacity_items:\n                        if item <= remaining_capacity + item_value:\n                            priorities[i] = 0.8 + prev_priorities_sum\n                            break\n                        prev_priorities_sum += 0.05\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n                if available_bins:\n                    for idx in available_bins:\n                        priorities[idx] = 1.0 - (item - sum(bins[:idx])) / bins[idx]\n                    for j in range(i, len(bins)):\n                        if priorities[j] == 0:\n                            priorities[j] = 1.0 - (item - sum(bins[:j])) / (bins[j] + max(bins))\n                            break\n                else:\n                    temp_sum = 0\n                    for j in range(i, len(bins)):\n                        temp_sum += bins[j]\n                        if item <= temp_sum + max(bins):\n                            priorities[j] = 1.0 - (item - sum(bins[:j])) / (bin_capacity + max(bins))\n                            break\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:51:57", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            elif bin_capacity % item == 1:\n                priority = 1.5 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    elif bin_capacity % i == 1:\n                        priority = 0.5 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:52:00", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        for j in range(2, int(bin_capacity/3)):\n                            if bin_capacity % j == 0:\n                                priority = 0.5 / (bin_capacity - item + j)\n                                break\n                            else:\n                                priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:52:02", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                divisors = [i for i in range(2, int(bin_capacity/2)) if bin_capacity % i == 0]\n                if divisors:\n                    priority = 1 / (bin_capacity - item + divisors[0])\n                else:\n                    priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:52:05", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                highest_divisor = 1\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        highest_divisor = i\n                if highest_divisor != 1:\n                    priority = 1 / (bin_capacity - item + highest_divisor)\n                else:\n                    priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:52:07", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Further improved version of `priority_v1`.\n    Now considering additional factors for priority calculation.\n    \"\"\"\n    \n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n    \n    # Add an additional factor based on bin capacity ratio\n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        priorities[i] += 0.5 * (max_bin_capacity - bins[i])  # Adjust priority based on capacity ratio\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Further improved version of `priority_v1`.\n    Now considering multiple factors for priority calculation.\n    \"\"\"\n\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n    avg_capacity = np.mean(bins)\n    total_capacity = np.sum(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = abs(item - bins[i]) / (avg_capacity - min_capacity)\n        elif bins[i] == min_capacity:\n            priorities[i] = abs(item - bins[i]) / (avg_capacity - max_capacity)\n        else:\n            priorities[i] = (item - bins[i]) / total_capacity\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v3(item: float, bins: np.ndarray) -> np.ndarray:\n    \n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n    avg_capacity = np.mean(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = abs(item - bins[i]) / (avg_capacity - min_capacity)\n        elif bins[i] == min_capacity:\n            priorities[i] = abs(item - bins[i]) / (avg_capacity - max_capacity)\n        else:\n            priorities[i] = (item - bins[i]) / sum(bins)\n    \n    # Apply additional condition based on item size\n    if item > avg_capacity:\n        priorities = priorities * 1.5  # Increase priority by 50% for larger items\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:52:11", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Further improved version of `priority_v1`.\n    Now considering additional factors for priority calculation.\n    \"\"\"\n    \n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n    \n    # Add an additional factor based on bin capacity ratio\n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        priorities[i] += 0.5 * (max_bin_capacity - bins[i])  # Adjust priority based on capacity ratio\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Further improved version of `priority_v1`.\n    Now considering multiple factors for priority calculation.\n    \"\"\"\n\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n    avg_capacity = np.mean(bins)\n    total_capacity = np.sum(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = abs(item - bins[i]) / (avg_capacity - min_capacity)\n        elif bins[i] == min_capacity:\n            priorities[i] = abs(item - bins[i]) / (avg_capacity - max_capacity)\n        else:\n            priorities[i] = (item - bins[i]) / total_capacity\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority_function(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n    avg_capacity = np.mean(bins)\n    total_capacity = np.sum(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            if item > bins[i]:\n                priorities[i] = abs(item - bins[i]) / (avg_capacity - min_capacity)\n            else:\n                priorities[i] = max_capacity - item\n        elif bins[i] == min_capacity:\n            if item > bins[i]:\n                priorities[i] = abs(item - bins[i]) / (avg_capacity - max_capacity)\n            else:\n                priorities[i] = min_capacity - item\n        else:\n            if item > bins[i]:\n                priorities[i] = (item - bins[i]) / total_capacity\n            else:\n                priorities[i] = bins[i] - item\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:52:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Further improved version of `priority_v1`.\n    Now considering additional factors for priority calculation.\n    \"\"\"\n    \n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n    \n    # Add an additional factor based on bin capacity ratio\n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        priorities[i] += 0.5 * (max_bin_capacity - bins[i])  # Adjust priority based on capacity ratio\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Further improved version of `priority_v1`.\n    Now considering multiple factors for priority calculation.\n    \"\"\"\n\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n    avg_capacity = np.mean(bins)\n    total_capacity = np.sum(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = abs(item - bins[i]) / (avg_capacity - min_capacity)\n        elif bins[i] == min_capacity:\n            priorities[i] = abs(item - bins[i]) / (avg_capacity - max_capacity)\n        else:\n            priorities[i] = (item - bins[i]) / total_capacity\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n    avg_capacity = np.mean(bins)\n    total_capacity = np.sum(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = abs(item - bins[i]) / (avg_capacity - min_capacity)\n        elif bins[i] == min_capacity:\n            priorities[i] = abs(item - bins[i]) / (avg_capacity - max_capacity)\n        else:\n            priorities[i] = (item - bins[i]) / total_capacity\n\n    # Additional factor based on the sum of bin capacities\n    sum_priorities = np.sum(priorities)\n    priorities = np.where(priorities > 0, priorities + sum_priorities / len(bins), 0)\n\n    # Adjust priorities based on index position\n    for i in range(len(bins)):\n        priorities[i] += i * 0.1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:52:17", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Further improved version of `priority_v1`.\n    Now considering additional factors for priority calculation.\n    \"\"\"\n    \n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n    \n    # Add an additional factor based on bin capacity ratio\n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        priorities[i] += 0.5 * (max_bin_capacity - bins[i])  # Adjust priority based on capacity ratio\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Further improved version of `priority_v1`.\n    Now considering multiple factors for priority calculation.\n    \"\"\"\n\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n    avg_capacity = np.mean(bins)\n    total_capacity = np.sum(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = abs(item - bins[i]) / (avg_capacity - min_capacity)\n        elif bins[i] == min_capacity:\n            priorities[i] = abs(item - bins[i]) / (avg_capacity - max_capacity)\n        else:\n            priorities[i] = (item - bins[i]) / total_capacity\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray, thresholds: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(data)\n    \n    for i in range(len(data)):\n        if data[i] < thresholds[0]:\n            result[i] = data[i] * 2\n        elif thresholds[0] <= data[i] < thresholds[1]:\n            result[i] = data[i] ** 2\n        elif thresholds[1] <= data[i] < thresholds[2]:\n            result[i] = data[i] + thresholds[1]\n        else:\n            temp = data[i]\n            for j in range(2, len(thresholds)):\n                temp = temp * thresholds[j]\n            result[i] = temp\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:52:25", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif 0.8 <= ratios[i] < 0.9:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif 0.6 <= ratios[i] < 0.8:\n            if item > 4 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 2 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif 0.4 <= ratios[i] < 0.6:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif 0.7 <= ratios[i] < 0.9:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 3:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif 0.5 <= ratios[i] < 0.7:\n            if item > 6 and bins[i] > 4:\n                priorities[i] = 3\n            elif item > 4 and bins[i] > 3:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif 0.3 <= ratios[i] < 0.5:\n            if item > 4 and bins[i] > 2:\n                priorities[i] = 2\n            elif item > 2 and bins[i] > 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:52:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif 0.8 <= ratios[i] < 0.9:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif 0.6 <= ratios[i] < 0.8:\n            if item > 4 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 2 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif 0.4 <= ratios[i] < 0.6:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "import math\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif 0.8 <= ratios[i] < 0.9:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif 0.6 <= ratios[i] < 0.8:\n            if item > 4 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 2 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif 0.4 <= ratios[i] < 0.6:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if item + bins[i] > 20:\n                priorities[i] = math.ceil(item / 10)\n            else:\n                priorities[i] = 0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:52:34", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif 0.8 <= ratios[i] < 0.9:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif 0.6 <= ratios[i] < 0.8:\n            if item > 4 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 2 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif 0.4 <= ratios[i] < 0.6:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif 0.8 <= ratios[i] < 0.9:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif 0.6 <= ratios[i] < 0.8:\n            if item > 4 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 2 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif 0.4 <= ratios[i] < 0.6:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:52:38", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif 0.8 <= ratios[i] < 0.9:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif 0.6 <= ratios[i] < 0.8:\n            if item > 4 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 2 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif 0.4 <= ratios[i] < 0.6:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif 0.8 <= ratios[i] < 0.9:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif 0.6 <= ratios[i] < 0.8:\n            if item > 4 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 2 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif 0.4 <= ratios[i] < 0.6:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:52:42", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        highest_priority = -1\n                        highest_priority_idx = -1\n                        for k in range(i, j):\n                            if priorities[k] == -1:\n                                continue\n                            if priorities[k] > highest_priority:\n                                highest_priority = priorities[k]\n                                highest_priority_idx = k\n                        if highest_priority > 1:\n                            priorities[highest_priority_idx] = 1\n                            priorities[j] = (j - highest_priority_idx) + 1\n                        else:\n                            priorities[i] = -1\n                            break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    bin_ranges = []\n    current_range = [0, 0]\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            if current_range[0] == 0:\n                current_range[0] = i\n            current_range[1] = i\n            if i == len(bins) - 1 or bins[i] + bins[i+1] < item:\n                bin_ranges.append(current_range)\n                current_range = [0, 0]\n    \n    for start, end in bin_ranges:\n        remaining_capacity = sum(bins[start:end+1])\n        for j in range(end, len(bins)):\n            remaining_capacity += bins[j]\n            if bins[j] >= item and remaining_capacity >= item:\n                priorities[j] = (j - start) + 1\n                break\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:52:46", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        highest_priority = -1\n                        highest_priority_idx = -1\n                        for k in range(i, j):\n                            if priorities[k] == -1:\n                                continue\n                            if priorities[k] > highest_priority:\n                                highest_priority = priorities[k]\n                                highest_priority_idx = k\n                        if highest_priority > 1:\n                            priorities[highest_priority_idx] = 1\n                            priorities[j] = (j - highest_priority_idx) + 1\n                        else:\n                            priorities[i] = -1\n                            break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n    \n    total_capacity = sum(bins)\n    \n    if item > total_capacity:\n        msg = \"Item size exceeds total bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        remaining_capacity = total_capacity - sum(bins[:i])\n        if bins[i] >= item and remaining_capacity >= item:\n            priorities[i] = 1\n            break\n        elif i == len(bins) - 1:\n            priorities[i] = -1\n        else:\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:52:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        highest_priority = -1\n                        highest_priority_idx = -1\n                        for k in range(i, j):\n                            if priorities[k] == -1:\n                                continue\n                            if priorities[k] > highest_priority:\n                                highest_priority = priorities[k]\n                                highest_priority_idx = k\n                        if highest_priority > 1:\n                            priorities[highest_priority_idx] = 1\n                            priorities[j] = (j - highest_priority_idx) + 1\n                        else:\n                            priorities[i] = -1\n                            break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    highest_priority = -1\n                    highest_priority_idx = -1\n                    for k in range(i, j):\n                        if priorities[k] == -1:\n                            continue\n                        if priorities[k] > highest_priority:\n                            highest_priority = priorities[k]\n                            highest_priority_idx = k\n                    if highest_priority > 1:\n                        priorities[highest_priority_idx] = 1\n                        priorities[j] = (j - highest_priority_idx) + 1\n                    else:\n                        priorities[i] = -1\n                        break\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:52:53", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        highest_priority = -1\n                        highest_priority_idx = -1\n                        for k in range(i, j):\n                            if priorities[k] == -1:\n                                continue\n                            if priorities[k] > highest_priority:\n                                highest_priority = priorities[k]\n                                highest_priority_idx = k\n                        if highest_priority > 1:\n                            priorities[highest_priority_idx] = 1\n                            priorities[j] = (j - highest_priority_idx) + 1\n                        else:\n                            priorities[i] = -1\n                            break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    highest_priority = -1\n                    highest_priority_idx = -1\n                    for k in range(i, j):\n                        if priorities[k] == -1:\n                            continue\n                        if priorities[k] > highest_priority:\n                            highest_priority = priorities[k]\n                            highest_priority_idx = k\n                    if highest_priority > 1:\n                        priorities[highest_priority_idx] = 1\n                        priorities[j] = (j - highest_priority_idx) + 1\n                    else:\n                        priorities[i] = -1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:53:02", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            elif bin_capacity % item == 1:\n                priority = 1.5 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2) + 1):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:53:04", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:53:07", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                found_divisor = False\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        found_divisor = True\n                        break\n                if not found_divisor:\n                    priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:53:10", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        \n        if priority < 0:\n            priority = 0\n        elif priority > 10:\n            priority = 10\n        \n        if bin_capacity < item:\n            priority *= 0.5\n        elif bin_capacity == item:\n            priority *= 2\n        \n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:53:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    bin_ranges = []\n    current_range = [0, 0]\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            if current_range[0] == 0:\n                current_range[0] = i\n            current_range[1] = i\n            if i == len(bins) - 1 or bins[i] + bins[i+1] < item:\n                bin_ranges.append(current_range)\n                current_range = [0, 0]\n    \n    for start, end in bin_ranges:\n        remaining_capacity = sum(bins[start:end+1])\n        for j in range(end, len(bins)):\n            remaining_capacity += bins[j]\n            if bins[j] >= item and remaining_capacity >= item:\n                priorities[j] = (j - start) + 1\n                break\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    bin_ranges = []\n    current_range = [0, 0]\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            if current_range[0] == 0:\n                current_range[0] = i\n            current_range[1] = i\n            if i == len(bins) - 1 or bins[i] + bins[i+1] < item:\n                bin_ranges.append(current_range)\n                current_range = [0, 0]\n    \n    for start, end in bin_ranges:\n        remaining_capacity = sum(bins[start:end+1])\n        for j in range(end, len(bins)):\n            remaining_capacity += bins[j]\n            if bins[j] >= item and remaining_capacity >= item:\n                priorities[j] = (j - start) + 1\n                break\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:53:19", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    bin_ranges = []\n    current_range = [0, 0]\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            if current_range[0] == 0:\n                current_range[0] = i\n            current_range[1] = i\n            if i == len(bins) - 1 or bins[i] + bins[i+1] < item:\n                bin_ranges.append(current_range)\n                current_range = [0, 0]\n    \n    for start, end in bin_ranges:\n        remaining_capacity = sum(bins[start:end+1])\n        for j in range(end, len(bins)):\n            remaining_capacity += bins[j]\n            if bins[j] >= item and remaining_capacity >= item:\n                priorities[j] = (j - start) + 1\n                break\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    bin_ranges = []\n    current_range = [0, 0]\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            if current_range[0] == 0:\n                current_range[0] = i\n            current_range[1] = i\n            if i == len(bins) - 1 or bins[i] + bins[i+1] < item:\n                bin_ranges.append(current_range)\n                current_range = [0, 0]\n\n    for start, end in bin_ranges:\n        remaining_capacity = sum(bins[start:end+1])\n        \n        for j in range(end, len(bins)):\n            if j == (len(bins) - 1) and remaining_capacity < item:\n                priorities[start:end+1] = [-1] * (end-start+1)\n                break\n            remaining_capacity += bins[j]\n            if bins[j] >= item and remaining_capacity >= item:\n                priorities[j] = (j - start) + 1\n                break\n                \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:53:22", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    bin_ranges = []\n    current_range = [0, 0]\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            if current_range[0] == 0:\n                current_range[0] = i\n            current_range[1] = i\n            if i == len(bins) - 1 or bins[i] + bins[i+1] < item:\n                bin_ranges.append(current_range)\n                current_range = [0, 0]\n    \n    for start, end in bin_ranges:\n        remaining_capacity = sum(bins[start:end+1])\n        for j in range(end, len(bins)):\n            remaining_capacity += bins[j]\n            if bins[j] >= item and remaining_capacity >= item:\n                priorities[j] = (j - start) + 1\n                break\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    bin_ranges = []\n    current_range = [0, 0]\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        elif current_range[0] == 0:\n            current_range[0] = i\n        else:\n            current_range[1] = i\n            if i == len(bins) - 1 or bins[i] + bins[i+1] < item:\n                bin_ranges.append(current_range)\n                current_range = [0, 0]\n    \n    for start, end in bin_ranges:\n        remaining_capacity = sum(bins[start:end+1])\n        for j in range(end, len(bins)):\n            remaining_capacity += bins[j]\n            if bins[j] >= item and remaining_capacity >= item:\n                priorities[j] = (j - start) + 1\n                break\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:53:26", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    bin_ranges = []\n    current_range = [0, 0]\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            if current_range[0] == 0:\n                current_range[0] = i\n            current_range[1] = i\n            if i == len(bins) - 1 or bins[i] + bins[i+1] < item:\n                bin_ranges.append(current_range)\n                current_range = [0, 0]\n    \n    for start, end in bin_ranges:\n        remaining_capacity = sum(bins[start:end+1])\n        for j in range(end, len(bins)):\n            remaining_capacity += bins[j]\n            if bins[j] >= item and remaining_capacity >= item:\n                priorities[j] = (j - start) + 1\n                break\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    bin_ranges = []\n    current_range = [0, 0]\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            if current_range[0] == 0:\n                current_range[0] = i\n            current_range[1] = i\n            if i == len(bins) - 1 or bins[i] + bins[i+1] < item:\n                bin_ranges.append(current_range)\n                current_range = [0, 0]\n    \n    for start, end in bin_ranges:\n        remaining_capacity = sum(bins[start:end+1])\n        for j in range(end, len(bins)):\n            remaining_capacity += bins[j]\n            if bins[j] >= item and remaining_capacity >= item:\n                priorities[j] = (j - start) + 1\n                break\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:53:29", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_function(input_data: np.ndarray) -> np.ndarray:\n    output_data = np.zeros_like(input_data)\n    \n    for i in range(len(input_data)):\n        if input_data[i] % 2 == 0:\n            output_data[i] = input_data[i] * 2\n        else:\n            if input_data[i] < 10:\n                output_data[i] = input_data[i] + 5\n            else:\n                output_data[i] = input_data[i] - 5\n    \n    return output_data\n```", "strategy": []}
{"timestamp": "2025-04-27 05:53:32", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n    \n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            utilization = item / bins[i]\n            \n            if left_capacity == 0:\n                priorities[i] = 0\n            elif 0.2 <= utilization < 0.4:\n                priorities[i] = 2 / (1 + utilization)\n            elif 0.4 <= utilization < 0.6:\n                priorities[i] = 3 * bins[i]\n            elif 0.6 <= utilization < 0.8:\n                priorities[i] = 4 * np.sqrt(bins[i]) * utilization\n            elif 0.8 <= utilization <= 1.0:\n                priorities[i] = 5 * np.log(utilization + 1)\n                \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:53:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "import math\n\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.1:\n                    priorities[i] = math.sqrt(1 / utilization)\n                elif 0.1 <= utilization < 0.3:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.3 <= utilization < 0.5:\n                    priorities[i] = 3 * utilization\n                elif 0.5 <= utilization < 0.7:\n                    priorities[i] = 4 * (1 - utilization)\n                elif 0.7 <= utilization <= 1.0:\n                    priorities[i] = 5 * utilization ** 2\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:53:38", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:53:45", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    for k in range(len(priorities)):\n        if priorities[k] == 0:\n            priorities[k] = -1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:53:48", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        if priorities[i] == 0:\n                            priorities[i] = -1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:53:51", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    # Initializing variables\n    remaining_capacity = np.zeros(len(bins))\n    for i in range(len(bins)):\n        remaining_capacity[i] = sum(bins[i:])\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    if remaining_capacity[j] >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:53:55", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    remaining_items = item\n\n    for i in range(len(bins)):\n        if bins[i] >= remaining_items:\n            priorities[i] = remaining_items / bins[i]\n            remaining_items = 0\n            break\n        else:\n            priorities[i] = 1\n            remaining_items -= bins[i]\n    \n    if remaining_items > 0:\n        max_capacity_bin_index = np.argmax(bins)\n        if remaining_items <= bins[max_capacity_bin_index]:\n            priorities[max_capacity_bin_index] += remaining_items / bins[max_capacity_bin_index]\n            remaining_items = 0\n        else:\n            priorities[max_capacity_bin_index] = 1\n            remaining_items -= bins[max_capacity_bin_index]\n    \n    for j in range(max_capacity_bin_index+1, len(bins)):\n        if bins[j] >= remaining_items:\n            priorities[j] = remaining_items / bins[j]\n            remaining_items = 0\n            break\n        else:\n            priorities[j] = 1\n            remaining_items -= bins[j]\n    \n    if remaining_items > 0:\n        for k in range(len(bins)):\n            if bins[k] >= remaining_items:\n                priorities[k] += remaining_items / bins[k]\n                remaining_items = 0\n                break\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:54:01", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.4\n                else:\n                    priority += 0.6\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 1.8\n            elif priority < 0.4:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.7\n                else:\n                    priorities[j] = 0.4\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.4\n                else:\n                    priority += 0.6\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 1.8\n            elif priority < 0.4:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.7\n                else:\n                    priorities[j] = 0.4\n            \n            if i % 2 == 0:\n                priorities[i] *= 1.1\n            else:\n                priorities[i] *= 0.9\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:54:04", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.4\n                else:\n                    priority += 0.6\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 1.8\n            elif priority < 0.4:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.7\n                else:\n                    priorities[j] = 0.4\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.1 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.3 * item:\n                    priority += 0.4\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 2.0\n            elif priority < 0.4:\n                priorities[i] *= 0.5\n            else:\n                priorities[i] *= 1.3\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.8\n                else:\n                    priorities[j] = 0.6\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:54:08", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.4\n                else:\n                    priority += 0.6\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 1.8\n            elif priority < 0.4:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.7\n                else:\n                    priorities[j] = 0.4\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.3 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.8\n                remaining_capacity += bins[i]\n                \n                if priority > 0.8:\n                    priorities[i] *= 2.0\n                elif priority < 0.5:\n                    priorities[i] *= 0.8\n                else:\n                    priorities[i] *= 1.5\n                \n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.6\n                    else:\n                        priorities[j] = 0.3\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:54:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.4\n                else:\n                    priority += 0.6\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 1.8\n            elif priority < 0.4:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.7\n                else:\n                    priorities[j] = 0.4\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.4\n                else:\n                    priority += 0.6\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 1.8\n            elif priority < 0.4:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.7\n                else:\n                    remaining_capacity = bins[j]\n                    priority = 0.0\n                    while remaining_capacity < item:\n                        if remaining_capacity < 0.2 * item:\n                            priority += 0.1\n                        elif remaining_capacity < 0.5 * item:\n                            priority += 0.3\n                        else:\n                            priority += 0.5\n                        remaining_capacity += bins[j]\n                    priorities[j] = priority\n                    \n                    if priority > 0.5:\n                        priorities[j] *= 1.6\n                    elif priority < 0.3:\n                        priorities[j] *= 0.8\n                    else:\n                        priorities[j] *= 1.1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:54:17", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_function(data: np.ndarray, target: float) -> np.ndarray:\n    result = np.zeros_like(data)\n    \n    for i in range(len(data)):\n        if data[i] == target:\n            result[i] = 0\n        elif data[i] < target:\n            if data[i] % 2 == 0:\n                result[i] = data[i] * 2\n            else:\n                result[i] = data[i] + 5\n        else:\n            temp = data[i]\n            while temp > target:\n                temp /= 2\n            result[i] = temp\n            \n    return result\n```", "strategy": []}
{"timestamp": "2025-04-27 05:54:20", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(data)\n    \n    for i in range(len(data)):\n        if data[i] % 2 == 0:\n            for j in range(1, data[i] + 1):\n                if j % 2 == 0:\n                    result[i] += j ** 2\n        else:\n            for j in range(1, data[i] + 1):\n                if j % 2 != 0:\n                    result[i] += j ** 3\n    \n    return result\n```", "strategy": []}
{"timestamp": "2025-04-27 05:54:22", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_function(input_data: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(input_data)\n    \n    for i in range(len(input_data)):\n        if input_data[i] % 2 == 0:\n            result[i] = input_data[i] * 2\n        else:\n            temp = input_data[i]\n            for j in range(temp):\n                if temp % j == 0:\n                    result[i] += j\n                    \n    return result\n```", "strategy": []}
{"timestamp": "2025-04-27 05:54:25", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(matrix: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(matrix)\n    for i in range(matrix.shape[0]):\n        for j in range(matrix.shape[1]):\n            if i % 2 == 0:\n                if matrix[i, j] % 2 == 0:\n                    result[i, j] = matrix[i, j] * 2\n                else:\n                    result[i, j] = matrix[i, j] * 3\n            else:\n                if matrix[i, j] % 2 == 0:\n                    result[i, j] = matrix[i, j] // 2\n                else:\n                    result[i, j] = matrix[i, j] // 3\n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:54:29", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(input_data: np.ndarray) -> np.ndarray:\n    output_data = np.zeros_like(input_data)\n\n    for i in range(len(input_data)):\n        if i % 2 == 0:\n            output_data[i] = input_data[i] * 2\n        else:\n            if input_data[i] % 3 == 0:\n                output_data[i] = input_data[i] + 10\n            else:\n                output_data[i] = input_data[i] - 5\n\n    return output_data", "strategy": []}
{"timestamp": "2025-04-27 05:54:32", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_function(param1, param2, param3):\n    result = 0\n    \n    if param1 > param2:\n        for i in range(param1):\n            if i % 2 == 0:\n                result += i * param2\n            else:\n                result -= i * param3\n    else:\n        for i in range(param2):\n            if i % 3 == 0:\n                result += i * param3\n            else:\n                result -= i * param1\n    \n    return result\n```", "strategy": []}
{"timestamp": "2025-04-27 05:54:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_complex(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.1:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.1 <= utilization < 0.3:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.3 <= utilization < 0.5:\n                    priorities[i] = 3\n                elif 0.5 <= utilization < 0.7:\n                    priorities[i] = 4 * utilization\n                elif 0.7 <= utilization < 0.9:\n                    for j in range(1, 6):\n                        priorities[i] += j * (1 - utilization)\n                elif 0.9 <= utilization:\n                    priorities[i] = 10 * np.log(utilization)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:54:40", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.1:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.1 <= utilization < 0.2:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.2 <= utilization < 0.3:\n                    priorities[i] = 3\n                elif 0.3 <= utilization < 0.4:\n                    priorities[i] = 4 * np.log(utilization + 1)\n                elif 0.4 <= utilization < 0.5:\n                    priorities[i] = 5 * np.exp(utilization)\n                elif 0.5 <= utilization < 0.6:\n                    priorities[i] = 6 * utilization ** 2\n                elif 0.6 <= utilization < 0.7:\n                    priorities[i] = 7 * np.sqrt(utilization)\n                elif 0.7 <= utilization < 0.8:\n                    priorities[i] = 8 / utilization\n                elif 0.8 <= utilization < 0.9:\n                    priorities[i] = 9 * utilization\n                elif 0.9 <= utilization <= 1.0:\n                    priorities[i] = 10 * np.sin(utilization)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:54:47", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                if bin_capacity >= item * 2:\n                    priority = 3 / (bin_capacity - item + 1)\n                else:\n                    for i in range(2, int(bin_capacity/2)):\n                        if bin_capacity % i == 0:\n                            priority = 1 / (bin_capacity - item + i)\n                            break\n                        else:\n                            priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:54:49", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                divisor_found = False\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        divisor_found = True\n                        break\n                if not divisor_found:\n                    priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:54:53", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            if bin_capacity % item == 0:\n                priority = -2 / (bin_capacity + item)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = -1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = -1 / (bin_capacity - item + 1)\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:54:56", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        if bin_capacity % 3 == 0:\n                            priority = 1.5 / (bin_capacity - item + i)\n                        elif bin_capacity % 5 == 0:\n                            priority = 1.75 / (bin_capacity - item + i)\n                        else:\n                            priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:54:59", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    sorted_bins = np.sort(bins)\n    n = len(bins)\n    \n    for i in range(n):\n        if i == 0:\n            priorities[i] = abs(item - sorted_bins[i])\n        elif i == n-1:\n            priorities[i] = abs(item - sorted_bins[i])\n        else:\n            priorities[i] = abs(item - sorted_bins[i]) / (sorted_bins[n-1] - sorted_bins[0])\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = bins[i] - item\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n            priorities[i] = abs(item - remaining_capacity) * 2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = bins[i] - item\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n            priorities[i] = abs(item - remaining_capacity) * 2\n        \n        if i > 0:\n            priorities[i] += priorities[i-1]\n        \n        if i < len(bins) - 1:\n            priorities[i] += priorities[i+1]\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:55:01", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    sorted_bins = np.sort(bins)\n    n = len(bins)\n    \n    for i in range(n):\n        if i == 0:\n            priorities[i] = abs(item - sorted_bins[i])\n        elif i == n-1:\n            priorities[i] = abs(item - sorted_bins[i])\n        else:\n            priorities[i] = abs(item - sorted_bins[i]) / (sorted_bins[n-1] - sorted_bins[0])\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = bins[i] - item\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n            priorities[i] = abs(item - remaining_capacity) * 2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    n = len(bins)\n    priorities = np.zeros_like(bins)\n    \n    for i in range(n):\n        remaining_capacity = np.sum(bins[i:])\n        if remaining_capacity >= item:\n            priorities[i] = remaining_capacity - item\n        else:\n            for j in range(i+1, n):\n                remaining_capacity += bins[j]\n            priorities[i] = abs(item - remaining_capacity) * (n-i)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:55:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    sorted_bins = np.sort(bins)\n    n = len(bins)\n    \n    for i in range(n):\n        if i == 0:\n            priorities[i] = abs(item - sorted_bins[i])\n        elif i == n-1:\n            priorities[i] = abs(item - sorted_bins[i])\n        else:\n            priorities[i] = abs(item - sorted_bins[i]) / (sorted_bins[n-1] - sorted_bins[0])\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = bins[i] - item\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n            priorities[i] = abs(item - remaining_capacity) * 2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    n = len(bins)\n    \n    for i in range(n):\n        if bins[i] >= item:\n            priorities[i] = bins[i] - item\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, n):\n                remaining_capacity += bins[j]\n            priorities[i] = abs(item - remaining_capacity) * 2\n            \n            if i > 0:\n                priorities[i] = max(priorities[i], priorities[i-1] * 1.5)\n            if i < n - 1:\n                priorities[i] = max(priorities[i], priorities[i+1] * 1.5)\n                \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:55:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    sorted_bins = np.sort(bins)\n    n = len(bins)\n    \n    for i in range(n):\n        if i == 0:\n            priorities[i] = abs(item - sorted_bins[i])\n        elif i == n-1:\n            priorities[i] = abs(item - sorted_bins[i])\n        else:\n            priorities[i] = abs(item - sorted_bins[i]) / (sorted_bins[n-1] - sorted_bins[0])\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = bins[i] - item\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n            priorities[i] = abs(item - remaining_capacity) * 2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    n = len(bins)\n    \n    for i in range(n):\n        if bins[i] >= item:\n            priorities[i] = bins[i] - item\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, n):\n                remaining_capacity += bins[j]\n            if remaining_capacity >= item:\n                priorities[i] = remaining_capacity - item\n            else:\n                min_diff = float('inf')\n                for j in range(n):\n                    if bins[j] >= item:\n                        min_diff = min(min_diff, bins[j] - item)\n                priorities[i] = min_diff * 1.5\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:55:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif 0.8 <= ratios[i] < 0.9:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif 0.6 <= ratios[i] < 0.8:\n            if item > 4 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 2 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif 0.4 <= ratios[i] < 0.6:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif 0.8 <= ratios[i] < 0.9:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif 0.6 <= ratios[i] < 0.8:\n            if item > 4 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 2 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif 0.4 <= ratios[i] < 0.6:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif 0.8 <= ratios[i] < 0.9:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif 0.6 <= ratios[i] < 0.8:\n            if item > 4 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 2 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif 0.4 <= ratios[i] < 0.6:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    for j in range(len(bins)):\n        if priorities[j] == 6:\n            priorities[j] = priorities[j] * 1.5\n        elif priorities[j] == 5:\n            priorities[j] = priorities[j] * 1.3\n        elif priorities[j] == 4:\n            priorities[j] = priorities[j] * 1.1\n        elif priorities[j] == 3:\n            priorities[j] = priorities[j] * 1.05\n        elif priorities[j] == 2:\n            priorities[j] = priorities[j] * 0.9\n        elif priorities[j] == 1:\n            priorities[j] = priorities[j] * 0.8\n        else:\n            priorities[j] = 0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:55:18", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif 0.8 <= ratios[i] < 0.9:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif 0.6 <= ratios[i] < 0.8:\n            if item > 4 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 2 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif 0.4 <= ratios[i] < 0.6:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif 0.8 <= ratios[i] < 0.9:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif 0.6 <= ratios[i] < 0.8:\n            if item > 4 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 2 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif 0.4 <= ratios[i] < 0.6:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif 0.8 <= ratios[i] < 0.9:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif 0.6 <= ratios[i] < 0.8:\n            if item > 4 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 2 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif 0.4 <= ratios[i] < 0.6:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] < 0.4:\n            if item > 1 and bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n        else:\n            priorities[i] = 0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:55:24", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif 0.8 <= ratios[i] < 0.9:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif 0.6 <= ratios[i] < 0.8:\n            if item > 4 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 2 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif 0.4 <= ratios[i] < 0.6:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif 0.8 <= ratios[i] < 0.9:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif 0.6 <= ratios[i] < 0.8:\n            if item > 4 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 2 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif 0.4 <= ratios[i] < 0.6:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif 0.8 <= ratios[i] < 0.9:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif 0.6 <= ratios[i] < 0.8:\n            if item > 4 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 2 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif 0.4 <= ratios[i] < 0.6:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n        # Additional conditions for adjusting priorities\n        if item < 5 or bins[i] < 3:\n            priorities[i] -= 1\n\n        if ratios[i] > 0.7:\n            priorities[i] += 1\n\n        if bins[i] < 1:\n            priorities[i] = 0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:55:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif 0.8 <= ratios[i] < 0.9:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif 0.6 <= ratios[i] < 0.8:\n            if item > 4 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 2 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif 0.4 <= ratios[i] < 0.6:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif 0.8 <= ratios[i] < 0.9:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif 0.6 <= ratios[i] < 0.8:\n            if item > 4 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 2 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif 0.4 <= ratios[i] < 0.6:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if item > 20 and bins[i] > 15:\n            priorities[i] = 6\n        elif item > 15 and bins[i] > 12:\n            priorities[i] = 5\n        elif item > 10 and bins[i] > 8:\n            priorities[i] = 4\n        elif 0.7 <= ratios[i] < 0.8:\n            priorities[i] = 3\n        elif 0.5 <= ratios[i] < 0.7:\n            priorities[i] = 2\n        elif ratios[i] < 0.5:\n            priorities[i] = 1\n        else:\n            priorities[i] = 0\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:55:34", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(6*ratio) + np.cos(4*ratio) - np.tan(2*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(1.5*ratio) * np.log(2*ratio) + np.sqrt(2*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(2*ratio) * np.sinh(2*ratio) - np.tanh(ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(2*ratio) * np.cos(2*ratio) * np.tan(2*ratio)\n        else:\n            priority = np.arcsin(2*ratio) + np.arccos(2*ratio) + np.arctan(2*ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:55:38", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n        for i in range(5):\n            priority = np.sin(i*ratio) + np.cos(i*ratio) - np.tan(1.5*ratio)\n            priorities.append(priority)\n        elif ratio >= 0.2 and ratio < 0.4:\n        for i in range(5):\n            priority = np.cos(i*ratio) * np.tan(1.5*ratio) + np.sin(i*ratio)\n            priorities.append(priority)\n        elif ratio >= 0.4 and ratio < 0.6:\n        for i in range(5):\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n            priorities.append(priority)\n        elif ratio >= 0.6 and ratio < 0.8:\n        for i in range(5):\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n            priorities.append(priority)\n        elif ratio >= 0.8 and ratio < 1.0:\n        for i in range(5):\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n            priorities.append(priority)\n        else:\n        for i in range(5):\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n            priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:55:43", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.05:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio) ** 2\n        elif ratio >= 0.05 and ratio < 0.1:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) ** 2\n        elif ratio >= 0.1 and ratio < 0.15:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio) ** 2\n        elif ratio >= 0.15 and ratio < 0.2:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio) ** 2\n        elif ratio >= 0.2 and ratio < 0.25:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio) ** 2\n        elif ratio >= 0.25 and ratio < 0.3:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) ** 2\n        elif ratio >= 0.3 and ratio < 0.35:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio) ** 2\n        elif ratio >= 0.35 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio) ** 2\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio) ** 2\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:55:46", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of priority function.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(5*ratio) - np.cos(3*ratio) + np.tan(1.5*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) - np.sin(3*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio**2)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:55:53", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(input_array: np.ndarray) -> np.ndarray:\n    output_array = []\n\n    for i in range(len(input_array)):\n        if input_array[i] % 2 == 0:\n            result = input_array[i] ** 2\n            for j in range(1, input_array[i]):\n                result += j\n            output_array.append(result)\n        else:\n            result = input_array[i] * 3\n            for j in range(1, input_array[i]):\n                result -= j\n            output_array.append(result)\n\n    return np.array(output_array)", "strategy": []}
{"timestamp": "2025-04-27 05:55:57", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(7*ratio) + np.cos(2*ratio) - np.tan(1.2*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.log(4*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(2*ratio) * np.log10(ratio) + np.sqrt(2*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(1.5*ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:56:01", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:56:04", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:56:09", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.1\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.8 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 2.0\n            elif priority < 0.4:\n                priorities[i] *= 0.6\n            else:\n                priorities[i] *= 1.5\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.8\n                else:\n                    priorities[j] = 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.3 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.8\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 2.0\n            elif priority < 0.5:\n                priorities[i] *= 0.6\n            else:\n                priorities[i] *= 1.5\n            \n            if i % 2 == 0:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.8\n                    else:\n                        priorities[j] = 0.5\n            else:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.6\n                    else:\n                        priorities[j] = 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.25 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.5\n                elif remaining_capacity < 0.75 * item:\n                    priority += 0.7\n                else:\n                    priority += 0.9\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.8:\n                priorities[i] *= 2.0\n            elif priority < 0.6:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.3\n            \n            if i % 3 == 0:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.9\n                    else:\n                        priorities[j] = 0.6\n            elif i % 3 == 1:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.7\n                    else:\n                        priorities[j] = 0.4\n            else:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.8\n                    else:\n                        priorities[j] = 0.5\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:56:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.1\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.8 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 2.0\n            elif priority < 0.4:\n                priorities[i] *= 0.6\n            else:\n                priorities[i] *= 1.5\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.8\n                else:\n                    priorities[j] = 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.3 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.8\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 2.0\n            elif priority < 0.5:\n                priorities[i] *= 0.6\n            else:\n                priorities[i] *= 1.5\n            \n            if i % 2 == 0:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.8\n                    else:\n                        priorities[j] = 0.5\n            else:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.6\n                    else:\n                        priorities[j] = 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.4 * item:\n                    priority += 0.4\n                elif remaining_capacity < 0.7 * item:\n                    priority += 0.6\n                else:\n                    priority += 0.9\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n\n            if priority > 0.8:\n                priorities[i] *= 2.0\n            elif priority < 0.6:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.3\n\n            total_bins = len(bins)\n            for j in range(i+1, total_bins):\n                if i % 2 == 0:\n                    if bins[j] >= item:\n                        priorities[j] = 0.9\n                    else:\n                        priorities[j] = 0.6\n                else:\n                    if bins[j] >= item:\n                        priorities[j] = 0.7\n                    else:\n                        priorities[j] = 0.4\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:56:18", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.1\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.8 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 2.0\n            elif priority < 0.4:\n                priorities[i] *= 0.6\n            else:\n                priorities[i] *= 1.5\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.8\n                else:\n                    priorities[j] = 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.3 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.8\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 2.0\n            elif priority < 0.5:\n                priorities[i] *= 0.6\n            else:\n                priorities[i] *= 1.5\n            \n            if i % 2 == 0:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.8\n                    else:\n                        priorities[j] = 0.5\n            else:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.6\n                    else:\n                        priorities[j] = 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.25 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.4\n                elif remaining_capacity < 0.75 * item:\n                    priority += 0.6\n                else:\n                    priority += 0.8\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 2.0\n            elif priority < 0.4:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.3\n            \n            if i % 3 == 0:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.7\n                    else:\n                        priorities[j] = 0.4\n            elif i % 3 == 1:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.5\n                    else:\n                        priorities[j] = 0.2\n            else:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.8\n                    else:\n                        priorities[j] = 0.3\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:56:21", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.1\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.8 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 2.0\n            elif priority < 0.4:\n                priorities[i] *= 0.6\n            else:\n                priorities[i] *= 1.5\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.8\n                else:\n                    priorities[j] = 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.3 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.8\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 2.0\n            elif priority < 0.5:\n                priorities[i] *= 0.6\n            else:\n                priorities[i] *= 1.5\n            \n            if i % 2 == 0:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.8\n                    else:\n                        priorities[j] = 0.5\n            else:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.6\n                    else:\n                        priorities[j] = 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.3 * item:\n                    if i % 2 == 0:\n                        priority += 0.4\n                    else:\n                        priority += 0.3\n                elif remaining_capacity < 0.6 * item:\n                    if i % 2 == 0:\n                        priority += 0.6\n                    else:\n                        priority += 0.5\n                else:\n                    if i % 2 == 0:\n                        priority += 0.8\n                    else:\n                        priority += 0.7\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 2.0\n            elif priority < 0.5:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.8\n            \n            if i % 3 == 0:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.9\n                    else:\n                        priorities[j] = 0.6\n            else:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.7\n                    else:\n                        priorities[j] = 0.4\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:56:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:56:32", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    result = []\n\n    for row in data:\n        max_val = np.max(row)\n        min_val = np.min(row)\n        avg = np.mean(row)\n        \n        if max_val > 0 and min_val < 0:\n            result.append(np.sum(row) + np.prod(row))\n        elif max_val > 0 and min_val > 0:\n            result.append(np.sum(np.sqrt(row)) + np.prod(np.square(row)))\n        elif max_val < 0 and min_val < 0:\n            result.append(np.sum(np.cbrt(row)) + np.prod(np.abs(row)))\n        else:\n            result.append(np.sum(np.exp(row)) + np.prod(np.log(np.abs(row))))\n    \n    return np.array(result)", "strategy": []}
{"timestamp": "2025-04-27 05:56:36", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:56:38", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for i in range(len(ratios)):\n        ratio = ratios[i]\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n            priorities.append(priority)\n        else:\n            priority = np.exp(np.log(ratio)) * np.sqrt(ratio) - np.square(ratio)\n            priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:56:45", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(matrix: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(matrix)\n    \n    for i in range(matrix.shape[0]):\n        for j in range(matrix.shape[1]):\n            if matrix[i, j] % 2 == 0:\n                result[i, j] = matrix[i, j] * 2\n            elif matrix[i, j] % 3 == 0:\n                result[i, j] = matrix[i, j] * 3\n            else:\n                result[i, j] = matrix[i, j]\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:56:47", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def calculate_similarity_matrix(data: np.ndarray) -> np.ndarray:\n    rows, cols = data.shape\n    similarity_matrix = np.zeros((rows, rows))\n    \n    for i in range(rows):\n        for j in range(rows):\n            if i == j:\n                similarity_matrix[i, j] = 1.0\n            else:\n                dist = np.linalg.norm(data[i] - data[j])\n                similarity_matrix[i, j] = 1 / (1 + dist)\n    \n    return similarity_matrix", "strategy": []}
{"timestamp": "2025-04-27 05:56:49", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def custom_function(matrix: np.ndarray, target_value: int) -> np.ndarray:\n    result = np.zeros_like(matrix)\n    rows, cols = matrix.shape\n    \n    for i in range(rows):\n        for j in range(cols):\n            if matrix[i][j] == target_value:\n                result[i][j] = 1\n            else:\n                count = 0\n                for k in range(rows):\n                    if matrix[k][j] == target_value:\n                        count += 1\n                result[i][j] = count\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:56:51", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros(data.shape)\n    \n    for i in range(len(data)):\n        if data[i] % 2 == 0:\n            result[i] = data[i] ** 2\n        else:\n            if data[i] < 0:\n                result[i] = -1\n            else:\n                for j in range(1, data[i] + 1):\n                    result[i] += j\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:56:55", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n        \n        if bins[i] < 0.5 * item:\n            priorities[i] *= 1.5  # Increase priority for bins with low capacity\n        elif bins[i] > 1.5 * item:\n            priorities[i] *= 0.5  # Decrease priority for bins with high capacity\n        else:\n            priorities[i] *= 1.0  # Keep priority unchanged\n        \n        if i % 2 == 0:\n            priorities[i] += 2  # Add additional priority for even-indexed bins\n        else:\n            priorities[i] -= 1  # Reduce priority for odd-indexed bins\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n        \n        if bins[i] < 0.5 * item:\n            priorities[i] *= 1.5  # Increase priority for bins with low capacity\n        elif bins[i] > 1.5 * item:\n            priorities[i] *= 0.5  # Decrease priority for bins with high capacity\n        else:\n            priorities[i] *= 1.0  # Keep priority unchanged\n        \n        if i % 2 == 0:\n            priorities[i] += 2  # Add additional priority for even-indexed bins\n        else:\n            priorities[i] -= 1  # Reduce priority for odd-indexed bins\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(matrix: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(matrix)\n    \n    for i in range(matrix.shape[0]):\n        for j in range(matrix.shape[1]):\n            if matrix[i, j] % 2 == 0:\n                result[i, j] = matrix[i, j] * 2\n            else:\n                result[i, j] = matrix[i, j] + 1\n                \n            if i % 2 == 0:\n                result[i, j] += 1\n            else:\n                result[i, j] -= 1\n                \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:56:58", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n        \n        if bins[i] < 0.5 * item:\n            priorities[i] *= 1.5  # Increase priority for bins with low capacity\n        elif bins[i] > 1.5 * item:\n            priorities[i] *= 0.5  # Decrease priority for bins with high capacity\n        else:\n            priorities[i] *= 1.0  # Keep priority unchanged\n        \n        if i % 2 == 0:\n            priorities[i] += 2  # Add additional priority for even-indexed bins\n        else:\n            priorities[i] -= 1  # Reduce priority for odd-indexed bins\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n        \n        if bins[i] < 0.5 * item:\n            priorities[i] *= 1.5  # Increase priority for bins with low capacity\n        elif bins[i] > 1.5 * item:\n            priorities[i] *= 0.5  # Decrease priority for bins with high capacity\n        else:\n            priorities[i] *= 1.0  # Keep priority unchanged\n        \n        if i % 2 == 0:\n            priorities[i] += 2  # Add additional priority for even-indexed bins\n        else:\n            priorities[i] -= 1  # Reduce priority for odd-indexed bins\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(data)\n    \n    for i in range(len(data)):\n        if data[i] < 0:\n            result[i] = data[i] ** 2\n        elif data[i] >= 0 and data[i] < 5:\n            result[i] = data[i] * 3\n        else:\n            result[i] = data[i] + 10\n            \n        for j in range(1, 5):\n            result[i] += j * (data[i] + j)\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:57:00", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n        \n        if bins[i] < 0.5 * item:\n            priorities[i] *= 1.5  # Increase priority for bins with low capacity\n        elif bins[i] > 1.5 * item:\n            priorities[i] *= 0.5  # Decrease priority for bins with high capacity\n        else:\n            priorities[i] *= 1.0  # Keep priority unchanged\n        \n        if i % 2 == 0:\n            priorities[i] += 2  # Add additional priority for even-indexed bins\n        else:\n            priorities[i] -= 1  # Reduce priority for odd-indexed bins\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n        \n        if bins[i] < 0.5 * item:\n            priorities[i] *= 1.5  # Increase priority for bins with low capacity\n        elif bins[i] > 1.5 * item:\n            priorities[i] *= 0.5  # Decrease priority for bins with high capacity\n        else:\n            priorities[i] *= 1.0  # Keep priority unchanged\n        \n        if i % 2 == 0:\n            priorities[i] += 2  # Add additional priority for even-indexed bins\n        else:\n            priorities[i] -= 1  # Reduce priority for odd-indexed bins\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(matrix: np.ndarray, threshold: float) -> np.ndarray:\n    result = np.zeros_like(matrix)\n    rows, cols = matrix.shape\n    \n    for i in range(rows):\n        for j in range(cols):\n            if matrix[i, j] > threshold:\n                result[i, j] = matrix[i, j] * 2\n            elif matrix[i, j] < threshold / 2:\n                result[i, j] = matrix[i, j] / 2\n            else:\n                result[i, j] = matrix[i, j]\n                \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:57:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n        \n        if bins[i] < 0.5 * item:\n            priorities[i] *= 1.5  # Increase priority for bins with low capacity\n        elif bins[i] > 1.5 * item:\n            priorities[i] *= 0.5  # Decrease priority for bins with high capacity\n        else:\n            priorities[i] *= 1.0  # Keep priority unchanged\n        \n        if i % 2 == 0:\n            priorities[i] += 2  # Add additional priority for even-indexed bins\n        else:\n            priorities[i] -= 1  # Reduce priority for odd-indexed bins\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n        \n        if bins[i] < 0.5 * item:\n            priorities[i] *= 1.5  # Increase priority for bins with low capacity\n        elif bins[i] > 1.5 * item:\n            priorities[i] *= 0.5  # Decrease priority for bins with high capacity\n        else:\n            priorities[i] *= 1.0  # Keep priority unchanged\n        \n        if i % 2 == 0:\n            priorities[i] += 2  # Add additional priority for even-indexed bins\n        else:\n            priorities[i] -= 1  # Reduce priority for odd-indexed bins\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n        \n        if item < 0.2:\n            priorities[i] *= 2.0\n        elif item >= 0.2 and item < 0.5:\n            priorities[i] *= 1.5\n        else:\n            priorities[i] *= 1.0\n        \n        if i % 3 == 0:\n            priorities[i] += 3\n        elif i % 3 == 1:\n            priorities[i] -= 1\n        else:\n            priorities[i] += 2\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:57:09", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                max_gap = -1\n                max_gap_idx = -1\n                for j, cap in enumerate(bins):\n                    if cap >= item:\n                        gap = cap - item\n                        if gap > max_gap:\n                            max_gap = gap\n                            max_gap_idx = j\n                if max_gap_idx >= 0:\n                    priorities[max_gap_idx] = 1.0\n                    for k in range(max_gap_idx+1, len(bins)):\n                        gap_diff = bins[k] - bins[k-1]\n                        if gap_diff >= item:\n                            priorities[k] = 0.0\n                        else:\n                            priorities[k] = (item - gap_diff) / (bins[k] - bins[k-1])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Advanced version of `priority_v1`.\"\"\"\n\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                max_gap = -1\n                max_gap_idx = -1\n                for j, cap in enumerate(bins):\n                    if cap >= item:\n                        gap = cap - item\n                        if gap > max_gap:\n                            max_gap = gap\n                            max_gap_idx = j\n                if max_gap_idx >= 0:\n                    priorities[max_gap_idx] = 1.0\n                    for k in range(max_gap_idx+1, len(bins)):\n                        gap_diff = bins[k] - bins[k-1]\n                        if gap_diff >= item:\n                            priorities[k] = 0.0\n                        else:\n                            priorities[k] = (item - gap_diff) / (bins[k] - bins[k-1])\n                else:\n                    min_bin_capacity = min(bins)\n                    min_index = np.argmin(bins)\n                    priorities[min_index] = 1 - ((item - remaining_capacity) / (min_bin_capacity - remaining_capacity))\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:57:12", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                max_gap = -1\n                max_gap_idx = -1\n                for j, cap in enumerate(bins):\n                    if cap >= item:\n                        gap = cap - item\n                        if gap > max_gap:\n                            max_gap = gap\n                            max_gap_idx = j\n                if max_gap_idx >= 0:\n                    priorities[max_gap_idx] = 1.0\n                    for k in range(max_gap_idx+1, len(bins)):\n                        gap_diff = bins[k] - bins[k-1]\n                        if gap_diff >= item:\n                            priorities[k] = 0.0\n                        else:\n                            priorities[k] = (item - gap_diff) / (bins[k] - bins[k-1])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            max_gap = -1\n            max_gap_idx = -1\n            for j, cap in enumerate(bins):\n                if cap >= item:\n                    gap = cap - item\n                    if gap > max_gap:\n                        max_gap = gap\n                        max_gap_idx = j\n            if max_gap_idx >= 0:\n                priorities[max_gap_idx] = 1.0\n                for k in range(max_gap_idx+1, len(bins)):\n                    gap_diff = bins[k] - bins[k-1]\n                    if gap_diff >= item:\n                        priorities[k] = 0.0\n                    else:\n                        priorities[k] = (item - gap_diff) / (bins[k] - bins[k-1])\n            else:\n                max_capacity = max(bins)\n                max_index = np.argmax(bins)\n                priorities[max_index] = 1 - ((item - bin_capacity) / (max_capacity - bin_capacity))\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:57:17", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                max_gap = -1\n                max_gap_idx = -1\n                for j, cap in enumerate(bins):\n                    if cap >= item:\n                        gap = cap - item\n                        if gap > max_gap:\n                            max_gap = gap\n                            max_gap_idx = j\n                if max_gap_idx >= 0:\n                    priorities[max_gap_idx] = 1.0\n                    for k in range(max_gap_idx+1, len(bins)):\n                        gap_diff = bins[k] - bins[k-1]\n                        if gap_diff >= item:\n                            priorities[k] = 0.0\n                        else:\n                            priorities[k] = (item - gap_diff) / (bins[k] - bins[k-1])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                max_gap = -1\n                max_gap_idx = -1\n                for j, cap in enumerate(bins):\n                    if cap >= item:\n                        gap = cap - item\n                        if gap > max_gap:\n                            max_gap = gap\n                            max_gap_idx = j\n                if max_gap_idx >= 0:\n                    priorities[max_gap_idx] = 1.0\n                    for k in range(max_gap_idx+1, len(bins)):\n                        gap_diff = bins[k] - bins[k-1]\n                        if gap_diff >= item:\n                            priorities[k] = 0.0\n                        else:\n                            priorities[k] = (item - gap_diff) / (bins[k] - bins[k-1])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n                    \n    # Additional adjustments\n    sum_priorities = sum(priorities)\n    if sum_priorities < 1.0:\n        remaining_bins = np.where(priorities == 0)[0]\n        for idx in remaining_bins:\n            priorities[idx] = 1.0 / len(remaining_bins)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:57:20", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                max_gap = -1\n                max_gap_idx = -1\n                for j, cap in enumerate(bins):\n                    if cap >= item:\n                        gap = cap - item\n                        if gap > max_gap:\n                            max_gap = gap\n                            max_gap_idx = j\n                if max_gap_idx >= 0:\n                    priorities[max_gap_idx] = 1.0\n                    for k in range(max_gap_idx+1, len(bins)):\n                        gap_diff = bins[k] - bins[k-1]\n                        if gap_diff >= item:\n                            priorities[k] = 0.0\n                        else:\n                            priorities[k] = (item - gap_diff) / (bins[k] - bins[k-1])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                max_gap = -1\n                max_gap_idx = -1\n                for j, cap in enumerate(bins):\n                    if cap >= item:\n                        gap = cap - item\n                        if gap > max_gap:\n                            max_gap = gap\n                            max_gap_idx = j\n                if max_gap_idx >= 0:\n                    priorities[max_gap_idx] = 1.0\n                    for k in range(max_gap_idx+1, len(bins)):\n                        gap_diff = bins[k] - bins[k-1]\n                        if gap_diff >= item:\n                            priorities[k] = 0.0\n                        else:\n                            priorities[k] = (item - gap_diff) / (bins[k] - bins[k-1])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:57:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    remaining_capacity = bins[j]\n                    subpriority = 0.0\n                    while remaining_capacity < item:\n                        subpriority += 0.1\n                        remaining_capacity += bins[j]\n                    priorities[j] = subpriority\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:57:32", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n            \n            if i % 2 == 0:\n                priorities[i] *= 1.2\n            elif i % 3 == 0:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.0\n            \n            if i > 0 and bins[i] < bins[i-1]:\n                priorities[i] *= 1.1\n            elif i > 0 and bins[i] > bins[i-1]:\n                priorities[i] *= 0.9\n            else:\n                priorities[i] *= 1.0\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:57:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n                \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item and priorities[j] == 0:\n                    priorities[j] = 0.9\n                elif bins[j] < item and priorities[j] == 0:\n                    priorities[j] = 0.5\n                else:\n                    priorities[j] = priorities[j]\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:57:38", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    priorities[j] = 0.5\n                    \n    max_priority = np.max(priorities)\n    for k in range(len(priorities)):\n        if priorities[k] < max_priority * 0.7:\n            priorities[k] += 0.3\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:57:41", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = np.sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                total_available_capacity = remaining_capacity\n                for j in range(i+1, len(bins)):\n                    total_available_capacity += bins[j]\n                    if item <= total_available_capacity:\n                        for k in range(i, j):\n                            priorities[k] = (total_available_capacity - item) / (total_available_capacity - bins[i])\n                        break\n                    elif item > total_available_capacity and j == len(bins) - 1:\n                        for k in range(i, j+1):\n                            priorities[k] = 0.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                excess_capacity = item - remaining_capacity\n                capacity_left = bins[i] - remaining_capacity\n                \n                if excess_capacity < capacity_left * 0.1:\n                    priorities[i] = 0.9\n                elif excess_capacity < capacity_left * 0.2:\n                    priorities[i] = 0.8\n                elif excess_capacity < capacity_left * 0.3:\n                    priorities[i] = 0.7\n                elif excess_capacity < capacity_left * 0.4:\n                    priorities[i] = 0.6\n                elif excess_capacity < capacity_left * 0.5:\n                    priorities[i] = 0.5\n                elif excess_capacity < capacity_left * 0.6:\n                    priorities[i] = 0.4\n                elif excess_capacity < capacity_left * 0.7:\n                    priorities[i] = 0.3\n                elif excess_capacity < capacity_left * 0.8:\n                    priorities[i] = 0.2\n                else:\n                    priorities[i] = 0.1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                excess_capacity = item - remaining_capacity\n                capacity_left = bins[i] - remaining_capacity\n                \n                for j in range(i, len(bins)):\n                    if bins[j] >= excess_capacity:\n                        priorities[j] = excess_capacity / bins[j]\n                        excess_capacity = 0\n                        break\n                    else:\n                        priorities[j] = 1.0\n                        excess_capacity -= bins[j]\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:57:45", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = np.sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                total_available_capacity = remaining_capacity\n                for j in range(i+1, len(bins)):\n                    total_available_capacity += bins[j]\n                    if item <= total_available_capacity:\n                        for k in range(i, j):\n                            priorities[k] = (total_available_capacity - item) / (total_available_capacity - bins[i])\n                        break\n                    elif item > total_available_capacity and j == len(bins) - 1:\n                        for k in range(i, j+1):\n                            priorities[k] = 0.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                excess_capacity = item - remaining_capacity\n                capacity_left = bins[i] - remaining_capacity\n                \n                if excess_capacity < capacity_left * 0.1:\n                    priorities[i] = 0.9\n                elif excess_capacity < capacity_left * 0.2:\n                    priorities[i] = 0.8\n                elif excess_capacity < capacity_left * 0.3:\n                    priorities[i] = 0.7\n                elif excess_capacity < capacity_left * 0.4:\n                    priorities[i] = 0.6\n                elif excess_capacity < capacity_left * 0.5:\n                    priorities[i] = 0.5\n                elif excess_capacity < capacity_left * 0.6:\n                    priorities[i] = 0.4\n                elif excess_capacity < capacity_left * 0.7:\n                    priorities[i] = 0.3\n                elif excess_capacity < capacity_left * 0.8:\n                    priorities[i] = 0.2\n                else:\n                    priorities[i] = 0.1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                excess_capacity = item - remaining_capacity\n                capacity_left = bins[i] - remaining_capacity\n                \n                if excess_capacity < capacity_left * 0.1:\n                    priorities[i] = 0.9\n                elif excess_capacity < capacity_left * 0.2:\n                    priorities[i] = 0.8\n                elif excess_capacity < capacity_left * 0.3:\n                    priorities[i] = 0.7\n                elif excess_capacity < capacity_left * 0.4:\n                    priorities[i] = 0.6\n                elif excess_capacity < capacity_left * 0.5:\n                    priorities[i] = 0.5\n                elif excess_capacity < capacity_left * 0.6:\n                    priorities[i] = 0.4\n                elif excess_capacity < capacity_left * 0.7:\n                    priorities[i] = 0.3\n                elif excess_capacity < capacity_left * 0.8:\n                    priorities[i] = 0.2\n                else:\n                    priorities[i] = 0.1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:57:48", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = np.sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                total_available_capacity = remaining_capacity\n                for j in range(i+1, len(bins)):\n                    total_available_capacity += bins[j]\n                    if item <= total_available_capacity:\n                        for k in range(i, j):\n                            priorities[k] = (total_available_capacity - item) / (total_available_capacity - bins[i])\n                        break\n                    elif item > total_available_capacity and j == len(bins) - 1:\n                        for k in range(i, j+1):\n                            priorities[k] = 0.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                excess_capacity = item - remaining_capacity\n                capacity_left = bins[i] - remaining_capacity\n                \n                if excess_capacity < capacity_left * 0.1:\n                    priorities[i] = 0.9\n                elif excess_capacity < capacity_left * 0.2:\n                    priorities[i] = 0.8\n                elif excess_capacity < capacity_left * 0.3:\n                    priorities[i] = 0.7\n                elif excess_capacity < capacity_left * 0.4:\n                    priorities[i] = 0.6\n                elif excess_capacity < capacity_left * 0.5:\n                    priorities[i] = 0.5\n                elif excess_capacity < capacity_left * 0.6:\n                    priorities[i] = 0.4\n                elif excess_capacity < capacity_left * 0.7:\n                    priorities[i] = 0.3\n                elif excess_capacity < capacity_left * 0.8:\n                    priorities[i] = 0.2\n                else:\n                    priorities[i] = 0.1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                excess_capacity = item - remaining_capacity\n                capacity_left = bins[i] - remaining_capacity\n                \n                for j in range(i, len(bins)):\n                    if excess_capacity < capacity_left * (j-i+1) * 0.1:\n                        priorities[i] = 1.0 / (j-i+1)\n                        for k in range(i+1, j+1):\n                            priorities[k] = 1.0 / (j-i+1)\n                        break\n                    else:\n                        priorities[j] = 0.0\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:57:51", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = np.sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                total_available_capacity = remaining_capacity\n                for j in range(i+1, len(bins)):\n                    total_available_capacity += bins[j]\n                    if item <= total_available_capacity:\n                        for k in range(i, j):\n                            priorities[k] = (total_available_capacity - item) / (total_available_capacity - bins[i])\n                        break\n                    elif item > total_available_capacity and j == len(bins) - 1:\n                        for k in range(i, j+1):\n                            priorities[k] = 0.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                excess_capacity = item - remaining_capacity\n                capacity_left = bins[i] - remaining_capacity\n                \n                if excess_capacity < capacity_left * 0.1:\n                    priorities[i] = 0.9\n                elif excess_capacity < capacity_left * 0.2:\n                    priorities[i] = 0.8\n                elif excess_capacity < capacity_left * 0.3:\n                    priorities[i] = 0.7\n                elif excess_capacity < capacity_left * 0.4:\n                    priorities[i] = 0.6\n                elif excess_capacity < capacity_left * 0.5:\n                    priorities[i] = 0.5\n                elif excess_capacity < capacity_left * 0.6:\n                    priorities[i] = 0.4\n                elif excess_capacity < capacity_left * 0.7:\n                    priorities[i] = 0.3\n                elif excess_capacity < capacity_left * 0.8:\n                    priorities[i] = 0.2\n                else:\n                    priorities[i] = 0.1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                excess_capacity = item - remaining_capacity\n                capacity_left = bins[i] - remaining_capacity\n                \n                for j in range(1, 11):\n                    threshold = j / 10\n                    if excess_capacity < capacity_left * threshold:\n                        priorities[i] = 1 - threshold + 0.1\n                        break\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:57:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                max_divisor = 0\n                for i in range(2, int(bin_capacity/2) + 1):\n                    if bin_capacity % i == 0:\n                        max_divisor = i\n                \n                if max_divisor > 0:\n                    priority = 1 / (bin_capacity - item + max_divisor)\n                else:\n                    priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:57:58", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                factor = 1\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        factor = i\n                        break\n                priority += factor / bin_capacity\n                \n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:58:00", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            if item % bin_capacity == 0:\n                priority = 0.5 / item\n            else:\n                priority = 0\n        priorities.append(priority)\n    \n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:58:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            elif bin_capacity % item == 1:\n                priority = 1 / (bin_capacity - item + 2)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        elif item < bin_capacity * 1.5:\n            priority = 0.5\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 05:58:09", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        highest_priority = -1\n                        highest_priority_idx = -1\n                        for k in range(i, j):\n                            if priorities[k] == -1:\n                                continue\n                            if priorities[k] > highest_priority:\n                                highest_priority = priorities[k]\n                                highest_priority_idx = k\n                        if highest_priority > 1:\n                            priorities[highest_priority_idx] = 1\n                            priorities[j] = (j - highest_priority_idx) + 1\n                        else:\n                            priorities[i] = -1\n                            break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        highest_priority = -1\n                        highest_priority_idx = -1\n                        for k in range(i, j):\n                            if priorities[k] == -1:\n                                continue\n                            if priorities[k] > highest_priority:\n                                highest_priority = priorities[k]\n                                highest_priority_idx = k\n                        if highest_priority > 1:\n                            priorities[highest_priority_idx] = 1\n                            priorities[j] = (j - highest_priority_idx) + 1\n                        else:\n                            priorities[i] = -1\n                            break\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        highest_priority = -1\n                        highest_priority_idx = -1\n                        for k in range(i, j):\n                            if priorities[k] == -1:\n                                continue\n                            if priorities[k] > highest_priority:\n                                highest_priority = priorities[k]\n                                highest_priority_idx = k\n                        if highest_priority > 1:\n                            priorities[highest_priority_idx] = 1\n                            priorities[j] = (j - highest_priority_idx) + 1\n                        else:\n                            priorities[i] = -1\n                            break\n                    elif remaining_capacity < item:\n                        remaining_items = item - remaining_capacity\n                        for m in range(j, len(bins)):\n                            if bins[m] >= remaining_items:\n                                priorities[m] = (m - i) + 1\n                                break\n                            else:\n                                remaining_items -= bins[m]\n                                if remaining_items <= 0:\n                                    break\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:58:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        highest_priority = -1\n                        highest_priority_idx = -1\n                        for k in range(i, j):\n                            if priorities[k] == -1:\n                                continue\n                            if priorities[k] > highest_priority:\n                                highest_priority = priorities[k]\n                                highest_priority_idx = k\n                        if highest_priority > 1:\n                            priorities[highest_priority_idx] = 1\n                            priorities[j] = (j - highest_priority_idx) + 1\n                        else:\n                            priorities[i] = -1\n                            break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        highest_priority = -1\n                        highest_priority_idx = -1\n                        for k in range(i, j):\n                            if priorities[k] == -1:\n                                continue\n                            if priorities[k] > highest_priority:\n                                highest_priority = priorities[k]\n                                highest_priority_idx = k\n                        if highest_priority > 1:\n                            priorities[highest_priority_idx] = 1\n                            priorities[j] = (j - highest_priority_idx) + 1\n                        else:\n                            priorities[i] = -1\n                            break\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        highest_priority = -1\n                        highest_priority_idx = -1\n                        for k in range(i, j):\n                            if priorities[k] == -1:\n                                continue\n                            if priorities[k] > highest_priority:\n                                highest_priority = priorities[k]\n                                highest_priority_idx = k\n                        if highest_priority > 1:\n                            priorities[highest_priority_idx] = 1\n                            priorities[j] = (j - highest_priority_idx) + 1\n                        else:\n                            priorities[i] = -1\n                            break\n                    if priorities[i] == -1:\n                        break\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:58:18", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        highest_priority = -1\n                        highest_priority_idx = -1\n                        for k in range(i, j):\n                            if priorities[k] == -1:\n                                continue\n                            if priorities[k] > highest_priority:\n                                highest_priority = priorities[k]\n                                highest_priority_idx = k\n                        if highest_priority > 1:\n                            priorities[highest_priority_idx] = 1\n                            priorities[j] = (j - highest_priority_idx) + 1\n                        else:\n                            priorities[i] = -1\n                            break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        highest_priority = -1\n                        highest_priority_idx = -1\n                        for k in range(i, j):\n                            if priorities[k] == -1:\n                                continue\n                            if priorities[k] > highest_priority:\n                                highest_priority = priorities[k]\n                                highest_priority_idx = k\n                        if highest_priority > 1:\n                            priorities[highest_priority_idx] = 1\n                            priorities[j] = (j - highest_priority_idx) + 1\n                        else:\n                            priorities[i] = -1\n                            break\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        highest_priority = -1\n                        highest_priority_idx = -1\n                        for k in range(i, j):\n                            if priorities[k] == -1:\n                                continue\n                            if priorities[k] > highest_priority:\n                                highest_priority = priorities[k]\n                                highest_priority_idx = k\n                        if highest_priority > 1:\n                            priorities[highest_priority_idx] = 1\n                            priorities[j] = (j - highest_priority_idx) + 1\n                        else:\n                            priorities[i] = -1\n                            break\n    \n    # Additional improvement logic\n    for idx in range(len(priorities)):\n        if priorities[idx] == -1:\n            for k in range(idx, -1, -1):\n                if priorities[k] == 0 and bins[k] >= item:\n                    priorities[k] = len(priorities) - idx\n                    break\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:58:21", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        highest_priority = -1\n                        highest_priority_idx = -1\n                        for k in range(i, j):\n                            if priorities[k] == -1:\n                                continue\n                            if priorities[k] > highest_priority:\n                                highest_priority = priorities[k]\n                                highest_priority_idx = k\n                        if highest_priority > 1:\n                            priorities[highest_priority_idx] = 1\n                            priorities[j] = (j - highest_priority_idx) + 1\n                        else:\n                            priorities[i] = -1\n                            break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        highest_priority = -1\n                        highest_priority_idx = -1\n                        for k in range(i, j):\n                            if priorities[k] == -1:\n                                continue\n                            if priorities[k] > highest_priority:\n                                highest_priority = priorities[k]\n                                highest_priority_idx = k\n                        if highest_priority > 1:\n                            priorities[highest_priority_idx] = 1\n                            priorities[j] = (j - highest_priority_idx) + 1\n                        else:\n                            priorities[i] = -1\n                            break\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        highest_priority = -1\n                        highest_priority_idx = -1\n                        for k in range(i, j):\n                            if priorities[k] == -1:\n                                continue\n                            if priorities[k] > highest_priority:\n                                highest_priority = priorities[k]\n                                highest_priority_idx = k\n                        if highest_priority > 1:\n                            priorities[highest_priority_idx] = 1\n                            priorities[j] = (j - highest_priority_idx) + 1\n                        else:\n                            for l in range(i, j+1):\n                                if priorities[l] == 0:\n                                    priorities[l] = -1\n                            break\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:58:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n            if bins[i] <= 0.3 * max_bin_capacity:\n                priorities[i] += 1.2 * bins[i]  # Increase priority for bins with very low capacity\n        else:\n            priorities[i] = bins[i] - item\n            if bins[i] >= 0.7 * max_bin_capacity:\n                priorities[i] -= 1.1 * (bins[i] - item)  # Decrease priority for bins with high capacity\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])\n            if bins[i] <= 0.3 * max_bin_capacity:\n                priorities[i] += 1.2 * bins[i]\n            if i % 3 == 0:\n                priorities[i] += 2.3  # Additional priority for every 3rd bin\n            elif i % 3 == 1:\n                priorities[i] -= 1.3  # Reduced priority for every 3rd bin\n            \n        else:\n            priorities[i] = bins[i] - item\n            if bins[i] >= 0.7 * max_bin_capacity:\n                priorities[i] -= 1.1 * (bins[i] - item)\n            if i % 4 == 0:\n                priorities[i] -= 1.5  # Reduced priority for every 4th bin\n            elif i % 4 == 1:\n                priorities[i] += 0.5  # Increased priority for every 4th bin\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])\n            if bins[i] <= 0.3 * max_bin_capacity:\n                priorities[i] += 1.2 * bins[i] * (1 + i/10)  # Increase priority for low capacity bins with incremental factor\n            if i % 2 == 0:\n                priorities[i] += 2.3 * (i + 1)  # Additional priority for every 2nd bin with incremental factor\n            else:\n                priorities[i] -= 1.3  # Reduced priority for other bins\n            \n        else:\n            priorities[i] = bins[i] - item\n            if bins[i] >= 0.7 * max_bin_capacity:\n                priorities[i] -= 1.1 * (bins[i] - item)\n            if i % 3 == 0:\n                priorities[i] -= 1.5 * (i + 1)  # Reduced priority for every 3rd bin with incremental factor\n            elif i % 3 == 1:\n                priorities[i] += 0.5 * (i + 1)  # Increased priority for every 3rd bin with incremental factor\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:58:31", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n            if bins[i] <= 0.3 * max_bin_capacity:\n                priorities[i] += 1.2 * bins[i]  # Increase priority for bins with very low capacity\n        else:\n            priorities[i] = bins[i] - item\n            if bins[i] >= 0.7 * max_bin_capacity:\n                priorities[i] -= 1.1 * (bins[i] - item)  # Decrease priority for bins with high capacity\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])\n            if bins[i] <= 0.3 * max_bin_capacity:\n                priorities[i] += 1.2 * bins[i]\n            if i % 3 == 0:\n                priorities[i] += 2.3  # Additional priority for every 3rd bin\n            elif i % 3 == 1:\n                priorities[i] -= 1.3  # Reduced priority for every 3rd bin\n            \n        else:\n            priorities[i] = bins[i] - item\n            if bins[i] >= 0.7 * max_bin_capacity:\n                priorities[i] -= 1.1 * (bins[i] - item)\n            if i % 4 == 0:\n                priorities[i] -= 1.5  # Reduced priority for every 4th bin\n            elif i % 4 == 1:\n                priorities[i] += 0.5  # Increased priority for every 4th bin\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])\n            if bins[i] <= 0.3 * max_bin_capacity:\n                priorities[i] += 1.2 * bins[i]\n            if i % 3 == 0:\n                priorities[i] += 2.3\n            elif i % 3 == 1:\n                priorities[i] -= 1.3\n            if item >= 1.5 * max_bin_capacity:\n                priorities[i] += 3.5  # Additional priority for item larger than 1.5 times max capacity\n            \n        else:\n            priorities[i] = bins[i] - item\n            if bins[i] >= 0.7 * max_bin_capacity:\n                priorities[i] -= 1.1 * (bins[i] - item)\n            if i % 4 == 0:\n                priorities[i] -= 1.5\n            elif i % 4 == 1:\n                priorities[i] += 0.5\n            if item < 0.5 * max_bin_capacity:\n                priorities[i] += 2.7  # Additional priority for item smaller than 0.5 times max capacity\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:58:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n            if bins[i] <= 0.3 * max_bin_capacity:\n                priorities[i] += 1.2 * bins[i]  # Increase priority for bins with very low capacity\n        else:\n            priorities[i] = bins[i] - item\n            if bins[i] >= 0.7 * max_bin_capacity:\n                priorities[i] -= 1.1 * (bins[i] - item)  # Decrease priority for bins with high capacity\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])\n            if bins[i] <= 0.3 * max_bin_capacity:\n                priorities[i] += 1.2 * bins[i]\n            if i % 3 == 0:\n                priorities[i] += 2.3  # Additional priority for every 3rd bin\n            elif i % 3 == 1:\n                priorities[i] -= 1.3  # Reduced priority for every 3rd bin\n            \n        else:\n            priorities[i] = bins[i] - item\n            if bins[i] >= 0.7 * max_bin_capacity:\n                priorities[i] -= 1.1 * (bins[i] - item)\n            if i % 4 == 0:\n                priorities[i] -= 1.5  # Reduced priority for every 4th bin\n            elif i % 4 == 1:\n                priorities[i] += 0.5  # Increased priority for every 4th bin\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])\n            if bins[i] <= 0.3 * max_bin_capacity:\n                priorities[i] += 1.2 * bins[i]\n            \n            if i % 5 == 0:\n                priorities[i] += 3.5  # Additional priority for every 5th bin\n            elif i % 5 == 1:\n                priorities[i] -= 1.5  # Reduced priority for every 5th bin\n            elif i % 5 == 2:\n                priorities[i] += 2.2  # Additional priority for every 5th bin\n            \n        else:\n            priorities[i] = bins[i] - item\n            if bins[i] >= 0.7 * max_bin_capacity:\n                priorities[i] -= 1.1 * (bins[i] - item)\n            \n            if i % 6 == 0:\n                priorities[i] -= 2.0  # Reduced priority for every 6th bin\n            elif i % 6 == 1:\n                priorities[i] += 0.8  # Increased priority for every 6th bin\n            elif i % 6 == 2:\n                priorities[i] -= 1.3  # Reduced priority for every 6th bin\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:58:39", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n            if bins[i] <= 0.3 * max_bin_capacity:\n                priorities[i] += 1.2 * bins[i]  # Increase priority for bins with very low capacity\n        else:\n            priorities[i] = bins[i] - item\n            if bins[i] >= 0.7 * max_bin_capacity:\n                priorities[i] -= 1.1 * (bins[i] - item)  # Decrease priority for bins with high capacity\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])\n            if bins[i] <= 0.3 * max_bin_capacity:\n                priorities[i] += 1.2 * bins[i]\n            if i % 3 == 0:\n                priorities[i] += 2.3  # Additional priority for every 3rd bin\n            elif i % 3 == 1:\n                priorities[i] -= 1.3  # Reduced priority for every 3rd bin\n            \n        else:\n            priorities[i] = bins[i] - item\n            if bins[i] >= 0.7 * max_bin_capacity:\n                priorities[i] -= 1.1 * (bins[i] - item)\n            if i % 4 == 0:\n                priorities[i] -= 1.5  # Reduced priority for every 4th bin\n            elif i % 4 == 1:\n                priorities[i] += 0.5  # Increased priority for every 4th bin\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])\n            if bins[i] <= 0.3 * max_bin_capacity:\n                priorities[i] += 1.2 * bins[i]\n            if i % 2 == 0:\n                priorities[i] += 1.5  # Additional priority for every 2nd bin\n            else:\n                priorities[i] -= 0.5  # Reduced priority for other bins\n            \n            if bins[i] < 0.2 * max_bin_capacity:\n                priorities[i] += 2.0  # Additional priority for bins with very low capacity\n            elif bins[i] >= 0.8 * max_bin_capacity:\n                priorities[i] -= 1.7  # Reduced priority for bins with very high capacity\n        else:\n            priorities[i] = bins[i] - item\n            if bins[i] >= 0.7 * max_bin_capacity:\n                priorities[i] -= 1.1 * (bins[i] - item)\n            if i % 3 == 0:\n                priorities[i] -= 1.2  # Reduced priority for every 3rd bin\n            else:\n                priorities[i] += 0.8  # Increased priority for other bins\n          \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:58:49", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            max_gap = -1\n            max_gap_idx = -1\n            for j, cap in enumerate(bins):\n                if cap >= item:\n                    gap = cap - item\n                    if gap > max_gap:\n                        max_gap = gap\n                        max_gap_idx = j\n            if max_gap_idx >= 0:\n                priorities[max_gap_idx] = 1.0\n                for k in range(max_gap_idx+1, len(bins)):\n                    gap_diff = bins[k] - bins[k-1]\n                    if gap_diff >= item:\n                        priorities[k] = 0.0\n                    else:\n                        priorities[k] = (item - gap_diff) / (bins[k] - bins[k-1])\n            else:\n                max_capacity = max(bins)\n                max_index = np.argmax(bins)\n                priorities[max_index] = 1 - ((item - bin_capacity) / (max_capacity - bin_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                temp_priorities = []\n                for j in range(i, len(bins)):\n                    if bins[j] > item:\n                        temp_priorities.append(1.0 - (item - sum(bins[:j])) / bins[j])\n                    else:\n                        remaining_items_sum = sum([item for index, item in enumerate(bins) if index > j])\n                        if remaining_items_sum >= item:\n                            temp_priorities.append(0.8)\n                        else:\n                            prev_priorities_sum = sum(priorities[:j])\n                            remaining_capacity_items = [(index, item_value) for index, item_value in enumerate(bins) if index > j]\n                            remaining_capacity_items.sort(key=lambda x: x[1])\n                            for index, item_value in remaining_capacity_items:\n                                if item <= remaining_capacity + item_value:\n                                    temp_priorities.append(0.6 + prev_priorities_sum)\n                                    break\n                                prev_priorities_sum += 0.03\n                if temp_priorities:\n                    max_priority = max(temp_priorities)\n                    max_idxs = [idx for idx, val in enumerate(temp_priorities) if val == max_priority]\n                    for idx in max_idxs:\n                        priorities[idx + i] = max_priority\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity - sum(bins[:i])\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                temp_priorities = []\n                for j in range(i, len(bins)):\n                    if bins[j] > item:\n                        temp_priorities.append(1.0 - (item - sum(bins[:j])) / bins[j])\n                    else:\n                        remaining_items_sum = sum([item_val for idx, item_val in enumerate(bins) if idx > j])\n                        if remaining_items_sum >= item:\n                            temp_priorities.append(0.8)\n                        else:\n                            prev_priorities_sum = sum(priorities[:j])\n                            remaining_items = [(idx, val) for idx, val in enumerate(bins) if idx > j]\n                            remaining_items.sort(key=lambda x: x[1])\n                            for idx, item_val in remaining_items:\n                                if item <= remaining_capacity + item_val:\n                                    temp_priorities.append(0.6 + prev_priorities_sum)\n                                    break\n                                prev_priorities_sum += 0.03\n                if temp_priorities:\n                    max_priority = max(temp_priorities)\n                    max_idxs = [idx for idx, val in enumerate(temp_priorities) if val == max_priority]\n                    for idx in max_idxs:\n                        priorities[idx + i] = max_priority\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:58:53", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            max_gap = -1\n            max_gap_idx = -1\n            for j, cap in enumerate(bins):\n                if cap >= item:\n                    gap = cap - item\n                    if gap > max_gap:\n                        max_gap = gap\n                        max_gap_idx = j\n            if max_gap_idx >= 0:\n                priorities[max_gap_idx] = 1.0\n                for k in range(max_gap_idx+1, len(bins)):\n                    gap_diff = bins[k] - bins[k-1]\n                    if gap_diff >= item:\n                        priorities[k] = 0.0\n                    else:\n                        priorities[k] = (item - gap_diff) / (bins[k] - bins[k-1])\n            else:\n                max_capacity = max(bins)\n                max_index = np.argmax(bins)\n                priorities[max_index] = 1 - ((item - bin_capacity) / (max_capacity - bin_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                temp_priorities = []\n                for j in range(i, len(bins)):\n                    if bins[j] > item:\n                        temp_priorities.append(1.0 - (item - sum(bins[:j])) / bins[j])\n                    else:\n                        remaining_items_sum = sum([item for index, item in enumerate(bins) if index > j])\n                        if remaining_items_sum >= item:\n                            temp_priorities.append(0.8)\n                        else:\n                            prev_priorities_sum = sum(priorities[:j])\n                            remaining_capacity_items = [(index, item_value) for index, item_value in enumerate(bins) if index > j]\n                            remaining_capacity_items.sort(key=lambda x: x[1])\n                            for index, item_value in remaining_capacity_items:\n                                if item <= remaining_capacity + item_value:\n                                    temp_priorities.append(0.6 + prev_priorities_sum)\n                                    break\n                                prev_priorities_sum += 0.03\n                if temp_priorities:\n                    max_priority = max(temp_priorities)\n                    max_idxs = [idx for idx, val in enumerate(temp_priorities) if val == max_priority]\n                    for idx in max_idxs:\n                        priorities[idx + i] = max_priority\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                temp_priorities = []\n                for j in range(i, len(bins)):\n                    if bins[j] > item:\n                        temp_priorities.append(1.0 - (item - sum(bins[:j])) / bins[j])\n                    else:\n                        remaining_items_sum = sum([item for index, item in enumerate(bins) if index > j])\n                        if remaining_items_sum >= item:\n                            temp_priorities.append(0.8)\n                        else:\n                            prev_priorities_sum = sum(priorities[:j])\n                            remaining_capacity_items = [(index, item_value) for index, item_value in enumerate(bins) if index > j]\n                            remaining_capacity_items.sort(key=lambda x: x[1])\n                            for index, item_value in remaining_capacity_items:\n                                if item <= remaining_capacity + item_value:\n                                    temp_priorities.append(0.6 + prev_priorities_sum)\n                                    break\n                                prev_priorities_sum += 0.03\n                if temp_priorities:\n                    max_priority = max(temp_priorities)\n                    max_idxs = [idx for idx, val in enumerate(temp_priorities) if val == max_priority]\n                    for idx in max_idxs:\n                        priorities[idx + i] = max_priority\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:58:58", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            max_gap = -1\n            max_gap_idx = -1\n            for j, cap in enumerate(bins):\n                if cap >= item:\n                    gap = cap - item\n                    if gap > max_gap:\n                        max_gap = gap\n                        max_gap_idx = j\n            if max_gap_idx >= 0:\n                priorities[max_gap_idx] = 1.0\n                for k in range(max_gap_idx+1, len(bins)):\n                    gap_diff = bins[k] - bins[k-1]\n                    if gap_diff >= item:\n                        priorities[k] = 0.0\n                    else:\n                        priorities[k] = (item - gap_diff) / (bins[k] - bins[k-1])\n            else:\n                max_capacity = max(bins)\n                max_index = np.argmax(bins)\n                priorities[max_index] = 1 - ((item - bin_capacity) / (max_capacity - bin_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                temp_priorities = []\n                for j in range(i, len(bins)):\n                    if bins[j] > item:\n                        temp_priorities.append(1.0 - (item - sum(bins[:j])) / bins[j])\n                    else:\n                        remaining_items_sum = sum([item for index, item in enumerate(bins) if index > j])\n                        if remaining_items_sum >= item:\n                            temp_priorities.append(0.8)\n                        else:\n                            prev_priorities_sum = sum(priorities[:j])\n                            remaining_capacity_items = [(index, item_value) for index, item_value in enumerate(bins) if index > j]\n                            remaining_capacity_items.sort(key=lambda x: x[1])\n                            for index, item_value in remaining_capacity_items:\n                                if item <= remaining_capacity + item_value:\n                                    temp_priorities.append(0.6 + prev_priorities_sum)\n                                    break\n                                prev_priorities_sum += 0.03\n                if temp_priorities:\n                    max_priority = max(temp_priorities)\n                    max_idxs = [idx for idx, val in enumerate(temp_priorities) if val == max_priority]\n                    for idx in max_idxs:\n                        priorities[idx + i] = max_priority\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                temp_priorities = []\n                for j in range(i, len(bins)):\n                    if bins[j] > item:\n                        temp_priorities.append(1.0 - (item - sum(bins[:j])) / bins[j])\n                    else:\n                        remaining_items_sum = sum([item for index, item in enumerate(bins) if index > j])\n                        if remaining_items_sum >= item:\n                            temp_priorities.append(0.8)\n                        else:\n                            prev_priorities_sum = sum(priorities[:j])\n                            remaining_capacity_items = [(index, item_value) for index, item_value in enumerate(bins) if index > j]\n                            remaining_capacity_items.sort(key=lambda x: x[1])\n                            for index, item_value in remaining_capacity_items:\n                                if item <= remaining_capacity + item_value:\n                                    temp_priorities.append(0.6 + prev_priorities_sum)\n                                    break\n                                prev_priorities_sum += 0.03\n                if temp_priorities:\n                    max_priority = max(temp_priorities)\n                    max_idxs = [idx for idx, val in enumerate(temp_priorities) if val == max_priority]\n                    for idx in max_idxs:\n                        priorities[idx + i] = max_priority\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 05:59:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            max_gap = -1\n            max_gap_idx = -1\n            for j, cap in enumerate(bins):\n                if cap >= item:\n                    gap = cap - item\n                    if gap > max_gap:\n                        max_gap = gap\n                        max_gap_idx = j\n            if max_gap_idx >= 0:\n                priorities[max_gap_idx] = 1.0\n                for k in range(max_gap_idx+1, len(bins)):\n                    gap_diff = bins[k] - bins[k-1]\n                    if gap_diff >= item:\n                        priorities[k] = 0.0\n                    else:\n                        priorities[k] = (item - gap_diff) / (bins[k] - bins[k-1])\n            else:\n                max_capacity = max(bins)\n                max_index = np.argmax(bins)\n                priorities[max_index] = 1 - ((item - bin_capacity) / (max_capacity - bin_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                temp_priorities = []\n                for j in range(i, len(bins)):\n                    if bins[j] > item:\n                        temp_priorities.append(1.0 - (item - sum(bins[:j])) / bins[j])\n                    else:\n                        remaining_items_sum = sum([item for index, item in enumerate(bins) if index > j])\n                        if remaining_items_sum >= item:\n                            temp_priorities.append(0.8)\n                        else:\n                            prev_priorities_sum = sum(priorities[:j])\n                            remaining_capacity_items = [(index, item_value) for index, item_value in enumerate(bins) if index > j]\n                            remaining_capacity_items.sort(key=lambda x: x[1])\n                            for index, item_value in remaining_capacity_items:\n                                if item <= remaining_capacity + item_value:\n                                    temp_priorities.append(0.6 + prev_priorities_sum)\n                                    break\n                                prev_priorities_sum += 0.03\n                if temp_priorities:\n                    max_priority = max(temp_priorities)\n                    max_idxs = [idx for idx, val in enumerate(temp_priorities) if val == max_priority]\n                    for idx in max_idxs:\n                        priorities[idx + i] = max_priority\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                temp_priorities = []\n                for j in range(i, len(bins)):\n                    if bins[j] > item:\n                        temp_priorities.append(1.0 - (item - sum(bins[:j])) / bins[j])\n                    else:\n                        remaining_items_sum = sum([item for index, item in enumerate(bins) if index > j])\n                        if remaining_items_sum >= item:\n                            temp_priorities.append(0.8)\n                        else:\n                            prev_priorities_sum = sum(priorities[:j])\n                            remaining_capacity_items = [(index, item_value) for index, item_value in enumerate(bins) if index > j]\n                            remaining_capacity_items.sort(key=lambda x: x[1])\n                            for index, item_value in remaining_capacity_items:\n                                if item <= remaining_capacity + item_value:\n                                    temp_priorities.append(0.6 + prev_priorities_sum)\n                                    break\n                                prev_priorities_sum += 0.03\n                if temp_priorities:\n                    max_priority = max(temp_priorities)\n                    max_idxs = [idx for idx, val in enumerate(temp_priorities) if val == max_priority]\n                    for idx in max_idxs:\n                        priorities[idx + i] = max_priority\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:59:09", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(input_data: np.ndarray) -> np.ndarray:\n    output_data = np.zeros_like(input_data)\n\n    for i in range(len(input_data)):\n        if input_data[i] % 2 == 0:\n            output_data[i] = input_data[i] ** 2\n        else:\n            output_data[i] = input_data[i] * 3\n\n    temp_sum = 0\n    for j in range(len(output_data)):\n        if j % 2 == 0:\n            temp_sum += output_data[j]\n\n    for k in range(len(output_data)):\n        if output_data[k] > temp_sum:\n            output_data[k] -= temp_sum\n        else:\n            output_data[k] += temp_sum\n\n    return output_data", "strategy": []}
{"timestamp": "2025-04-27 05:59:11", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(matrix: np.ndarray) -> np.ndarray:\n    result = np.zeros(matrix.shape)\n    \n    for i in range(matrix.shape[0]):\n        for j in range(matrix.shape[1]):\n            if matrix[i][j] % 2 == 0:  # If element is even\n                result[i][j] = matrix[i][j] ** 2\n            else:  # If element is odd\n                result[i][j] = matrix[i][j] * 3\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:59:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros(len(data))\n    \n    for i in range(len(data)):\n        if data[i] % 2 == 0:\n            result[i] = data[i] * 2\n        elif data[i] % 3 == 0:\n            result[i] = data[i] * 3\n        else:\n            result[i] = data[i]\n    \n    # Additional processing\n    for i in range(len(result)):\n        if result[i] < 0:\n            result[i] = 0\n        elif result[i] > 100:\n            result[i] = 100\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:59:16", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray, threshold: float) -> np.ndarray:\n    result = np.zeros(len(data))\n    \n    for i in range(len(data)):\n        if data[i] < threshold:\n            result[i] = data[i] ** 2\n        elif data[i] >= threshold and data[i] < 2 * threshold:\n            result[i] = data[i] * 3\n        else:\n            result[i] = data[i] / 2\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 05:59:23", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                if item % 2 == 0:\n                    priorities[i] = 6\n                else:\n                    priorities[i] = 5\n            elif item > 10 and bins[i] > 8:\n                if item % 3 == 0:\n                    priorities[i] = 5\n                else:\n                    priorities[i] = 4\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                if item % 2 == 0:\n                    priorities[i] = 4\n                else:\n                    priorities[i] = 3\n            elif item > 8 and bins[i] > 4:\n                if item % 3 == 0:\n                    priorities[i] = 3\n                else:\n                    priorities[i] = 2\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                if item % 2 == 0:\n                    priorities[i] = 3\n                else:\n                    priorities[i] = 2\n            elif item > 3 and bins[i] > 2:\n                if item % 3 == 0:\n                    priorities[i] = 2\n                else:\n                    priorities[i] = 1\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                if item % 2 == 0:\n                    priorities[i] = 2\n                else:\n                    priorities[i] = 1\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                if item % 2 == 0:\n                    priorities[i] = 6\n                else:\n                    priorities[i] = 5\n            elif item > 10 and bins[i] > 8:\n                if item % 3 == 0:\n                    priorities[i] = 5\n                else:\n                    priorities[i] = 4\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                if item % 2 == 0:\n                    priorities[i] = 4\n                else:\n                    priorities[i] = 3\n            elif item > 8 and bins[i] > 4:\n                if item % 3 == 0:\n                    priorities[i] = 3\n                else:\n                    priorities[i] = 2\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                if item % 2 == 0:\n                    priorities[i] = 3\n                else:\n                    priorities[i] = 2\n            elif item > 3 and bins[i] > 2:\n                if item % 3 == 0:\n                    priorities[i] = 2\n                else:\n                    priorities[i] = 1\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                if item % 2 == 0:\n                    priorities[i] = 2\n                else:\n                    priorities[i] = 1\n            else:\n                priorities[i] = 1\n        else:\n            priorities[i] = 0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:59:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                if item % 2 == 0:\n                    priorities[i] = 6\n                else:\n                    priorities[i] = 5\n            elif item > 10 and bins[i] > 8:\n                if item % 3 == 0:\n                    priorities[i] = 5\n                else:\n                    priorities[i] = 4\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                if item % 2 == 0:\n                    priorities[i] = 4\n                else:\n                    priorities[i] = 3\n            elif item > 8 and bins[i] > 4:\n                if item % 3 == 0:\n                    priorities[i] = 3\n                else:\n                    priorities[i] = 2\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                if item % 2 == 0:\n                    priorities[i] = 3\n                else:\n                    priorities[i] = 2\n            elif item > 3 and bins[i] > 2:\n                if item % 3 == 0:\n                    priorities[i] = 2\n                else:\n                    priorities[i] = 1\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                if item % 2 == 0:\n                    priorities[i] = 2\n                else:\n                    priorities[i] = 1\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                if item % 2 == 0:\n                    priorities[i] = 6\n                else:\n                    priorities[i] = 5\n            elif item > 10 and bins[i] > 8:\n                if item % 3 == 0:\n                    priorities[i] = 5\n                else:\n                    priorities[i] = 4\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                if item % 2 == 0:\n                    priorities[i] = 4\n                else:\n                    priorities[i] = 3\n            elif item > 8 and bins[i] > 4:\n                if item % 3 == 0:\n                    priorities[i] = 3\n                else:\n                    priorities[i] = 2\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                if item % 2 == 0:\n                    priorities[i] = 3\n                else:\n                    priorities[i] = 2\n            elif item > 3 and bins[i] > 2:\n                if item % 3 == 0:\n                    priorities[i] = 2\n                else:\n                    priorities[i] = 1\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                if item % 2 == 0:\n                    priorities[i] = 2\n                else:\n                    priorities[i] = 1\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:59:32", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                if item % 2 == 0:\n                    priorities[i] = 6\n                else:\n                    priorities[i] = 5\n            elif item > 10 and bins[i] > 8:\n                if item % 3 == 0:\n                    priorities[i] = 5\n                else:\n                    priorities[i] = 4\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                if item % 2 == 0:\n                    priorities[i] = 4\n                else:\n                    priorities[i] = 3\n            elif item > 8 and bins[i] > 4:\n                if item % 3 == 0:\n                    priorities[i] = 3\n                else:\n                    priorities[i] = 2\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                if item % 2 == 0:\n                    priorities[i] = 3\n                else:\n                    priorities[i] = 2\n            elif item > 3 and bins[i] > 2:\n                if item % 3 == 0:\n                    priorities[i] = 2\n                else:\n                    priorities[i] = 1\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                if item % 2 == 0:\n                    priorities[i] = 2\n                else:\n                    priorities[i] = 1\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1:\n            priorities[i] = 10\n        elif ratios[i] > 0.9:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 9\n            elif item > 15 and bins[i] > 10:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 0.8:\n            if item > 12 and bins[i] > 8:\n                priorities[i] = 7\n            elif item > 10 and bins[i] > 6:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.7:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 5\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.5:\n            if item > 4 and bins[i] > 3:\n                priorities[i] = 4\n            elif item > 2 and bins[i] > 2:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] > 0.3:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:59:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                if item % 2 == 0:\n                    priorities[i] = 6\n                else:\n                    priorities[i] = 5\n            elif item > 10 and bins[i] > 8:\n                if item % 3 == 0:\n                    priorities[i] = 5\n                else:\n                    priorities[i] = 4\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                if item % 2 == 0:\n                    priorities[i] = 4\n                else:\n                    priorities[i] = 3\n            elif item > 8 and bins[i] > 4:\n                if item % 3 == 0:\n                    priorities[i] = 3\n                else:\n                    priorities[i] = 2\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                if item % 2 == 0:\n                    priorities[i] = 3\n                else:\n                    priorities[i] = 2\n            elif item > 3 and bins[i] > 2:\n                if item % 3 == 0:\n                    priorities[i] = 2\n                else:\n                    priorities[i] = 1\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                if item % 2 == 0:\n                    priorities[i] = 2\n                else:\n                    priorities[i] = 1\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 0.9:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] >= 0.8:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] >= 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        elif ratios[i] >= 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if item > 10 and bins[i] > 5:\n            priorities[i] = 6\n        elif item > 8 and bins[i] > 4:\n            priorities[i] = 5\n        elif item > 5 and bins[i] > 3:\n            priorities[i] = 4\n        elif item > 2 and bins[i] > 1:\n            priorities[i] = 3\n        elif bins[i] >= 1:\n            priorities[i] = 2\n        else:\n            priorities[i] = 1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 05:59:45", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:59:49", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.tan(5*ratio) + np.sin(3*ratio) - np.cos(2*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(2*ratio) * np.log(1.8*ratio) + np.sqrt(2*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(1.5*ratio) * np.sinh(ratio) - np.tanh(0.8*ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio) + np.arcsin(ratio)\n        else:\n            priority = np.arccos(ratio) + np.arctan(ratio) + np.arcsinh(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:59:52", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(10*ratio) + np.cos(5*ratio) - np.tan(2*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(2*ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(2*ratio) * np.cos(2*ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio) - ratio\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 05:59:56", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(matrix: np.ndarray) -> np.ndarray:\n    result = []\n\n    for row in matrix:\n        row_sum = np.sum(row)\n        if row_sum < 10:\n            new_row = [elem * 2 for elem in row]\n        elif row_sum >= 10 and row_sum < 20:\n            new_row = [elem ** 2 for elem in row]\n        elif row_sum >= 20 and row_sum < 30:\n            new_row = [elem + 10 for elem in row]\n        else:\n            new_row = [elem - 5 for elem in row]\n\n        result.append(new_row)\n\n    return np.array(result)", "strategy": []}
{"timestamp": "2025-04-27 05:59:59", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros(data.shape)\n    \n    for i in range(data.shape[0]):\n        for j in range(data.shape[1]):\n            if data[i, j] % 2 == 0:\n                result[i, j] = data[i, j] * 2\n            elif data[i, j] % 3 == 0:\n                result[i, j] = data[i, j] * 3\n            else:\n                result[i, j] = data[i, j] * 4\n                \n    return result\n```", "strategy": []}
{"timestamp": "2025-04-27 06:00:02", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(input_data: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(input_data)\n    \n    for i in range(len(input_data)):\n        if input_data[i] % 2 == 0:\n            result[i] = input_data[i] * 2\n        else:\n            result[i] = input_data[i] + 1\n            \n    for i in range(1, len(input_data)):\n        if result[i] > result[i - 1]:\n            result[i] = result[i] - result[i - 1]\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 06:00:04", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(matrix: np.ndarray) -> np.ndarray:\n    result = np.zeros(matrix.shape)\n    \n    for i in range(matrix.shape[0]):\n        for j in range(matrix.shape[1]):\n            if matrix[i, j] % 2 == 0:\n                result[i, j] = matrix[i, j] * 2\n            else:\n                result[i, j] = matrix[i, j] + 1\n                \n    return result", "strategy": []}
{"timestamp": "2025-04-27 06:00:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros(len(data))\n    \n    for i in range(len(data)):\n        if data[i] % 2 == 0:\n            result[i] = data[i] * 2\n        elif data[i] % 3 == 0:\n            result[i] = data[i] * 3\n        else:\n            result[i] = data[i] + 1\n    \n    return result\n```", "strategy": []}
{"timestamp": "2025-04-27 06:00:10", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    sorted_bins = np.sort(bins)\n    n = len(bins)\n    \n    for i in range(n):\n        if i == 0:\n            priorities[i] = abs(item - sorted_bins[i])\n        elif i == n-1:\n            priorities[i] = abs(item - sorted_bins[i])\n        else:\n            priorities[i] = abs(item - sorted_bins[i]) / (sorted_bins[n-1] - sorted_bins[0])\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Further improved version of `priority_v1`.\n    Now considering additional factors for priority calculation.\n    \"\"\"\n    \n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n    \n    # Add an additional factor based on bin capacity ratio\n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        priorities[i] += 0.5 * (max_bin_capacity - bins[i])  # Adjust priority based on capacity ratio\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_complex(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n    \n    # Adjust priority based on bin capacity ratio\n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        priorities[i] += 0.5 * (max_bin_capacity - bins[i])  # Adjust priority based on capacity ratio\n    \n    # Add more complexity based on bin ratios\n    min_bin_capacity = np.min(bins)\n    for i in range(len(bins)):\n        if bins[i] == max_bin_capacity:\n            priorities[i] -= 1.5 * min_bin_capacity  # Adjust priority for max capacity bins based on min capacity\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:00:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    sorted_bins = np.sort(bins)\n    n = len(bins)\n    \n    for i in range(n):\n        if i == 0:\n            priorities[i] = abs(item - sorted_bins[i])\n        elif i == n-1:\n            priorities[i] = abs(item - sorted_bins[i])\n        else:\n            priorities[i] = abs(item - sorted_bins[i]) / (sorted_bins[n-1] - sorted_bins[0])\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Further improved version of `priority_v1`.\n    Now considering additional factors for priority calculation.\n    \"\"\"\n    \n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n    \n    # Add an additional factor based on bin capacity ratio\n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        priorities[i] += 0.5 * (max_bin_capacity - bins[i])  # Adjust priority based on capacity ratio\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 3 * (item - bins[i])  # Triple the priority\n        else:\n            priorities[i] = 2 * (bins[i] - item)  # Double the priority\n\n    # Add multiple factors to prioritize bins\n    for i in range(len(bins)):\n        if bins[i] < 0.5 * item:\n            priorities[i] += 0.5 * (item - bins[i])  # Adjust priority for smaller bins\n        elif bins[i] < 0.8 * item:\n            priorities[i] += 0.2 * (item - bins[i])  # Adjust priority for medium bins\n        else:\n            priorities[i] += 0.1 * (item - bins[i])  # Adjust priority for larger bins\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:00:16", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    sorted_bins = np.sort(bins)\n    n = len(bins)\n    \n    for i in range(n):\n        if i == 0:\n            priorities[i] = abs(item - sorted_bins[i])\n        elif i == n-1:\n            priorities[i] = abs(item - sorted_bins[i])\n        else:\n            priorities[i] = abs(item - sorted_bins[i]) / (sorted_bins[n-1] - sorted_bins[0])\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Further improved version of `priority_v1`.\n    Now considering additional factors for priority calculation.\n    \"\"\"\n    \n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n    \n    # Add an additional factor based on bin capacity ratio\n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        priorities[i] += 0.5 * (max_bin_capacity - bins[i])  # Adjust priority based on capacity ratio\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = 0.5 * bins[i] - item  # Adjust priority based on item and bin capacity\n    \n    # Add an additional factor based on bin capacity ratio\n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        priorities[i] += 0.5 * (max_bin_capacity - bins[i])  # Adjust priority based on capacity ratio\n        \n    # Consider the proximity of bin capacity to the item size\n    min_distance = np.min(np.abs(bins - item))\n    for i in range(len(bins)):\n        priorities[i] += 0.2 * (min_distance - np.abs(bins[i] - item))  # Adjust priority based on proximity\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:00:19", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    sorted_bins = np.sort(bins)\n    n = len(bins)\n    \n    for i in range(n):\n        if i == 0:\n            priorities[i] = abs(item - sorted_bins[i])\n        elif i == n-1:\n            priorities[i] = abs(item - sorted_bins[i])\n        else:\n            priorities[i] = abs(item - sorted_bins[i]) / (sorted_bins[n-1] - sorted_bins[0])\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Further improved version of `priority_v1`.\n    Now considering additional factors for priority calculation.\n    \"\"\"\n    \n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n    \n    # Add an additional factor based on bin capacity ratio\n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        priorities[i] += 0.5 * (max_bin_capacity - bins[i])  # Adjust priority based on capacity ratio\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Further improved version of `priority_v1`.\n    Now considering even more factors for priority calculation.\n    \"\"\"\n    \n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n    \n    # Add additional factor based on bin capacity ratio\n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        priorities[i] += 0.5 * (max_bin_capacity - bins[i])  # Adjust priority based on capacity ratio\n    \n    # Add another factor based on item size and bin capacity\n    half_item_size = item / 2\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] += 0.3 * (item - bins[i])  # Adjust based on difference\n        else:\n            priorities[i] += 0.3 * (half_item_size - bins[i])  # Adjust based on item size\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:00:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 3 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 3 == 1:\n                priorities[i] = (item + 2) / bins[i]\n            else:\n                priorities[i] = (item + 3) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i]) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i]) + np.log10(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.log2(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            if item % 2 == 0:\n                priorities[i] = np.sin(item / bins[i]) + np.cos(item / bins[i])\n            elif item % 2 == 1:\n                priorities[i] = np.sqrt(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.exp(item / bins[i]) + np.log(item / bins[i])\n        elif item > bins[i]/3 and item <= bins[i]*2/3:\n            if item % 3 == 0:\n                priorities[i] = np.tan(item / bins[i]) + np.arctan(item / bins[i])\n            elif item % 3 == 1:\n                priorities[i] = np.tanh(item / bins[i]) + np.arctanh(item / bins[i])\n            else:\n                priorities[i] = np.sinh(item / bins[i]) + np.cosh(item / bins[i])\n        else:\n            if item % 4 == 0:\n                priorities[i] = np.tan(np.log(item / bins[i])) + np.log(np.tan(item / bins[i]))\n            elif item % 4 == 1:\n                priorities[i] = np.arcsin(item / bins[i]) + np.arccos(item / bins[i])\n            elif item % 4 == 2:\n                priorities[i] = np.arcsinh(item / bins[i]) + np.arccosh(item / bins[i])\n            else:\n                priorities[i] = np.tanh(np.log(item / bins[i])) + np.log(np.tanh(item / bins[i]))\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:00:38", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 3 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 3 == 1:\n                priorities[i] = (item + 2) / bins[i]\n            else:\n                priorities[i] = (item + 3) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i]) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i]) + np.log10(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.log2(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            priorities[i] = np.sin(item) + np.cos(bins[i])\n        elif item > bins[i]/3 and item <= bins[i]/2:\n            priorities[i] = np.tan(item) * np.arctan(bins[i])\n        elif item > bins[i]/2 and item <= 2*bins[i]/3:\n            priorities[i] = np.exp(item) + np.exp(bins[i])\n        elif item > 2*bins[i]/3 and item <= bins[i]:\n            priorities[i] = np.log(item) * np.log1p(bins[i])\n        else:\n            priorities[i] = np.sqrt(item) + np.cbrt(bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:00:43", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 3 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 3 == 1:\n                priorities[i] = (item + 2) / bins[i]\n            else:\n                priorities[i] = (item + 3) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i]) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i]) + np.log10(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.log2(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of priority calculation.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 4 == 0:\n                priorities[i] = np.log(item / bins[i]) + np.exp(item / bins[i])\n            elif item % 4 == 1:\n                priorities[i] = np.sqrt(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 4 == 2:\n                priorities[i] = np.log1p(item / bins[i]) + np.square(item / bins[i])\n            else:\n                priorities[i] = np.exp(item / bins[i]) + np.cbrt(item / bins[i])\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.cbrt(item / bins[i]) + np.log10(item / bins[i])\n            elif bins[i] % 3 == 1:\n                priorities[i] = np.square(item / bins[i]) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.log1p(item / bins[i]) + np.exp(item / bins[i])\n        else:\n            if item % 6 == 0:\n                priorities[i] = np.cbrt(item / bins[i]) + np.square(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 6 == 1:\n                priorities[i] = np.log(item / bins[i]) + np.log10(item / bins[i]) + np.log1p(item / bins[i])\n            elif item % 6 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.cbrt(item / bins[i]) + np.square(item / bins[i])\n            elif item % 6 == 3:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 6 == 4:\n                priorities[i] = np.log1p(item / bins[i]) + np.square(item / bins[i]) + np.log10(item / bins[i])\n            else:\n                priorities[i] = np.exp(item / bins[i]) + np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:00:47", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 3 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 3 == 1:\n                priorities[i] = (item + 2) / bins[i]\n            else:\n                priorities[i] = (item + 3) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i]) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i]) + np.log10(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.log2(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 4 == 0:\n                priorities[i] = (item + 3) / bins[i]\n            elif item % 4 == 1:\n                priorities[i] = (item + 2) / bins[i]\n            elif item % 4 == 2:\n                priorities[i] = (item + 1) / bins[i]\n            else:\n                priorities[i] = (item + 4) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.cbrt(item / bins[i]) + np.square(item / bins[i])\n            elif bins[i] % 3 == 1:\n                priorities[i] = np.log(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.sqrt(item / bins[i]) + np.log10(item / bins[i])\n        else:\n            if item % 6 == 0:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 6 == 1:\n                priorities[i] = np.square(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 6 == 2:\n                priorities[i] = np.log2(item / bins[i]) + np.log1p(item / bins[i])\n            elif item % 6 == 3:\n                priorities[i] = np.sqrt(item / bins[i]) + np.square(item / bins[i])\n            elif item % 6 == 4:\n                priorities[i] = np.log10(item / bins[i]) + np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i]) + np.log2(item / bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:01:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 3 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 3 == 1:\n                priorities[i] = (item + 2) / bins[i]\n            else:\n                priorities[i] = (item + 3) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i]) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i]) + np.log10(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.log2(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 3 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 3 == 1:\n                priorities[i] = (item + 2) / bins[i]\n            else:\n                priorities[i] = (item + 3) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i]) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i]) + np.log10(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.log2(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            if item % 4 == 0:\n                priorities[i] = (item + 2) / bins[i]\n            elif item % 4 == 1:\n                priorities[i] = (item + 3) / bins[i]\n            elif item % 4 == 2:\n                priorities[i] = (item + 4) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]/2:\n            priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i]) + np.cbrt(item / bins[i])\n        elif item > bins[i]/2 and item <= 2*bins[i]/3:\n            priorities[i] = np.log10(item / bins[i]) + np.square(item / bins[i]) + np.cbrt(item / bins[i])\n        elif item > 2*bins[i]/3 and item <= bins[i]:\n            priorities[i] = np.log1p(item / bins[i]) + np.sqrt(item / bins[i]) + np.square(item / bins[i])\n        else:\n            priorities[i] = np.log2(item / bins[i]) + np.log1p(item / bins[i]) + np.square(item / bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:01:10", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 3 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 3 == 1:\n                priorities[i] = (item + 2) / bins[i]\n            else:\n                priorities[i] = (item + 3) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i]) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i]) + np.log10(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.log2(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 3 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 3 == 1:\n                priorities[i] = (item + 2) / bins[i]\n            else:\n                priorities[i] = (item + 3) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i]) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i]) + np.log10(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.log2(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            if item % 4 == 0:\n                priorities[i] = (item + 2) / bins[i]\n            elif item % 4 == 1:\n                priorities[i] = (item + 3) / bins[i]\n            elif item % 4 == 2:\n                priorities[i] = (item + 4) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]*2/3:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.sqrt(item / bins[i]) + np.log(item / bins[i])\n            elif bins[i] % 3 == 1:\n                priorities[i] = np.cbrt(item / bins[i]) + np.log10(item / bins[i])\n            else:\n                priorities[i] = np.log2(item / bins[i]) + np.square(item / bins[i])\n        else:\n            if item % 6 == 0:\n                priorities[i] = np.log(item / bins[i]) + np.square(item / bins[i])\n            elif item % 6 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 6 == 2:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 6 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 6 == 4:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i]) + np.square(item / bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:01:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 3 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 3 == 1:\n                priorities[i] = (item + 2) / bins[i]\n            else:\n                priorities[i] = (item + 3) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i]) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i]) + np.log10(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.log2(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 3 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 3 == 1:\n                priorities[i] = (item + 2) / bins[i]\n            else:\n                priorities[i] = (item + 3) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i]) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i]) + np.log10(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.log2(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 3 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 3 == 1:\n                priorities[i] = (item + 2) / bins[i]\n            else:\n                priorities[i] = (item + 3) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i]) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i]) + np.log10(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.log2(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n        priorities[i] = np.clip(priorities[i], 0, 1)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:01:21", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 3 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 3 == 1:\n                priorities[i] = (item + 2) / bins[i]\n            else:\n                priorities[i] = (item + 3) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i]) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i]) + np.log10(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.log2(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 3 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 3 == 1:\n                priorities[i] = (item + 2) / bins[i]\n            else:\n                priorities[i] = (item + 3) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i]) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i]) + np.log10(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.log2(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/4:\n            if item % 4 == 0:\n                priorities[i] = (item + 2) / bins[i]\n            elif item % 4 == 1:\n                priorities[i] = (item + 3) / bins[i]\n            elif item % 4 == 2:\n                priorities[i] = (item + 4) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/4 and item <= bins[i]/2:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.sqrt(item / bins[i]) + np.log(item / bins[i])\n            elif bins[i] % 3 == 1:\n                priorities[i] = np.cbrt(item / bins[i]) + np.log10(item / bins[i])\n            else:\n                priorities[i] = np.square(item / bins[i]) + np.log2(item / bins[i])\n        elif item > bins[i]/2 and item <= 3*bins[i]/4:\n            if item % 6 == 0:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 6 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 6 == 2:\n                priorities[i] = np.log2(item / bins[i]) + np.square(item / bins[i])\n            elif item % 6 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 6 == 4:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.log2(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 4:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 5:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log2(item / bins[i]) + np.square(item / bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:01:37", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            if ratio % 2 == 0:\n                priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio) - np.log10(ratio)\n            else:\n                priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio) + np.log10(ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) * np.sin(ratio)\n        elif ratio >= 0.9 and ratio < 1.1:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio) - np.arcsin(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio) + np.sinh(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 06:01:41", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(7*ratio) + np.cos(4*ratio) - np.tan(2*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(1.5*ratio) * np.log(1.5*ratio) + np.sqrt(2*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(1.5*ratio) * np.sinh(1.5*ratio) - np.tanh(1.5*ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(2*ratio) * np.cos(2*ratio) * np.tan(2*ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 06:01:45", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.1 and ratio < 0.3:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.3 and ratio < 0.5:\n            priority = np.exp(ratio) * np.log(ratio) - np.sqrt(1.5*ratio)\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        elif ratio >= 0.9 and ratio < 1.0:\n            priority = np.arcsin(ratio) + np.arccos(ratio) - np.arctan(ratio)\n        else:\n            priority = np.arctan(ratio) + np.arccosh(ratio) - np.arcsinh(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 06:01:47", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.cos(3*ratio) - np.tan(1.5*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) * np.tan(1.5*ratio) + np.sin(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(1.5*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.sin(ratio) * np.cos(ratio) * np.tan(ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 06:01:57", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 3 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 3 == 1:\n                priorities[i] = (item + 2) / bins[i]\n            else:\n                priorities[i] = (item + 3) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i]) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i]) + np.log10(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.log2(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 3 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 3 == 1:\n                priorities[i] = (item + 2) / bins[i]\n            else:\n                priorities[i] = (item + 3) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i]) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i]) + np.log10(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.log2(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = (item + 2) / bins[i]\n            else:\n                priorities[i] = (item + 3) / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]/2:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.sqrt(item / bins[i]) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i]) + np.log10(item / bins[i])\n        else:\n            if item % 4 == 0:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 4 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 4 == 2:\n                priorities[i] = np.log2(item / bins[i]) + np.square(item / bins[i])\n            else:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:02:02", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 3 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 3 == 1:\n                priorities[i] = (item + 2) / bins[i]\n            else:\n                priorities[i] = (item + 3) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i]) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i]) + np.log10(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.log2(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 3 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 3 == 1:\n                priorities[i] = (item + 2) / bins[i]\n            else:\n                priorities[i] = (item + 3) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i]) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i]) + np.log10(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.log2(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            if item % 4 == 0:\n                priorities[i] = (item + 2) / bins[i]\n            elif item % 4 == 1:\n                priorities[i] = (item + 3) / bins[i]\n            elif item % 4 == 2:\n                priorities[i] = (item + 4) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]/2:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.sqrt(item / bins[i]) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i]) + np.log2(item / bins[i])\n        else:\n            if item % 6 == 0:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i]) + np.sin(item / bins[i])\n            elif item % 6 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i]) + np.cos(item / bins[i])\n            elif item % 6 == 2:\n                priorities[i] = np.log2(item / bins[i]) + np.square(item/bins[i]) + np.tan(item / bins[i])\n            elif item % 6 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i]) + np.arcsin(item / bins[i])\n            elif item % 6 == 4:\n                priorities[i] = np.exp(item / bins[i]) + np.cosh(item / bins[i]) + np.sinh(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i]) + np.arccos(item / bins[i])\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:02:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 3 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 3 == 1:\n                priorities[i] = (item + 2) / bins[i]\n            else:\n                priorities[i] = (item + 3) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i]) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i]) + np.log10(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.log2(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 3 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 3 == 1:\n                priorities[i] = (item + 2) / bins[i]\n            else:\n                priorities[i] = (item + 3) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i]) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i]) + np.log10(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.log2(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:02:10", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 3 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 3 == 1:\n                priorities[i] = (item + 2) / bins[i]\n            else:\n                priorities[i] = (item + 3) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i]) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i]) + np.log10(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.log2(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 3 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 3 == 1:\n                priorities[i] = (item + 2) / bins[i]\n            else:\n                priorities[i] = (item + 3) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i]) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i]) + np.log10(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.log2(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 4 == 0:\n                priorities[i] = (item + 2) / bins[i]\n            elif item % 4 == 1:\n                priorities[i] = (item + 4) / bins[i]\n            elif item % 4 == 2:\n                priorities[i] = (item + 6) / bins[i]\n            else:\n                priorities[i] = (item + 8) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.sqrt(item / bins[i]) + np.log(item / bins[i]) + np.square(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i]) + np.log10(item / bins[i]) + np.square(item / bins[i])\n        else:\n            if item % 6 == 0:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 6 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i]) + np.square(item / bins[i])\n            elif item % 6 == 2:\n                priorities[i] = np.log2(item / bins[i]) + np.square(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 6 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i]) + np.log(item / bins[i])\n            elif item % 6 == 4:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i]) + np.log2(item / bins[i])\n            else:\n                priorities[i] = np.abs(item / bins[i]) + np.square(item / bins[i]) + np.log(item / bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:02:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1:\n            priorities[i] = 10\n        elif ratios[i] > 0.9:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 9\n            elif item > 15 and bins[i] > 10:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 0.8:\n            if item > 12 and bins[i] > 8:\n                priorities[i] = 7\n            elif item > 10 and bins[i] > 6:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.7:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 5\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.5:\n            if item > 4 and bins[i] > 3:\n                priorities[i] = 4\n            elif item > 2 and bins[i] > 2:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] > 0.3:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1:\n            priorities[i] = 10\n        elif ratios[i] > 0.9:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 9\n            elif item > 15 and bins[i] > 10:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 0.8:\n            if item > 12 and bins[i] > 8:\n                priorities[i] = 7\n            elif item > 10 and bins[i] > 6:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.7:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 5\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.5:\n            if item > 4 and bins[i] > 3:\n                priorities[i] = 4\n            elif item > 2 and bins[i] > 2:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] > 0.3:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        elif item == bins[i]:\n            priorities[i] = 5\n        else:\n            diff = bins[i] - item\n            if diff > 10:\n                priorities[i] = 8\n            elif diff > 5:\n                priorities[i] = 6\n            elif diff >= 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:02:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1:\n            priorities[i] = 10\n        elif ratios[i] > 0.9:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 9\n            elif item > 15 and bins[i] > 10:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 0.8:\n            if item > 12 and bins[i] > 8:\n                priorities[i] = 7\n            elif item > 10 and bins[i] > 6:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.7:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 5\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.5:\n            if item > 4 and bins[i] > 3:\n                priorities[i] = 4\n            elif item > 2 and bins[i] > 2:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] > 0.3:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1:\n            priorities[i] = 10\n        elif ratios[i] > 0.9:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 9\n            elif item > 15 and bins[i] > 10:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 0.8:\n            if item > 12 and bins[i] > 8:\n                priorities[i] = 7\n            elif item > 10 and bins[i] > 6:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.7:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 5\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.5:\n            if item > 4 and bins[i] > 3:\n                priorities[i] = 4\n            elif item > 2 and bins[i] > 2:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] > 0.3:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1:\n            priorities[i] = 10\n        elif ratios[i] > 0.9:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 9\n            elif item > 15 and bins[i] > 10:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        else:\n            if item > 10 and bins[i] > 5:\n                priorities[i] = 6\n            elif item > 8 and bins[i] > 4:\n                priorities[i] = 5\n            elif item > 6 and bins[i] > 3:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:02:36", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1:\n            priorities[i] = 10\n        elif ratios[i] > 0.9:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 9\n            elif item > 15 and bins[i] > 10:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 0.8:\n            if item > 12 and bins[i] > 8:\n                priorities[i] = 7\n            elif item > 10 and bins[i] > 6:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.7:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 5\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.5:\n            if item > 4 and bins[i] > 3:\n                priorities[i] = 4\n            elif item > 2 and bins[i] > 2:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] > 0.3:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1:\n            priorities[i] = 10\n        elif ratios[i] > 0.9:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 9\n            elif item > 15 and bins[i] > 10:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 0.8:\n            if item > 12 and bins[i] > 8:\n                priorities[i] = 7\n            elif item > 10 and bins[i] > 6:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.7:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 5\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.5:\n            if item > 4 and bins[i] > 3:\n                priorities[i] = 4\n            elif item > 2 and bins[i] > 2:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] > 0.3:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1:\n            priorities[i] = 10\n        elif ratios[i] > 0.9:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 9\n            elif item > 15 and bins[i] > 10:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 0.8:\n            if item > 12 and bins[i] > 8:\n                priorities[i] = 7\n            elif item > 10 and bins[i] > 6:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.7:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 5\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.5:\n            if item > 4 and bins[i] > 3:\n                priorities[i] = 4\n            elif item > 2 and bins[i] > 2:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] > 0.3:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:02:40", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1:\n            priorities[i] = 10\n        elif ratios[i] > 0.9:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 9\n            elif item > 15 and bins[i] > 10:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 0.8:\n            if item > 12 and bins[i] > 8:\n                priorities[i] = 7\n            elif item > 10 and bins[i] > 6:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.7:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 5\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.5:\n            if item > 4 and bins[i] > 3:\n                priorities[i] = 4\n            elif item > 2 and bins[i] > 2:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] > 0.3:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1:\n            priorities[i] = 10\n        elif ratios[i] > 0.9:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 9\n            elif item > 15 and bins[i] > 10:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 0.8:\n            if item > 12 and bins[i] > 8:\n                priorities[i] = 7\n            elif item > 10 and bins[i] > 6:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.7:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 5\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.5:\n            if item > 4 and bins[i] > 3:\n                priorities[i] = 4\n            elif item > 2 and bins[i] > 2:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] > 0.3:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            priorities[i] = 10\n        elif ratios[i] > 1.1:\n            if item > 25 and bins[i] > 20:\n                priorities[i] = 9\n            elif item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 18 and bins[i] > 12:\n                priorities[i] = 7\n            elif item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.9:\n            if item > 12 and bins[i] > 8:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 6:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.8:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 5\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.7:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 4\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] > 0.5:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:02:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                prime_flag = False\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        prime_flag = True\n                        break\n                \n                if not prime_flag:\n                    priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 06:02:53", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        if i % 2 == 0:\n                            priority = 1 / (bin_capacity - item + i)\n                        else:\n                            priority = 1.5 / (bin_capacity - item + i)\n                        break\n                    else:\n                        if bin_capacity - item > 5:\n                            priority = 1.25 / (bin_capacity - item + 2)\n                        else:\n                            priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 06:02:56", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                found_divisor = False\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        found_divisor = True\n                        break\n                if not found_divisor:\n                    priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 06:02:58", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        elif item > 2 * bin_capacity:\n            priority = -1\n        else:\n            priority = 0\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 06:03:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    # Additional complex logic for each bin\n    for j in range(len(bins)):\n        if item % (bins[j]+1) == 0:\n            priorities[j] = priorities[j] * np.log(item / bins[j]) - np.sqrt(item / bins[j])\n        elif item % (bins[j]+1) == 1:\n            priorities[j] = priorities[j] * np.log10(item / bins[j]) - np.cbrt(item / bins[j])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:03:07", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            if item % 2 == 0:\n                priorities[i] = (item + 2) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 3*(item + 4) / bins[i]\n            else:\n                priorities[i] = (item + 6) / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]*2/3:\n            if bins[i] % 4 == 0:\n                priorities[i] = np.exp(item / bins[i]) + np.cos(item / bins[i])\n            else:\n                priorities[i] = np.tan(item / bins[i]) + np.sin(item / bins[i])\n        else:\n            if item % 9 == 0:\n                priorities[i] = np.tanh(item / bins[i]) + np.arcsin(item / bins[i])\n            elif item % 9 == 1:\n                priorities[i] = np.arctan(item / bins[i]) + np.sinh(item / bins[i])\n            elif item % 9 == 2:\n                priorities[i] = np.cosh(item / bins[i]) + np.arccos(item / bins[i])\n            elif item % 9 == 3:\n                priorities[i] = np.arcsinh(item / bins[i]) + np.cosh(item / bins[i])\n            else:\n                priorities[i] = np.arccosh(item / bins[i]) + np.tanh(item / bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:03:11", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:03:15", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]*0.7:\n            if bins[i] % 5 == 0:\n                priorities[i] = np.power(item / bins[i], 2) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log10(item / bins[i])\n        elif item > bins[i]*0.7 and item <= bins[i]:\n            if item % 4 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 4 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 4 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 4 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n        else:\n            priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:03:24", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    priorities[i] = 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Further improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([bin_item for index, bin_item in enumerate(bins) if index > i]) - item\n                if remaining_items_sum >= remaining_capacity:\n                    priorities[i] = 0.9\n                elif remaining_items_sum >= item:\n                    priorities[i] = 0.7\n                else:\n                    priorities[i] = 0.5\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:03:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    priorities[i] = 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Most sophisticated version of `priority` function.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    total_available_capacity = 0\n                    for bin in bins:\n                        total_available_capacity += bin\n                    if total_available_capacity >= 3 * item:\n                        priorities[i] = 0.8\n                    else:\n                        priorities[i] = 0.5\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:03:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    priorities[i] = 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([(bin_cap - sum(bins[:ind])) for ind, bin_cap in enumerate(bins) if ind > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:03:34", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    priorities[i] = 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more advanced version of the priority function.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            \n            for j in range(i):\n                used_capacity += bins[j]\n                \n            remaining_capacity -= used_capacity\n            \n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priority = (item - remaining_capacity) / (bins[i] - remaining_capacity)\n                \n                if priority > 0.7:\n                    priorities[i] = priority\n                elif priority > 0.3:\n                    priorities[i] = 0.6\n                else:\n                    priorities[i] = 0.4\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:03:38", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    prev_priorities_sum = sum(priorities[:i])\n                    remaining_capacity_items = [(index, item_value) for index, item_value in enumerate(bins) if index > i]\n                    remaining_capacity_items.sort(key=lambda x: x[1])\n                    for index, item_value in remaining_capacity_items:\n                        if item <= remaining_capacity + item_value:\n                            priorities[i] = 0.8 + prev_priorities_sum\n                            break\n                        prev_priorities_sum += 0.05\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    prev_priorities_sum = sum(priorities[:i])\n                    remaining_capacity_items = [(index, item_value) for index, item_value in enumerate(bins) if index > i]\n                    remaining_capacity_items.sort(key=lambda x: x[1])\n                    for index, item_value in remaining_capacity_items:\n                        if item <= remaining_capacity + item_value:\n                            priorities[i] = 0.8 + prev_priorities_sum\n                            break\n                        prev_priorities_sum += 0.05\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:03:41", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    prev_priorities_sum = sum(priorities[:i])\n                    remaining_capacity_items = [(index, item_value) for index, item_value in enumerate(bins) if index > i]\n                    remaining_capacity_items.sort(key=lambda x: x[1])\n                    for index, item_value in remaining_capacity_items:\n                        if item <= remaining_capacity + item_value:\n                            priorities[i] = 0.8 + prev_priorities_sum\n                            break\n                        prev_priorities_sum += 0.05\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    prev_priorities_sum = sum(priorities[:i])\n                    remaining_capacity_items = [(index, item_value) for index, item_value in enumerate(bins) if index > i]\n                    remaining_capacity_items.sort(key=lambda x: x[1])\n                    for index, item_value in remaining_capacity_items:\n                        if item <= remaining_capacity + item_value:\n                            priorities[i] = 0.8 + prev_priorities_sum\n                            break\n                        prev_priorities_sum += 0.05\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:03:45", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    prev_priorities_sum = sum(priorities[:i])\n                    remaining_capacity_items = [(index, item_value) for index, item_value in enumerate(bins) if index > i]\n                    remaining_capacity_items.sort(key=lambda x: x[1])\n                    for index, item_value in remaining_capacity_items:\n                        if item <= remaining_capacity + item_value:\n                            priorities[i] = 0.8 + prev_priorities_sum\n                            break\n                        prev_priorities_sum += 0.05\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                main_condition_met = False\n                for j in range(i+1, len(bins)):\n                    items_sum = sum(bins[j:])\n                    if items_sum >= item:\n                        priorities[i] = 0.9\n                        main_condition_met = True\n                        break\n                if not main_condition_met:\n                    prev_priorities_sum = sum(priorities[:i])\n                    remaining_capacity_items = [(index, item_value) for index, item_value in enumerate(bins) if index > i]\n                    remaining_capacity_items.sort(key=lambda x: x[1])\n                    for index, item_value in remaining_capacity_items:\n                        if item <= remaining_capacity + item_value:\n                            priorities[i] = 0.8 + prev_priorities_sum\n                            break\n                        prev_priorities_sum += 0.05\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:03:48", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    prev_priorities_sum = sum(priorities[:i])\n                    remaining_capacity_items = [(index, item_value) for index, item_value in enumerate(bins) if index > i]\n                    remaining_capacity_items.sort(key=lambda x: x[1])\n                    for index, item_value in remaining_capacity_items:\n                        if item <= remaining_capacity + item_value:\n                            priorities[i] = 0.8 + prev_priorities_sum\n                            break\n                        prev_priorities_sum += 0.05\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n\n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    prev_priorities_sum = sum(priorities[:i])\n                    remaining_capacity_items = [(index, item_value) for index, item_value in enumerate(bins) if index > i]\n                    remaining_capacity_items.sort(key=lambda x: x[1])\n                    for index, item_value in remaining_capacity_items:\n                        if item <= remaining_capacity + item_value:\n                            priorities[i] = 0.8 + prev_priorities_sum\n                            break\n                        prev_priorities_sum += 0.05\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:03:53", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.4\n                else:\n                    priority += 0.6\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 1.8\n            elif priority < 0.4:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.7\n                else:\n                    priorities[j] = 0.4\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.1 * item:\n                    priority += 0.1\n                elif remaining_capacity < 0.3 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.6\n                else:\n                    priority += 0.9\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 1.5\n            elif priority < 0.4:\n                priorities[i] *= 0.6\n            else:\n                priorities[i] *= 1.1\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.6\n                else:\n                    priorities[j] = 0.3\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:03:56", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.4\n                else:\n                    priority += 0.6\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 1.8\n            elif priority < 0.4:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.7\n                else:\n                    priorities[j] = 0.4\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.25 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.4\n                else:\n                    priority += 0.6\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.6\n            else:\n                priorities[i] *= 1.3\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.5\n                else:\n                    priorities[j] = 0.3\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:03:59", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.4\n                else:\n                    priority += 0.6\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 1.8\n            elif priority < 0.4:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.7\n                else:\n                    priorities[j] = 0.4\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            if item > 1.5 * bins[i]:\n                priority += 0.8\n            elif item > 1.2 * bins[i]:\n                priority += 0.6\n            else:\n                priority += 0.4\n            \n            while remaining_capacity < item:\n                if remaining_capacity < 0.3 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n                \n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 1.5\n            elif priority < 0.5:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.1\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.6\n                else:\n                    priorities[j] = 0.3\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:04:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.4\n                else:\n                    priority += 0.6\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 1.8\n            elif priority < 0.4:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.7\n                else:\n                    priorities[j] = 0.4\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.4\n                else:\n                    priority += 0.6\n                remaining_capacity += bins[i]\n            \n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 1.8\n            elif priority < 0.4:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.7\n                else:\n                    priorities[j] = 0.4\n            \n            for k in range(len(bins)):\n                if priorities[k] < 0.5:\n                    priorities[k] *= 0.5\n                elif priorities[k] > 1.0:\n                    priorities[k] = 1.0\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:04:08", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        elif remaining_capacity < -10:\n            priorities[i] = 0\n        else:\n            priorities[i] = -np.log(np.abs(ratio)) + np.sqrt(remaining_capacity)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:04:10", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(matrix: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(matrix)\n    \n    for i in range(matrix.shape[0]):\n        for j in range(matrix.shape[1]):\n            if matrix[i, j] % 2 == 0:\n                result[i, j] = matrix[i, j] * 2\n            elif matrix[i, j] % 3 == 0:\n                result[i, j] = matrix[i, j] * 3\n            else:\n                result[i, j] = matrix[i, j] * 4\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 06:04:12", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(input_data: np.ndarray) -> np.ndarray:\n    output_data = np.zeros(input_data.shape)\n\n    for i in range(input_data.shape[0]):\n        for j in range(input_data.shape[1]):\n            if input_data[i, j] > 0:\n                output_data[i, j] = input_data[i, j] ** 2\n            else:\n                output_data[i, j] = abs(input_data[i, j]) * 2\n    \n    return output_data", "strategy": []}
{"timestamp": "2025-04-27 06:04:15", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros(len(data))\n    \n    for i in range(len(data)):\n        if data[i] % 2 == 0:\n            result[i] = data[i] * 2\n        elif data[i] % 3 == 0:\n            result[i] = data[i] * 3\n        else:\n            result[i] = data[i]\n    \n    for i in range(len(result)):\n        if result[i] < 0:\n            result[i] = 0\n            \n    return result", "strategy": []}
{"timestamp": "2025-04-27 06:04:18", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.log(np.exp(ratio) + np.sqrt(ratio)) * np.cos(np.pi * ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.tan(np.sin(ratio)) + np.arctan(np.cos(ratio))\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.log10(np.exp2(ratio)) + np.sqrt(np.log1p(ratio))\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.arccos(np.arcsin(ratio)) * np.tanh(np.sinh(ratio))\n        else:\n            priority = np.cosh(np.sinh(ratio)) - np.tan(np.cos(ratio)) + np.sqrt(np.log1p(np.exp(ratio)))\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 06:04:21", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio) + np.sin(ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = 2 * np.cosh(ratio) + np.tan(3*ratio) - np.arccos(ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.arctan(ratio) + np.tanh(ratio) - np.cos(ratio)\n        else:\n            priority = np.tan(ratio) + np.cbrt(ratio) + np.exp(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 06:04:24", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.power(2*ratio, 3) + np.log(ratio) - np.sqrt(ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.arctan(ratio) * np.tan(3*ratio) + np.sin(5*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.cosh(ratio) * np.sinh(2*ratio) - np.tanh(ratio) + np.arcsin(ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.tanh(ratio) * np.cos(4*ratio) + np.exp(ratio)\n        else:\n            priority = np.sqrt(ratio) * np.cbrt(ratio) + np.power(ratio, 2)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 06:04:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.1:\n            priority = (3*ratio) ** 2 + np.sqrt(np.log(ratio)) - np.cbrt(ratio)\n        elif ratio >= 0.1 and ratio < 0.5:\n            priority = np.cos(5*ratio) * np.tan(3*ratio) + np.sin(7*ratio)\n        elif ratio >= 0.5 and ratio < 0.8:\n            priority = np.sinh(ratio) * np.cosh(ratio) + np.arctan(ratio) + np.cosh(ratio)\n        else:\n            priority = np.tan(ratio) * np.cosh(ratio) - np.tanh(ratio) + np.arccos(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 06:04:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if 0.1 <= utilization < 0.3:\n                    priorities[i] = 2 / (1 - utilization)\n                elif 0.3 <= utilization < 0.5:\n                    priorities[i] = 3 / (1 + utilization)\n                elif 0.5 <= utilization < 0.7:\n                    priorities[i] = 4 * np.sqrt(utilization)\n                elif 0.7 <= utilization < 0.9:\n                    priorities[i] = 5 * utilization\n                elif 0.9 <= utilization <= 1.0:\n                    priorities[i] = 6 * np.log(utilization + 1)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:04:37", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef complex_function(input_data: np.ndarray) -> np.ndarray:\n    output_data = np.zeros_like(input_data)\n    \n    for i in range(len(input_data)):\n        if input_data[i] < 0:\n            output_data[i] = -input_data[i]\n        else:\n            if input_data[i] % 2 == 0:\n                output_data[i] = input_data[i] * 2\n            else:\n                output_data[i] = input_data[i] ** 2\n    \n    return output_data", "strategy": []}
{"timestamp": "2025-04-27 06:04:39", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(data)\n    \n    for i in range(len(data)):\n        if data[i] % 2 == 0:\n            result[i] = data[i] * 2\n        elif data[i] % 3 == 0:\n            result[i] = data[i] * 3\n        else:\n            for j in range(1, data[i] + 1):\n                if data[i] % j == 0:\n                    result[i] += j\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 06:04:43", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n                else:\n                    priorities[i] = 3.14  # Assign a special value for other cases\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:04:48", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = 0.5 * bins[i] - item  # Adjust priority based on item and bin capacity\n    \n    # Add an additional factor based on bin capacity ratio\n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        priorities[i] += 0.5 * (max_bin_capacity - bins[i])  # Adjust priority based on capacity ratio\n        \n    # Consider the proximity of bin capacity to the item size\n    min_distance = np.min(np.abs(bins - item))\n    for i in range(len(bins)):\n        priorities[i] += 0.2 * (min_distance - np.abs(bins[i] - item))  # Adjust priority based on proximity\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n    \n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        if bins[i] == max_bin_capacity:\n            priorities[i] += 1.5 * max_bin_capacity  # Increase priority for bins with max capacity\n        elif bins[i] <= 0.5 * max_bin_capacity:\n            priorities[i] -= 0.3 * bins[i]  # Decrease priority for bins with very low capacity\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n    \n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        if bins[i] == max_bin_capacity:\n            priorities[i] += 1.5 * max_bin_capacity  # Increase priority for bins with max capacity\n        elif bins[i] <= 0.5 * max_bin_capacity:\n            priorities[i] -= 0.3 * bins[i]  # Decrease priority for bins with very low capacity\n    \n    # Add additional complexity based on item value\n    if item > np.mean(bins):\n        for i in range(len(bins)):\n            if bins[i] >= 0.8 * item:\n                priorities[i] += 0.8 * item  # Increase priority for bins with high capacity relative to item\n    else:\n        for i in range(len(bins)):\n            if bins[i] <= 0.4 * item:\n                priorities[i] += 0.3 * item  # Increase priority for bins with low capacity relative to item\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:04:52", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = 0.5 * bins[i] - item  # Adjust priority based on item and bin capacity\n    \n    # Add an additional factor based on bin capacity ratio\n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        priorities[i] += 0.5 * (max_bin_capacity - bins[i])  # Adjust priority based on capacity ratio\n        \n    # Consider the proximity of bin capacity to the item size\n    min_distance = np.min(np.abs(bins - item))\n    for i in range(len(bins)):\n        priorities[i] += 0.2 * (min_distance - np.abs(bins[i] - item))  # Adjust priority based on proximity\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n    \n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        if bins[i] == max_bin_capacity:\n            priorities[i] += 1.5 * max_bin_capacity  # Increase priority for bins with max capacity\n        elif bins[i] <= 0.5 * max_bin_capacity:\n            priorities[i] -= 0.3 * bins[i]  # Decrease priority for bins with very low capacity\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n    \n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        if bins[i] == max_bin_capacity:\n            priorities[i] += 1.5 * max_bin_capacity  # Increase priority for bins with max capacity\n        elif bins[i] <= 0.5 * max_bin_capacity:\n            priorities[i] -= 0.3 * bins[i]  # Decrease priority for bins with very low capacity\n        \n    min_capacity = np.min(bins)\n    total_capacity = np.sum(bins)\n    avg_capacity = total_capacity / len(bins)\n    for i in range(len(bins)):\n        if bins[i] == min_capacity:\n            priorities[i] += 2 * min_capacity  # Increase priority for bins with the minimum capacity\n        elif bins[i] > 0.8 * avg_capacity:\n            priorities[i] -= 0.2 * bins[i]  # Decrease priority for bins with high capacity\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:04:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = 0.5 * bins[i] - item  # Adjust priority based on item and bin capacity\n    \n    # Add an additional factor based on bin capacity ratio\n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        priorities[i] += 0.5 * (max_bin_capacity - bins[i])  # Adjust priority based on capacity ratio\n        \n    # Consider the proximity of bin capacity to the item size\n    min_distance = np.min(np.abs(bins - item))\n    for i in range(len(bins)):\n        priorities[i] += 0.2 * (min_distance - np.abs(bins[i] - item))  # Adjust priority based on proximity\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n    \n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        if bins[i] == max_bin_capacity:\n            priorities[i] += 1.5 * max_bin_capacity  # Increase priority for bins with max capacity\n        elif bins[i] <= 0.5 * max_bin_capacity:\n            priorities[i] -= 0.3 * bins[i]  # Decrease priority for bins with very low capacity\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])\n        else:\n            priorities[i] = bins[i] - item\n\n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] == max_bin_capacity:\n            priorities[i] += 1.5 * max_bin_capacity\n        elif bins[i] == min_bin_capacity:\n            priorities[i] += 0.5 * min_bin_capacity\n        else:\n            priorities[i] += 0.8 * np.mean(bins)  # Increase priority for bins with capacity close to the mean\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:04:58", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = 0.5 * bins[i] - item  # Adjust priority based on item and bin capacity\n    \n    # Add an additional factor based on bin capacity ratio\n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        priorities[i] += 0.5 * (max_bin_capacity - bins[i])  # Adjust priority based on capacity ratio\n        \n    # Consider the proximity of bin capacity to the item size\n    min_distance = np.min(np.abs(bins - item))\n    for i in range(len(bins)):\n        priorities[i] += 0.2 * (min_distance - np.abs(bins[i] - item))  # Adjust priority based on proximity\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n    \n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        if bins[i] == max_bin_capacity:\n            priorities[i] += 1.5 * max_bin_capacity  # Increase priority for bins with max capacity\n        elif bins[i] <= 0.5 * max_bin_capacity:\n            priorities[i] -= 0.3 * bins[i]  # Decrease priority for bins with very low capacity\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])\n        else:\n            priorities[i] = bins[i] - item\n\n    max_bin_capacity = np.max(bins)\n    for i in range(len(bins)):\n        if bins[i] == max_bin_capacity:\n            priorities[i] += 1.5 * max_bin_capacity\n        elif bins[i] <= 0.5 * max_bin_capacity:\n            priorities[i] -= 0.3 * bins[i]\n\n    total_capacity = np.sum(bins)\n    capacity_ratio = bins / total_capacity\n    for i in range(len(bins)):\n        if capacity_ratio[i] >= 0.3:\n            priorities[i] += 0.5 * capacity_ratio[i] * max_bin_capacity\n        elif capacity_ratio[i] < 0.1:\n            priorities[i] -= 0.2 * bins[i]\n\n    min_bin_capacity = np.min(bins)\n    for i in range(len(bins)):\n        if bins[i] == min_bin_capacity:\n            priorities[i] = 0  # Remove priority for bins with minimum capacity\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:05:05", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n                \n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n                \n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:05:10", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:05:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Further improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n\n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    for j in range(len(priorities)):\n        priorities[j] = (priorities[j] - min_priority) / (max_priority - min_priority)\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:05:18", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    def function_1(x, y):\n        return x * y + x - y\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = function_1(item, bins[i])\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:05:24", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.1\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.8 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 2.0\n            elif priority < 0.4:\n                priorities[i] *= 0.6\n            else:\n                priorities[i] *= 1.5\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.8\n                else:\n                    priorities[j] = 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            if item > 1.5 * bins[i]:\n                priority += 0.8\n            elif item > 1.2 * bins[i]:\n                priority += 0.6\n            else:\n                priority += 0.4\n            \n            while remaining_capacity < item:\n                if remaining_capacity < 0.3 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n                \n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 1.5\n            elif priority < 0.5:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.1\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.6\n                else:\n                    priorities[j] = 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            \n            if item > 1.5 * bins[i]:\n                priority += 0.8\n            elif item > 1.2 * bins[i]:\n                priority += 0.6\n            else:\n                priority += 0.4\n            \n            while remaining_capacity < item:\n                if remaining_capacity < 0.3 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n                \n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 1.5\n            elif priority < 0.5:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.1\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.6\n                else:\n                    priorities[j] = 0.3\n                    \n            for k in range(3):\n                priorities[i] -= 0.1\n                \n            if priorities[i] < 0.1:\n                priorities[i] = 0.1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:05:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.1\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.8 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 2.0\n            elif priority < 0.4:\n                priorities[i] *= 0.6\n            else:\n                priorities[i] *= 1.5\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.8\n                else:\n                    priorities[j] = 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            if item > 1.5 * bins[i]:\n                priority += 0.8\n            elif item > 1.2 * bins[i]:\n                priority += 0.6\n            else:\n                priority += 0.4\n            \n            while remaining_capacity < item:\n                if remaining_capacity < 0.3 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n                \n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 1.5\n            elif priority < 0.5:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.1\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.6\n                else:\n                    priorities[j] = 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            if item > 1.5 * bins[i]:\n                priority += 0.9\n            elif item > 1.2 * bins[i]:\n                priority += 0.7\n            elif item > bins[i]:\n                priority += 0.4\n            else:\n                priority += 0.3\n            \n            while remaining_capacity < item:\n                if remaining_capacity < 0.3 * item:\n                    priority += 0.4\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.6\n                else:\n                    priority += 0.8\n                remaining_capacity += bins[i]\n                \n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 1.6\n            elif priority < 0.4:\n                priorities[i] *= 0.9\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.7\n                else:\n                    priorities[j] = 0.4\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:05:31", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.1\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.8 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 2.0\n            elif priority < 0.4:\n                priorities[i] *= 0.6\n            else:\n                priorities[i] *= 1.5\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.8\n                else:\n                    priorities[j] = 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            if item > 1.5 * bins[i]:\n                priority += 0.8\n            elif item > 1.2 * bins[i]:\n                priority += 0.6\n            else:\n                priority += 0.4\n            \n            while remaining_capacity < item:\n                if remaining_capacity < 0.3 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n                \n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 1.5\n            elif priority < 0.5:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.1\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.6\n                else:\n                    priorities[j] = 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            if item > 1.5 * bins[i]:\n                priority += 0.8\n            elif item > 1.2 * bins[i]:\n                priority += 0.6\n            else:\n                priority += 0.4\n            \n            while remaining_capacity < item:\n                if remaining_capacity < 0.3 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n                \n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 1.5\n            elif priority < 0.5:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.1\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.6\n                else:\n                    priorities[j] = 0.3\n    \n    # Additional complex logic here\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:05:36", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.1\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.8 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 2.0\n            elif priority < 0.4:\n                priorities[i] *= 0.6\n            else:\n                priorities[i] *= 1.5\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.8\n                else:\n                    priorities[j] = 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            if item > 1.5 * bins[i]:\n                priority += 0.8\n            elif item > 1.2 * bins[i]:\n                priority += 0.6\n            else:\n                priority += 0.4\n            \n            while remaining_capacity < item:\n                if remaining_capacity < 0.3 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n                \n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 1.5\n            elif priority < 0.5:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.1\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.6\n                else:\n                    priorities[j] = 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            if item > 1.5 * bins[i]:\n                priority += 0.8\n            elif item > 1.2 * bins[i]:\n                priority += 0.6\n            else:\n                priority += 0.4\n            \n            while remaining_capacity < item:\n                if remaining_capacity < 0.4 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.7 * item:\n                    priority += 0.4\n                else:\n                    priority += 0.6\n                remaining_capacity += bins[i]\n                \n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 1.3\n            elif priority < 0.4:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.0\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.5\n                else:\n                    priorities[j] = 0.2\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:05:43", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/4:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 3*(item + 4) / bins[i]\n            else:\n                priorities[i] = (item + 7) / bins[i]\n        elif item > bins[i]/4 and item <= bins[i]/2:\n            if bins[i] % 4 == 0:\n                priorities[i] = np.power(item / bins[i], 2) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 1.2) + np.log10(item / bins[i])\n        elif item > bins[i]/2 and item <= bins[i] - 5:\n            if item % 5 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.square(item / bins[i])\n        else:\n            if item % 6 == 0:\n                priorities[i] = np.cosh(item / bins[i]) + np.tanh(item / bins[i])\n            elif item % 6 == 1:\n                priorities[i] = np.sinh(item / bins[i]) + np.tanh(item / bins[i])\n            elif item % 6 == 2:\n                priorities[i] = np.arcsinh(item / bins[i]) + np.arctanh(item / bins[i])\n            elif item % 6 == 3:\n                priorities[i] = np.cosh(item / bins[i]) + np.arctanh(item / bins[i])\n            else:\n                priorities[i] = np.sinh(item / bins[i]) + np.arcsinh(item / bins[i])\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:05:47", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = 2*(item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 3*(item + 3) / bins[i]\n            else:\n                priorities[i] = 4*(item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.3) + np.log1p(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.8) + np.log2(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log1p(item / bins[i]) + np.exp(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = 2*np.log(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.sqrt(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log2(item / bins[i]) + np.exp(item / bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:05:51", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            if item % 2 == 0:\n                priorities[i] = (item + 2) / bins[i]\n            elif item % 2 == 1:\n                if bins[i] % 2 == 0:\n                    priorities[i] = (item + 4) / bins[i]\n                else:\n                    priorities[i] = (item + 6) / bins[i]\n            else:\n                priorities[i] = (item + 8) / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]*2/3:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.8) + np.log(item / bins[i])\n            elif bins[i] % 3 == 1:\n                priorities[i] = np.power(item / bins[i], 0.6) + np.log10(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.9) + np.log2(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log1p(item / bins[i]) + np.square(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:05:55", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n            if item % 2 == 0:\n                priorities[i] *= 1.1\n            elif item % 3 == 1:\n                priorities[i] *= 1.2\n            else:\n                priorities[i] *= 0.9\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:06:09", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n        \n        if bins[i] < 0.5 * item:\n            priorities[i] *= 1.5  # Increase priority for bins with low capacity\n        elif bins[i] > 1.5 * item:\n            priorities[i] *= 0.5  # Decrease priority for bins with high capacity\n        else:\n            priorities[i] *= 1.0  # Keep priority unchanged\n        \n        if i % 2 == 0:\n            priorities[i] += 2  # Add additional priority for even-indexed bins\n        else:\n            priorities[i] -= 1  # Reduce priority for odd-indexed bins\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 3 * (item - bins[i])  # Triple the priority\n        else:\n            priorities[i] = 2 * (bins[i] - item)  # Double the priority\n\n    # Add multiple factors to prioritize bins\n    for i in range(len(bins)):\n        if bins[i] < 0.5 * item:\n            priorities[i] += 0.5 * (item - bins[i])  # Adjust priority for smaller bins\n        elif bins[i] < 0.8 * item:\n            priorities[i] += 0.2 * (item - bins[i])  # Adjust priority for medium bins\n        else:\n            priorities[i] += 0.1 * (item - bins[i])  # Adjust priority for larger bins\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 4 * (item - bins[i])  # Quadruple the priority\n        else:\n            priorities[i] = 3 * (bins[i] - item)  # Triple the priority\n\n    # Add multiple factors to prioritize bins\n    for i in range(len(bins)):\n        if bins[i] < 0.5 * item:\n            priorities[i] += 0.3 * (item - bins[i])  # Adjust priority for smaller bins\n        elif bins[i] < 0.8 * item:\n            priorities[i] += 0.2 * (item - bins[i])  # Adjust priority for medium bins\n        else:\n            priorities[i] += 0.1 * (item - bins[i])  # Adjust priority for larger bins\n        \n        if i % 3 == 0:\n            priorities[i] += 3  # Add more priority for bins with index divisible by 3\n        elif i % 2 == 0:\n            priorities[i] += 2  # Add priority for even-indexed bins\n        else:\n            priorities[i] -= 1  # Reduce priority for odd-indexed bins\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:06:12", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n        \n        if bins[i] < 0.5 * item:\n            priorities[i] *= 1.5  # Increase priority for bins with low capacity\n        elif bins[i] > 1.5 * item:\n            priorities[i] *= 0.5  # Decrease priority for bins with high capacity\n        else:\n            priorities[i] *= 1.0  # Keep priority unchanged\n        \n        if i % 2 == 0:\n            priorities[i] += 2  # Add additional priority for even-indexed bins\n        else:\n            priorities[i] -= 1  # Reduce priority for odd-indexed bins\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 3 * (item - bins[i])  # Triple the priority\n        else:\n            priorities[i] = 2 * (bins[i] - item)  # Double the priority\n\n    # Add multiple factors to prioritize bins\n    for i in range(len(bins)):\n        if bins[i] < 0.5 * item:\n            priorities[i] += 0.5 * (item - bins[i])  # Adjust priority for smaller bins\n        elif bins[i] < 0.8 * item:\n            priorities[i] += 0.2 * (item - bins[i])  # Adjust priority for medium bins\n        else:\n            priorities[i] += 0.1 * (item - bins[i])  # Adjust priority for larger bins\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 4 * (item - bins[i])  # Quadruple the priority\n        else:\n            priorities[i] = 3 * (bins[i] - item)  # Triple the priority\n\n    for i in range(len(bins)):\n        if bins[i] < 0.3 * item:\n            priorities[i] += 0.3 * (item - bins[i])  # Adjust priority for very small bins\n        elif bins[i] < 0.6 * item:\n            priorities[i] += 0.2 * (item - bins[i])  # Adjust priority for small bins\n        elif bins[i] < 0.8 * item:\n            priorities[i] += 0.1 * (item - bins[i])  # Adjust priority for medium bins\n        else:\n            priorities[i] += 0.05 * (item - bins[i])  # Adjust priority for larger bins\n        \n        if i % 3 == 0:\n            priorities[i] += 3  # Add additional priority for bins at every third index\n        elif i % 3 == 1:\n            priorities[i] -= 2  # Reduce priority for bins at every third index + 1\n        else:\n            priorities[i] += 0.5  # Add small priority for bins at every third index + 2\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:06:16", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n        \n        if bins[i] < 0.5 * item:\n            priorities[i] *= 1.5  # Increase priority for bins with low capacity\n        elif bins[i] > 1.5 * item:\n            priorities[i] *= 0.5  # Decrease priority for bins with high capacity\n        else:\n            priorities[i] *= 1.0  # Keep priority unchanged\n        \n        if i % 2 == 0:\n            priorities[i] += 2  # Add additional priority for even-indexed bins\n        else:\n            priorities[i] -= 1  # Reduce priority for odd-indexed bins\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 3 * (item - bins[i])  # Triple the priority\n        else:\n            priorities[i] = 2 * (bins[i] - item)  # Double the priority\n\n    # Add multiple factors to prioritize bins\n    for i in range(len(bins)):\n        if bins[i] < 0.5 * item:\n            priorities[i] += 0.5 * (item - bins[i])  # Adjust priority for smaller bins\n        elif bins[i] < 0.8 * item:\n            priorities[i] += 0.2 * (item - bins[i])  # Adjust priority for medium bins\n        else:\n            priorities[i] += 0.1 * (item - bins[i])  # Adjust priority for larger bins\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 4 * (item - bins[i])  # Quadruple the priority\n        else:\n            priorities[i] = 3 * (bins[i] - item)  # Triple the priority\n        \n        if bins[i] < 0.3 * item:\n            priorities[i] += 0.6 * (item - bins[i])  # Adjust priority for very small bins\n        elif bins[i] < 0.6 * item:\n            priorities[i] += 0.4 * (item - bins[i])  # Adjust priority for small bins\n        elif bins[i] < 0.9 * item:\n            priorities[i] += 0.2 * (item - bins[i])  # Adjust priority for medium bins\n        else:\n            priorities[i] += 0.1 * (item - bins[i])  # Adjust priority for larger bins\n        \n        if i % 3 == 0:\n            priorities[i] += 3  # Add more priority for every third bin\n        elif i % 2 == 0:\n            priorities[i] += 2  # Add additional priority for even-indexed bins\n        else:\n            priorities[i] -= 1  # Reduce priority for odd-indexed bins\n        \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:06:20", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n        \n        if bins[i] < 0.5 * item:\n            priorities[i] *= 1.5  # Increase priority for bins with low capacity\n        elif bins[i] > 1.5 * item:\n            priorities[i] *= 0.5  # Decrease priority for bins with high capacity\n        else:\n            priorities[i] *= 1.0  # Keep priority unchanged\n        \n        if i % 2 == 0:\n            priorities[i] += 2  # Add additional priority for even-indexed bins\n        else:\n            priorities[i] -= 1  # Reduce priority for odd-indexed bins\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 3 * (item - bins[i])  # Triple the priority\n        else:\n            priorities[i] = 2 * (bins[i] - item)  # Double the priority\n\n    # Add multiple factors to prioritize bins\n    for i in range(len(bins)):\n        if bins[i] < 0.5 * item:\n            priorities[i] += 0.5 * (item - bins[i])  # Adjust priority for smaller bins\n        elif bins[i] < 0.8 * item:\n            priorities[i] += 0.2 * (item - bins[i])  # Adjust priority for medium bins\n        else:\n            priorities[i] += 0.1 * (item - bins[i])  # Adjust priority for larger bins\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 4 * (item - bins[i])  # Quadruple the priority\n        else:\n            priorities[i] = 2 * (bins[i] - item)  # Double the priority\n        \n        if bins[i] < 0.3 * item:\n            priorities[i] += 0.6 * (item - bins[i])  # Adjust priority for very small bins\n        elif bins[i] < 0.6 * item:\n            priorities[i] += 0.3 * (item - bins[i])  # Adjust priority for small bins\n        elif bins[i] < 0.9 * item:\n            priorities[i] += 0.1 * (item - bins[i])  # Adjust priority for medium bins\n        else:\n            priorities[i] += 0.05 * (item - bins[i])  # Adjust priority for large bins\n        \n        if i % 3 == 0:\n            priorities[i] += 3  # Add extra priority for every third bin\n        elif i % 3 == 1:\n            priorities[i] -= 1  # Reduce priority for bins with index of (3n+1)\n        else:\n            priorities[i] += 0.5  # Add a small bonus priority for the rest of the bins\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:06:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.1:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.1 <= utilization < 0.3:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.3 <= utilization < 0.5:\n                    priorities[i] = 3\n                elif 0.5 <= utilization < 0.7:\n                    priorities[i] = 4 * utilization\n                elif 0.7 <= utilization < 0.9:\n                    priorities[i] = 5 * np.log(utilization)\n                elif 0.9 <= utilization <= 1.0:\n                    priorities[i] = 6 * np.sqrt(utilization)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:06:32", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(data)\n    \n    for i in range(len(data)):\n        if data[i] % 2 == 0:\n            result[i] = data[i] ** 2\n        else:\n            if data[i] < 0:\n                result[i] = 0\n            else:\n                temp = 1\n                for j in range(1, data[i] + 1):\n                    temp *= j\n                result[i] = temp\n    \n    return result\n```", "strategy": []}
{"timestamp": "2025-04-27 06:06:34", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(data)\n    \n    for i in range(len(data)):\n        if data[i] % 2 == 0:\n            result[i] = data[i] * 2\n        else:\n            if data[i] < 0:\n                result[i] = data[i] - 10\n            else:\n                result[i] = data[i] + 10\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 06:06:37", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n                else:\n                    priorities[i] = 0  # Assign 0 if utilization is outside [0, 1]\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:06:42", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.4\n                else:\n                    priority += 0.6\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 1.8\n            elif priority < 0.4:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.7\n                else:\n                    remaining_capacity = bins[j]\n                    priority = 0.0\n                    while remaining_capacity < item:\n                        if remaining_capacity < 0.2 * item:\n                            priority += 0.1\n                        elif remaining_capacity < 0.5 * item:\n                            priority += 0.3\n                        else:\n                            priority += 0.5\n                        remaining_capacity += bins[j]\n                    priorities[j] = priority\n                    \n                    if priority > 0.5:\n                        priorities[j] *= 1.6\n                    elif priority < 0.3:\n                        priorities[j] *= 0.8\n                    else:\n                        priorities[j] *= 1.1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            \n            if priority > 0.5:\n                priorities[i] = 0.8\n            elif priority < 0.3:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.7\n                \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 1.0\n                else:\n                    remaining_capacity = bins[j]\n                    priority = 0.0\n                    while remaining_capacity < item:\n                        priority += 0.2\n                        remaining_capacity += bins[j]\n                    priorities[j] = priority * 0.9\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.8\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 1.5\n            elif priority < 0.4:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.9\n                else:\n                    remaining_capacity = bins[j]\n                    priority = 0.0\n                    while remaining_capacity < item:\n                        if remaining_capacity < 0.2 * item:\n                            priority += 0.2\n                        elif remaining_capacity < 0.5 * item:\n                            priority += 0.4\n                        else:\n                            priority += 0.7\n                        remaining_capacity += bins[j]\n                    priorities[j] = priority\n                    \n                    if priority > 0.5:\n                        priorities[j] *= 1.3\n                    elif priority < 0.3:\n                        priorities[j] *= 0.7\n                    else:\n                        priorities[j] *= 1.1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:06:46", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.4\n                else:\n                    priority += 0.6\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 1.8\n            elif priority < 0.4:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.7\n                else:\n                    remaining_capacity = bins[j]\n                    priority = 0.0\n                    while remaining_capacity < item:\n                        if remaining_capacity < 0.2 * item:\n                            priority += 0.1\n                        elif remaining_capacity < 0.5 * item:\n                            priority += 0.3\n                        else:\n                            priority += 0.5\n                        remaining_capacity += bins[j]\n                    priorities[j] = priority\n                    \n                    if priority > 0.5:\n                        priorities[j] *= 1.6\n                    elif priority < 0.3:\n                        priorities[j] *= 0.8\n                    else:\n                        priorities[j] *= 1.1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            \n            if priority > 0.5:\n                priorities[i] = 0.8\n            elif priority < 0.3:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.7\n                \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 1.0\n                else:\n                    remaining_capacity = bins[j]\n                    priority = 0.0\n                    while remaining_capacity < item:\n                        priority += 0.2\n                        remaining_capacity += bins[j]\n                    priorities[j] = priority * 0.9\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.1 * item:\n                    priority += 0.1\n                elif remaining_capacity < 0.3 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n            \n            if priority > 0.6:\n                priorities[i] = 0.9\n            elif priority < 0.4:\n                priorities[i] = 0.7\n            else:\n                priorities[i] = 0.8\n                \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 1.0\n                else:\n                    remaining_capacity = bins[j]\n                    priority = 0.0\n                    while remaining_capacity < item:\n                        if remaining_capacity < 0.2 * item:\n                            priority += 0.2\n                        elif remaining_capacity < 0.5 * item:\n                            priority += 0.4\n                        else:\n                            priority += 0.6\n                        remaining_capacity += bins[j]\n                    priorities[j] = priority * 0.8\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:06:49", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.4\n                else:\n                    priority += 0.6\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 1.8\n            elif priority < 0.4:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.7\n                else:\n                    remaining_capacity = bins[j]\n                    priority = 0.0\n                    while remaining_capacity < item:\n                        if remaining_capacity < 0.2 * item:\n                            priority += 0.1\n                        elif remaining_capacity < 0.5 * item:\n                            priority += 0.3\n                        else:\n                            priority += 0.5\n                        remaining_capacity += bins[j]\n                    priorities[j] = priority\n                    \n                    if priority > 0.5:\n                        priorities[j] *= 1.6\n                    elif priority < 0.3:\n                        priorities[j] *= 0.8\n                    else:\n                        priorities[j] *= 1.1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            \n            if priority > 0.5:\n                priorities[i] = 0.8\n            elif priority < 0.3:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.7\n                \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 1.0\n                else:\n                    remaining_capacity = bins[j]\n                    priority = 0.0\n                    while remaining_capacity < item:\n                        priority += 0.2\n                        remaining_capacity += bins[j]\n                    priorities[j] = priority * 0.9\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.25 * item:\n                    priority += 0.15\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.3\n                else:\n                    priority += 0.5\n                remaining_capacity += bins[i]\n            \n            if priority > 0.4:\n                priorities[i] = 0.9\n            elif priority < 0.2:\n                priorities[i] = 0.7\n            else:\n                priorities[i] = 0.8\n                \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 1.0\n                else:\n                    remaining_capacity = bins[j]\n                    priority = 0.0\n                    while remaining_capacity < item:\n                        if remaining_capacity < 0.3 * item:\n                            priority += 0.2\n                        elif remaining_capacity < 0.6 * item:\n                            priority += 0.4\n                        else:\n                            priority += 0.6\n                        remaining_capacity += bins[j]\n                    priorities[j] = priority * 0.9\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:06:53", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.4\n                else:\n                    priority += 0.6\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 1.8\n            elif priority < 0.4:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.7\n                else:\n                    remaining_capacity = bins[j]\n                    priority = 0.0\n                    while remaining_capacity < item:\n                        if remaining_capacity < 0.2 * item:\n                            priority += 0.1\n                        elif remaining_capacity < 0.5 * item:\n                            priority += 0.3\n                        else:\n                            priority += 0.5\n                        remaining_capacity += bins[j]\n                    priorities[j] = priority\n                    \n                    if priority > 0.5:\n                        priorities[j] *= 1.6\n                    elif priority < 0.3:\n                        priorities[j] *= 0.8\n                    else:\n                        priorities[j] *= 1.1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            \n            if priority > 0.5:\n                priorities[i] = 0.8\n            elif priority < 0.3:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.7\n                \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 1.0\n                else:\n                    remaining_capacity = bins[j]\n                    priority = 0.0\n                    while remaining_capacity < item:\n                        priority += 0.2\n                        remaining_capacity += bins[j]\n                    priorities[j] = priority * 0.9\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Advanced version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.1\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.3\n                else:\n                    priority += 0.5\n                remaining_capacity += bins[i]\n            \n            if priority > 0.5:\n                priorities[i] = 0.8\n            elif priority < 0.3:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.7\n                \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 1.0\n                else:\n                    remaining_capacity = bins[j]\n                    priority = 0.0\n                    while remaining_capacity < item:\n                        if remaining_capacity < 0.3 * item:\n                            priority += 0.2\n                        elif remaining_capacity < 0.6 * item:\n                            priority += 0.4\n                        else:\n                            priority += 0.6\n                        remaining_capacity += bins[j]\n                    if priority > 0.6:\n                        priorities[j] = 0.9\n                    elif priority < 0.4:\n                        priorities[j] = 0.7\n                    else:\n                        priorities[j] = 0.8\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:07:00", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.3 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.8\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 2.0\n            elif priority < 0.5:\n                priorities[i] *= 0.6\n            else:\n                priorities[i] *= 1.5\n            \n            if i % 2 == 0:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.8\n                    else:\n                        priorities[j] = 0.5\n            else:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.6\n                    else:\n                        priorities[j] = 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.4\n                else:\n                    priority += 0.6\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 1.8\n            elif priority < 0.4:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.7\n                else:\n                    priorities[j] = 0.4\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.1 * item:\n                    priority += 0.1\n                elif remaining_capacity < 0.4 * item:\n                    priority += 0.3\n                else:\n                    priority += 0.5\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n                if i % 2 == 0:\n                    for j in range(i+1, len(bins)):\n                        if bins[j] >= item:\n                            priorities[j] = 0.6\n                        else:\n                            priorities[j] = 0.3\n            else:\n                priorities[i] *= 0.8\n                if i % 2 != 0:\n                    for j in range(i+1, len(bins)):\n                        if bins[j] >= item:\n                            priorities[j] = 0.8\n                        else:\n                            priorities[j] = 0.4\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:07:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.3 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.8\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 2.0\n            elif priority < 0.5:\n                priorities[i] *= 0.6\n            else:\n                priorities[i] *= 1.5\n            \n            if i % 2 == 0:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.8\n                    else:\n                        priorities[j] = 0.5\n            else:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.6\n                    else:\n                        priorities[j] = 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.4\n                else:\n                    priority += 0.6\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 1.8\n            elif priority < 0.4:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.7\n                else:\n                    priorities[j] = 0.4\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.1 * item:\n                    priority += 0.1\n                elif remaining_capacity < 0.4 * item:\n                    priority += 0.3\n                else:\n                    priority += 0.5\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.5:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    if priorities[j] < 0.6:\n                        priorities[j] += 0.3\n                else:\n                    if priorities[j] > 0.2:\n                        priorities[j] -= 0.2\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:07:07", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.3 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.8\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 2.0\n            elif priority < 0.5:\n                priorities[i] *= 0.6\n            else:\n                priorities[i] *= 1.5\n            \n            if i % 2 == 0:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.8\n                    else:\n                        priorities[j] = 0.5\n            else:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.6\n                    else:\n                        priorities[j] = 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.4\n                else:\n                    priority += 0.6\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 1.8\n            elif priority < 0.4:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.7\n                else:\n                    priorities[j] = 0.4\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.1\n                elif remaining_capacity < 0.4 * item:\n                    priority += 0.3\n                else:\n                    priority += 0.5\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.4:\n                priorities[i] *= 1.5\n            elif priority < 0.2:\n                priorities[i] *= 0.6\n            else:\n                priorities[i] *= 1.2\n            \n            if i % 3 == 0:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.6\n                    else:\n                        priorities[j] = 0.3\n            elif i % 3 == 1:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.7\n                    else:\n                        priorities[j] = 0.4\n            else:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.8\n                    else:\n                        priorities[j] = 0.5\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:07:11", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.3 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.8\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 2.0\n            elif priority < 0.5:\n                priorities[i] *= 0.6\n            else:\n                priorities[i] *= 1.5\n            \n            if i % 2 == 0:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.8\n                    else:\n                        priorities[j] = 0.5\n            else:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.6\n                    else:\n                        priorities[j] = 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.4\n                else:\n                    priority += 0.6\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.6:\n                priorities[i] *= 1.8\n            elif priority < 0.4:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.2\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.7\n                else:\n                    priorities[j] = 0.4\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.15 * item:\n                    priority += 0.15\n                elif remaining_capacity < 0.4 * item:\n                    priority += 0.3\n                else:\n                    priority += 0.5\n                remaining_capacity += bins[i]\n            \n            priorities[i] = priority\n            if priority > 0.4:\n                priorities[i] *= 1.5\n            elif priority < 0.3:\n                priorities[i] *= 0.6\n            else:\n                priorities[i] *= 1.0\n                \n            if i % 3 == 0:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.6\n                    else:\n                        priorities[j] = 0.3\n            elif i % 3 == 1:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.7\n                    else:\n                        priorities[j] = 0.4\n            else:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.8\n                    else:\n                        priorities[j] = 0.5\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:07:16", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n    \n    total_capacity = sum(bins)\n    \n    if item > total_capacity:\n        msg = \"Item size exceeds total bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        remaining_capacity = total_capacity - sum(bins[:i])\n        if bins[i] >= item and remaining_capacity >= item:\n            priorities[i] = 1\n            break\n        elif i == len(bins) - 1:\n            priorities[i] = -1\n        else:\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n    \n    total_capacity = sum(bins)\n    \n    if item > total_capacity:\n        msg = \"Item size exceeds total bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        remaining_capacity = total_capacity - sum(bins[:i])\n        if bins[i] >= item and remaining_capacity >= item:\n            priorities[i] = 1\n            break\n        elif i == len(bins) - 1:\n            priorities[i] = -1\n        else:\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "import numpy as np\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n    \n    total_capacity = sum(bins)\n    \n    if item > total_capacity:\n        msg = \"Item size exceeds total bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        remaining_capacity = total_capacity - sum(bins[:i])\n        if bins[i] >= item and remaining_capacity >= item:\n            priorities[i] = 1\n            break\n        elif i == len(bins) - 1:\n            priorities[i] = -1\n        else:\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    updated_priorities = np.zeros(len(priorities))\n    max_priority = max(priorities)\n    \n    for k in range(len(priorities)):\n        if priorities[k] == -1:\n            updated_priorities[k] = 0\n        else:\n            updated_priorities[k] = priorities[k] / max_priority\n    \n    return updated_priorities", "strategy": []}
{"timestamp": "2025-04-27 06:07:20", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n    \n    total_capacity = sum(bins)\n    \n    if item > total_capacity:\n        msg = \"Item size exceeds total bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        remaining_capacity = total_capacity - sum(bins[:i])\n        if bins[i] >= item and remaining_capacity >= item:\n            priorities[i] = 1\n            break\n        elif i == len(bins) - 1:\n            priorities[i] = -1\n        else:\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n    \n    total_capacity = sum(bins)\n    \n    if item > total_capacity:\n        msg = \"Item size exceeds total bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        remaining_capacity = total_capacity - sum(bins[:i])\n        if bins[i] >= item and remaining_capacity >= item:\n            priorities[i] = 1\n            break\n        elif i == len(bins) - 1:\n            priorities[i] = -1\n        else:\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n    \n    total_capacity = sum(bins)\n    \n    if item > total_capacity:\n        msg = \"Item size exceeds total bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        remaining_capacity = total_capacity - sum(bins[:i])\n        if bins[i] >= item and remaining_capacity >= item:\n            priorities[i] = 1\n            break\n        elif i == len(bins) - 1:\n            priorities[i] = -1\n        else:\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    if all(p == -1 for p in priorities[i:j]):\n                        priorities[i] = -1\n                        break\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:07:23", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n    \n    total_capacity = sum(bins)\n    \n    if item > total_capacity:\n        msg = \"Item size exceeds total bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        remaining_capacity = total_capacity - sum(bins[:i])\n        if bins[i] >= item and remaining_capacity >= item:\n            priorities[i] = 1\n            break\n        elif i == len(bins) - 1:\n            priorities[i] = -1\n        else:\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n    \n    total_capacity = sum(bins)\n    \n    if item > total_capacity:\n        msg = \"Item size exceeds total bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        remaining_capacity = total_capacity - sum(bins[:i])\n        if bins[i] >= item and remaining_capacity >= item:\n            priorities[i] = 1\n            break\n        elif i == len(bins) - 1:\n            priorities[i] = -1\n        else:\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n    \n    total_capacity = sum(bins)\n    \n    if item > total_capacity:\n        msg = \"Item size exceeds total bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        remaining_capacity = total_capacity - sum(bins[:i])\n        if bins[i] >= item and remaining_capacity >= item:\n            priorities[i] = 1\n            break\n        elif i == len(bins) - 1:\n            priorities[i] = -1\n        else:\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n                else:\n                    for k in range(j+1, len(bins)):\n                        remaining_capacity += bins[k]\n                        if bins[k] >= item and remaining_capacity >= item:\n                            priorities[k] = (k - j) + (j - i) + 2\n                            break\n                        elif k == len(bins) - 1:\n                            priorities[i] = -1\n                            priorities[j] = -1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:07:26", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n    \n    total_capacity = sum(bins)\n    \n    if item > total_capacity:\n        msg = \"Item size exceeds total bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        remaining_capacity = total_capacity - sum(bins[:i])\n        if bins[i] >= item and remaining_capacity >= item:\n            priorities[i] = 1\n            break\n        elif i == len(bins) - 1:\n            priorities[i] = -1\n        else:\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n    \n    total_capacity = sum(bins)\n    \n    if item > total_capacity:\n        msg = \"Item size exceeds total bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        remaining_capacity = total_capacity - sum(bins[:i])\n        if bins[i] >= item and remaining_capacity >= item:\n            priorities[i] = 1\n            break\n        elif i == len(bins) - 1:\n            priorities[i] = -1\n        else:\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n    \n    total_capacity = sum(bins)\n    \n    if item > total_capacity:\n        msg = \"Item size exceeds total bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        remaining_capacity = total_capacity - sum(bins[:i])\n        \n        if bins[i] >= item and remaining_capacity >= item:\n            priorities[i] = 1\n            break\n\n        if i == len(bins) - 1:\n            priorities[i] = -1\n            break\n\n        for j in range(i+1, len(bins)):\n            remaining_capacity += bins[j]\n\n            if bins[j] >= item and remaining_capacity >= item:\n                priorities[j] = (j - i) + 1\n                break\n\n            if j == len(bins) - 1:\n                priorities[i] = -1\n                break\n    \n    if sum(priorities) == 0:\n        max_capacity_bin = max(range(len(bins)), key=lambda x: bins[x])\n        priorities[max_capacity_bin] = 1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:07:32", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            if item > 1.5 * bins[i]:\n                priority += 0.8\n            elif item > 1.2 * bins[i]:\n                priority += 0.6\n            else:\n                priority += 0.4\n            \n            while remaining_capacity < item:\n                if remaining_capacity < 0.3 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n                \n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 1.5\n            elif priority < 0.5:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.1\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.6\n                else:\n                    priorities[j] = 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            if item > 1.5 * bins[i]:\n                priority += 0.8\n            elif item > 1.2 * bins[i]:\n                priority += 0.6\n            else:\n                priority += 0.4\n            \n            while remaining_capacity < item:\n                if remaining_capacity < 0.3 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n                \n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 1.5\n            elif priority < 0.5:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.1\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.6\n                else:\n                    priorities[j] = 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            if item > 1.5 * bins[i]:\n                priority += 0.8\n            elif item > 1.2 * bins[i]:\n                priority += 0.6\n            else:\n                priority += 0.4\n            \n            while remaining_capacity < item:\n                if remaining_capacity < 0.3 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n                \n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 1.5\n            elif priority < 0.5:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.1\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.6\n                else:\n                    priorities[j] = 0.3\n            \n            if item % 2 == 0:\n                priorities[i] *= 1.2\n            else:\n                priorities[i] *= 0.9\n                \n            if bins[i] % 2 == 0:\n                priorities[i] *= 1.1\n            else:\n                priorities[i] *= 0.8\n            \n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:07:37", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            if item > 1.5 * bins[i]:\n                priority += 0.8\n            elif item > 1.2 * bins[i]:\n                priority += 0.6\n            else:\n                priority += 0.4\n            \n            while remaining_capacity < item:\n                if remaining_capacity < 0.3 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n                \n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 1.5\n            elif priority < 0.5:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.1\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.6\n                else:\n                    priorities[j] = 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            if item > 1.5 * bins[i]:\n                priority += 0.8\n            elif item > 1.2 * bins[i]:\n                priority += 0.6\n            else:\n                priority += 0.4\n            \n            while remaining_capacity < item:\n                if remaining_capacity < 0.3 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n                \n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 1.5\n            elif priority < 0.5:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.1\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.6\n                else:\n                    priorities[j] = 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            if item > 1.5 * bins[i]:\n                priority += 0.8\n            elif item > 1.2 * bins[i]:\n                priority += 0.6\n            else:\n                priority += 0.4\n            \n            while remaining_capacity < item:\n                if remaining_capacity < 0.3 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n                \n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 1.5\n            elif priority < 0.5:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.1\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.6\n                else:\n                    priorities[j] = 0.3\n            \n            if i % 2 == 0:\n                priorities[i] += 0.2\n            else:\n                priorities[i] -= 0.1\n            \n            if bin[i] < 0.3 * item:\n                priorities[i] += 0.3\n            elif bin[i] < 0.7 * item:\n                priorities[i] += 0.6\n            else:\n                priorities[i] += 0.9\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:07:41", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            if item > 1.5 * bins[i]:\n                priority += 0.8\n            elif item > 1.2 * bins[i]:\n                priority += 0.6\n            else:\n                priority += 0.4\n            \n            while remaining_capacity < item:\n                if remaining_capacity < 0.3 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n                \n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 1.5\n            elif priority < 0.5:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.1\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.6\n                else:\n                    priorities[j] = 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            if item > 1.5 * bins[i]:\n                priority += 0.8\n            elif item > 1.2 * bins[i]:\n                priority += 0.6\n            else:\n                priority += 0.4\n            \n            while remaining_capacity < item:\n                if remaining_capacity < 0.3 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n                \n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 1.5\n            elif priority < 0.5:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.1\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.6\n                else:\n                    priorities[j] = 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            if item > 1.5 * bins[i]:\n                priority += 0.8\n            elif item > 1.2 * bins[i]:\n                priority += 0.6\n            else:\n                priority += 0.4\n            \n            while remaining_capacity < item:\n                if remaining_capacity < 0.3 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n                \n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 1.5\n            elif priority < 0.5:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.1\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.6\n                else:\n                    priorities[j] = 0.3\n        \n        for k in range(i-1, -1, -1):\n            if bins[k] >= item:\n                priorities[k] = 0.8\n            else:\n                priorities[k] = 0.4\n                \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:07:44", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            if item > 1.5 * bins[i]:\n                priority += 0.8\n            elif item > 1.2 * bins[i]:\n                priority += 0.6\n            else:\n                priority += 0.4\n            \n            while remaining_capacity < item:\n                if remaining_capacity < 0.3 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n                \n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 1.5\n            elif priority < 0.5:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.1\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.6\n                else:\n                    priorities[j] = 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            if item > 1.5 * bins[i]:\n                priority += 0.8\n            elif item > 1.2 * bins[i]:\n                priority += 0.6\n            else:\n                priority += 0.4\n            \n            while remaining_capacity < item:\n                if remaining_capacity < 0.3 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n                \n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 1.5\n            elif priority < 0.5:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.1\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.6\n                else:\n                    priorities[j] = 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            if item > 1.5 * bins[i]:\n                priority += 0.8\n            elif item > 1.2 * bins[i]:\n                priority += 0.6\n            else:\n                priority += 0.4\n            \n            while remaining_capacity < item:\n                if remaining_capacity < 0.3 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n                \n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 1.5\n            elif priority < 0.5:\n                priorities[i] *= 0.8\n            else:\n                priorities[i] *= 1.1\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.6\n                else:\n                    priorities[j] = 0.3\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:07:49", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(4*ratio) * np.tan(3*ratio) + np.sin(5*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(3*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(2*ratio) * np.sinh(2*ratio) - np.tanh(2*ratio) + np.arcsin(2*ratio)\n        else:\n            priority = np.power(np.sinh(ratio), 2) - np.tan(ratio) + np.log1p(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 06:07:52", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.exp(ratio) + np.log(ratio) - np.sqrt(ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.sin(ratio) * np.cos(ratio) + np.tan(ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.arcsin(ratio) * np.arccos(ratio) + np.arctan(ratio)\n        else:\n            priority = np.cbrt(ratio) * np.sqrt(ratio) - np.square(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 06:07:55", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = np.sinh(ratio) * np.cosh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.exp2(ratio) * np.log1p(ratio) + np.sqrt(ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.tanh(ratio) * np.sinh(ratio) + np.arcsinh(ratio)\n        else:\n            priority = np.cbrt(ratio) * np.log1p(ratio) - np.arctan(ratio) + np.arccos(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 06:07:58", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = ratio ** 3 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.2 and ratio < 0.5:\n            priority = np.sin(5*ratio) * np.tan(3*ratio) + np.cos(4*ratio)\n        elif ratio >= 0.5 and ratio < 0.8:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(3*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arccos(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 06:08:07", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = []\n                for k, capacity in enumerate(bins):\n                    if capacity >= item:\n                        available_bins.append(k)\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        priorities[available_bins[idx]] = (item - bins[available_bins[idx-1]]) / (bins[available_bins[idx]] - bins[available_bins[idx-1]])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"More complex version of prioritizing bins based on item size and capacity.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = []\n                for k, capacity in enumerate(bins):\n                    if capacity >= item:\n                        available_bins.append(k)\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        priorities[available_bins[idx]] = (item - bins[available_bins[idx-1]]) / (bins[available_bins[idx]] - bins[available_bins[idx-1])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:08:10", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = []\n                for k, capacity in enumerate(bins):\n                    if capacity >= item:\n                        available_bins.append(k)\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        priorities[available_bins[idx]] = (item - bins[available_bins[idx-1]]) / (bins[available_bins[idx]] - bins[available_bins[idx-1]])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                max_diff = -1\n                selected_bin = -1\n                for idx, capacity in enumerate(bins):\n                    if capacity >= item:\n                        diff = capacity - item\n                        if diff > max_diff:\n                            max_diff = diff\n                            selected_bin = idx\n                if selected_bin != -1:\n                    priorities[selected_bin] = 1.0\n                    for j in range(i+1, selected_bin):\n                        priorities[j] = (item - bins[j-1]) / (bins[selected_bin] - bins[j-1])\n                    if selected_bin < len(bins) - 1:\n                        priorities[selected_bin + 1] = (item - bins[selected_bin]) / (bins[selected_bin + 1] - bins[selected_bin])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:08:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = []\n                for k, capacity in enumerate(bins):\n                    if capacity >= item:\n                        available_bins.append(k)\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        priorities[available_bins[idx]] = (item - bins[available_bins[idx-1]]) / (bins[available_bins[idx]] - bins[available_bins[idx-1]])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = []\n                for k, capacity in enumerate(bins):\n                    if capacity >= item:\n                        available_bins.append(k)\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        priorities[available_bins[idx]] = (item - bins[available_bins[idx-1]]) / (bins[available_bins[idx]] - bins[available_bins[idx-1])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    # Add additional logic for special cases or optimizations here\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:08:17", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Highest priority if bin has exact capacity, otherwise pro-rated.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = 1 - ((item - remaining_capacity) / (bins[i] - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = []\n                for k, capacity in enumerate(bins):\n                    if capacity >= item:\n                        available_bins.append(k)\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        priorities[available_bins[idx]] = (item - bins[available_bins[idx-1]]) / (bins[available_bins[idx]] - bins[available_bins[idx-1]])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if item > sum(bins):\n        max_capacity = max(bins)\n        max_index = np.argmax(bins)\n        priorities[max_index] = 1.0\n        return priorities\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = []\n                for k, capacity in enumerate(bins):\n                    if capacity >= item:\n                        available_bins.append(k)\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        priorities[available_bins[idx]] = (item - bins[available_bins[idx-1]]) / (bins[available_bins[idx]] - bins[available_bins[idx-1]])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:08:25", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            priorities[i] = 10\n        elif ratios[i] > 1.1:\n            if item > 25 and bins[i] > 20:\n                priorities[i] = 9\n            elif item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 18 and bins[i] > 12:\n                priorities[i] = 7\n            elif item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.9:\n            if item > 12 and bins[i] > 8:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 6:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.8:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 5\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.7:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 4\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] > 0.5:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            priorities[i] = 10\n        elif ratios[i] > 1.1:\n            if item > 25 and bins[i] > 20:\n                priorities[i] = 9\n            elif item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 18 and bins[i] > 12:\n                priorities[i] = 7\n            elif item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.9:\n            if item > 12 and bins[i] > 8:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 6:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.8:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 5\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.7:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 4\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] > 0.5:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            priorities[i] = 10\n        elif ratios[i] > 1.1:\n            if item > 25 and bins[i] > 20:\n                priorities[i] = 9\n            elif item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 18 and bins[i] > 12:\n                priorities[i] = 7\n            elif item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.9:\n            if item > 12 and bins[i] > 8:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 6:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.8:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 5\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.7:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 4\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] > 0.5:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n        # Additional logic for adjusting priority\n        if item % 2 == 0 and bins[i] % 2 == 0:\n            priorities[i] += 1\n        if item % 3 == 0 or bins[i] % 3 == 0:\n            priorities[i] += 2\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:08:31", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            priorities[i] = 10\n        elif ratios[i] > 1.1:\n            if item > 25 and bins[i] > 20:\n                priorities[i] = 9\n            elif item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 18 and bins[i] > 12:\n                priorities[i] = 7\n            elif item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.9:\n            if item > 12 and bins[i] > 8:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 6:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.8:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 5\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.7:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 4\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] > 0.5:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            priorities[i] = 10\n        elif ratios[i] > 1.1:\n            if item > 25 and bins[i] > 20:\n                priorities[i] = 9\n            elif item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 18 and bins[i] > 12:\n                priorities[i] = 7\n            elif item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.9:\n            if item > 12 and bins[i] > 8:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 6:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.8:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 5\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.7:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 4\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] > 0.5:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.5:\n            priorities[i] = 10\n        elif ratios[i] > 1.3:\n            if item > 30 and bins[i] > 25:\n                priorities[i] = 9\n            elif item > 25 and bins[i] > 20:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.2:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 7\n            elif item > 18 and bins[i] > 12:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 1.1:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 12 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 1.0:\n            if item > 10 and bins[i] > 6:\n                priorities[i] = 5\n            elif item > 8 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.9:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 4\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n", "strategy": []}
{"timestamp": "2025-04-27 06:08:36", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            priorities[i] = 10\n        elif ratios[i] > 1.1:\n            if item > 25 and bins[i] > 20:\n                priorities[i] = 9\n            elif item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 18 and bins[i] > 12:\n                priorities[i] = 7\n            elif item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.9:\n            if item > 12 and bins[i] > 8:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 6:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.8:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 5\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.7:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 4\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] > 0.5:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            priorities[i] = 10\n        elif ratios[i] > 1.1:\n            if item > 25 and bins[i] > 20:\n                priorities[i] = 9\n            elif item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 18 and bins[i] > 12:\n                priorities[i] = 7\n            elif item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.9:\n            if item > 12 and bins[i] > 8:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 6:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.8:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 5\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.7:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 4\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] > 0.5:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            if item > 30 and bins[i] > 25:\n                priorities[i] = 11\n            elif item > 25 and bins[i] > 20:\n                priorities[i] = 10\n            else:\n                priorities[i] = 9\n        elif ratios[i] > 1.1:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 15 and bins[i] > 12:\n                priorities[i] = 7\n            else:\n                priorities[i] = 6\n        elif ratios[i] > 0.9:\n            if item > 10 and bins[i] > 8:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.8:\n            if item > 6 and bins[i] > 4:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.7:\n            if item > 3 and bins[i] > 2:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.5:\n            if item > 1 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:08:41", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            priorities[i] = 10\n        elif ratios[i] > 1.1:\n            if item > 25 and bins[i] > 20:\n                priorities[i] = 9\n            elif item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 18 and bins[i] > 12:\n                priorities[i] = 7\n            elif item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.9:\n            if item > 12 and bins[i] > 8:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 6:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.8:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 5\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.7:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 4\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] > 0.5:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            priorities[i] = 10\n        elif ratios[i] > 1.1:\n            if item > 25 and bins[i] > 20:\n                priorities[i] = 9\n            elif item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 18 and bins[i] > 12:\n                priorities[i] = 7\n            elif item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.9:\n            if item > 12 and bins[i] > 8:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 6:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.8:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 5\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.7:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 4\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] > 0.5:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.5:\n            priorities[i] = 10\n        elif ratios[i] > 1.3:\n            if item > 30 and bins[i] > 25:\n                priorities[i] = 9\n            elif item > 25 and bins[i] > 20:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.2:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 7\n            elif item > 18 and bins[i] > 12:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 1.1:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 12 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 1.0:\n            if item > 10 and bins[i] > 6:\n                priorities[i] = 5\n            elif item > 8 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        else:\n            priorities[i] = 2\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:08:52", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            priorities[i] = 10\n        elif ratios[i] > 1.1:\n            if item > 25 and bins[i] > 20:\n                priorities[i] = 9\n            elif item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 18 and bins[i] > 12:\n                priorities[i] = 7\n            elif item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.9:\n            if item > 12 and bins[i] > 8:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 6:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.8:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 5\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.7:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 4\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] > 0.5:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            if item > 30 and bins[i] > 25:\n                priorities[i] = 11\n            elif item > 25 and bins[i] > 20:\n                priorities[i] = 10\n            else:\n                priorities[i] = 9\n        elif ratios[i] > 1.1:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 15 and bins[i] > 12:\n                priorities[i] = 7\n            else:\n                priorities[i] = 6\n        elif ratios[i] > 0.9:\n            if item > 10 and bins[i] > 8:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.8:\n            if item > 6 and bins[i] > 4:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.7:\n            if item > 3 and bins[i] > 2:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.5:\n            if item > 1 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            if item > 30 and bins[i] > 25:\n                priorities[i] = 11\n            elif item > 25 and bins[i] > 20:\n                priorities[i] = 10\n            else:\n                priorities[i] = 9\n        elif ratios[i] > 1.1:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 15 and bins[i] > 12:\n                priorities[i] = 7\n            else:\n                priorities[i] = 6\n        elif ratios[i] > 0.9:\n            if item > 10 and bins[i] > 8:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.8:\n            if item > 6 and bins[i] > 4:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n\n        # New conditions\n        elif ratios[i] > 0.6:\n            if item > 4 and bins[i] > 2:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.4:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:08:56", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            priorities[i] = 10\n        elif ratios[i] > 1.1:\n            if item > 25 and bins[i] > 20:\n                priorities[i] = 9\n            elif item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 18 and bins[i] > 12:\n                priorities[i] = 7\n            elif item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.9:\n            if item > 12 and bins[i] > 8:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 6:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.8:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 5\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.7:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 4\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] > 0.5:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            if item > 30 and bins[i] > 25:\n                priorities[i] = 11\n            elif item > 25 and bins[i] > 20:\n                priorities[i] = 10\n            else:\n                priorities[i] = 9\n        elif ratios[i] > 1.1:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 15 and bins[i] > 12:\n                priorities[i] = 7\n            else:\n                priorities[i] = 6\n        elif ratios[i] > 0.9:\n            if item > 10 and bins[i] > 8:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.8:\n            if item > 6 and bins[i] > 4:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.7:\n            if item > 3 and bins[i] > 2:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.5:\n            if item > 1 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            if item > 30 and bins[i] > 25:\n                priorities[i] = 11\n            elif item > 25 and bins[i] > 20:\n                priorities[i] = 10\n            else:\n                priorities[i] = 9\n        elif ratios[i] > 1.1:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 15 and bins[i] > 12:\n                priorities[i] = 7\n            else:\n                priorities[i] = 6\n        elif ratios[i] > 0.9:\n            if item > 10 and bins[i] > 8:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.8:\n            if item > 6 and bins[i] > 4:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.7:\n            if item > 3 and bins[i] > 2:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.5:\n            if item > 1 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:09:01", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            priorities[i] = 10\n        elif ratios[i] > 1.1:\n            if item > 25 and bins[i] > 20:\n                priorities[i] = 9\n            elif item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 18 and bins[i] > 12:\n                priorities[i] = 7\n            elif item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.9:\n            if item > 12 and bins[i] > 8:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 6:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.8:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 5\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.7:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 4\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] > 0.5:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            if item > 30 and bins[i] > 25:\n                priorities[i] = 11\n            elif item > 25 and bins[i] > 20:\n                priorities[i] = 10\n            else:\n                priorities[i] = 9\n        elif ratios[i] > 1.1:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 15 and bins[i] > 12:\n                priorities[i] = 7\n            else:\n                priorities[i] = 6\n        elif ratios[i] > 0.9:\n            if item > 10 and bins[i] > 8:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.8:\n            if item > 6 and bins[i] > 4:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.7:\n            if item > 3 and bins[i] > 2:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.5:\n            if item > 1 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.5:\n            if item > 40 and bins[i] > 30:\n                priorities[i] = 12\n            elif item > 35 and bins[i] > 25:\n                priorities[i] = 11\n            else:\n                priorities[i] = 10\n        elif ratios[i] > 1.3:\n            if item > 30 and bins[i] > 20:\n                priorities[i] = 9\n            else:\n                priorities[i] = 8\n        elif ratios[i] > 1.1:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 7\n            else:\n                priorities[i] = 6\n        elif ratios[i] > 1.0:\n            if item > 10 and bins[i] > 7:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.8:\n            if item > 5 and bins[i] > 4:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.6:\n            if item > 3 and bins[i] > 2:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.4:\n            if item > 1 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:09:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            priorities[i] = 10\n        elif ratios[i] > 1.1:\n            if item > 25 and bins[i] > 20:\n                priorities[i] = 9\n            elif item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 18 and bins[i] > 12:\n                priorities[i] = 7\n            elif item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.9:\n            if item > 12 and bins[i] > 8:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 6:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.8:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 5\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.7:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 4\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] > 0.5:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            if item > 30 and bins[i] > 25:\n                priorities[i] = 11\n            elif item > 25 and bins[i] > 20:\n                priorities[i] = 10\n            else:\n                priorities[i] = 9\n        elif ratios[i] > 1.1:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 15 and bins[i] > 12:\n                priorities[i] = 7\n            else:\n                priorities[i] = 6\n        elif ratios[i] > 0.9:\n            if item > 10 and bins[i] > 8:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.8:\n            if item > 6 and bins[i] > 4:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.7:\n            if item > 3 and bins[i] > 2:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.5:\n            if item > 1 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.5:\n            priorities[i] = 12\n        elif ratios[i] > 1.3:\n            if item > 35 and bins[i] > 30:\n                priorities[i] = 11\n            elif item > 30 and bins[i] > 25:\n                priorities[i] = 10\n            else:\n                priorities[i] = 9\n        elif ratios[i] > 1.1:\n            if item > 25 and bins[i] > 20:\n                priorities[i] = 8\n            elif item > 20 and bins[i] > 15:\n                priorities[i] = 7\n            else:\n                priorities[i] = 6\n        elif ratios[i] > 1.0:\n            if item > 18 and bins[i] > 12:\n                priorities[i] = 6\n            elif item > 15 and bins[i] > 10:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.9:\n            if item > 12 and bins[i] > 8:\n                priorities[i] = 5\n            elif item > 10 and bins[i] > 6:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.8:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 4\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] > 0.7:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 3\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:09:11", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    sorted_bins = np.sort(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] == sorted_bins[0]:\n            priorities[i] = 1.0\n        elif bins[i] == sorted_bins[-1]:\n            priorities[i] = 0.5\n        else:\n            priorities[i] = (sorted_bins[i] - sorted_bins[0]) / (sorted_bins[-1] - sorted_bins[0])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] == max_bin_capacity:\n            priorities[i] = 1.0\n        else:\n            priorities[i] = (max_bin_capacity - bins[i]) / max_bin_capacity\n            \n        if item > bins[i]:\n            priorities[i] *= 1.5\n        else:\n            priorities[i] *= 0.5\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:09:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    sorted_bins = np.sort(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] == sorted_bins[0]:\n            priorities[i] = 1.0\n        elif bins[i] == sorted_bins[-1]:\n            priorities[i] = 0.5\n        else:\n            priorities[i] = (sorted_bins[i] - sorted_bins[0]) / (sorted_bins[-1] - sorted_bins[0])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            if item > 2 * bins[i]:\n                priorities[i] = 2 * (item - bins[i])\n            else:\n                priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:09:17", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    sorted_bins = np.sort(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] == sorted_bins[0]:\n            priorities[i] = 1.0\n        elif bins[i] == sorted_bins[-1]:\n            priorities[i] = 0.5\n        else:\n            priorities[i] = (sorted_bins[i] - sorted_bins[0]) / (sorted_bins[-1] - sorted_bins[0])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    sorted_bins = np.sort(bins)\n    \n    for i in range(len(bins)):\n        if item > sorted_bins[i]:\n            priorities[i] = (item - sorted_bins[i]) / item\n        else:\n            priorities[i] = (sorted_bins[i] - item) / item\n            \n        if priorities[i] < 0.2:\n            priorities[i] *= 0.5\n        elif priorities[i] > 0.8:\n            priorities[i] *= 1.5\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:09:19", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    sorted_bins = np.sort(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] == sorted_bins[0]:\n            priorities[i] = 1.0\n        elif bins[i] == sorted_bins[-1]:\n            priorities[i] = 0.5\n        else:\n            priorities[i] = (sorted_bins[i] - sorted_bins[0]) / (sorted_bins[-1] - sorted_bins[0])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        else:\n            priorities[i] = bins[i] - item\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    min_bin_capacity = np.min(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] == min_bin_capacity:\n            priorities[i] = 1.0\n        elif bins[i] == max_bin_capacity:\n            priorities[i] = 0.0\n        else:\n            diff_from_min = (bins[i] - min_bin_capacity) / (max_bin_capacity - min_bin_capacity)\n            priorities[i] = 1 - diff_from_min\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:09:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            if item > 30 and bins[i] > 25:\n                priorities[i] = 11\n            elif item > 25 and bins[i] > 20:\n                priorities[i] = 10\n            else:\n                priorities[i] = 9\n        elif ratios[i] > 1.1:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 15 and bins[i] > 12:\n                priorities[i] = 7\n            else:\n                priorities[i] = 6\n        elif ratios[i] > 0.9:\n            if item > 10 and bins[i] > 8:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.8:\n            if item > 6 and bins[i] > 4:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.7:\n            if item > 3 and bins[i] > 2:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.5:\n            if item > 1 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            if item > 30 and bins[i] > 25:\n                priorities[i] = 11\n            elif item > 25 and bins[i] > 20:\n                priorities[i] = 10\n            else:\n                priorities[i] = 9\n        elif ratios[i] > 1.1:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 15 and bins[i] > 12:\n                priorities[i] = 7\n            else:\n                priorities[i] = 6\n        elif ratios[i] > 0.9:\n            if item > 10 and bins[i] > 8:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.8:\n            if item > 6 and bins[i] > 4:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.7:\n            if item > 3 and bins[i] > 2:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.5:\n            if item > 1 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            if item > 30 and bins[i] > 25:\n                priorities[i] = 11\n            elif item > 25 and bins[i] > 20:\n                priorities[i] = 10\n            elif item > 20 and bins[i] > 15:\n                priorities[i] = 9\n            else:\n                priorities[i] = 8\n        elif ratios[i] > 1.0:\n            if item > 15 and bins[i] > 12:\n                priorities[i] = 7\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.8:\n            if item > 6 and bins[i] > 4:\n                priorities[i] = 4\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 1\n            else:\n                priorities[i] = 0\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:09:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            if item > 30 and bins[i] > 25:\n                priorities[i] = 11\n            elif item > 25 and bins[i] > 20:\n                priorities[i] = 10\n            else:\n                priorities[i] = 9\n        elif ratios[i] > 1.1:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 15 and bins[i] > 12:\n                priorities[i] = 7\n            else:\n                priorities[i] = 6\n        elif ratios[i] > 0.9:\n            if item > 10 and bins[i] > 8:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.8:\n            if item > 6 and bins[i] > 4:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.7:\n            if item > 3 and bins[i] > 2:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.5:\n            if item > 1 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            if item > 30 and bins[i] > 25:\n                priorities[i] = 11\n            elif item > 25 and bins[i] > 20:\n                priorities[i] = 10\n            else:\n                priorities[i] = 9\n        elif ratios[i] > 1.1:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 15 and bins[i] > 12:\n                priorities[i] = 7\n            else:\n                priorities[i] = 6\n        elif ratios[i] > 0.9:\n            if item > 10 and bins[i] > 8:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.8:\n            if item > 6 and bins[i] > 4:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.7:\n            if item > 3 and bins[i] > 2:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.5:\n            if item > 1 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(input_list: list) -> list:\n    output_list = []\n\n    for i in range(len(input_list)):\n        if input_list[i] % 2 == 0:\n            result = input_list[i] * 2\n            output_list.append(result)\n        else:\n            if i % 2 == 0:\n                output_list.append(input_list[i] + 10)\n            else:\n                output_list.append(input_list[i] - 5)\n\n    return output_list\n", "strategy": []}
{"timestamp": "2025-04-27 06:09:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            if item > 30 and bins[i] > 25:\n                priorities[i] = 11\n            elif item > 25 and bins[i] > 20:\n                priorities[i] = 10\n            else:\n                priorities[i] = 9\n        elif ratios[i] > 1.1:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 15 and bins[i] > 12:\n                priorities[i] = 7\n            else:\n                priorities[i] = 6\n        elif ratios[i] > 0.9:\n            if item > 10 and bins[i] > 8:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.8:\n            if item > 6 and bins[i] > 4:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.7:\n            if item > 3 and bins[i] > 2:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.5:\n            if item > 1 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            if item > 30 and bins[i] > 25:\n                priorities[i] = 11\n            elif item > 25 and bins[i] > 20:\n                priorities[i] = 10\n            else:\n                priorities[i] = 9\n        elif ratios[i] > 1.1:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 15 and bins[i] > 12:\n                priorities[i] = 7\n            else:\n                priorities[i] = 6\n        elif ratios[i] > 0.9:\n            if item > 10 and bins[i] > 8:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.8:\n            if item > 6 and bins[i] > 4:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.7:\n            if item > 3 and bins[i] > 2:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.5:\n            if item > 1 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.5:\n            if item > 40 and bins[i] > 30:\n                priorities[i] = 12\n            elif item > 35 and bins[i] > 25:\n                priorities[i] = 11\n            else:\n                priorities[i] = 10\n        elif ratios[i] > 1.3:\n            if item > 30 and bins[i] > 20:\n                priorities[i] = 9\n            else:\n                priorities[i] = 8\n        elif ratios[i] > 1.1:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 7\n            else:\n                priorities[i] = 6\n        elif ratios[i] > 0.9:\n            if item > 15 and bins[i] > 12:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.7:\n            if item > 8 and bins[i] > 6:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.5:\n            if item > 4 and bins[i] > 3:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.3:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:09:40", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            if item > 30 and bins[i] > 25:\n                priorities[i] = 11\n            elif item > 25 and bins[i] > 20:\n                priorities[i] = 10\n            else:\n                priorities[i] = 9\n        elif ratios[i] > 1.1:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 15 and bins[i] > 12:\n                priorities[i] = 7\n            else:\n                priorities[i] = 6\n        elif ratios[i] > 0.9:\n            if item > 10 and bins[i] > 8:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.8:\n            if item > 6 and bins[i] > 4:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.7:\n            if item > 3 and bins[i] > 2:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.5:\n            if item > 1 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            if item > 30 and bins[i] > 25:\n                priorities[i] = 11\n            elif item > 25 and bins[i] > 20:\n                priorities[i] = 10\n            else:\n                priorities[i] = 9\n        elif ratios[i] > 1.1:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 15 and bins[i] > 12:\n                priorities[i] = 7\n            else:\n                priorities[i] = 6\n        elif ratios[i] > 0.9:\n            if item > 10 and bins[i] > 8:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.8:\n            if item > 6 and bins[i] > 4:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.7:\n            if item > 3 and bins[i] > 2:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.5:\n            if item > 1 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            if item > 30 and bins[i] > 25:\n                priorities[i] = 11\n            elif item > 25 and bins[i] > 20:\n                priorities[i] = 10\n            else:\n                priorities[i] = 9\n        elif ratios[i] > 1.1:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 15 and bins[i] > 12:\n                priorities[i] = 7\n            else:\n                priorities[i] = 6\n        elif ratios[i] > 0.9:\n            if item > 10 and bins[i] > 8:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.8:\n            if item > 6 and bins[i] > 4:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.7:\n            if item > 3 and bins[i] > 2:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.5:\n            if item > 1 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n        if item > 10:\n            if bins[i] >= 5:\n                priorities[i] += 1\n        elif item > 5:\n            if bins[i] >= 3:\n                priorities[i] += 1\n        elif item > 2:\n            if bins[i] >= 2:\n                priorities[i] += 1\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:09:46", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(input_data: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(input_data)\n    for i in range(len(input_data)):\n        if input_data[i] < 0:\n            result[i] = input_data[i] * 2\n        elif input_data[i] >= 0 and input_data[i] < 5:\n            result[i] = input_data[i] ** 2 + 3\n        else:\n            sum_val = 0\n            for j in range(1, int(input_data[i]) + 1):\n                if j % 2 == 0:\n                    sum_val += j\n            result[i] = sum_val + input_data[i]\n    return result", "strategy": []}
{"timestamp": "2025-04-27 06:09:48", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(data)\n    \n    for i in range(len(data)):\n        if data[i] % 2 == 0:\n            result[i] = data[i] * 2\n        else:\n            if data[i] < 0:\n                result[i] = 0\n            else:\n                result[i] = data[i] ** 2\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 06:09:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_function(input_data: list) -> int:\n    result = 0\n    \n    for i in range(len(input_data)):\n        if input_data[i] % 2 == 0:\n            result += input_data[i] * 2\n        else:\n            result -= input_data[i]\n    \n    if result < 0:\n        result = abs(result)\n    \n    return result\n```", "strategy": []}
{"timestamp": "2025-04-27 06:09:53", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = (1 - utilization) ** 2\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = (2 - 1 / utilization) * np.log(utilization + 1)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 2 * np.sin(utilization * np.pi)\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = np.exp(utilization) / (utilization + 0.5)\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = np.cosh(utilization)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:10:02", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            if item % 2 == 0:\n                priorities[i] = (item + 2) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 3*(item + 4) / bins[i]\n            else:\n                priorities[i] = (item + 6) / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]/2:\n            if bins[i] % 4 == 0:\n                priorities[i] = np.power(item / bins[i], 1.8) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.9) + np.log10(item / bins[i])\n        elif item > bins[i]/2 and item <= 2*bins[i]/3:\n            if item % 5 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.square(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.cbrt(item / bins[i])\n        else:\n            priorities[i] = np.exp(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:10:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            if item % 3 == 0:\n                priorities[i] = (item + 2) / bins[i]\n            elif item % 3 == 1:\n                priorities[i] = 3*(item + 4) / bins[i]\n            else:\n                priorities[i] = (item + 6) / bins[i]\n        elif item > bins[i]/3 and item <= 2 * bins[i]/3:\n            if bins[i] % 4 == 0:\n                priorities[i] = np.power(item / bins[i], 1.8) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.6) + np.log10(item / bins[i])\n        elif item > 2 * bins[i]/3 and item <= bins[i]:\n            if item % 5 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.sin(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.tan(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.cos(item / bins[i])\n        else:\n            priorities[i] = np.cos(item / bins[i]) + np.sin(item / bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:10:10", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            elif item % 2 == 0:\n                priorities[i] = np.square(item / bins[i]) + np.log10(item / bins[i])\n            else:\n                priorities[i] = np.cbrt(item / bins[i]) + np.log1p(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:10:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priorities[i] = item / bins[i] if item % 2 == 0 else (item + 3) / bins[i] if item % 2 == 1 else (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i]) if bins[i] % 3 == 0 else np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:10:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    \n    # Calculate the sum of bin capacities\n    total_capacity = np.sum(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 3 * (item - bins[i])  # Triple the priority\n        else:\n            priorities[i] = bins[i] - item\n            \n        # Add an additional factor based on capacity distribution\n        capacity_ratio = bins[i] / total_capacity\n        if capacity_ratio >= 0.5:\n            priorities[i] += 0.3 * (capacity_ratio - 0.5) * total_capacity\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 3 * (item - bins[i])  # Triple the priority\n        else:\n            priorities[i] = bins[i] - item\n        \n        if i % 2 == 0:\n            priorities[i] += 0.5 * bins[i]  # Increase priority for even indexed bins\n        else:\n            priorities[i] -= 0.3 * bins[i]  # Decrease priority for odd indexed bins\n    \n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n    for i in range(len(bins)):\n        if bins[i] == max_bin_capacity:\n            priorities[i] += 1.5 * max_bin_capacity  # Increase priority for bins with max capacity\n        elif bins[i] == min_bin_capacity:\n            priorities[i] -= 1.2 * min_bin_capacity  # Decrease priority for bins with min capacity\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    total_capacity = np.sum(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 3 * (item - bins[i]) + 0.6 * total_capacity  # Increased priority\n        else:\n            priorities[i] = bins[i] - item\n        \n        if bins[i] % 5 == 0:\n            priorities[i] += 2.0 * bins[i]  # Increase priority for bins divisible by 5\n        elif bins[i] % 3 == 0:\n            priorities[i] -= 1.5 * bins[i]  # Decrease priority for bins divisible by 3\n        \n        if bins[i] > total_capacity / 2:\n            priorities[i] += 1.2 * (bins[i] - total_capacity / 2)  # Boost priority for bins above half total capacity\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:10:32", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    \n    # Calculate the sum of bin capacities\n    total_capacity = np.sum(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 3 * (item - bins[i])  # Triple the priority\n        else:\n            priorities[i] = bins[i] - item\n            \n        # Add an additional factor based on capacity distribution\n        capacity_ratio = bins[i] / total_capacity\n        if capacity_ratio >= 0.5:\n            priorities[i] += 0.3 * (capacity_ratio - 0.5) * total_capacity\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 3 * (item - bins[i])  # Triple the priority\n        else:\n            priorities[i] = bins[i] - item\n        \n        if i % 2 == 0:\n            priorities[i] += 0.5 * bins[i]  # Increase priority for even indexed bins\n        else:\n            priorities[i] -= 0.3 * bins[i]  # Decrease priority for odd indexed bins\n    \n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n    for i in range(len(bins)):\n        if bins[i] == max_bin_capacity:\n            priorities[i] += 1.5 * max_bin_capacity  # Increase priority for bins with max capacity\n        elif bins[i] == min_bin_capacity:\n            priorities[i] -= 1.2 * min_bin_capacity  # Decrease priority for bins with min capacity\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 3 * (item - bins[i])  # Triple the priority\n        else:\n            priorities[i] = bins[i] - item\n        \n        if i % 2 == 0:\n            priorities[i] += 0.5 * bins[i]  # Increase priority for even indexed bins\n        else:\n            priorities[i] -= 0.3 * bins[i]  # Decrease priority for odd indexed bins\n    \n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n    for i in range(len(bins)):\n        if bins[i] == max_bin_capacity:\n            priorities[i] += 1.5 * max_bin_capacity  # Increase priority for bins with max capacity\n        elif bins[i] == min_bin_capacity:\n            priorities[i] -= 1.2 * min_bin_capacity  # Decrease priority for bins with min capacity\n        \n    for i in range(len(bins)):\n        if i < len(bins) // 2:\n            priorities[i] += 0.8 * np.sqrt(bins[i])  # Increase priority for first half of bins\n        else:\n            priorities[i] -= 0.4 * bins[i]  # Decrease priority for second half of bins\n        \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:10:36", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    \n    # Calculate the sum of bin capacities\n    total_capacity = np.sum(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 3 * (item - bins[i])  # Triple the priority\n        else:\n            priorities[i] = bins[i] - item\n            \n        # Add an additional factor based on capacity distribution\n        capacity_ratio = bins[i] / total_capacity\n        if capacity_ratio >= 0.5:\n            priorities[i] += 0.3 * (capacity_ratio - 0.5) * total_capacity\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 3 * (item - bins[i])  # Triple the priority\n        else:\n            priorities[i] = bins[i] - item\n        \n        if i % 2 == 0:\n            priorities[i] += 0.5 * bins[i]  # Increase priority for even indexed bins\n        else:\n            priorities[i] -= 0.3 * bins[i]  # Decrease priority for odd indexed bins\n    \n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n    for i in range(len(bins)):\n        if bins[i] == max_bin_capacity:\n            priorities[i] += 1.5 * max_bin_capacity  # Increase priority for bins with max capacity\n        elif bins[i] == min_bin_capacity:\n            priorities[i] -= 1.2 * min_bin_capacity  # Decrease priority for bins with min capacity\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    total_capacity = np.sum(bins)\n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 3 * (item - bins[i])  # Triple the priority\n        else:\n            priorities[i] = bins[i] - item\n        \n        if i % 2 == 0:\n            priorities[i] += 0.5 * bins[i]  # Increase priority for even indexed bins\n        else:\n            priorities[i] -= 0.3 * bins[i]  # Decrease priority for odd indexed bins\n        \n        capacity_ratio = bins[i] / total_capacity\n        if capacity_ratio >= 0.5:\n            priorities[i] += 0.3 * (capacity_ratio - 0.5) * total_capacity  # Adjust based on capacity distribution\n        \n        if bins[i] == max_bin_capacity:\n            priorities[i] += 1.5 * max_bin_capacity  # Increase priority for bins with max capacity\n        elif bins[i] == min_bin_capacity:\n            priorities[i] -= 1.2 * min_bin_capacity  # Decrease priority for bins with min capacity\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:10:40", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    \n    # Calculate the sum of bin capacities\n    total_capacity = np.sum(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 3 * (item - bins[i])  # Triple the priority\n        else:\n            priorities[i] = bins[i] - item\n            \n        # Add an additional factor based on capacity distribution\n        capacity_ratio = bins[i] / total_capacity\n        if capacity_ratio >= 0.5:\n            priorities[i] += 0.3 * (capacity_ratio - 0.5) * total_capacity\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 3 * (item - bins[i])  # Triple the priority\n        else:\n            priorities[i] = bins[i] - item\n        \n        if i % 2 == 0:\n            priorities[i] += 0.5 * bins[i]  # Increase priority for even indexed bins\n        else:\n            priorities[i] -= 0.3 * bins[i]  # Decrease priority for odd indexed bins\n    \n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n    for i in range(len(bins)):\n        if bins[i] == max_bin_capacity:\n            priorities[i] += 1.5 * max_bin_capacity  # Increase priority for bins with max capacity\n        elif bins[i] == min_bin_capacity:\n            priorities[i] -= 1.2 * min_bin_capacity  # Decrease priority for bins with min capacity\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Further improved version of `priority_v1`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 3 * (item - bins[i])  # Triple the priority\n        else:\n            priorities[i] = bins[i] - item\n        \n        if i % 3 == 0:\n            priorities[i] += 0.8 * bins[i]  # Increase priority for every third indexed bin\n        elif i % 3 == 1:\n            priorities[i] -= 0.6 * bins[i]  # Decrease priority for bins with index 1 mod 3\n        else:\n            priorities[i] += 0.4 * bins[i]  # Increase priority for bins with index 2 mod 3\n    \n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n    for i in range(len(bins)):\n        if i % 2 == 0:\n            priorities[i] += 0.5 * max_bin_capacity  # Increase priority for even indexed bins with max capacity\n        else:\n            priorities[i] -= 0.3 * min_bin_capacity  # Decrease priority for odd indexed bins with min capacity\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:10:52", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more advanced version of `priority_v1`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                adjustment_factor = 0.8\n                for k in range(i + 1, len(bins)):\n                    adjustment_factor -= 0.1\n                    if adjustment_factor < 0.3:\n                        adjustment_factor = 0.3\n                    if item <= (bin_capacity + sum(bins[i+1:k])):\n                        priorities[i] = adjustment_factor\n                        break\n                    priorities[i] = 0.2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = []\n                for k, capacity in enumerate(bins):\n                    if capacity >= item:\n                        available_bins.append(k)\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        priorities[available_bins[idx]] = (item - bins[available_bins[idx-1]]) / (bins[available_bins[idx]] - bins[available_bins[idx-1]])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = []\n                for k, capacity in enumerate(bins):\n                    if capacity >= item:\n                        available_bins.append(k)\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        priorities[available_bins[idx]] = (item - bins[available_bins[idx-1]]) / (bins[available_bins[idx]] - bins[available_bins[idx-1]])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:10:55", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more advanced version of `priority_v1`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                adjustment_factor = 0.8\n                for k in range(i + 1, len(bins)):\n                    adjustment_factor -= 0.1\n                    if adjustment_factor < 0.3:\n                        adjustment_factor = 0.3\n                    if item <= (bin_capacity + sum(bins[i+1:k])):\n                        priorities[i] = adjustment_factor\n                        break\n                    priorities[i] = 0.2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = []\n                for k, capacity in enumerate(bins):\n                    if capacity >= item:\n                        available_bins.append(k)\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        priorities[available_bins[idx]] = (item - bins[available_bins[idx-1]]) / (bins[available_bins[idx]] - bins[available_bins[idx-1]])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = []\n                for k, capacity in enumerate(bins):\n                    if capacity >= item:\n                        available_bins.append(k)\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        priorities[available_bins[idx]] = (item - bins[available_bins[idx-1]]) / (bins[available_bins[idx]] - bins[available_bins[idx-1]])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    if max_capacity == bin_capacity:\n                        priorities[i] = 1.0\n                    else:\n                        priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:10:58", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more advanced version of `priority_v1`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                adjustment_factor = 0.8\n                for k in range(i + 1, len(bins)):\n                    adjustment_factor -= 0.1\n                    if adjustment_factor < 0.3:\n                        adjustment_factor = 0.3\n                    if item <= (bin_capacity + sum(bins[i+1:k])):\n                        priorities[i] = adjustment_factor\n                        break\n                    priorities[i] = 0.2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = []\n                for k, capacity in enumerate(bins):\n                    if capacity >= item:\n                        available_bins.append(k)\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        priorities[available_bins[idx]] = (item - bins[available_bins[idx-1]]) / (bins[available_bins[idx]] - bins[available_bins[idx-1]])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                for k in range(i+1, len(bins)):\n                    cumulative_capacity = sum(bins[i+1:k])\n                    if item <= (bin_capacity + cumulative_capacity):\n                        priorities[i] = (item - remaining_capacity) / cumulative_capacity\n                        break\n                    if k == len(bins) - 1:\n                        priorities[i] = 0.2\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:11:02", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more advanced version of `priority_v1`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                adjustment_factor = 0.8\n                for k in range(i + 1, len(bins)):\n                    adjustment_factor -= 0.1\n                    if adjustment_factor < 0.3:\n                        adjustment_factor = 0.3\n                    if item <= (bin_capacity + sum(bins[i+1:k])):\n                        priorities[i] = adjustment_factor\n                        break\n                    priorities[i] = 0.2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = []\n                for k, capacity in enumerate(bins):\n                    if capacity >= item:\n                        available_bins.append(k)\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        priorities[available_bins[idx]] = (item - bins[available_bins[idx-1]]) / (bins[available_bins[idx]] - bins[available_bins[idx-1]])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = 0\n            for j in range(i):\n                used_capacity += bins[j]\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = []\n                for k, capacity in enumerate(bins):\n                    if capacity >= item:\n                        available_bins.append(k)\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        priorities[available_bins[idx]] = (item - bins[available_bins[idx-1]]) / (bins[available_bins[idx]] - bins[available_bins[idx-1]])\n                else:\n                    max_capacity = max(bins)\n                    max_index = np.argmax(bins)\n                    priorities[max_index] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:11:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    max_priority = np.max(priorities)\n    \n    for j in range(len(priorities)):\n        if priorities[j] == -1:\n            priorities[j] = max_priority + 1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:11:09", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item, bins):\n    priorities = []\n    \n    for i in range(len(bins)):\n        priority = 0\n        \n        if item > bins[i]:\n            priority = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priority = 0\n            else:\n                utilization = item / bins[i]\n                \n                if utilization < 0.1:\n                    priority = 1 / (1 - utilization)\n                elif 0.1 <= utilization < 0.2:\n                    priority = 2 / (1 + utilization)\n                elif 0.2 <= utilization < 0.3:\n                    priority = 3\n                elif 0.3 <= utilization < 0.4:\n                    priority = 4 * utilization\n                elif 0.4 <= utilization < 0.6:\n                    priority = 5 * np.sqrt(utilization)\n                elif 0.6 <= utilization <= 1.0:\n                    priority = 6 * np.log(utilization)\n        \n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 06:11:11", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_function(input_data):\n    result = []\n    \n    for data in input_data:\n        if data % 2 == 0:\n            processed_data = data * 2\n        else:\n            processed_data = data + 1\n        result.append(processed_data)\n        \n    final_result = []\n    for i in range(len(result)):\n        if result[i] < 10:\n            final_result.append(result[i] + 5)\n        elif result[i] >= 10 and result[i] < 20:\n            final_result.append(result[i] - 5)\n        else:\n            final_result.append(result[i] * 2)\n    \n    return final_result\n```", "strategy": []}
{"timestamp": "2025-04-27 06:11:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(input_data: np.ndarray) -> np.ndarray:\n    output_data = np.zeros_like(input_data)\n\n    for i in range(len(input_data)):\n        if input_data[i] % 2 == 0:\n            output_data[i] = input_data[i] * 2\n        else:\n            output_data[i] = input_data[i] ** 2\n\n    return output_data", "strategy": []}
{"timestamp": "2025-04-27 06:11:19", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.25:\n            priority = np.log(ratio) + np.sqrt(ratio) + np.sin(ratio)\n        elif ratio >= 0.25 and ratio < 0.5:\n            priority = np.cos(ratio) * np.tan(ratio) - np.arctan(ratio)\n        elif ratio >= 0.5 and ratio < 0.75:\n            priority = np.exp(ratio) * np.cosh(ratio) - np.sinh(ratio)\n        else:\n            priority = np.sqrt(ratio) * np.arcsinh(ratio) + np.cbrt(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 06:11:22", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.tan(3*ratio) * np.sin(2*ratio) + np.cos(4*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(ratio) * np.sqrt(ratio) + np.cbrt(2*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.sinh(ratio) * np.tanh(ratio) - np.arcsin(ratio) + np.cosh(ratio)\n        else:\n            priority = np.log(3*ratio) * np.cosh(2*ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 06:11:25", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = ratio ** 3 + np.power(ratio, 4) - np.square(ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cos(2*ratio) + np.tan(3*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.sinh(ratio) * np.cosh(ratio) + np.tanh(ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(ratio)\n        else:\n            priority = np.arcsinh(ratio) + np.arccos(ratio) - np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 06:11:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.tanh(ratio) + np.arcsin(ratio) - np.cosh(ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.sin(ratio) * np.cos(ratio) - np.tan(ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cbrt(ratio) * np.cosh(ratio) - np.arctan(ratio)\n        else:\n            priority = np.arcsin(ratio) * np.arccos(ratio) - np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 06:11:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(data)\n    \n    for i in range(len(data)):\n        if data[i] % 2 == 0:\n            result[i] = data[i] * 2\n        else:\n            temp = 1\n            for j in range(1, data[i] + 1):\n                temp *= j\n            result[i] = temp\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 06:11:37", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(data)\n    \n    for i in range(len(data)):\n        if data[i] % 2 == 0:\n            for j in range(data[i]):\n                if j % 2 == 0:\n                    result[i] += j\n        else:\n            for j in range(data[i]):\n                if j % 2 != 0:\n                    result[i] += j\n    \n    return result\n```", "strategy": []}
{"timestamp": "2025-04-27 06:11:39", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    output = np.zeros_like(data)\n    \n    for i in range(len(data)):\n        if data[i] % 2 == 0:\n            output[i] = data[i] * 2\n        else:\n            square_sum = 0\n            for digit in str(data[i]):\n                square_sum += int(digit) ** 2\n            output[i] = square_sum\n    \n    return output", "strategy": []}
{"timestamp": "2025-04-27 06:11:42", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                if item % 2 == 0:\n                    utilization = item / bins[i]\n                    if utilization < 0.2:\n                        priorities[i] = 1 / (1 - utilization)\n                    elif 0.2 <= utilization < 0.4:\n                        priorities[i] = 2 / (1 + utilization)\n                    elif 0.4 <= utilization < 0.6:\n                        priorities[i] = 3\n                    elif 0.6 <= utilization < 0.8:\n                        priorities[i] = 4 * utilization\n                    elif 0.8 <= utilization <= 1.0:\n                        priorities[i] = 5 * np.sqrt(utilization)\n                else:\n                    for j in range(int(item)):\n                        priorities[i] += j\n                \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:11:45", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(input_data: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(input_data)\n    \n    for i in range(len(input_data)):\n        if input_data[i] % 2 == 0:\n            result[i] = input_data[i] ** 2\n        else:\n            for j in range(1, input_data[i] + 1):\n                result[i] += j\n                \n    return result", "strategy": []}
{"timestamp": "2025-04-27 06:11:48", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> float:\n    result = 0\n    \n    for row in data:\n        sum_row = 0\n        for val in row:\n            if val % 2 == 0:\n                sum_row += val * 2\n            else:\n                sum_row += val\n        \n        if sum_row > 10:\n            result += sum_row ** 2\n        else:\n            result += sum_row\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 06:11:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(data)\n    \n    for i in range(len(data)):\n        if data[i] % 2 == 0:\n            result[i] = data[i] * 2\n        else:\n            if data[i] < 0:\n                result[i] = data[i] ** 2\n            else:\n                for j in range(1, data[i]+1):\n                    result[i] += j\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 06:11:52", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_function(input_data: np.ndarray) -> np.ndarray:\n    output_data = np.zeros_like(input_data)\n    \n    for i in range(len(input_data)):\n        if input_data[i] % 2 == 0:\n            output_data[i] = input_data[i] * 2\n        elif input_data[i] % 3 == 0:\n            output_data[i] = input_data[i] ** 2\n        else:\n            output_data[i] = input_data[i] + 10\n            \n    return output_data\n```", "strategy": []}
{"timestamp": "2025-04-27 06:11:59", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            if item % 3 == 0:\n                priorities[i] = (item + 2) / bins[i]\n            elif item % 3 == 1:\n                priorities[i] = 3*(item + 4) / bins[i]\n            elif item % 3 == 2:\n                priorities[i] = (item + 6) / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]/2:\n            if bins[i] % 4 == 0:\n                priorities[i] = np.power(item / bins[i], 1.8) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.6) + np.log10(item / bins[i])\n        elif item > bins[i]/2 and item <= bins[i]:\n            if item % 4 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 4 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 4 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 4 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:12:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 4:\n                priorities[i] = np.sin(item / bins[i]) + np.arccos(item / bins[i])\n            elif item % 7 == 5:\n                priorities[i] = np.cos(item / bins[i]) + np.tan(item / bins[i])\n            else:\n                priorities[i] = np.sqrt(item / bins[i]) + np.sign(item / bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:12:07", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:12:11", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            if item % 3 == 0:\n                priorities[i] = (item + 2) / bins[i]\n            elif item % 3 == 1:\n                priorities[i] = 3*(item + 4) / bins[i]\n            else:\n                priorities[i] = (item + 6) / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]:\n            if bins[i] % 4 == 0:\n                priorities[i] = np.power(item / bins[i], 1.7) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.6) + np.log10(item / bins[i])\n        else:\n            if item % 8 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 8 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 8 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 8 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 8 == 4:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.log2(item / bins[i]) + np.exp(item / bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:12:20", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n    \n    total_capacity = sum(bins)\n    \n    if item > total_capacity:\n        msg = \"Item size exceeds total bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        remaining_capacity = total_capacity - sum(bins[:i])\n        if bins[i] >= item and remaining_capacity >= item:\n            priorities[i] = 1\n            break\n        elif i == len(bins) - 1:\n            priorities[i] = -1\n        else:\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n    \n    total_capacity = sum(bins)\n    \n    if item > total_capacity:\n        msg = \"Item size exceeds total bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        remaining_capacity = total_capacity - sum(bins[:i])\n        if bins[i] >= item and remaining_capacity >= item:\n            priorities[i] = 1\n            break\n        elif i == len(bins) - 1:\n            priorities[i] = -1\n        elif bins[i] < item:\n            remaining_items = len(bins) - i\n            total_item_capacity = item * float(remaining_items)\n            if total_item_capacity <= remaining_capacity: \n                priorities[i:] = np.arange(2, remaining_items+2)\n                break\n            else:\n                priorities[i] = -1\n                \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:12:24", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n    \n    total_capacity = sum(bins)\n    \n    if item > total_capacity:\n        msg = \"Item size exceeds total bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        remaining_capacity = total_capacity - sum(bins[:i])\n        if bins[i] >= item and remaining_capacity >= item:\n            priorities[i] = 1\n            break\n        elif i == len(bins) - 1:\n            priorities[i] = -1\n        else:\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n\n    total_capacity = sum(bins)\n\n    if item > total_capacity:\n        msg = \"Item size exceeds total bin capacity\"\n        raise ValueError(msg)\n\n    for i in range(len(bins)):\n        remaining_capacity = total_capacity - sum(bins[:i])\n\n        if bins[i] >= item and remaining_capacity >= item:\n            priorities[i] = 1\n            break\n        elif i == len(bins) - 1:\n            priorities[i] = -1\n        else:\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif remaining_capacity >= item:\n                    count = 0\n                    for k in range(j+1, len(bins)):\n                        if bins[k] >= item:\n                            count += 1\n                        remaining_capacity += bins[k]\n                        if count == 2:\n                            priorities[k] = (k - i) + 2\n                            break\n                    if count < 2:\n                        priorities[i] = -1\n                        break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:12:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n    \n    total_capacity = sum(bins)\n    \n    if item > total_capacity:\n        msg = \"Item size exceeds total bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        remaining_capacity = total_capacity - sum(bins[:i])\n        if bins[i] >= item and remaining_capacity >= item:\n            priorities[i] = 1\n            break\n        elif i == len(bins) - 1:\n            priorities[i] = -1\n        else:\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n    \n    total_capacity = sum(bins)\n    \n    if item > total_capacity:\n        msg = \"Item size exceeds total bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        remaining_capacity = total_capacity - sum(bins[:i])\n        if bins[i] >= item and remaining_capacity >= item:\n            priorities[i] = 1\n            break\n        elif i == len(bins) - 1:\n            priorities[i] = -1\n        else:\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n                else:\n                    if item < total_capacity / 2:\n                        priorities[j] = 0\n                    else:\n                        priorities[j] = 0.5\n                        break\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:12:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                else:\n                    remaining_capacity += bins[j]\n                    if remaining_capacity >= item:\n                        priorities[j] = (j - i) + 1\n                        break\n                    elif j == len(bins) - 1:\n                        priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n    \n    total_capacity = sum(bins)\n    \n    if item > total_capacity:\n        msg = \"Item size exceeds total bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        remaining_capacity = total_capacity - sum(bins[:i])\n        if bins[i] >= item and remaining_capacity >= item:\n            priorities[i] = 1\n            break\n        elif i == len(bins) - 1:\n            priorities[i] = -1\n        else:\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n    \n    total_capacity = sum(bins)\n    \n    if item > total_capacity:\n        msg = \"Item size exceeds total bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        remaining_capacity = total_capacity - sum(bins[:i])\n        if bins[i] >= item and remaining_capacity >= item:\n            priorities[i] = 1\n            break\n        elif i == len(bins) - 1:\n            priorities[i] = -1\n        else:\n            for j in range(i+1, len(bins)):\n                priority_score = 1\n                while sum(bins[i:j+1]) < item and j < len(bins) - 1:\n                    priority_score += 1\n                    j += 1\n                if sum(bins[i:j+1]) >= item:\n                    for k in range(i, j+1):\n                        priorities[k] = priority_score\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:12:34", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    highest_priority = -1\n                    highest_priority_idx = -1\n                    for k in range(i, j):\n                        if priorities[k] == -1:\n                            continue\n                        if priorities[k] > highest_priority:\n                            highest_priority = priorities[k]\n                            highest_priority_idx = k\n                    if highest_priority > 1:\n                        priorities[highest_priority_idx] = 1\n                        priorities[j] = (j - highest_priority_idx) + 1\n                    else:\n                        priorities[i] = -1\n                        break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            allocated_capacity = bins[i]\n            allocated_bins = [i]\n            for j in range(i+1, len(bins)):\n                allocated_capacity += bins[j]\n                allocated_bins.append(j)\n                \n                if bins[j] >= item and allocated_capacity >= item:\n                    for bin_idx in allocated_bins:\n                        priorities[bin_idx] = (bin_idx - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    for bin_idx in allocated_bins:\n                        priorities[bin_idx] = -1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:12:37", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    highest_priority = -1\n                    highest_priority_idx = -1\n                    for k in range(i, j):\n                        if priorities[k] == -1:\n                            continue\n                        if priorities[k] > highest_priority:\n                            highest_priority = priorities[k]\n                            highest_priority_idx = k\n                    if highest_priority > 1:\n                        priorities[highest_priority_idx] = 1\n                        priorities[j] = (j - highest_priority_idx) + 1\n                    else:\n                        priorities[i] = -1\n                        break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    highest_priority = -1\n                    highest_priority_idx = -1\n                    for k in range(i, j):\n                        if priorities[k] == -1:\n                            continue\n                        if priorities[k] > highest_priority:\n                            highest_priority = priorities[k]\n                            highest_priority_idx = k\n                    if highest_priority > 1:\n                        priorities[highest_priority_idx] = 1\n                        priorities[j] = (j - highest_priority_idx) + 1\n                    else:\n                        priorities[i] = -1\n                        break\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:12:41", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    highest_priority = -1\n                    highest_priority_idx = -1\n                    for k in range(i, j):\n                        if priorities[k] == -1:\n                            continue\n                        if priorities[k] > highest_priority:\n                            highest_priority = priorities[k]\n                            highest_priority_idx = k\n                    if highest_priority > 1:\n                        priorities[highest_priority_idx] = 1\n                        priorities[j] = (j - highest_priority_idx) + 1\n                    else:\n                        priorities[i] = -1\n                        break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    highest_priority = -1\n                    highest_priority_idx = -1\n                    for k in range(i, j):\n                        if priorities[k] == -1:\n                            continue\n                        if priorities[k] > highest_priority:\n                            highest_priority = priorities[k]\n                            highest_priority_idx = k\n                    if highest_priority > 1:\n                        priorities[highest_priority_idx] = 1\n                        priorities[j] = (j - highest_priority_idx) + 1\n                    else:\n                        priorities[i] = -1\n                        break\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:12:44", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    highest_priority = -1\n                    highest_priority_idx = -1\n                    for k in range(i, j):\n                        if priorities[k] == -1:\n                            continue\n                        if priorities[k] > highest_priority:\n                            highest_priority = priorities[k]\n                            highest_priority_idx = k\n                    if highest_priority > 1:\n                        priorities[highest_priority_idx] = 1\n                        priorities[j] = (j - highest_priority_idx) + 1\n                    else:\n                        priorities[i] = -1\n                        break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            valid_bins = []\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    valid_bins.append(j)\n            \n            if len(valid_bins) == 1:\n                priorities[valid_bins[0]] = (valid_bins[0] - i) + 1\n            elif len(valid_bins) > 1:\n                min_priority = (min(valid_bins) - i) + 1\n                max_priority = (max(valid_bins) - i) + 1\n                priorities[valid_bins[0]] = min_priority\n                priorities[valid_bins[-1]] = max_priority\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:12:51", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    bin_ranges = []\n    current_range = [0, 0]\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            if current_range[0] == 0:\n                current_range[0] = i\n            current_range[1] = i\n            if i == len(bins) - 1 or bins[i] + bins[i+1] < item:\n                bin_ranges.append(current_range)\n                current_range = [0, 0]\n    \n    for start, end in bin_ranges:\n        remaining_capacity = sum(bins[start:end+1])\n        for j in range(end, len(bins)):\n            remaining_capacity += bins[j]\n            if bins[j] >= item and remaining_capacity >= item:\n                priorities[j] = (j - start) + 1\n                break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n    \n    total_capacity = sum(bins)\n    \n    if item > total_capacity:\n        msg = \"Item size exceeds total bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        remaining_capacity = total_capacity - sum(bins[:i])\n        if bins[i] >= item and remaining_capacity >= item:\n            priorities[i] = 1\n            break\n        elif i == len(bins) - 1:\n            priorities[i] = -1\n        else:\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n\n    total_capacity = sum(bins)\n\n    if item > total_capacity:\n        msg = \"Item size exceeds total bin capacity\"\n        raise ValueError(msg)\n\n    for i in range(len(bins)):\n        remaining_capacity = total_capacity - sum(bins[:i])\n        if bins[i] >= item and remaining_capacity >= item:\n            priorities[i] = 1\n            break\n        elif i == len(bins) - 1:\n            priorities[i] = -1\n        else:\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n\n    max_priority = max(priorities)\n    min_priority = min(priorities)\n    avg_priority = np.mean(priorities)\n\n    if max_priority > 1 and min_priority == 0:\n        priorities = [p / max_priority for p in priorities]\n    elif max_priority == 0 and min_priority < 0:\n        priorities = [1 - abs(p) for p in priorities]\n    elif avg_priority > 0:\n        priorities = [p / avg_priority for p in priorities]\n    else:\n        priorities = [0 for _ in priorities]\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:12:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    bin_ranges = []\n    current_range = [0, 0]\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            if current_range[0] == 0:\n                current_range[0] = i\n            current_range[1] = i\n            if i == len(bins) - 1 or bins[i] + bins[i+1] < item:\n                bin_ranges.append(current_range)\n                current_range = [0, 0]\n    \n    for start, end in bin_ranges:\n        remaining_capacity = sum(bins[start:end+1])\n        for j in range(end, len(bins)):\n            remaining_capacity += bins[j]\n            if bins[j] >= item and remaining_capacity >= item:\n                priorities[j] = (j - start) + 1\n                break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n    \n    total_capacity = sum(bins)\n    \n    if item > total_capacity:\n        msg = \"Item size exceeds total bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        remaining_capacity = total_capacity - sum(bins[:i])\n        if bins[i] >= item and remaining_capacity >= item:\n            priorities[i] = 1\n            break\n        elif i == len(bins) - 1:\n            priorities[i] = -1\n        else:\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n    \n    total_capacity = sum(bins)\n    \n    if item > total_capacity:\n        msg = \"Item size exceeds total bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        remaining_capacity = total_capacity - sum(bins[:i])\n        if bins[i] >= item and remaining_capacity >= item:\n            priorities[i] = 1\n            break\n        elif i == len(bins) - 1:\n            priorities[i] = -1\n        else:\n            max_priority = -1\n            for j in range(i + 1, len(bins)):\n                current_priority = 1\n                current_cap = bins[j]\n                while current_cap < item and j < len(bins) - 1:\n                    j += 1\n                    current_cap += bins[j]\n                    current_priority += 1\n                if current_cap >= item and current_priority > max_priority:\n                    max_priority = current_priority\n            priorities[i] = max_priority\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:12:58", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    bin_ranges = []\n    current_range = [0, 0]\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            if current_range[0] == 0:\n                current_range[0] = i\n            current_range[1] = i\n            if i == len(bins) - 1 or bins[i] + bins[i+1] < item:\n                bin_ranges.append(current_range)\n                current_range = [0, 0]\n    \n    for start, end in bin_ranges:\n        remaining_capacity = sum(bins[start:end+1])\n        for j in range(end, len(bins)):\n            remaining_capacity += bins[j]\n            if bins[j] >= item and remaining_capacity >= item:\n                priorities[j] = (j - start) + 1\n                break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n    \n    total_capacity = sum(bins)\n    \n    if item > total_capacity:\n        msg = \"Item size exceeds total bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        remaining_capacity = total_capacity - sum(bins[:i])\n        if bins[i] >= item and remaining_capacity >= item:\n            priorities[i] = 1\n            break\n        elif i == len(bins) - 1:\n            priorities[i] = -1\n        else:\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n    \n    total_capacity = sum(bins)\n    \n    if item > total_capacity:\n        msg = \"Item size exceeds total bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        remaining_capacity = total_capacity - sum(bins[:i])\n        if bins[i] >= item and remaining_capacity >= item:\n            priorities[i] = 1\n            break\n        elif i == len(bins) - 1:\n            priorities[i] = -1\n        else:\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n\n    max_priority = max(priorities)\n    if max_priority == 1:\n        return priorities\n    \n    for i in range(len(bins)):\n        if priorities[i] == 0:\n            remaining_capacity = total_capacity - sum(bins[:i])\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item and bins[j] <= remaining_capacity:\n                    priorities[i] = j - i + 1\n                    remaining_capacity -= bins[j]\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:13:02", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    bin_ranges = []\n    current_range = [0, 0]\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            if current_range[0] == 0:\n                current_range[0] = i\n            current_range[1] = i\n            if i == len(bins) - 1 or bins[i] + bins[i+1] < item:\n                bin_ranges.append(current_range)\n                current_range = [0, 0]\n    \n    for start, end in bin_ranges:\n        remaining_capacity = sum(bins[start:end+1])\n        for j in range(end, len(bins)):\n            remaining_capacity += bins[j]\n            if bins[j] >= item and remaining_capacity >= item:\n                priorities[j] = (j - start) + 1\n                break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n    \n    total_capacity = sum(bins)\n    \n    if item > total_capacity:\n        msg = \"Item size exceeds total bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        remaining_capacity = total_capacity - sum(bins[:i])\n        if bins[i] >= item and remaining_capacity >= item:\n            priorities[i] = 1\n            break\n        elif i == len(bins) - 1:\n            priorities[i] = -1\n        else:\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    priorities[i] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n    \n    total_capacity = sum(bins)\n    \n    if item > total_capacity:\n        msg = \"Item size exceeds total bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        remaining_capacity = total_capacity - sum(bins[:i])\n        if bins[i] >= item and remaining_capacity >= item:\n            priorities[i] = 1\n            break\n        elif i == len(bins) - 1:\n            priorities[i] = -1\n        else:\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    temp_capacity = total_capacity - sum(bins[:j])\n                    temp_sum = sum(bins[i:j+1])\n                    for k in range(j, len(bins)):\n                        temp_capacity += bins[k]\n                        temp_sum += bins[k]\n                        if bins[k] >= item and temp_sum >= item and temp_capacity >= item:\n                            priorities[j] = (k - i) + 1\n                            break\n                        elif k == len(bins) - 1:\n                            priorities[i] = -1\n                            break\n                if priorities[j] != 0:\n                    break\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:13:10", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        priority = 0\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n            if bin_capacity > 100:\n                priority *= 1.5\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 06:13:12", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if bin_capacity < item:\n            priority = -1\n        else:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            elif bin_capacity % item == 1:\n                priority = 1 / (bin_capacity - item + 2)\n            else:\n                priority = 1 / (bin_capacity - item + 3)\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 06:13:15", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                found_divisor = False\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        found_divisor = True\n                        break\n                if not found_divisor:\n                    priority = max(0, (3 - (bin_capacity - item))/2)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 06:13:17", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            if item % bin_capacity == 0:\n                priority = 0\n            else:\n                max_divisor = 1\n                for j in range(2, int(item/2)):\n                    if item % j == 0:\n                        max_divisor = j\n                priority = -(item - max_divisor)\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 06:13:21", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(data)\n    \n    for i in range(len(data)):\n        if data[i] % 2 == 0:\n            result[i] = data[i] * 2\n        elif data[i] % 3 == 0:\n            result[i] = data[i] * 3\n        else:\n            result[i] = data[i] // 2\n    \n    return result\n```", "strategy": []}
{"timestamp": "2025-04-27 06:13:23", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(matrix: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(matrix)\n    \n    for i in range(matrix.shape[0]):\n        for j in range(matrix.shape[1]):\n            if matrix[i, j] % 2 == 0:\n                result[i, j] = matrix[i, j] * 2\n            elif matrix[i, j] % 3 == 0:\n                result[i, j] = matrix[i, j] * 3\n            else:\n                result[i, j] = matrix[i, j]\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 06:13:25", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(input_list: List[int], target: int) -> List[List[int]]:\n    result = []\n\n    def backtrack(remaining_list, path):\n        if sum(path) == target:\n            result.append(path)\n            return\n        if sum(path) > target:\n            return\n\n        for i in range(len(remaining_list)):\n            new_path = path + [remaining_list[i]]\n            new_remaining_list = remaining_list[i+1:] \n            backtrack(new_remaining_list, new_path)\n\n    backtrack(input_list, [])\n    return result", "strategy": []}
{"timestamp": "2025-04-27 06:13:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(input_list: list) -> int:\n    result = 0\n    for i in range(len(input_list)):\n        if input_list[i] % 2 == 0:\n            result += input_list[i] ** 2\n        else:\n            result -= input_list[i] // 2\n            \n    if result > 100:\n        result *= 2\n    elif result < -100:\n        result //= 2\n        \n    return result", "strategy": []}
{"timestamp": "2025-04-27 06:13:31", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.25 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.5\n                elif remaining_capacity < 0.75 * item:\n                    priority += 0.7\n                else:\n                    priority += 0.9\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.8:\n                priorities[i] *= 2.0\n            elif priority < 0.6:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.3\n            \n            if i % 3 == 0:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.9\n                    else:\n                        priorities[j] = 0.6\n            elif i % 3 == 1:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.7\n                    else:\n                        priorities[j] = 0.4\n            else:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.8\n                    else:\n                        priorities[j] = 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i]\n        priority = 0.0\n        \n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            \n            if priority > 0.5:\n                priorities[i] = priority * 1.5\n            elif priority < 0.3:\n                priorities[i] = priority * 0.8\n            else:\n                priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i]\n        priority = 0.0\n        \n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            while remaining_capacity < item:\n                if remaining_capacity < item * 0.2:\n                    priority += 0.1\n                elif remaining_capacity < item * 0.4:\n                    priority += 0.3\n                elif remaining_capacity < item * 0.6:\n                    priority += 0.5\n                elif remaining_capacity < item * 0.8:\n                    priority += 0.7\n                else:\n                    priority += 0.9\n                remaining_capacity += bins[i] * 0.5\n            \n            if priority > 0.6:\n                priorities[i] = priority * 1.3\n            elif priority < 0.4:\n                priorities[i] = priority * 0.7\n            else:\n                priorities[i] = priority\n    \n    for j in range(len(bins)):\n        if priorities[j] > 0.8:\n            priorities[j] = min(priorities[j] * 1.2, 1.0)\n        elif priorities[j] < 0.4:\n            priorities[j] = max(priorities[j] * 0.8, 0.0)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:13:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.25 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.5\n                elif remaining_capacity < 0.75 * item:\n                    priority += 0.7\n                else:\n                    priority += 0.9\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.8:\n                priorities[i] *= 2.0\n            elif priority < 0.6:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.3\n            \n            if i % 3 == 0:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.9\n                    else:\n                        priorities[j] = 0.6\n            elif i % 3 == 1:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.7\n                    else:\n                        priorities[j] = 0.4\n            else:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.8\n                    else:\n                        priorities[j] = 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i]\n        priority = 0.0\n        \n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            \n            if priority > 0.5:\n                priorities[i] = priority * 1.5\n            elif priority < 0.3:\n                priorities[i] = priority * 0.8\n            else:\n                priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i]\n        priority = 0.0\n        \n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            while remaining_capacity < item:\n                if remaining_capacity < 0.25 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.4\n                elif remaining_capacity < 0.75 * item:\n                    priority += 0.6\n                else:\n                    priority += 0.8\n                remaining_capacity += bins[i]\n            \n            if priority > 0.6:\n                priorities[i] = priority * 1.3\n            elif priority < 0.4:\n                priorities[i] = priority * 0.7\n            else:\n                priorities[i] = priority\n            \n            if i % 2 == 0:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.8\n                    else:\n                        priorities[j] = 0.5\n            else:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.7\n                    else:\n                        priorities[j] = 0.4\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:13:39", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.25 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.5\n                elif remaining_capacity < 0.75 * item:\n                    priority += 0.7\n                else:\n                    priority += 0.9\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.8:\n                priorities[i] *= 2.0\n            elif priority < 0.6:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.3\n            \n            if i % 3 == 0:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.9\n                    else:\n                        priorities[j] = 0.6\n            elif i % 3 == 1:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.7\n                    else:\n                        priorities[j] = 0.4\n            else:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.8\n                    else:\n                        priorities[j] = 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i]\n        priority = 0.0\n        \n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            \n            if priority > 0.5:\n                priorities[i] = priority * 1.5\n            elif priority < 0.3:\n                priorities[i] = priority * 0.8\n            else:\n                priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i]\n        priority = 0.0\n        \n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            while remaining_capacity < item:\n                if remaining_capacity < 0.25 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.4\n                elif remaining_capacity < 0.75 * item:\n                    priority += 0.6\n                else:\n                    priority += 0.8\n                remaining_capacity += bins[i]\n            \n            if priority > 0.6:\n                priorities[i] = priority * 1.3\n            elif priority < 0.4:\n                priorities[i] = priority * 0.7\n            else:\n                priorities[i] = priority\n                \n            if i % 2 == 0:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= 2*item:\n                        priorities[j] = 0.8\n                    else:\n                        priorities[j] = 0.5\n            elif i % 2 == 1:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= 1.5*item:\n                        priorities[j] = 0.7\n                    else:\n                        priorities[j] = 0.4\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:13:42", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.25 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.5\n                elif remaining_capacity < 0.75 * item:\n                    priority += 0.7\n                else:\n                    priority += 0.9\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.8:\n                priorities[i] *= 2.0\n            elif priority < 0.6:\n                priorities[i] *= 0.7\n            else:\n                priorities[i] *= 1.3\n            \n            if i % 3 == 0:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.9\n                    else:\n                        priorities[j] = 0.6\n            elif i % 3 == 1:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.7\n                    else:\n                        priorities[j] = 0.4\n            else:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.8\n                    else:\n                        priorities[j] = 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i]\n        priority = 0.0\n        \n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            while remaining_capacity < item:\n                priority += 0.1\n                remaining_capacity += bins[i]\n            \n            if priority > 0.5:\n                priorities[i] = priority * 1.5\n            elif priority < 0.3:\n                priorities[i] = priority * 0.8\n            else:\n                priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i]\n        priority = 0.0\n        \n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            while remaining_capacity < item:\n                if remaining_capacity < 0.25 * item:\n                    priority += 0.2\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.4\n                elif remaining_capacity < 0.75 * item:\n                    priority += 0.6\n                else:\n                    priority += 0.8\n                remaining_capacity += bins[i]\n            \n            if priority > 0.7:\n                priorities[i] = priority * 1.8\n            elif priority < 0.4:\n                priorities[i] = priority * 0.6\n            else:\n                priorities[i] = priority\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:13:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                max_divisor = int(bin_capacity/2)\n                for i in range(2, max_divisor):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 06:13:53", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        priority = 0\n        \n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        for j in range(1, i):\n                            if bin_capacity % (i+j) == 0:\n                                priority = 0.5 / (bin_capacity - item + (i+j))\n                                break\n                        else:\n                            priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        \n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 06:13:56", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            elif bin_capacity % item == 1:\n                priority = 1 / (bin_capacity - item + 2)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 06:13:58", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        break\n                    else:\n                        priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            if bin_capacity % item == 0:\n                priority = 2 / (bin_capacity - item + 1)\n            else:\n                found_divisor = False\n                for i in range(2, int(bin_capacity/2)):\n                    if bin_capacity % i == 0:\n                        priority = 1 / (bin_capacity - item + i)\n                        found_divisor = True\n                        break\n                if not found_divisor:\n                    priority = 1 / (bin_capacity - item + 1)\n        else:\n            priority = -1\n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 06:14:02", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = 2*(item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 3*(item + 3) / bins[i]\n            else:\n                priorities[i] = 4*(item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.3) + np.log1p(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.8) + np.log2(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log1p(item / bins[i]) + np.exp(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = 2*np.log(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.sqrt(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log2(item / bins[i]) + np.exp(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = 2*(item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 3*(item + 3) / bins[i]\n            else:\n                priorities[i] = 4*(item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.3) + np.log1p(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.8) + np.log2(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log1p(item / bins[i]) + np.exp(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = 2*np.log(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.sqrt(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log2(item / bins[i]) + np.exp(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            if item % 3 == 0:\n                priorities[i] = 3*(item + 2) / bins[i]\n            elif item % 3 == 1:\n                priorities[i] = 4*(item + 4) / bins[i]\n            else:\n                priorities[i] = 5*(item + 6) / bins[i]\n        elif item > bins[i]/3 and item <= 2*bins[i]/3:\n            if item % 4 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log1p(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.9) + np.log2(item / bins[i])\n        else:\n            if item % 6 == 0:\n                priorities[i] = np.log1p(item / bins[i]) + np.exp(item / bins[i])\n            elif item % 6 == 1:\n                priorities[i] = 2*np.log(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 6 == 2:\n                priorities[i] = np.sqrt(item / bins[i]) + np.square(item / bins[i])\n            elif item % 6 == 3:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 6 == 4:\n                priorities[i] = np.log2(item / bins[i]) + np.exp(item / bins[i])\n            else:\n                priorities[i] = 1.5*np.log1p(item / bins[i]) + np.square(item / bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:14:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = 2*(item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 3*(item + 3) / bins[i]\n            else:\n                priorities[i] = 4*(item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.3) + np.log1p(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.8) + np.log2(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log1p(item / bins[i]) + np.exp(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = 2*np.log(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.sqrt(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log2(item / bins[i]) + np.exp(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = 2*(item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 3*(item + 3) / bins[i]\n            else:\n                priorities[i] = 4*(item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.3) + np.log1p(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.8) + np.log2(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log1p(item / bins[i]) + np.exp(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = 2*np.log(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.sqrt(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log2(item / bins[i]) + np.exp(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = 2*(item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 3*(item + 3) / bins[i]\n            else:\n                priorities[i] = 4*(item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.3) + np.log1p(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.8) + np.log2(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log1p(item / bins[i]) + np.exp(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = 2*np.log(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.sqrt(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log2(item / bins[i]) + np.exp(item / bins[i])\n            priorities[i] = priorities[i] ** 2\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:14:11", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = 2*(item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 3*(item + 3) / bins[i]\n            else:\n                priorities[i] = 4*(item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.3) + np.log1p(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.8) + np.log2(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log1p(item / bins[i]) + np.exp(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = 2*np.log(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.sqrt(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log2(item / bins[i]) + np.exp(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = 2*(item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 3*(item + 3) / bins[i]\n            else:\n                priorities[i] = 4*(item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.3) + np.log1p(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.8) + np.log2(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log1p(item / bins[i]) + np.exp(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = 2*np.log(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.sqrt(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log2(item / bins[i]) + np.exp(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            if item % 3 == 0:\n                priorities[i] = np.exp(item + 2) / bins[i]\n            elif item % 3 == 1:\n                priorities[i] = np.log1p(item + 1) / bins[i]\n            else:\n                priorities[i] = np.log2(item + 3) / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]/2:\n            if bins[i] % 4 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log1p(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.9) + np.log2(item / bins[i])\n        elif item > bins[i]/2 and item <= 2*bins[i]/3:\n            if item % 4 == 0:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 4 == 1:\n                priorities[i] = 2*np.log(item / bins[i]) + np.square(item / bins[i])\n            elif item % 4 == 2:\n                priorities[i] = np.sqrt(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log2(item / bins[i]) + np.exp(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log1p(item / bins[i]) + np.exp(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = 2*np.log(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.sqrt(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log2(item / bins[i]) + np.exp(item / bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:14:16", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = 2*(item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 3*(item + 3) / bins[i]\n            else:\n                priorities[i] = 4*(item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.3) + np.log1p(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.8) + np.log2(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log1p(item / bins[i]) + np.exp(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = 2*np.log(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.sqrt(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log2(item / bins[i]) + np.exp(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = 2*(item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 3*(item + 3) / bins[i]\n            else:\n                priorities[i] = 4*(item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.3) + np.log1p(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.8) + np.log2(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log1p(item / bins[i]) + np.exp(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = 2*np.log(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.sqrt(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log2(item / bins[i]) + np.exp(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            if item % 2 == 0:\n                priorities[i] = 3*(item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 4*(item + 2) / bins[i]\n            else:\n                priorities[i] = 2*(item + 3) / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]/1.5:\n            if bins[i] % 4 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log1p(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 1.1) + np.log2(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log1p(item / bins[i]) + np.exp(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = 2*np.log(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.sqrt(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 4:\n                priorities[i] = np.log2(item / bins[i]) + np.exp(item / bins[i])\n            elif item % 7 == 5:\n                priorities[i] = np.sin(item / bins[i]) + np.cos(item / bins[i])\n            else:\n                priorities[i] = np.arctan(item / bins[i]) + np.tan(item / bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:14:31", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = 2*(item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 3*(item + 3) / bins[i]\n            else:\n                priorities[i] = 4*(item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.3) + np.log1p(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.8) + np.log2(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log1p(item / bins[i]) + np.exp(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = 2*np.log(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.sqrt(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log2(item / bins[i]) + np.exp(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = 2*(item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 3*(item + 3) / bins[i]\n            else:\n                priorities[i] = 4*(item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.3) + np.log1p(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.8) + np.log2(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log1p(item / bins[i]) + np.exp(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = 2*np.log(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.sqrt(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log2(item / bins[i]) + np.exp(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            if item % 3 == 0:\n                priorities[i] = 3*(item + 2) / bins[i]\n            elif item % 3 == 1:\n                priorities[i] = 4*(item + 4) / bins[i]\n            else:\n                priorities[i] = 5*(item + 6) / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]/2:\n            if bins[i] % 4 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log1p(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 1.2) + np.log2(item / bins[i])\n        elif item > bins[i]/2 and item <= 2 * bins[i]/3:\n            priorities[i] = np.power(item / bins[i], 1.8) + np.log10(item / bins[i])\n        elif item > 2 * bins[i]/3 and item <= bins[i]:\n            priorities[i] = np.power(item / bins[i], 1.2) + np.log2(item / bins[i])\n        else:\n            if item % 6 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 6 == 1:\n                priorities[i] = np.sqrt(item / bins[i]) + np.square(item / bins[i])\n            elif item % 6 == 2:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 6 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.exp(item / bins[i])\n            elif item % 6 == 4:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.exp(item / bins[i]) + np.power(item / bins[i], 1.4)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:14:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = 2*(item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 3*(item + 3) / bins[i]\n            else:\n                priorities[i] = 4*(item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.3) + np.log1p(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.8) + np.log2(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log1p(item / bins[i]) + np.exp(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = 2*np.log(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.sqrt(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log2(item / bins[i]) + np.exp(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = 2*(item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 3*(item + 3) / bins[i]\n            else:\n                priorities[i] = 4*(item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.3) + np.log1p(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.8) + np.log2(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log1p(item / bins[i]) + np.exp(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = 2*np.log(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.sqrt(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log2(item / bins[i]) + np.exp(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = 2*(item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 3*(item + 3) / bins[i]\n            else:\n                priorities[i] = 4*(item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.3) + np.log1p(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.8) + np.log2(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log1p(item / bins[i]) + np.exp(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = 2*np.log(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.sqrt(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log2(item / bins[i]) + np.exp(item / bins[i])\n    \n    priorities = np.where(priorities < 0.5, priorities * 2, priorities)\n    priorities = np.where(priorities > 2, priorities / 2, priorities)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:14:38", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = 2*(item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 3*(item + 3) / bins[i]\n            else:\n                priorities[i] = 4*(item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.3) + np.log1p(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.8) + np.log2(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log1p(item / bins[i]) + np.exp(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = 2*np.log(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.sqrt(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log2(item / bins[i]) + np.exp(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = 2*(item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 3*(item + 3) / bins[i]\n            else:\n                priorities[i] = 4*(item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.3) + np.log1p(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.8) + np.log2(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log1p(item / bins[i]) + np.exp(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = 2*np.log(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.sqrt(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log2(item / bins[i]) + np.exp(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "import numpy as np\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i] / 3:\n            priorities[i] = np.log(item + 2) / bins[i] + np.sqrt(item / bins[i])\n        elif item > bins[i] / 3 and item <= bins[i] / 2:\n            priorities[i] = np.exp(item + 1) / bins[i] + np.log1p(item / bins[i])\n        elif item > bins[i] / 2 and item <= bins[i]:\n            priorities[i] = np.square(item + 5) / bins[i] + np.power(item / bins[i], 0.8)\n        else:\n            priorities[i] = np.cbrt(item + 3) / bins[i] + np.log2(item / bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:14:41", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = 2*(item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 3*(item + 3) / bins[i]\n            else:\n                priorities[i] = 4*(item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.3) + np.log1p(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.8) + np.log2(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log1p(item / bins[i]) + np.exp(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = 2*np.log(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.sqrt(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log2(item / bins[i]) + np.exp(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = 2*(item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 3*(item + 3) / bins[i]\n            else:\n                priorities[i] = 4*(item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.3) + np.log1p(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.8) + np.log2(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log1p(item / bins[i]) + np.exp(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = 2*np.log(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.sqrt(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log2(item / bins[i]) + np.exp(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/4:\n            priorities[i] = np.power(item / bins[i], 1.5) + np.log1p(item / bins[i])\n        elif item > bins[i]/4 and item <= bins[i]/2:\n            priorities[i] = np.power(item / bins[i], 1.2) + np.log2(item / bins[i])\n        elif item > bins[i]/2 and item <= bins[i]:\n            if item % 2 == 0:\n                priorities[i] = 1.5*(item + 2) / bins[i]\n            else:\n                priorities[i] = 2*(item + 4) / bins[i]\n        else:\n            if item % 3 == 0:\n                priorities[i] = np.log1p(item / bins[i]) + np.square(item / bins[i])\n            elif item % 3 == 1:\n                priorities[i] = 1.5*np.log(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.sqrt(item / bins[i]) + np.exp(item / bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:14:53", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "import numpy as np\n\n\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            if ratio < -0.5:\n                priorities[i] = -np.log(np.abs(ratio)) + 0.5\n            else:\n                priorities[i] = -np.log(np.abs(ratio)) - 0.5\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:14:55", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def custom_function(param1, param2):\n    result = []\n    for i in range(len(param1)):\n        if param1[i] > param2:\n            temp = param1[i] * param2\n            for j in range(param2):\n                temp += j\n            result.append(temp)\n        else:\n            temp = param1[i] + param2\n            for j in range(param2):\n                temp -= j\n            result.append(temp)\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 06:14:57", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(matrix: np.ndarray, values: np.ndarray) -> np.ndarray:\n    result = np.zeros(matrix.shape)\n    rows, cols = matrix.shape\n    \n    for i in range(rows):\n        for j in range(cols):\n            if matrix[i][j] > values[i]:\n                result[i][j] = matrix[i][j] + values[i]\n            elif matrix[i][j] <= values[i]:\n                result[i][j] = matrix[i][j] - values[i]\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 06:14:59", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros(data.shape)\n    \n    for i in range(data.shape[0]):\n        for j in range(data.shape[1]):\n            if data[i, j] >= 0:\n                result[i, j] = np.sqrt(data[i, j])\n            else:\n                result[i, j] = np.power(data[i, j], 2)\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 06:15:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n        \n        if bins[i] == max_bin_capacity:\n            priorities[i] += 1.5 * max_bin_capacity  # Increase priority for bins with max capacity\n        elif bins[i] <= 0.5 * max_bin_capacity:\n            priorities[i] -= 0.3 * bins[i]  # Decrease priority for bins with very low capacity\n        \n        for j in range(len(bins)):\n            if j != i:\n                diff = abs(bins[j] - bins[i])\n                priorities[j] -= 0.2 * diff  # Penalize bins with large capacity difference\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = item - bins[i]\n        elif bins[i] == min_capacity:\n            priorities[i] = bins[i] - item\n        else:\n            priorities[i] = abs(item - bins[i]) / (max_capacity - min_capacity)\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = item - bins[i]\n        elif bins[i] == min_capacity:\n            priorities[i] = bins[i] - item\n        else:\n            priorities[i] = abs(item - bins[i]) / (max_capacity - min_capacity)\n            \n        if item > bins[i]:\n            priorities[i] += 0.2 * (item - bins[i])\n        else:\n            priorities[i] -= 0.1 * (bins[i] - item)\n            \n        for j in range(len(bins)):\n            if j != i:\n                diff = abs(bins[j] - bins[i])\n                priorities[j] -= 0.1 * diff\n        \n        if bins[i] < 0.5 * max_capacity:\n            priorities[i] -= 0.3 * bins[i]\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:15:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n        \n        if bins[i] == max_bin_capacity:\n            priorities[i] += 1.5 * max_bin_capacity  # Increase priority for bins with max capacity\n        elif bins[i] <= 0.5 * max_bin_capacity:\n            priorities[i] -= 0.3 * bins[i]  # Decrease priority for bins with very low capacity\n        \n        for j in range(len(bins)):\n            if j != i:\n                diff = abs(bins[j] - bins[i])\n                priorities[j] -= 0.2 * diff  # Penalize bins with large capacity difference\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = item - bins[i]\n        elif bins[i] == min_capacity:\n            priorities[i] = bins[i] - item\n        else:\n            priorities[i] = abs(item - bins[i]) / (max_capacity - min_capacity)\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    capacities_diff = np.max(bins) - np.min(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = item - bins[i]\n        elif item < bins[i]:\n            priorities[i] = bins[i] - item\n        else:\n            priorities[i] = 0\n        \n        if bins[i] == np.max(bins):\n            priorities[i] += 0.5 * capacities_diff\n        if bins[i] == np.min(bins):\n            priorities[i] -= 0.3 * bins[i]\n        \n        for j in range(len(bins)):\n            if j != i:\n                diff = abs(bins[j] - bins[i])\n                priorities[j] -= 0.1 * diff\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:15:10", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n        \n        if bins[i] == max_bin_capacity:\n            priorities[i] += 1.5 * max_bin_capacity  # Increase priority for bins with max capacity\n        elif bins[i] <= 0.5 * max_bin_capacity:\n            priorities[i] -= 0.3 * bins[i]  # Decrease priority for bins with very low capacity\n        \n        for j in range(len(bins)):\n            if j != i:\n                diff = abs(bins[j] - bins[i])\n                priorities[j] -= 0.2 * diff  # Penalize bins with large capacity difference\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = item - bins[i]\n        elif bins[i] == min_capacity:\n            priorities[i] = bins[i] - item\n        else:\n            priorities[i] = abs(item - bins[i]) / (max_capacity - min_capacity)\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n    total_capacity = np.sum(bins)\n\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # High priority for bins that cannot accommodate the item\n        else:\n            priorities[i] = bins[i] - item\n        \n        if bins[i] == max_capacity:\n            priorities[i] += 1.5 * max_capacity  # Increase priority for bins with max capacity\n        elif bins[i] == min_capacity:\n            priorities[i] += 1.2 * min_capacity  # Increase priority for bins with min capacity\n        \n        for j in range(len(bins)):\n            if j != i:\n                diff = abs(bins[j] - bins[i])\n                priorities[j] -= 0.2 * diff  # Penalize bins with large capacity difference\n        \n        if total_capacity > 2 * item:\n            priorities[i] *= 0.8  # Reduce priority if the total capacity is much larger than the item size\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:15:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n    \n    priorities = np.zeros_like(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 2 * (item - bins[i])  # Double the priority\n        else:\n            priorities[i] = bins[i] - item\n        \n        if bins[i] == max_bin_capacity:\n            priorities[i] += 1.5 * max_bin_capacity  # Increase priority for bins with max capacity\n        elif bins[i] <= 0.5 * max_bin_capacity:\n            priorities[i] -= 0.3 * bins[i]  # Decrease priority for bins with very low capacity\n        \n        for j in range(len(bins)):\n            if j != i:\n                diff = abs(bins[j] - bins[i])\n                priorities[j] -= 0.2 * diff  # Penalize bins with large capacity difference\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = item - bins[i]\n        elif bins[i] == min_capacity:\n            priorities[i] = bins[i] - item\n        else:\n            priorities[i] = abs(item - bins[i]) / (max_capacity - min_capacity)\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if np.all(item <= bins):\n        return np.zeros_like(bins)\n\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    min_capacity = np.min(bins)\n    avg_capacity = np.mean(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == max_capacity:\n            priorities[i] = item - bins[i]\n        elif bins[i] == min_capacity:\n            priorities[i] = bins[i] - item\n        else:\n            priorities[i] = abs(item - bins[i]) / (max_capacity - min_capacity)\n        \n        if item > avg_capacity:\n            priorities[i] *= 1.2  # Increase priority for larger items\n        \n        for j in range(len(bins)):\n            if j != i:\n                diff = abs(bins[j] - bins[i])\n                priorities[j] -= 0.1 * diff  # Penalize bins with large capacity difference\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:15:22", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.square(ratio) + np.sqrt(np.sin(ratio)) - np.log(np.tanh(ratio))\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.tan(np.cosh(ratio)) * np.arcsin(np.cos(ratio)) + np.sinh(np.tan(ratio))\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.exp(np.square(ratio)) * np.log(np.cosh(ratio)) + np.sqrt(np.tanh(ratio))\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cosh(np.arctan(ratio)) * np.sinh(np.arcsin(ratio)) - np.tanh(np.cos(ratio))\n        else:\n            priority = np.square(np.cbrt(ratio)) + np.sqrt(np.exp(ratio)) - np.log(np.sinh(ratio))\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 06:15:25", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority_function(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.exp(ratio) + np.log(np.sqrt(ratio)) - np.tanh(ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.sin(2*ratio) * np.cos(3*ratio) + np.tan(4*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.abs(np.sinh(ratio)) * np.cosh(ratio) - np.arctan(ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cbrt(ratio) + np.sqrt(ratio) - np.cosh(ratio)\n        else:\n            priority = np.tan(ratio) + np.arcsinh(ratio) - np.arccos(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 06:15:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(ratio) * np.exp(2*ratio) - np.tan(ratio) + np.log(ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cbrt(2*ratio) * np.cos(ratio) + np.tanh(3*ratio) - np.sqrt(ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.arcsin(ratio) * np.arccos(ratio) + np.arctan(ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.exp(3*ratio) - np.log(ratio) + np.tan(2*ratio)\n        else:\n            priority = np.sinh(ratio) * np.cosh(ratio) - np.arcsinh(ratio) + np.tanh(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 06:15:31", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(ratio) * np.cos(2*ratio) + np.tan(3*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.tan(np.log(ratio)) + np.sqrt(ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.arctan(ratio) + np.arcsin(ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cbrt(ratio) + np.log10(ratio)\n        else:\n            priority = np.exp(ratio) + np.cos(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 06:15:47", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.exp(ratio) + np.log(ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cosh(2*ratio) * np.sinh(3*ratio) - np.tanh(ratio) + np.arcsin(ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.tan(ratio) * np.arctan(ratio) - np.sinh(ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cbrt(ratio) * np.sqrt(ratio) + np.log1p(ratio)\n        elif ratio >= 0.8 and ratio < 1.0:\n            priority = np.cosh(ratio) * np.sin(ratio) + np.tan(ratio)\n        else:\n            priority = np.exp(ratio) - np.log1p(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 06:15:51", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sinh(ratio) * np.cosh(ratio) + np.tanh(ratio) - np.arctan(ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.log(np.exp(ratio)) + np.sqrt(np.abs(ratio)) + np.tan(np.arcsin(ratio))\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.arcsin(np.arccos(ratio)) - np.log1p(ratio) + np.arctan(np.tanh(ratio))\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.cbrt(ratio) * np.exp(ratio) - np.log(np.abs(ratio)) + np.sinh(np.cosh(ratio))\n        else:\n            priority = np.exp(-ratio) + np.cos(np.tan(ratio)) + np.log(np.arcsin(ratio))\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 06:15:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(5*ratio) + np.exp(np.log(ratio)) - np.tanh(ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.cosh(ratio) * np.tan(ratio) + np.log(ratio) - np.sqrt(ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.arcsin(ratio) * np.arccos(ratio) + np.tanh(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.exp(ratio) * np.cosh(ratio) + np.sinh(ratio) - np.arcsin(ratio)\n        else:\n            priority = np.cos(4*ratio) * np.tan(3*ratio) + np.sqrt(ratio) - np.log(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 06:15:58", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \n    priorities = []\n    \n    for i in range(len(bins)):\n        bin_capacity = bins[i]\n        ratio = item / bin_capacity\n        \n        if ratio < 0.2:\n            priority = np.log(ratio) + np.sqrt(ratio) + np.cos(ratio)\n        elif ratio >= 0.2 and ratio < 0.5:\n            priority = np.exp(ratio) * np.log1p(ratio) + np.sinh(ratio)\n        elif ratio >= 0.5 and ratio < 0.8:\n            priority = np.cosh(ratio) * np.tanh(ratio) + np.arcsinh(ratio)\n        else:\n            priority = np.arccos(ratio) + np.arctan(ratio) + np.arcsin(ratio)\n        \n        priorities.append(priority)\n    \n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 06:16:07", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.exp(ratio) - np.log(ratio) + np.sqrt(np.sin(ratio))\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.tan(2*ratio) * np.arctan(ratio) + np.sinh(ratio) - np.cosh(ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.cbrt(ratio) * np.sqrt(ratio) + np.arcsinh(ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.sqrt(np.log(1/ratio)) + np.tanh(np.arctanh(ratio))\n        else:\n            priority = np.arccos(ratio) * np.arcsin(ratio) + np.euler_gamma\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 06:16:11", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sinh(ratio) * np.cosh(ratio) + np.log1p(ratio) - np.expm1(ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.tan(ratio) * np.arctan(ratio) + np.cos(ratio) - np.sin(ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.cbrt(ratio) * np.sqrt(ratio) + np.exp(ratio) - np.log(ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.arcsin(ratio) * np.arccos(ratio) + np.tan(ratio) - np.cos(ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 06:16:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(ratio) * np.cos(2*ratio) + np.tan(3*ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.tan(ratio) * np.sin(2*ratio) + np.cos(3*ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.sinh(ratio) * np.cosh(2*ratio) + np.tanh(3*ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.tanh(ratio) * np.sinh(2*ratio) + np.cosh(3*ratio)\n        else:\n            priority = np.arctan(ratio) * np.arcsin(2*ratio) + np.arccos(3*ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 06:16:17", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.power(ratio, 3) + np.log(ratio) - np.sqrt(ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.power(np.cos(ratio), 2) * np.tan(ratio) + np.arcsin(ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.cosh(ratio) + np.sinh(ratio) - np.tanh(ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.exp(ratio) * np.log(ratio) - np.sqrt(ratio)\n        else:\n            priority = np.cbrt(ratio) * np.sqrt(ratio) + np.cos(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 06:16:21", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    highest_priority = -1\n                    highest_priority_idx = -1\n                    for k in range(i, j):\n                        if priorities[k] == -1:\n                            continue\n                        if priorities[k] > highest_priority:\n                            highest_priority = priorities[k]\n                            highest_priority_idx = k\n                    if highest_priority > 1:\n                        priorities[highest_priority_idx] = 1\n                        priorities[j] = (j - highest_priority_idx) + 1\n                    else:\n                        priorities[i] = -1\n                        break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    remaining_items = item\n\n    for i in range(len(bins)):\n        if bins[i] >= remaining_items:\n            priorities[i] = remaining_items / bins[i]\n            remaining_items = 0\n            break\n        else:\n            priorities[i] = 1\n            remaining_items -= bins[i]\n    \n    if remaining_items > 0:\n        max_capacity_bin_index = np.argmax(bins)\n        if remaining_items <= bins[max_capacity_bin_index]:\n            priorities[max_capacity_bin_index] += remaining_items / bins[max_capacity_bin_index]\n            remaining_items = 0\n        else:\n            priorities[max_capacity_bin_index] = 1\n            remaining_items -= bins[max_capacity_bin_index]\n    \n    for j in range(max_capacity_bin_index+1, len(bins)):\n        if bins[j] >= remaining_items:\n            priorities[j] = remaining_items / bins[j]\n            remaining_items = 0\n            break\n        else:\n            priorities[j] = 1\n            remaining_items -= bins[j]\n    \n    if remaining_items > 0:\n        for k in range(len(bins)):\n            if bins[k] >= remaining_items:\n                priorities[k] += remaining_items / bins[k]\n                remaining_items = 0\n                break\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros(len(bins))\n    remaining_items = item\n    \n    max_capacity = max(bins)\n    \n    if item > max_capacity:\n        max_capacity_bin_index = np.argmax(bins)\n        remaining_items -= bins[max_capacity_bin_index]\n        priorities[max_capacity_bin_index] = 1\n        if remaining_items <= 0:\n            return priorities\n    \n    for i in range(len(bins)):\n        if bins[i] >= remaining_items:\n            priorities[i] = remaining_items / bins[i]\n            remaining_items = 0\n            break\n        else:\n            priorities[i] = 1\n            remaining_items -= bins[i]\n    \n    if remaining_items > 0:\n        for j in range(max_capacity_bin_index+1, len(bins)):\n            if bins[j] >= remaining_items:\n                priorities[j] = remaining_items / bins[j]\n                remaining_items = 0\n                break\n            else:\n                priorities[j] = 1\n                remaining_items -= bins[j]\n    \n    if remaining_items > 0:\n        for k in range(len(bins)):\n            if bins[k] >= remaining_items:\n                priorities[k] += remaining_items / bins[k]\n                remaining_items = 0\n                break\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:16:24", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    highest_priority = -1\n                    highest_priority_idx = -1\n                    for k in range(i, j):\n                        if priorities[k] == -1:\n                            continue\n                        if priorities[k] > highest_priority:\n                            highest_priority = priorities[k]\n                            highest_priority_idx = k\n                    if highest_priority > 1:\n                        priorities[highest_priority_idx] = 1\n                        priorities[j] = (j - highest_priority_idx) + 1\n                    else:\n                        priorities[i] = -1\n                        break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    remaining_items = item\n\n    for i in range(len(bins)):\n        if bins[i] >= remaining_items:\n            priorities[i] = remaining_items / bins[i]\n            remaining_items = 0\n            break\n        else:\n            priorities[i] = 1\n            remaining_items -= bins[i]\n    \n    if remaining_items > 0:\n        max_capacity_bin_index = np.argmax(bins)\n        if remaining_items <= bins[max_capacity_bin_index]:\n            priorities[max_capacity_bin_index] += remaining_items / bins[max_capacity_bin_index]\n            remaining_items = 0\n        else:\n            priorities[max_capacity_bin_index] = 1\n            remaining_items -= bins[max_capacity_bin_index]\n    \n    for j in range(max_capacity_bin_index+1, len(bins)):\n        if bins[j] >= remaining_items:\n            priorities[j] = remaining_items / bins[j]\n            remaining_items = 0\n            break\n        else:\n            priorities[j] = 1\n            remaining_items -= bins[j]\n    \n    if remaining_items > 0:\n        for k in range(len(bins)):\n            if bins[k] >= remaining_items:\n                priorities[k] += remaining_items / bins[k]\n                remaining_items = 0\n                break\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    remaining_items = item\n\n    if len(bins) == 0:\n        return priorities\n\n    max_capacity_bin_index = np.argmax(bins)\n    \n    if item > sum(bins):\n        max_priority_bins = np.argsort(bins)[::-1][:len(bins)//2]\n        for idx in max_priority_bins:\n            if remaining_items <= bins[idx]:\n                priorities[idx] += remaining_items / bins[idx]\n                remaining_items = 0\n                break\n            else:\n                priorities[idx] = 1\n                remaining_items -= bins[idx]\n    \n    for i in range(len(bins)):\n        if remaining_items == 0:\n            break\n        if bins[i] >= remaining_items:\n            priorities[i] = remaining_items / bins[i]\n            remaining_items = 0\n        else:\n            priorities[i] = 1\n            remaining_items -= bins[i]\n\n    if remaining_items > 0:\n        for j in range(len(bins)):\n            if bins[j] >= remaining_items:\n                priorities[j] += remaining_items / bins[j]\n                remaining_items = 0\n                break\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:16:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    highest_priority = -1\n                    highest_priority_idx = -1\n                    for k in range(i, j):\n                        if priorities[k] == -1:\n                            continue\n                        if priorities[k] > highest_priority:\n                            highest_priority = priorities[k]\n                            highest_priority_idx = k\n                    if highest_priority > 1:\n                        priorities[highest_priority_idx] = 1\n                        priorities[j] = (j - highest_priority_idx) + 1\n                    else:\n                        priorities[i] = -1\n                        break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    remaining_items = item\n\n    for i in range(len(bins)):\n        if bins[i] >= remaining_items:\n            priorities[i] = remaining_items / bins[i]\n            remaining_items = 0\n            break\n        else:\n            priorities[i] = 1\n            remaining_items -= bins[i]\n    \n    if remaining_items > 0:\n        max_capacity_bin_index = np.argmax(bins)\n        if remaining_items <= bins[max_capacity_bin_index]:\n            priorities[max_capacity_bin_index] += remaining_items / bins[max_capacity_bin_index]\n            remaining_items = 0\n        else:\n            priorities[max_capacity_bin_index] = 1\n            remaining_items -= bins[max_capacity_bin_index]\n    \n    for j in range(max_capacity_bin_index+1, len(bins)):\n        if bins[j] >= remaining_items:\n            priorities[j] = remaining_items / bins[j]\n            remaining_items = 0\n            break\n        else:\n            priorities[j] = 1\n            remaining_items -= bins[j]\n    \n    if remaining_items > 0:\n        for k in range(len(bins)):\n            if bins[k] >= remaining_items:\n                priorities[k] += remaining_items / bins[k]\n                remaining_items = 0\n                break\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    remaining_items = item\n\n    for i in range(len(bins)):\n        if remaining_items == 0:\n            break\n        if bins[i] >= remaining_items:\n            priorities[i] = remaining_items / bins[i]\n            remaining_items = 0\n        else:\n            priorities[i] = 1\n            remaining_items -= bins[i]\n    \n    if remaining_items > 0:\n        max_capacity_bin_index = np.argmax(bins)\n        if remaining_items <= bins[max_capacity_bin_index]:\n            priorities[max_capacity_bin_index] += remaining_items / bins[max_capacity_bin_index]\n            remaining_items = 0\n        else:\n            priorities[max_capacity_bin_index] = 1\n            remaining_items -= bins[max_capacity_bin_index]\n    \n    for j in range(max_capacity_bin_index+1, len(bins)):\n        if remaining_items == 0:\n            break\n        if bins[j] >= remaining_items:\n            priorities[j] = remaining_items / bins[j]\n            remaining_items = 0\n        else:\n            priorities[j] = 1\n            remaining_items -= bins[j]\n    \n    if remaining_items > 0:\n        for k in range(len(bins)):\n            if remaining_items == 0:\n                break\n            if bins[k] >= remaining_items:\n                priorities[k] += remaining_items / bins[k]\n                remaining_items = 0\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:16:31", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            remaining_capacity = bins[i]\n            for j in range(i+1, len(bins)):\n                remaining_capacity += bins[j]\n                if bins[j] >= item and remaining_capacity >= item:\n                    priorities[j] = (j - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    highest_priority = -1\n                    highest_priority_idx = -1\n                    for k in range(i, j):\n                        if priorities[k] == -1:\n                            continue\n                        if priorities[k] > highest_priority:\n                            highest_priority = priorities[k]\n                            highest_priority_idx = k\n                    if highest_priority > 1:\n                        priorities[highest_priority_idx] = 1\n                        priorities[j] = (j - highest_priority_idx) + 1\n                    else:\n                        priorities[i] = -1\n                        break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    remaining_items = item\n\n    for i in range(len(bins)):\n        if bins[i] >= remaining_items:\n            priorities[i] = remaining_items / bins[i]\n            remaining_items = 0\n            break\n        else:\n            priorities[i] = 1\n            remaining_items -= bins[i]\n    \n    if remaining_items > 0:\n        max_capacity_bin_index = np.argmax(bins)\n        if remaining_items <= bins[max_capacity_bin_index]:\n            priorities[max_capacity_bin_index] += remaining_items / bins[max_capacity_bin_index]\n            remaining_items = 0\n        else:\n            priorities[max_capacity_bin_index] = 1\n            remaining_items -= bins[max_capacity_bin_index]\n    \n    for j in range(max_capacity_bin_index+1, len(bins)):\n        if bins[j] >= remaining_items:\n            priorities[j] = remaining_items / bins[j]\n            remaining_items = 0\n            break\n        else:\n            priorities[j] = 1\n            remaining_items -= bins[j]\n    \n    if remaining_items > 0:\n        for k in range(len(bins)):\n            if bins[k] >= remaining_items:\n                priorities[k] += remaining_items / bins[k]\n                remaining_items = 0\n                break\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    remaining_items = item\n\n    if len(bins) == 0:\n        return priorities\n\n    max_capacity_bin_index = np.argmax(bins)\n    \n    if item > sum(bins):\n        msg = \"Item size exceeds total bin capacity\"\n        raise ValueError(msg)\n\n    for i in range(len(bins)):\n        if bins[i] >= remaining_items:\n            priorities[i] = remaining_items / bins[i]\n            remaining_items = 0\n            break\n        else:\n            priorities[i] = 1\n            remaining_items -= bins[i]\n    \n    if remaining_items > 0:\n        if remaining_items <= bins[max_capacity_bin_index]:\n            priorities[max_capacity_bin_index] += remaining_items / bins[max_capacity_bin_index]\n            remaining_items = 0\n        else:\n            priorities[max_capacity_bin_index] = 1\n            remaining_items -= bins[max_capacity_bin_index]\n    \n    for j in range(max_capacity_bin_index+1, len(bins)):\n        if bins[j] >= remaining_items:\n            priorities[j] = remaining_items / bins[j]\n            remaining_items = 0\n            break\n        else:\n            priorities[j] = 1\n            remaining_items -= bins[j]\n    \n    if remaining_items > 0:\n        for k in range(len(bins)):\n            if bins[k] >= remaining_items:\n                priorities[k] += remaining_items / bins[k]\n                remaining_items = 0\n                break\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:16:46", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n\n    max_capacity = max(bins)\n    max_capacity_idx = np.argmax(bins)\n\n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        prev_bin_capacity = bins[available_bins[idx-1]]\n                        curr_bin_capacity = bins[available_bins[idx]]\n                        priorities[available_bins[idx]] = (item - prev_bin_capacity) / (curr_bin_capacity - prev_bin_capacity)\n                else:\n                    priorities[max_capacity_idx] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    priorities[i] = 0.5\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    max_capacity = max(bins)\n    max_capacity_idx = np.argmax(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                if i % 2 == 0:\n                    priorities[i] = 0.8\n                elif i % 3 == 0:\n                    priorities[i] = 0.6\n                else:\n                    remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                    if remaining_items_sum >= item:\n                        priorities[i] = 0.9\n                    else:\n                        priorities[i] = 0.5\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:16:49", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n\n    max_capacity = max(bins)\n    max_capacity_idx = np.argmax(bins)\n\n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        prev_bin_capacity = bins[available_bins[idx-1]]\n                        curr_bin_capacity = bins[available_bins[idx]]\n                        priorities[available_bins[idx]] = (item - prev_bin_capacity) / (curr_bin_capacity - prev_bin_capacity)\n                else:\n                    priorities[max_capacity_idx] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    priorities[i] = 0.5\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                sum_remaining_items = sum([remaining_item for remaining_item in bins[i+1:] if remaining_item > item])\n                if sum_remaining_items >= item:\n                    priorities[i] = 0.9\n                else:\n                    for j in range(i, len(bins)):\n                        if bins[j] >= item:\n                            priorities[j] = 0.8\n                            break\n                        else:\n                            priorities[j] = item / bins[j]\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:16:53", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n\n    max_capacity = max(bins)\n    max_capacity_idx = np.argmax(bins)\n\n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        prev_bin_capacity = bins[available_bins[idx-1]]\n                        curr_bin_capacity = bins[available_bins[idx]]\n                        priorities[available_bins[idx]] = (item - prev_bin_capacity) / (curr_bin_capacity - prev_bin_capacity)\n                else:\n                    priorities[max_capacity_idx] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    priorities[i] = 0.5\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    max_capacity = max(bins)\n    max_capacity_idx = np.argmax(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n                    if available_bins:\n                        priorities[available_bins[0]] = 1.0\n                        for idx in range(1, len(available_bins)):\n                            prev_bin_capacity = bins[available_bins[idx-1]]\n                            curr_bin_capacity = bins[available_bins[idx]]\n                            priorities[available_bins[idx]] = (item - prev_bin_capacity) / (curr_bin_capacity - prev_bin_capacity)\n                    else:\n                        priorities[max_capacity_idx] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:16:56", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n\n    max_capacity = max(bins)\n    max_capacity_idx = np.argmax(bins)\n\n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n                if available_bins:\n                    priorities[available_bins[0]] = 1.0\n                    for idx in range(1, len(available_bins)):\n                        prev_bin_capacity = bins[available_bins[idx-1]]\n                        curr_bin_capacity = bins[available_bins[idx]]\n                        priorities[available_bins[idx]] = (item - prev_bin_capacity) / (curr_bin_capacity - prev_bin_capacity)\n                else:\n                    priorities[max_capacity_idx] = 1 - ((item - remaining_capacity) / (max_capacity - remaining_capacity))\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                remaining_items_sum = sum([item for index, item in enumerate(bins) if index > i])\n                if remaining_items_sum >= item:\n                    priorities[i] = 0.9\n                else:\n                    priorities[i] = 0.5\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i, bin_capacity in enumerate(bins):\n        if item == bin_capacity:\n            priorities[i] = 1.0\n        elif item < bin_capacity:\n            priorities[i] = item / bin_capacity\n        else:\n            remaining_capacity = bin_capacity\n            used_capacity = sum(bins[:i])\n            remaining_capacity -= used_capacity\n            if item <= remaining_capacity:\n                priorities[i] = 1.0\n            else:\n                available_bins = [k for k, capacity in enumerate(bins) if capacity >= item]\n                if available_bins:\n                    for idx in range(len(available_bins)):\n                        prev_sum = sum(bins[:available_bins[idx]])\n                        curr_sum = sum(bins[:available_bins[idx+1]]) if (idx+1) < len(available_bins) else sum(bins)\n                        priorities[available_bins[idx]] = (item - prev_sum) / (curr_sum - prev_sum)\n                else:\n                    priority_sum = 0\n                    for j in range(i, len(bins)):\n                        if bins[j] >= item:\n                            priorities[j] = 0.8\n                            priority_sum += 0.8\n                            if priority_sum == 2.0:\n                                break\n                    if priority_sum < 2.0:\n                        max_idx = np.argmax(bins)\n                        if priorities[max_idx] == 0:\n                            priorities[max_idx] = 1.0\n                            priority_sum += 1.0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:17:02", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    bin_ranges = []\n    current_range = [0, 0]\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            if current_range[0] == 0:\n                current_range[0] = i\n            current_range[1] = i\n            if i == len(bins) - 1 or bins[i] + bins[i+1] < item:\n                bin_ranges.append(current_range)\n                current_range = [0, 0]\n    \n    for start, end in bin_ranges:\n        remaining_capacity = sum(bins[start:end+1])\n        for j in range(end, len(bins)):\n            remaining_capacity += bins[j]\n            if bins[j] >= item and remaining_capacity >= item:\n                priorities[j] = (j - start) + 1\n                break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n    \n    total_capacity = sum(bins)\n    \n    if item > total_capacity:\n        msg = \"Item size exceeds total bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        remaining_capacity = total_capacity - sum(bins[:i])\n        if bins[i] >= item and remaining_capacity >= item:\n            priorities[i] = 1\n            break\n        elif i == len(bins) - 1:\n            priorities[i] = -1\n        else:\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    temp_capacity = total_capacity - sum(bins[:j])\n                    temp_sum = sum(bins[i:j+1])\n                    for k in range(j, len(bins)):\n                        temp_capacity += bins[k]\n                        temp_sum += bins[k]\n                        if bins[k] >= item and temp_sum >= item and temp_capacity >= item:\n                            priorities[j] = (k - i) + 1\n                            break\n                        elif k == len(bins) - 1:\n                            priorities[i] = -1\n                            break\n                if priorities[j] != 0:\n                    break\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n\n    total_capacity = sum(bins)\n\n    if item > total_capacity:\n        msg = \"Item size exceeds total bin capacity\"\n        raise ValueError(msg)\n\n    for i in range(len(bins)):\n        remaining_capacity = total_capacity - sum(bins[:i])\n        if bins[i] >= item and remaining_capacity >= item:\n            priorities[i] = 1\n            break\n        elif i == len(bins) - 1:\n            priorities[i] = -1\n        else:\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    temp_capacity = total_capacity - sum(bins[:j])\n                    temp_sum = sum(bins[i:j+1])\n                    for k in range(j, len(bins)):\n                        temp_capacity += bins[k]\n                        temp_sum += bins[k]\n                        if bins[k] >= item and temp_sum >= item and temp_capacity >= item:\n                            priorities[j] = (k - i) + 1\n                            break\n                        elif k == len(bins) - 1:\n                            priorities[i] = -1\n                            break\n                if priorities[j] != 0:\n                    break\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:17:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    bin_ranges = []\n    current_range = [0, 0]\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            if current_range[0] == 0:\n                current_range[0] = i\n            current_range[1] = i\n            if i == len(bins) - 1 or bins[i] + bins[i+1] < item:\n                bin_ranges.append(current_range)\n                current_range = [0, 0]\n    \n    for start, end in bin_ranges:\n        remaining_capacity = sum(bins[start:end+1])\n        for j in range(end, len(bins)):\n            remaining_capacity += bins[j]\n            if bins[j] >= item and remaining_capacity >= item:\n                priorities[j] = (j - start) + 1\n                break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n    \n    total_capacity = sum(bins)\n    \n    if item > total_capacity:\n        msg = \"Item size exceeds total bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        remaining_capacity = total_capacity - sum(bins[:i])\n        if bins[i] >= item and remaining_capacity >= item:\n            priorities[i] = 1\n            break\n        elif i == len(bins) - 1:\n            priorities[i] = -1\n        else:\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    temp_capacity = total_capacity - sum(bins[:j])\n                    temp_sum = sum(bins[i:j+1])\n                    for k in range(j, len(bins)):\n                        temp_capacity += bins[k]\n                        temp_sum += bins[k]\n                        if bins[k] >= item and temp_sum >= item and temp_capacity >= item:\n                            priorities[j] = (k - i) + 1\n                            break\n                        elif k == len(bins) - 1:\n                            priorities[i] = -1\n                            break\n                if priorities[j] != 0:\n                    break\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n    \n    total_capacity = sum(bins)\n    \n    if item > total_capacity:\n        msg = \"Item size exceeds total bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        remaining_capacity = total_capacity - sum(bins[:i])\n        if bins[i] >= item and remaining_capacity >= item:\n            priorities[i] = 1\n            break\n        elif i == len(bins) - 1:\n            priorities[i] = -1\n        else:\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    temp_capacity = total_capacity - sum(bins[:j])\n                    temp_sum = sum(bins[i:j+1])\n                    for k in range(j, len(bins)):\n                        temp_capacity += bins[k]\n                        temp_sum += bins[k]\n                        if bins[k] >= item and temp_sum >= item and temp_capacity >= item:\n                            priorities[j] = (k - i) + 1\n                            break\n                        elif k == len(bins) - 1:\n                            priorities[i] = -1\n                            break\n                if priorities[j] != 0:\n                    break\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:17:10", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    bin_ranges = []\n    current_range = [0, 0]\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            if current_range[0] == 0:\n                current_range[0] = i\n            current_range[1] = i\n            if i == len(bins) - 1 or bins[i] + bins[i+1] < item:\n                bin_ranges.append(current_range)\n                current_range = [0, 0]\n    \n    for start, end in bin_ranges:\n        remaining_capacity = sum(bins[start:end+1])\n        for j in range(end, len(bins)):\n            remaining_capacity += bins[j]\n            if bins[j] >= item and remaining_capacity >= item:\n                priorities[j] = (j - start) + 1\n                break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n    \n    total_capacity = sum(bins)\n    \n    if item > total_capacity:\n        msg = \"Item size exceeds total bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        remaining_capacity = total_capacity - sum(bins[:i])\n        if bins[i] >= item and remaining_capacity >= item:\n            priorities[i] = 1\n            break\n        elif i == len(bins) - 1:\n            priorities[i] = -1\n        else:\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    temp_capacity = total_capacity - sum(bins[:j])\n                    temp_sum = sum(bins[i:j+1])\n                    for k in range(j, len(bins)):\n                        temp_capacity += bins[k]\n                        temp_sum += bins[k]\n                        if bins[k] >= item and temp_sum >= item and temp_capacity >= item:\n                            priorities[j] = (k - i) + 1\n                            break\n                        elif k == len(bins) - 1:\n                            priorities[i] = -1\n                            break\n                if priorities[j] != 0:\n                    break\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n    \n    total_capacity = sum(bins)\n    \n    if item > total_capacity:\n        msg = \"Item size exceeds total bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        remaining_capacity = total_capacity - sum(bins[:i])\n        if bins[i] >= item and remaining_capacity >= item:\n            priorities[i] = 1\n            break\n        elif i == len(bins) - 1:\n            priorities[i] = -1\n            break\n        else:\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    temp_capacity = total_capacity - sum(bins[:j])\n                    temp_sum = sum(bins[i:j+1])\n                    for k in range(j, len(bins)):\n                        temp_capacity += bins[k]\n                        temp_sum += bins[k]                        \n                        if bins[k] >= item and temp_sum >= item and temp_capacity >= item:\n                            priorities[j] = (k - i) + 1\n                            break\n                        elif k == len(bins) - 1:\n                            priorities[i] = -1\n                            break\n                if priorities[j] != 0:\n                    break\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:17:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    bin_ranges = []\n    current_range = [0, 0]\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            if current_range[0] == 0:\n                current_range[0] = i\n            current_range[1] = i\n            if i == len(bins) - 1 or bins[i] + bins[i+1] < item:\n                bin_ranges.append(current_range)\n                current_range = [0, 0]\n    \n    for start, end in bin_ranges:\n        remaining_capacity = sum(bins[start:end+1])\n        for j in range(end, len(bins)):\n            remaining_capacity += bins[j]\n            if bins[j] >= item and remaining_capacity >= item:\n                priorities[j] = (j - start) + 1\n                break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n    \n    total_capacity = sum(bins)\n    \n    if item > total_capacity:\n        msg = \"Item size exceeds total bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        remaining_capacity = total_capacity - sum(bins[:i])\n        if bins[i] >= item and remaining_capacity >= item:\n            priorities[i] = 1\n            break\n        elif i == len(bins) - 1:\n            priorities[i] = -1\n        else:\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    temp_capacity = total_capacity - sum(bins[:j])\n                    temp_sum = sum(bins[i:j+1])\n                    for k in range(j, len(bins)):\n                        temp_capacity += bins[k]\n                        temp_sum += bins[k]\n                        if bins[k] >= item and temp_sum >= item and temp_capacity >= item:\n                            priorities[j] = (k - i) + 1\n                            break\n                        elif k == len(bins) - 1:\n                            priorities[i] = -1\n                            break\n                if priorities[j] != 0:\n                    break\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n\n    if len(bins) == 0:\n        return priorities\n    \n    total_capacity = sum(bins)\n    \n    if item > total_capacity:\n        msg = \"Item size exceeds total bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        remaining_capacity = total_capacity - sum(bins[:i])\n        if bins[i] >= item and remaining_capacity >= item:\n            priorities[i] = 1\n            break\n        elif i == len(bins) - 1:\n            priorities[i] = -1\n        else:\n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    temp_capacity = total_capacity - sum(bins[:j])\n                    temp_sum = sum(bins[i:j+1])\n                    for k in range(j, len(bins)):\n                        temp_capacity += bins[k]\n                        temp_sum += bins[k]\n                        if bins[k] >= item and temp_sum >= item and temp_capacity >= item:\n                            priorities[j] = (k - i) + 1\n                            break\n                        elif k == len(bins) - 1:\n                            priorities[i] = -1\n                            break\n                if priorities[j] != 0:\n                    break\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:17:18", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(ratio) + np.cos(ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.exp(ratio) - np.log(ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.tan(ratio) + np.arctan(ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.sinh(ratio) + np.cosh(ratio)\n        else:\n            priority = np.arcsinh(ratio) + np.arccosh(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 06:17:22", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.tan(ratio) + np.cosh(ratio) - np.arctan(ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.sin(ratio) * np.cbrt(ratio) + np.exp(ratio) - np.log(ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.cos(ratio) * np.sqrt(ratio) + np.tanh(ratio) - np.tan(ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.sinh(ratio) * np.exp(ratio) + np.arcsin(ratio) - np.cos(ratio)\n        else:\n            priority = np.log(ratio) * np.arctan(ratio) + np.cbrt(ratio) - np.sinh(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 06:17:24", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "import numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n    \n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = np.sin(ratio) + np.cos(ratio) + np.tan(ratio)\n        elif ratio >= 0.2 and ratio < 0.4:\n            priority = np.sqrt(ratio) + np.log(ratio) + np.exp(ratio)\n        elif ratio >= 0.4 and ratio < 0.6:\n            priority = np.cosh(ratio) - np.sinh(ratio) + np.tanh(ratio)\n        elif ratio >= 0.6 and ratio < 0.8:\n            priority = np.sin(np.pi*ratio) + np.cos(np.pi*ratio) + np.tan(np.pi*ratio)\n        else:\n            priority = np.arcsin(ratio) + np.arccos(ratio) + np.arctan(ratio)\n        \n        priorities.append(priority)\n    \n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 06:17:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.3:\n            priority = ratio ** 2 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.3 and ratio < 0.6:\n            priority = np.cos(3*ratio) * np.tan(2*ratio) + np.sin(4*ratio)\n        elif ratio >= 0.6 and ratio < 0.9:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(2*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arcsin(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = []\n\n    for ratio in ratios:\n        if ratio < 0.2:\n            priority = ratio**3 + np.sqrt(ratio) - np.cbrt(ratio)\n        elif ratio >= 0.2 and ratio < 0.5:\n            priority = np.cos(4*ratio) * np.tan(3*ratio) + np.sin(5*ratio)\n        elif ratio >= 0.5 and ratio < 0.8:\n            priority = np.exp(ratio) * np.log(ratio) + np.sqrt(3*ratio)\n        else:\n            priority = np.cosh(ratio) * np.sinh(ratio) - np.tanh(ratio) + np.arctan(ratio)\n\n        priorities.append(priority)\n\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 06:17:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_function(input_data: np.ndarray) -> np.ndarray:\n    \"\"\"A complex and creative function.\"\"\"\n    output_data = np.zeros_like(input_data)\n\n    for i in range(len(input_data)):\n        if input_data[i] % 2 == 0:\n            output_data[i] = input_data[i] * 2\n        else:\n            output_data[i] = input_data[i] / 2\n\n        if i > 0:\n            if input_data[i] > input_data[i-1]:\n                output_data[i] += 10\n            else:\n                output_data[i] -= 10\n\n            if i < len(input_data) - 1:\n                if input_data[i] < input_data[i+1]:\n                    output_data[i] *= 2\n                else:\n                    output_data[i] /= 2\n\n    return output_data\n```", "strategy": []}
{"timestamp": "2025-04-27 06:17:37", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_function(input_data: np.ndarray) -> np.ndarray:\n    output_data = np.zeros_like(input_data)\n    \n    for i in range(len(input_data)):\n        if input_data[i] % 2 == 0:\n            output_data[i] = input_data[i] * 2\n        else:\n            temp_value = input_data[i]\n            while temp_value > 0:\n                output_data[i] += temp_value % 10\n                temp_value //= 10\n    \n    return output_data\n```", "strategy": []}
{"timestamp": "2025-04-27 06:17:40", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.1:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.1 <= utilization < 0.3:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.3 <= utilization < 0.5:\n                    priorities[i] = 3\n                elif 0.5 <= utilization < 0.7:\n                    priorities[i] = 4 * utilization\n                elif 0.7 <= utilization < 0.9:\n                    priorities[i] = 5 * np.sqrt(utilization)\n                elif 0.9 <= utilization <= 1.0:\n                    priorities[i] = 6 * np.cbrt(utilization)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:17:43", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.1:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.1 <= utilization < 0.3:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.3 <= utilization < 0.5:\n                    priorities[i] = 3\n                elif 0.5 <= utilization < 0.7:\n                    priorities[i] = 4 * utilization\n                elif 0.7 <= utilization < 0.9:\n                    priorities[i] = 5 * np.sqrt(utilization)\n                elif 0.9 <= utilization <= 1.0:\n                    priorities[i] = 6 * np.log(utilization + 1)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:17:48", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.1:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.1 <= utilization < 0.3:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.3 <= utilization < 0.5:\n                    priorities[i] = 3\n                elif 0.5 <= utilization < 0.7:\n                    priorities[i] = 4 * utilization\n                elif 0.7 <= utilization < 0.9:\n                    priorities[i] = 5 * np.sqrt(utilization)\n                elif 0.9 <= utilization <= 1.0:\n                    priorities[i] = 6 * np.log(utilization + 1)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:17:51", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n                    \n                    if bins[i] % 2 == 0:\n                        priorities[i] *= 1.5\n                    else:\n                        priorities[i] /= 2\n                    \n                    if item < 0.3 * bins[i]:\n                        priorities[i] += 2\n                    else:\n                        priorities[i] -= 1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:17:55", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n                    \n                if item < 10 and bins[i] > 20:\n                    priorities[i] += 2\n                elif item > 20 and utilization < 0.5:\n                    priorities[i] *= 1.5\n                elif item % 2 == 0 or bins[i] % 2 == 0:\n                    priorities[i] *= 1.2\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:17:59", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Another improved version of `priority`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            left_capacity = bins[i] - item\n            if left_capacity == 0:\n                priorities[i] = 0\n            else:\n                utilization = item / bins[i]\n                if utilization < 0.2:\n                    priorities[i] = 1 / (1 - utilization)\n                elif 0.2 <= utilization < 0.4:\n                    priorities[i] = 2 / (1 + utilization)\n                elif 0.4 <= utilization < 0.6:\n                    priorities[i] = 3\n                elif 0.6 <= utilization < 0.8:\n                    priorities[i] = 4 * utilization\n                elif 0.8 <= utilization <= 1.0:\n                    priorities[i] = 5 * np.sqrt(utilization)\n                    \n                # Additional complexity\n                if utilization > 0.5:\n                    priorities[i] *= 1.5\n                elif 0.3 <= utilization <= 0.5:\n                    priorities[i] *= 1.2\n                elif utilization < 0.3:\n                    priorities[i] *= 1.1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:18:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.3 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.8\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 2.0\n            elif priority < 0.5:\n                priorities[i] *= 0.6\n            else:\n                priorities[i] *= 1.5\n            \n            if i % 2 == 0:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.8\n                    else:\n                        priorities[j] = 0.5\n            else:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.6\n                    else:\n                        priorities[j] = 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.1\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.8 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 2.0\n            elif priority < 0.4:\n                priorities[i] *= 0.6\n            else:\n                priorities[i] *= 1.5\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.8\n                else:\n                    priorities[j] = 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.1\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.8 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 2.0\n            elif priority < 0.4:\n                priorities[i] *= 0.6\n            else:\n                priorities[i] *= 1.5\n            \n            if i % 3 == 0:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        if priorities[j] < 0.6:\n                            priorities[j] = 0.6\n                        else:\n                            priorities[j] += 0.3\n                    else:\n                        priorities[j] = 0.3\n            else:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.8\n                    else:\n                        priorities[j] = 0.4\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:18:08", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.3 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.8\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 2.0\n            elif priority < 0.5:\n                priorities[i] *= 0.6\n            else:\n                priorities[i] *= 1.5\n            \n            if i % 2 == 0:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.8\n                    else:\n                        priorities[j] = 0.5\n            else:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.6\n                    else:\n                        priorities[j] = 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.1\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.8 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 2.0\n            elif priority < 0.4:\n                priorities[i] *= 0.6\n            else:\n                priorities[i] *= 1.5\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.8\n                else:\n                    priorities[j] = 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.1\n                elif remaining_capacity < 0.4 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.5\n                elif remaining_capacity < 0.8 * item:\n                    priority += 0.7\n                else:\n                    priority += 0.9\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.8:\n                priorities[i] *= 2.0\n            elif priority < 0.4:\n                priorities[i] *= 0.6\n            else:\n                priorities[i] *= 1.3\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.7\n                else:\n                    priorities[j] = 0.4\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:18:11", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.3 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.8\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 2.0\n            elif priority < 0.5:\n                priorities[i] *= 0.6\n            else:\n                priorities[i] *= 1.5\n            \n            if i % 2 == 0:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.8\n                    else:\n                        priorities[j] = 0.5\n            else:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.6\n                    else:\n                        priorities[j] = 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.1\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.8 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 2.0\n            elif priority < 0.4:\n                priorities[i] *= 0.6\n            else:\n                priorities[i] *= 1.5\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.8\n                else:\n                    priorities[j] = 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.1\n                elif remaining_capacity < 0.4 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.5\n                elif remaining_capacity < 0.8 * item:\n                    priority += 0.6\n                else:\n                    priority += 0.8\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 2.0\n            elif priority < 0.3:\n                priorities[i] *= 0.5\n            else:\n                priorities[i] *= 1.4\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    if i % 2 == 0:\n                        priorities[j] = 0.9\n                    else:\n                        priorities[j] = 0.7\n                else:\n                    if i % 2 == 0:\n                        priorities[j] = 0.4\n                    else:\n                        priorities[j] = 0.2\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:18:15", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.3 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.6 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.8\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 2.0\n            elif priority < 0.5:\n                priorities[i] *= 0.6\n            else:\n                priorities[i] *= 1.5\n            \n            if i % 2 == 0:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.8\n                    else:\n                        priorities[j] = 0.5\n            else:\n                for j in range(i+1, len(bins)):\n                    if bins[j] >= item:\n                        priorities[j] = 0.6\n                    else:\n                        priorities[j] = 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.1\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.8 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 2.0\n            elif priority < 0.4:\n                priorities[i] *= 0.6\n            else:\n                priorities[i] *= 1.5\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.8\n                else:\n                    priorities[j] = 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            priority = 0.0\n            while remaining_capacity < item:\n                if remaining_capacity < 0.2 * item:\n                    priority += 0.1\n                elif remaining_capacity < 0.5 * item:\n                    priority += 0.3\n                elif remaining_capacity < 0.8 * item:\n                    priority += 0.5\n                else:\n                    priority += 0.7\n                remaining_capacity += bins[i]\n            priorities[i] = priority\n            \n            if priority > 0.7:\n                priorities[i] *= 2.0\n            elif priority < 0.4:\n                priorities[i] *= 0.6\n            else:\n                priorities[i] *= 1.5\n            \n            for j in range(i+1, len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = 0.8\n                else:\n                    priorities[j] = 0.3\n            \n            if i % 3 == 0:\n                for k in range(i+2, len(bins)):\n                    if bins[k] >= item:\n                        priorities[k] = 0.9\n                    else:\n                        priorities[k] = 0.4\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:18:23", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = 2*(item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 3*(item + 3) / bins[i]\n            else:\n                priorities[i] = 4*(item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.3) + np.log1p(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.8) + np.log2(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log1p(item / bins[i]) + np.exp(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = 2*np.log(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.sqrt(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log2(item / bins[i]) + np.exp(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/4:\n            if item % 3 == 0:\n                priorities[i] = (item + 2) / bins[i]\n            elif item % 3 == 1:\n                priorities[i] = 2*(item + 4) / bins[i]\n            else:\n                priorities[i] = (item + 6) / bins[i]\n        elif item > bins[i]/4 and item <= bins[i]/2:\n            if bins[i] % 5 == 0:\n                priorities[i] = np.power(item / bins[i], 1.7) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.6) + np.log10(item / bins[i])\n        elif item > bins[i]/2 and item <= 3*bins[i]/4:\n            if item % 4 == 0:\n                priorities[i] = np.cbrt(item / bins[i]) + np.square(item / bins[i])\n            elif item % 4 == 1:\n                priorities[i] = np.cbrt(item / bins[i]) + np.exp(item / bins[i])\n            elif item % 4 == 2:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n        else:\n            if item % 6 == 0:\n                priorities[i] = np.square(item / bins[i]) + np.exp(item / bins[i])\n            elif item % 6 == 1:\n                priorities[i] = np.cbrt(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 6 == 2:\n                priorities[i] = np.log10(item / bins[i]) + np.log1p(item / bins[i])\n            elif item % 6 == 3:\n                priorities[i] = np.log2(item / bins[i]) + np.exp(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:18:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = 2*(item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 3*(item + 3) / bins[i]\n            else:\n                priorities[i] = 4*(item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.3) + np.log1p(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.8) + np.log2(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log1p(item / bins[i]) + np.exp(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = 2*np.log(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.sqrt(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log2(item / bins[i]) + np.exp(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            if item % 3 == 0:\n                priorities[i] = np.sqrt(item) / bins[i]\n            elif item % 3 == 1:\n                priorities[i] = np.cbrt(item) / bins[i]\n            else:\n                priorities[i] = np.square(item) / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]*2/3:\n            if bins[i] % 4 == 0:\n                priorities[i] = np.power(item, 1.7) / np.log1p(item)\n            else:\n                priorities[i] = np.power(item, 0.6) + np.log2(item)\n        else:\n            if item % 6 == 0:\n                priorities[i] = np.cbrt(item) + np.log1p(item)\n            elif item % 6 == 1:\n                priorities[i] = np.square(item) + np.sqrt(item)\n            elif item % 6 == 2:\n                priorities[i] = np.log1p(item) + np.power(item, 1.5)\n            elif item % 6 == 3:\n                priorities[i] = np.exp(item) + np.log(item)\n            elif item % 6 == 4:\n                priorities[i] = np.sqrt(item) + np.cbrt(item)\n            else:\n                priorities[i] = np.log10(item) + np.exp(item)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:18:31", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = 2*(item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 3*(item + 3) / bins[i]\n            else:\n                priorities[i] = 4*(item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.3) + np.log1p(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.8) + np.log2(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log1p(item / bins[i]) + np.exp(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = 2*np.log(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.sqrt(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log2(item / bins[i]) + np.exp(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            if item % 3 == 0:\n                priorities[i] = np.log(item + 2) / bins[i]\n            elif item % 3 == 1:\n                priorities[i] = np.square(item + 3) / bins[i]\n            else:\n                priorities[i] = np.cbrt(item + 4) / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]*0.75:\n            if bins[i] % 4 == 0:\n                priorities[i] = np.power(item / bins[i], 1.6) + np.log1p(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.9) + np.log2(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log1p(item / bins[i]) + np.exp(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = np.tan(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.sqrt(np.sin(item) / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log10(item / bins[i]) + np.tanh(item / bins[i])\n            else:\n                priorities[i] = np.log2(item / bins[i]) + np.exp(np.tan(item) / bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:18:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = 2*(item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 3*(item + 3) / bins[i]\n            else:\n                priorities[i] = 4*(item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.3) + np.log1p(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.8) + np.log2(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log1p(item / bins[i]) + np.exp(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = 2*np.log(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.sqrt(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log2(item / bins[i]) + np.exp(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 3 == 0:\n                priorities[i] = (item + 2) / bins[i]\n            elif item % 3 == 1:\n                priorities[i] = 1.5*(item + 4) / bins[i]\n            else:\n                priorities[i] = (item + 3) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 4 == 0:\n                priorities[i] = np.power(item / bins[i], 1.7) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.6) + np.log10(item / bins[i])\n        else:\n            if item % 6 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 6 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 6 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 6 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:18:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = 2*(item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 3*(item + 3) / bins[i]\n            else:\n                priorities[i] = 4*(item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.3) + np.log1p(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.8) + np.log2(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log1p(item / bins[i]) + np.exp(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = 2*np.log(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.sqrt(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log2(item / bins[i]) + np.exp(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            if item % 3 == 0:\n                priorities[i] = np.power(item + 2, 1.2) / bins[i]\n            elif item % 3 == 1:\n                priorities[i] = np.log1p(item + 4) / bins[i] + np.sqrt(item + 4) / bins[i]\n            else:\n                priorities[i] = 3*(item + 6) / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]/2:\n            if bins[i] % 4 == 0:\n                priorities[i] = np.cbrt(item / bins[i]) + np.power(item / bins[i], 1.5)\n            else:\n                priorities[i] = np.log1p(item / bins[i]) + np.sqrt(item / bins[i])\n        elif item > bins[i]/2 and item <= bins[i]*0.75:\n            if item % 2 == 0:\n                priorities[i] = 2*(item + 3) / bins[i] + np.log1p(item + 3) / bins[i]\n            else:\n                priorities[i] = np.sqrt(item + 5) / bins[i] + np.exp(item + 5) / bins[i]\n        else:\n            if item % 4 == 0:\n                priorities[i] = np.cbrt(item / bins[i]) + np.power(item / bins[i], 1.8)\n            elif item % 4 == 1:\n                priorities[i] = np.log1p(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 4 == 2:\n                priorities[i] = np.log(item / bins[i]) + np.square(item / bins[i])\n            else:\n                priorities[i] = np.sqrt(item / bins[i]) + np.log1p(item / bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:19:00", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = 2*(item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 3*(item + 3) / bins[i]\n            else:\n                priorities[i] = 4*(item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.3) + np.log1p(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.8) + np.log2(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log1p(item / bins[i]) + np.exp(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = 2*np.log(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.sqrt(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log2(item / bins[i]) + np.exp(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 2) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = (item + 4) / bins[i]\n            else:\n                priorities[i] = (item + 6) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 4 == 0:\n                priorities[i] = np.power(item / bins[i], 1.7) + np.log(item / bins[i]) + np.sqrt(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.9) + np.log10(item / bins[i]) + np.square(item / bins[i])\n        else:\n            if item % 9 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 9 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i]) + np.square(item / bins[i])\n            elif item % 9 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 9 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i]) + np.log(item / bins[i])\n            elif item % 9 == 4:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i]) + np.log10(item / bins[i])\n            else:\n                priorities[i] = np.log2(item / bins[i]) + np.exp(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:19:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = 2*(item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 3*(item + 3) / bins[i]\n            else:\n                priorities[i] = 4*(item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.3) + np.log1p(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.8) + np.log2(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log1p(item / bins[i]) + np.exp(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = 2*np.log(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.sqrt(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log2(item / bins[i]) + np.exp(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 6 == 0:\n                priorities[i] = (item + 2) / bins[i]\n            elif item % 6 == 1:\n                priorities[i] = 2*(item + 4) / bins[i]\n            elif item % 6 == 2:\n                priorities[i] = 3*(item + 6) / bins[i]\n            elif item % 6 == 3:\n                priorities[i] = (item + 8) / bins[i]\n            elif item % 6 == 4:\n                priorities[i] = 5*(item + 10) / bins[i]\n            else:\n                priorities[i] = (item + 12) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 4 == 0:\n                priorities[i] = np.power(item / bins[i], 1.8) + np.log(item / bins[i])\n            elif bins[i] % 4 == 1:\n                priorities[i] = np.power(item / bins[i], 0.5) + np.log2(item / bins[i])\n            elif bins[i] % 4 == 2:\n                priorities[i] = np.power(item / bins[i], 2) + np.log10(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log1p(item / bins[i])\n        else:\n            if item % 8 == 0:\n                priorities[i] = np.sqrt(item / bins[i]) + np.square(item / bins[i])\n            elif item % 8 == 1:\n                priorities[i] = np.exp(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 8 == 2:\n                priorities[i] = np.log10(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 8 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 8 == 4:\n                priorities[i] = np.log(item / bins[i]) + np.square(item / bins[i])\n            elif item % 8 == 5:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 8 == 6:\n                priorities[i] = np.cbrt(item / bins[i]) + np.exp(item / bins[i])\n            else:\n                priorities[i] = np.square(item / bins[i]) + np.log(item / bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:19:11", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = 2*(item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 3*(item + 3) / bins[i]\n            else:\n                priorities[i] = 4*(item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.3) + np.log1p(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.8) + np.log2(item / bins[i])\n        else:\n            if item % 5 == 0:\n                priorities[i] = np.log1p(item / bins[i]) + np.exp(item / bins[i])\n            elif item % 5 == 1:\n                priorities[i] = 2*np.log(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 5 == 2:\n                priorities[i] = np.sqrt(item / bins[i]) + np.square(item / bins[i])\n            elif item % 5 == 3:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log2(item / bins[i]) + np.exp(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            if item % 2 == 0:\n                priorities[i] = (item + 1) / bins[i]\n            elif item % 2 == 1:\n                priorities[i] = 2*(item + 3) / bins[i]\n            else:\n                priorities[i] = (item + 5) / bins[i]\n        elif item > bins[i]/2 and item <= bins[i]:\n            if bins[i] % 3 == 0:\n                priorities[i] = np.power(item / bins[i], 1.5) + np.log(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.7) + np.log10(item / bins[i])\n        else:\n            if item % 7 == 0:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n            elif item % 7 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 7 == 2:\n                priorities[i] = np.exp(item / bins[i]) + np.square(item / bins[i])\n            elif item % 7 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            else:\n                priorities[i] = np.log(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]/3:\n            if item % 3 == 0:\n                priorities[i] = np.log1p(item) + np.sqrt(item) / bins[i]\n            elif item % 3 == 1:\n                priorities[i] = np.log(item) + np.cbrt(item) / bins[i]\n            else:\n                priorities[i] = np.exp(item) + np.square(item) / bins[i]\n        elif item > bins[i]/3 and item <= bins[i]*0.75:\n            if bins[i] % 4 == 0:\n                priorities[i] = np.power(item / bins[i], 1.8) + np.log10(item / bins[i])\n            else:\n                priorities[i] = np.power(item / bins[i], 0.6) + np.log2(item / bins[i])\n        else:\n            if item % 6 == 0:\n                priorities[i] = np.cbrt(item / bins[i]) + np.square(item / bins[i])\n            elif item % 6 == 1:\n                priorities[i] = np.log10(item / bins[i]) + np.exp(item / bins[i])\n            elif item % 6 == 2:\n                priorities[i] = np.sqrt(item / bins[i]) + np.exp(item / bins[i])\n            elif item % 6 == 3:\n                priorities[i] = np.log1p(item / bins[i]) + np.cbrt(item / bins[i])\n            elif item % 6 == 4:\n                priorities[i] = np.square(item / bins[i]) + np.exp(item / bins[i])\n            else:\n                priorities[i] = np.log2(item / bins[i]) + np.sqrt(item / bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:19:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def calculate_similarity_matrix(data: np.ndarray) -> np.ndarray:\n    num_samples = data.shape[0]\n    sim_matrix = np.zeros((num_samples, num_samples))\n\n    for i in range(num_samples):\n        for j in range(num_samples):\n            if i == j:\n                sim_matrix[i, j] = 1.0\n            elif i < j:\n                vec1 = data[i]\n                vec2 = data[j]\n                sim_score = 0\n                \n                for k in range(len(vec1)):\n                    if vec1[k] == vec2[k]:\n                        sim_score += 1\n                \n                sim_matrix[i, j] = sim_score / len(vec1)\n                sim_matrix[j, i] = sim_score / len(vec1)\n\n    return sim_matrix", "strategy": []}
{"timestamp": "2025-04-27 06:19:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef complex_function(input_list: list) -> int:\n    result = 0\n    \n    for i in range(len(input_list)):\n        if i % 2 == 0:\n            result += input_list[i] * 2\n        else:\n            result -= input_list[i]\n    \n    if result < 0:\n        result = abs(result)\n    else:\n        result = result ** 2\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 06:19:33", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_function(input_data: np.ndarray) -> np.ndarray:\n    output_data = np.zeros(input_data.shape)\n    \n    for i in range(input_data.shape[0]):\n        for j in range(input_data.shape[1]):\n            if input_data[i, j] % 2 == 0:\n                output_data[i, j] = input_data[i, j] * 2\n            elif input_data[i, j] % 3 == 0:\n                output_data[i, j] = input_data[i, j] * 3\n            else:\n                output_data[i, j] = input_data[i, j]\n    \n    return output_data\n```", "strategy": []}
{"timestamp": "2025-04-27 06:19:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(input_data):\n    output = []\n    \n    for i in range(len(input_data)):\n        if input_data[i] % 2 == 0:\n            output.append(input_data[i] ** 2)\n        else:\n            temp = 1\n            for j in range(1, input_data[i] + 1):\n                temp *= j\n            output.append(temp)\n    \n    return output", "strategy": []}
{"timestamp": "2025-04-27 06:19:42", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            if item > 30 and bins[i] > 25:\n                priorities[i] = 11\n            elif item > 25 and bins[i] > 20:\n                priorities[i] = 10\n            else:\n                priorities[i] = 9\n        elif ratios[i] > 1.1:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 15 and bins[i] > 12:\n                priorities[i] = 7\n            else:\n                priorities[i] = 6\n        elif ratios[i] > 0.9:\n            if item > 10 and bins[i] > 8:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.8:\n            if item > 6 and bins[i] > 4:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.7:\n            if item > 3 and bins[i] > 2:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.5:\n            if item > 1 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            priorities[i] = 10\n        elif ratios[i] > 1.1:\n            if item > 25 and bins[i] > 20:\n                priorities[i] = 9\n            elif item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 18 and bins[i] > 12:\n                priorities[i] = 7\n            elif item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.9:\n            if item > 12 and bins[i] > 8:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 6:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.8:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 5\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.7:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 4\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] > 0.5:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.5:\n            priorities[i] = 15\n        elif ratios[i] > 1.3:\n            if item > 28 and bins[i] > 22:\n                priorities[i] = 14\n            elif item > 25 and bins[i] > 20:\n                priorities[i] = 13\n            else:\n                priorities[i] = 12\n        elif ratios[i] > 1.2:\n            if item > 22 and bins[i] > 18:\n                priorities[i] = 11\n            elif item > 20 and bins[i] > 15:\n                priorities[i] = 10\n            else:\n                priorities[i] = 9\n        elif ratios[i] > 1.1:\n            if item > 18 and bins[i] > 12:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 7\n            else:\n                priorities[i] = 6\n        elif ratios[i] > 0.9:\n            if item > 10 and bins[i] > 6:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.8:\n            if item > 6 and bins[i] > 4:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.7:\n            if item > 3 and bins[i] > 2:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.5:\n            if item > 1 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:19:47", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            if item > 30 and bins[i] > 25:\n                priorities[i] = 11\n            elif item > 25 and bins[i] > 20:\n                priorities[i] = 10\n            else:\n                priorities[i] = 9\n        elif ratios[i] > 1.1:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 15 and bins[i] > 12:\n                priorities[i] = 7\n            else:\n                priorities[i] = 6\n        elif ratios[i] > 0.9:\n            if item > 10 and bins[i] > 8:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.8:\n            if item > 6 and bins[i] > 4:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.7:\n            if item > 3 and bins[i] > 2:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.5:\n            if item > 1 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            priorities[i] = 10\n        elif ratios[i] > 1.1:\n            if item > 25 and bins[i] > 20:\n                priorities[i] = 9\n            elif item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 18 and bins[i] > 12:\n                priorities[i] = 7\n            elif item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.9:\n            if item > 12 and bins[i] > 8:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 6:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.8:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 5\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.7:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 4\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] > 0.5:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.5:\n            priorities[i] = 14\n        elif ratios[i] > 1.3:\n            if item > 30 and bins[i] > 25:\n                priorities[i] = 13\n            elif item > 25 and bins[i] > 20:\n                priorities[i] = 12\n            else:\n                priorities[i] = 11\n        elif ratios[i] > 1.1:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 10\n            elif item > 18 and bins[i] > 14:\n                priorities[i] = 9\n            else:\n                priorities[i] = 8\n        elif ratios[i] > 1.0:\n            if item > 15 and bins[i] > 12:\n                priorities[i] = 7\n            elif item > 12 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.9:\n            if item > 10 and bins[i] > 8:\n                priorities[i] = 6\n            elif item > 8 and bins[i] > 6:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.8:\n            if item > 6 and bins[i] > 4:\n                priorities[i] = 5\n            elif item > 4 and bins[i] > 3:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.7:\n            if item > 3 and bins[i] > 2:\n                priorities[i] = 4\n            elif item > 2 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:19:53", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            if item > 30 and bins[i] > 25:\n                priorities[i] = 11\n            elif item > 25 and bins[i] > 20:\n                priorities[i] = 10\n            else:\n                priorities[i] = 9\n        elif ratios[i] > 1.1:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 15 and bins[i] > 12:\n                priorities[i] = 7\n            else:\n                priorities[i] = 6\n        elif ratios[i] > 0.9:\n            if item > 10 and bins[i] > 8:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.8:\n            if item > 6 and bins[i] > 4:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.7:\n            if item > 3 and bins[i] > 2:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.5:\n            if item > 1 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            priorities[i] = 10\n        elif ratios[i] > 1.1:\n            if item > 25 and bins[i] > 20:\n                priorities[i] = 9\n            elif item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 18 and bins[i] > 12:\n                priorities[i] = 7\n            elif item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.9:\n            if item > 12 and bins[i] > 8:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 6:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.8:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 5\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.7:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 4\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] > 0.5:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.5:\n            priorities[i] = 12\n        elif ratios[i] > 1.3:\n            if item > 30 and bins[i] > 25:\n                priorities[i] = 11\n            elif item > 25 and bins[i] > 20:\n                priorities[i] = 10\n            else:\n                priorities[i] = 9\n        elif ratios[i] > 1.1:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            elif item > 15 and bins[i] > 12:\n                priorities[i] = 7\n            else:\n                priorities[i] = 6\n        elif ratios[i] > 1.0:\n            if item > 12 and bins[i] > 10:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 8:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.8:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 5\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.6:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 4\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] > 0.4:\n            if item > 1 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:19:57", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            if item > 30 and bins[i] > 25:\n                priorities[i] = 11\n            elif item > 25 and bins[i] > 20:\n                priorities[i] = 10\n            else:\n                priorities[i] = 9\n        elif ratios[i] > 1.1:\n            if item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 15 and bins[i] > 12:\n                priorities[i] = 7\n            else:\n                priorities[i] = 6\n        elif ratios[i] > 0.9:\n            if item > 10 and bins[i] > 8:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.8:\n            if item > 6 and bins[i] > 4:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.7:\n            if item > 3 and bins[i] > 2:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.5:\n            if item > 1 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            priorities[i] = 10\n        elif ratios[i] > 1.1:\n            if item > 25 and bins[i] > 20:\n                priorities[i] = 9\n            elif item > 20 and bins[i] > 15:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 18 and bins[i] > 12:\n                priorities[i] = 7\n            elif item > 15 and bins[i] > 10:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.9:\n            if item > 12 and bins[i] > 8:\n                priorities[i] = 6\n            elif item > 10 and bins[i] > 6:\n                priorities[i] = 5\n            else:\n                priorities[i] = 4\n        elif ratios[i] > 0.8:\n            if item > 8 and bins[i] > 5:\n                priorities[i] = 5\n            elif item > 6 and bins[i] > 4:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.7:\n            if item > 5 and bins[i] > 3:\n                priorities[i] = 4\n            elif item > 3 and bins[i] > 2:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] > 0.5:\n            if item > 2 and bins[i] > 1:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def custom_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if ratios[i] > 1.2:\n            if item > 25 and bins[i] > 20:\n                priorities[i] = 10\n            elif item > 20 and bins[i] > 15:\n                priorities[i] = 9\n            else:\n                priorities[i] = 8\n        elif ratios[i] > 1.1:\n            if item > 18 and bins[i] > 12:\n                priorities[i] = 8\n            else:\n                priorities[i] = 7\n        elif ratios[i] > 1.0:\n            if item > 15 and bins[i] > 10:\n                priorities[i] = 7\n            elif item > 12 and bins[i] > 8:\n                priorities[i] = 6\n            else:\n                priorities[i] = 5\n        elif ratios[i] > 0.9:\n            if item > 10 and bins[i] > 6:\n                priorities[i] = 5\n            elif item > 8 and bins[i] > 5:\n                priorities[i] = 4\n            else:\n                priorities[i] = 3\n        elif ratios[i] > 0.8:\n            if item > 6 and bins[i] > 4:\n                priorities[i] = 4\n            elif item > 4 and bins[i] > 3:\n                priorities[i] = 3\n            else:\n                priorities[i] = 2\n        elif ratios[i] > 0.6:\n            if item > 3 and bins[i] > 2:\n                priorities[i] = 3\n            elif item > 2 and bins[i] > 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 1\n        else:\n            if bins[i] >= 1:\n                priorities[i] = 2\n            else:\n                priorities[i] = 0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:20:09", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(matrix: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(matrix)\n    \n    rows, cols = matrix.shape\n    \n    for i in range(rows):\n        for j in range(cols):\n            if matrix[i, j] % 2 == 0:\n                result[i, j] = matrix[i, j] ** 2\n            elif matrix[i, j] % 3 == 0:\n                result[i, j] = matrix[i, j] ** 3\n            else:\n                result[i, j] = matrix[i, j]\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 06:20:11", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def custom_function(input_list: list) -> int:\n    result = 0\n    \n    for i in range(len(input_list)):\n        if input_list[i] % 2 == 0:\n            result += input_list[i] ** 2\n        else:\n            result -= input_list[i]\n    \n    if len(input_list) > 5:\n        result *= 2\n    else:\n        result /= 2\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 06:20:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(matrix: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(matrix)\n    \n    for i in range(matrix.shape[0]):\n        for j in range(matrix.shape[1]):\n            if matrix[i][j] % 2 == 0:\n                result[i][j] = matrix[i][j] * 2\n            elif matrix[i][j] % 3 == 0:\n                result[i][j] = matrix[i][j] * 3\n            else:\n                result[i][j] = matrix[i][j]\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 06:20:16", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        ratio = item / bins[i]\n        \n        if remaining_capacity >= 0:\n            priorities[i] = 1 / (1 + np.exp(-ratio))\n        else:\n            priorities[i] = -np.log(np.abs(ratio))\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(input_list: list) -> int:\n    result = 0\n    \n    for i in range(len(input_list)):\n        if input_list[i] % 2 == 0:\n            result += input_list[i] * 2\n        else:\n            result -= input_list[i]\n    \n    if result > 100:\n        result = result // 2\n    elif result < -100:\n        result = result * 3\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 06:20:19", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    bin_ranges = []\n    current_range = [0, 0]\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            if current_range[0] == 0:\n                current_range[0] = i\n            current_range[1] = i\n            if i == len(bins) - 1 or bins[i] + bins[i+1] < item:\n                bin_ranges.append(current_range)\n                current_range = [0, 0]\n    \n    for start, end in bin_ranges:\n        remaining_capacity = sum(bins[start:end+1])\n        for j in range(end, len(bins)):\n            remaining_capacity += bins[j]\n            if bins[j] >= item and remaining_capacity >= item:\n                priorities[j] = (j - start) + 1\n                break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            allocated_capacity = bins[i]\n            allocated_bins = [i]\n            for j in range(i+1, len(bins)):\n                allocated_capacity += bins[j]\n                allocated_bins.append(j)\n                \n                if bins[j] >= item and allocated_capacity >= item:\n                    for bin_idx in allocated_bins:\n                        priorities[bin_idx] = (bin_idx - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    for bin_idx in allocated_bins:\n                        priorities[bin_idx] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            allocated_capacity = bins[i]\n            allocated_bins = [i]\n            remaining_bins = bins[i+1:]\n            remaining_capacity = sum(remaining_bins)\n            for j in range(i+1, len(bins)):\n                allocated_capacity += bins[j]\n                allocated_bins.append(j)\n                if bins[j] >= item and allocated_capacity >= item:\n                    for bin_idx in allocated_bins:\n                        priorities[bin_idx] = (bin_idx - i) + 1\n                    break\n                elif allocated_capacity + remaining_capacity < item:\n                    for bin_idx in allocated_bins:\n                        priorities[bin_idx] = -1\n                    break\n                else:\n                    remaining_bins = bins[j+1:]\n                    remaining_capacity = sum(remaining_bins)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:20:22", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    bin_ranges = []\n    current_range = [0, 0]\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            if current_range[0] == 0:\n                current_range[0] = i\n            current_range[1] = i\n            if i == len(bins) - 1 or bins[i] + bins[i+1] < item:\n                bin_ranges.append(current_range)\n                current_range = [0, 0]\n    \n    for start, end in bin_ranges:\n        remaining_capacity = sum(bins[start:end+1])\n        for j in range(end, len(bins)):\n            remaining_capacity += bins[j]\n            if bins[j] >= item and remaining_capacity >= item:\n                priorities[j] = (j - start) + 1\n                break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            allocated_capacity = bins[i]\n            allocated_bins = [i]\n            for j in range(i+1, len(bins)):\n                allocated_capacity += bins[j]\n                allocated_bins.append(j)\n                \n                if bins[j] >= item and allocated_capacity >= item:\n                    for bin_idx in allocated_bins:\n                        priorities[bin_idx] = (bin_idx - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    for bin_idx in allocated_bins:\n                        priorities[bin_idx] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            bin_sum = bins[i]\n            if len(bins) - i >= 2:\n                for j in range(i+1, len(bins)):\n                    bin_sum += bins[j]\n                    if bin_sum >= item:\n                        allocated_indices = list(range(i, j+1))\n                        for idx, alloc_idx in enumerate(allocated_indices, start=1):\n                            priorities[alloc_idx] = idx\n                        break\n                    elif j == len(bins) - 1:\n                        for idx, alloc_idx in enumerate(allocated_indices, start=1):\n                            priorities[alloc_idx] = -1\n            else:\n                priorities[i] = -1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:20:26", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    bin_ranges = []\n    current_range = [0, 0]\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            if current_range[0] == 0:\n                current_range[0] = i\n            current_range[1] = i\n            if i == len(bins) - 1 or bins[i] + bins[i+1] < item:\n                bin_ranges.append(current_range)\n                current_range = [0, 0]\n    \n    for start, end in bin_ranges:\n        remaining_capacity = sum(bins[start:end+1])\n        for j in range(end, len(bins)):\n            remaining_capacity += bins[j]\n            if bins[j] >= item and remaining_capacity >= item:\n                priorities[j] = (j - start) + 1\n                break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            allocated_capacity = bins[i]\n            allocated_bins = [i]\n            for j in range(i+1, len(bins)):\n                allocated_capacity += bins[j]\n                allocated_bins.append(j)\n                \n                if bins[j] >= item and allocated_capacity >= item:\n                    for bin_idx in allocated_bins:\n                        priorities[bin_idx] = (bin_idx - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    for bin_idx in allocated_bins:\n                        priorities[bin_idx] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    \n    if item > max_capacity:\n        raise ValueError(\"Item size exceeds maximum bin capacity\")\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            allocated_capacity = bins[i]\n            allocated_bins = [i]\n            for j in range(i+1, len(bins)):\n                allocated_capacity += bins[j]\n                allocated_bins.append(j)\n                \n                if bins[j] >= item and allocated_capacity >= item:\n                    for bin_idx in allocated_bins:\n                        priorities[bin_idx] = (bin_idx - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    for bin_idx in allocated_bins:\n                        sum_of_remaining = sum(bins[bin_idx:])\n                        if sum_of_remaining >= item:\n                            priorities[bin_idx] = (len(bins) - bin_idx) + 1\n                        else:\n                            priorities[bin_idx] = -1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:20:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    min_capacity = min(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    bin_ranges = []\n    current_range = [0, 0]\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            if current_range[0] == 0:\n                current_range[0] = i\n            current_range[1] = i\n            if i == len(bins) - 1 or bins[i] + bins[i+1] < item:\n                bin_ranges.append(current_range)\n                current_range = [0, 0]\n    \n    for start, end in bin_ranges:\n        remaining_capacity = sum(bins[start:end+1])\n        for j in range(end, len(bins)):\n            remaining_capacity += bins[j]\n            if bins[j] >= item and remaining_capacity >= item:\n                priorities[j] = (j - start) + 1\n                break\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            allocated_capacity = bins[i]\n            allocated_bins = [i]\n            for j in range(i+1, len(bins)):\n                allocated_capacity += bins[j]\n                allocated_bins.append(j)\n                \n                if bins[j] >= item and allocated_capacity >= item:\n                    for bin_idx in allocated_bins:\n                        priorities[bin_idx] = (bin_idx - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    for bin_idx in allocated_bins:\n                        priorities[bin_idx] = -1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    if len(bins) == 0:\n        return priorities\n    \n    max_capacity = max(bins)\n    \n    if item > max_capacity:\n        msg = \"Item size exceeds maximum bin capacity\"\n        raise ValueError(msg)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1\n        else:\n            allocated_capacity = bins[i]\n            allocated_bins = [i]\n            for j in range(i+1, len(bins)):\n                allocated_capacity += bins[j]\n                allocated_bins.append(j)\n                \n                if bins[j] >= item and allocated_capacity >= item:\n                    for bin_idx in allocated_bins:\n                        priorities[bin_idx] = (bin_idx - i) + 1\n                    break\n                elif j == len(bins) - 1:\n                    max_priority_bin_idx = -1\n                    max_priority = -1\n                    for k in range(i, j):\n                        if priorities[k] > max_priority:\n                            max_priority = priorities[k]\n                            max_priority_bin_idx = k\n                    priorities[max_priority_bin_idx] = -1\n    \n    return priorities", "strategy": []}
