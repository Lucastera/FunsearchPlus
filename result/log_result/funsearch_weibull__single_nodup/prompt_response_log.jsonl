{"timestamp": "2025-04-27 06:17:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if ratios[i] > 0.5:\n            priorities[i] = ratios[i] * 2\n        elif ratios[i] > 0.2:\n            priorities[i] = ratios[i] * 1.5\n        else:\n            priorities[i] = ratios[i]\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:17:29", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            priorities[i] = item - bins[i]\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:17:31", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:17:33", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            priorities[i] = bins[i] - item\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:17:41", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.5:\n            priorities[i] = np.sqrt(ratios[i])\n        elif ratios[i] >= 0.5 and ratios[i] < 0.8:\n            priorities[i] = np.log(ratios[i] + 1)\n        else:\n            priorities[i] = np.power(ratios[i], 0.5)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:17:44", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.25:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.25 and ratios[i] < 0.5:\n            priorities[i] = np.sqrt(ratios[i])\n        elif ratios[i] >= 0.5 and ratios[i] < 0.75:\n            priorities[i] = np.power(ratios[i], 3)\n        else:\n            priorities[i] = np.log(ratios[i] + 1)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:17:46", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.3 and ratios[i] < 0.6:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.log(ratios[i] + 1)\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:17:48", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.4 and ratios[i] < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i])) + 0.1\n        else:\n            priorities[i] = np.sqrt(ratios[i]) + 0.2\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:17:58", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = 1 / bins[i]\n        else:\n            priorities[i] = 0\n        \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:18:00", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        ratio = item / bins[i]\n        \n        if ratio >= 1:\n            priorities[i] = -np.log(ratio)\n        else:\n            priorities[i] = np.log(bins[i] / item)\n        \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:18:02", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = -np.log(item / bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:18:04", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= 0:\n            priorities[i] = 0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity < 0:\n                priorities[i] = -1\n            else:\n                priority_score = item / bins[i] + remaining_capacity\n                priorities[i] = priority_score\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:18:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            priorities[i] = 1.0 / (1.0 + remaining_capacity)  # Higher priority for more remaining capacity\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:18:15", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i, bin_capacity in enumerate(bins):\n        if bin_capacity >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity_ratio = (item - bin_capacity) / item\n            priorities[i] = np.exp(-remaining_capacity_ratio)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:18:17", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 1.0:\n            priorities[i] = -1.0\n        elif ratios[i] >= 0.5:\n            priorities[i] = -0.5\n        else:\n            priorities[i] = -np.log(ratios[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:18:19", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    num_bins = len(bins)\n    priorities = np.zeros(num_bins)\n    \n    for i in range(num_bins):\n        if item <= bins[i]:\n            priorities[i] = 1 / item\n        else:\n            priorities[i] = 1 / (item - bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:18:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.3 and ratios[i] < 0.6:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.log(ratios[i] + 1)\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 3)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log10(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i] * np.pi / 2)\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:18:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.3 and ratios[i] < 0.6:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.log(ratios[i] + 1)\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 3)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1) + np.sqrt(ratios[i])\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.exp(ratios[i]) - np.cbrt(ratios[i])\n        else:\n            priorities[i] = np.cos(ratios[i]) + np.sin(ratios[i])\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:18:33", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.3 and ratios[i] < 0.6:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.log(ratios[i] + 1)\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2) + 0.5\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1) + 1\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sqrt(ratios[i]) + 1.5\n        else:\n            priorities[i] = np.power(ratios[i], 3) + 2\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:18:36", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.3 and ratios[i] < 0.6:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.log(ratios[i] + 1)\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = ratios[i] ** 3\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.exp(ratios[i])\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.power(ratios[i], ratios[i])\n        else:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:18:48", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i] / 2:\n            priorities[i] = 1\n        elif item < bins[i] / 4:\n            priorities[i] = 0.5\n        else:\n            priorities[i] = 0.75\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:18:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    num_bins = len(bins)\n    priorities = np.zeros(num_bins)\n    \n    for i in range(num_bins):\n        if bins[i] - item >= 0:\n            priorities[i] = 1 / (bins[i] - item)\n        else:\n            priorities[i] = -1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:18:52", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i, bin_capacity in enumerate(bins):\n        if item > bin_capacity:\n            priorities[i] = -np.inf\n        else:\n            remaining_capacity = bin_capacity - item\n            priority = 1 / (1 + np.exp(-remaining_capacity))\n            priorities[i] = priority\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:18:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\nimport numpy as np\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.5)))\n        elif ratio >= 0.5 and ratio < 1:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.75)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.25)))\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:19:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = -np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = -np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        else:\n            sub_priority = 0\n            for j in range(len(bins)):\n                if bins[j] >= item:\n                    sub_priority += item / bins[j]\n                else:\n                    sub_priority += -np.log(item / bins[j])\n            priorities[i] = sub_priority / len(bins)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:19:04", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = -np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = -np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        else:\n            if item < 0:\n                priorities[i] = -np.log(-item / bins[i])\n            else:\n                priorities[i] = -np.log(item / bins[i] + 1) * (bins[i] / item)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:19:07", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = -np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = -np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        if remaining_capacity >= 0.5 * item:\n            priorities[i] = 1 - (remaining_capacity / bins[i])\n        elif remaining_capacity > 0:\n            priorities[i] = np.sqrt(remaining_capacity / bins[i])\n        else:\n            priorities[i] = -np.log(item / bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:19:09", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = -np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = -np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i]\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i]\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:19:19", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.5)))\n        elif ratio >= 0.5 and ratio < 1:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.75)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.25)))\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.5)))\n        elif ratio >= 0.5 and ratio < 1:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.75)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.25)))\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.3))) + 0.1\n        elif ratio >= 0.3 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.45))) + 0.2\n        elif ratio >= 0.6 and ratio < 1:\n            priorities[i] = 1 / (1 + np.exp(-3 * (ratio - 0.8))) + 0.3\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.25))) + 0.4\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:19:22", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.5)))\n        elif ratio >= 0.5 and ratio < 1:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.75)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.25)))\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.5)))\n        elif ratio >= 0.5 and ratio < 1:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.75)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.25)))\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.5)))\n        elif ratio >= 0.5 and ratio < 1:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.75)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.25)))\n            \n        if i % 2 == 0:\n            priorities[i] += 0.2\n        else:\n            priorities[i] -= 0.1\n        \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:19:25", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.5)))\n        elif ratio >= 0.5 and ratio < 1:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.75)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.25)))\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.5)))\n        elif ratio >= 0.5 and ratio < 1:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.75)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.25)))\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3)))\n        elif ratio >= 0.3 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-7 * (ratio - 0.45)))\n        elif ratio >= 0.6 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.75)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.25)))\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:19:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.5)))\n        elif ratio >= 0.5 and ratio < 1:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.75)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.25)))\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.5)))\n        elif ratio >= 0.5 and ratio < 1:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.75)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.25)))\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.3)))\n        elif ratio >= 0.3 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.45)))\n        elif ratio >= 0.6 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-3 * (ratio - 0.75)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1.0)))\n\n    return priorities\n", "strategy": []}
{"timestamp": "2025-04-27 06:19:39", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = -np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i]\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i]\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i]\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i]\n    for j in range(len(bins)):\n        if priorities[j] < 0.5:\n            priorities[j] = 0.5 * priorities[j]\n        elif priorities[j] > 1.5:\n            priorities[j] = 1.5\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:19:41", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = -np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i]\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i]\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i]\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i]\n            if priorities[i] < 0.1:\n                priorities[i] = 0.1\n            elif priorities[i] > 0.9:\n                priorities[i] = 0.9\n            priorities[i] *= 1.5\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:19:44", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = -np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i]\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i]\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i]\n        elif bins[i] >= item / 4:\n            priorities[i] = 0.25 * item / bins[i]\n        elif bins[i] >= item / 8:\n            priorities[i] = 0.125 * item / bins[i]\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i]\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:19:46", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = -np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i]\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i]\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i]\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i]\n            \n            if priorities[i] > 1.5:\n                priorities[i] = 1.5\n            elif priorities[i] < 0.5:\n                priorities[i] = 0.5\n            else:\n                priorities[i] = priorities[i] * 1.1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:19:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1  # Skip bin if item cannot fit\n        else:\n            remaining_space = bins[i] - item\n            if remaining_space == 0:\n                priorities[i] = 0.5  # Prefer bins with exact fit\n            else:\n                priorities[i] = 1 / np.sqrt(remaining_space)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:19:56", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = bins[i] - item\n        else:\n            priorities[i] = item - bins[i]\n            \n        if bins[i] < 0:\n            priorities[i] = 0\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:19:58", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            priority = 1 / remaining_capacity\n            priorities[index] = priority if priority > 0 else 0\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:20:00", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    for bin_capacity in bins:\n        if bin_capacity >= item:\n            priorities.append(1.0)\n        else:\n            priority = item / bin_capacity\n            if priority < 0.5:\n                priorities.append(0.9)\n            elif priority >= 0.5 and priority < 1.0:\n                priorities.append(0.7)\n            else:\n                priorities.append(0.5)\n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 06:20:09", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = -np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i]\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i]\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Advanced version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i]\n        else:\n            count = 0\n            remaining_item = item\n            while remaining_item > bins[i] / 2:\n                remaining_item -= bins[i] / 2\n                count += 1\n            if remaining_item == 0:\n                priorities[i] = count\n            elif remaining_item <= bins[i] / 4:\n                priorities[i] = count + remaining_item / (2 * bins[i])\n            else:\n                priorities[i] = count + remaining_item / bins[i]\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:20:12", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = -np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i]\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i]\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i]\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] * (1 + count)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:20:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = -np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i]\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i]\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:20:16", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = -np.log(item / bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i]\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i]\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i]\n        elif bins[i] >= item / 3:\n            priorities[i] = 0.33 * item / bins[i]\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i]\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:20:25", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.5:\n            priorities[i] = 1 / (ratios[i] + 0.1)\n        elif ratios[i] >= 0.5 and ratios[i] < 1:\n            priorities[i] = 1 / (ratios[i] + 0.5)\n        else:\n            priorities[i] = 1 / (ratios[i] + 1)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:20:26", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = bins[i] / item\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:20:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            priorities[i] = item / bins[i]\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:20:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = item / bins[i] + np.sqrt(item) - np.log(item)\n        else:\n            priorities[i] = np.sqrt(bins[i]) / item + np.log(bins[i]) - item\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:20:39", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.3))) + 0.1\n        elif ratio >= 0.3 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.45))) + 0.2\n        elif ratio >= 0.6 and ratio < 1:\n            priorities[i] = 1 / (1 + np.exp(-3 * (ratio - 0.8))) + 0.3\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.25))) + 0.4\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.5)))\n        elif ratio >= 0.5 and ratio < 1:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.75)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.25)))\n            \n        if i % 2 == 0:\n            priorities[i] += 0.2\n        else:\n            priorities[i] -= 0.1\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.25:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.25))) + 0.3\n        elif ratio >= 0.25 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.4))) + 0.5\n        elif ratio >= 0.5 and ratio < 0.75:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.6))) + 0.8\n        elif ratio >= 0.75 and ratio < 1:\n            priorities[i] = 1 / (1 + np.exp(-3 * (ratio - 0.9))) + 1\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.25))) + 1.2\n        \n        if i % 3 == 0:\n            priorities[i] += 0.2\n        elif i % 3 == 1:\n            priorities[i] -= 0.1\n        else:\n            priorities[i] += 0.3\n        \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:20:42", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.3))) + 0.1\n        elif ratio >= 0.3 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.45))) + 0.2\n        elif ratio >= 0.6 and ratio < 1:\n            priorities[i] = 1 / (1 + np.exp(-3 * (ratio - 0.8))) + 0.3\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.25))) + 0.4\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.5)))\n        elif ratio >= 0.5 and ratio < 1:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.75)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.25)))\n            \n        if i % 2 == 0:\n            priorities[i] += 0.2\n        else:\n            priorities[i] -= 0.1\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.3))) + 0.1\n        elif ratio >= 0.3 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.45))) + 0.2\n        elif ratio >= 0.6 and ratio < 1:\n            priorities[i] = 1 / (1 + np.exp(-3 * (ratio - 0.8))) + 0.3\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.25))) + 0.4\n            \n        if i % 3 == 0:\n            priorities[i] += 0.5\n        elif i % 3 == 1:\n            priorities[i] -= 0.3\n        else:\n            priorities[i] += 0.1\n        \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:20:45", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.3))) + 0.1\n        elif ratio >= 0.3 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.45))) + 0.2\n        elif ratio >= 0.6 and ratio < 1:\n            priorities[i] = 1 / (1 + np.exp(-3 * (ratio - 0.8))) + 0.3\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.25))) + 0.4\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.5)))\n        elif ratio >= 0.5 and ratio < 1:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.75)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.25)))\n            \n        if i % 2 == 0:\n            priorities[i] += 0.2\n        else:\n            priorities[i] -= 0.1\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.3))) + 0.1\n        elif ratio >= 0.3 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.45))) + 0.2\n        elif ratio >= 0.6 and ratio < 1:\n            priorities[i] = 1 / (1 + np.exp(-3 * (ratio - 0.8))) + 0.3\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.25))) + 0.4\n        \n        if i % 3 == 0:\n            priorities[i] += 0.15\n        elif i % 3 == 1:\n            priorities[i] -= 0.1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:20:48", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.3))) + 0.1\n        elif ratio >= 0.3 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.45))) + 0.2\n        elif ratio >= 0.6 and ratio < 1:\n            priorities[i] = 1 / (1 + np.exp(-3 * (ratio - 0.8))) + 0.3\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.25))) + 0.4\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.5)))\n        elif ratio >= 0.5 and ratio < 1:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.75)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.25)))\n            \n        if i % 2 == 0:\n            priorities[i] += 0.2\n        else:\n            priorities[i] -= 0.1\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.4)))\n        elif ratio >= 0.4 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.6)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-3 * (ratio - 0.9))\n        \n        if i % 3 == 0:\n            priorities[i] += 0.3\n        elif i % 3 == 1:\n            priorities[i] -= 0.1\n        else:\n            priorities[i] += 0.2\n        \n        if bins[i] < 10:\n            priorities[i] += 0.5\n        elif bins[i] >= 10 and bins[i] < 20:\n            priorities[i] += 0.3\n        else:\n            priorities[i] += 0.1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:20:59", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = ratio ** 2\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = ratio * 2\n        else:\n            priorities[i] = np.log(ratio)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:21:01", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:21:02", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = bins[i] - item\n        else:\n            priorities[i] = item - bins[i]\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:21:04", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item < bin_capacity:\n            priority = 1 / (bin_capacity - item)\n            priorities.append(priority)\n        else:\n            priorities.append(0)\n    \n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 06:21:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = bins[i] / item\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = bins[i] / item\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            if bins[i] == 0:\n                priorities[i] = 0\n            elif item > bins[i] * 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (item - bins[i]) / item\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:21:15", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = bins[i] / item\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = bins[i] / item\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = bins[i] / item\n\n        # Handling special cases\n        if item % 2 == 0:\n            priorities[i] += 0.1\n        else:\n            priorities[i] -= 0.1\n\n        if bins[i] < 10:\n            priorities[i] *= 1.5\n        elif bins[i] > 20:\n            priorities[i] *= 0.5\n        else:\n            priorities[i] *= 1.0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:21:17", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = bins[i] / item\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = bins[i] / item\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            priorities[i] = (bins[i] + diff) / item\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:21:19", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = bins[i] / item\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = bins[i] / item\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = bins[i] / item\n            if priorities[i] < 0.5:\n                priorities[i] = 0.5\n            elif priorities[i] > 0.9:\n                priorities[i] = 0.9\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:21:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] < max_priority:\n            priorities[i] = priorities[i] + 0.1\n        else:\n            priorities[i] = priorities[i]\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:21:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            if item == bins[i]:\n                priorities[i] = 0.5\n            else:\n                priorities[i] = 1.0 / (item - bins[i] + 1)\n        \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:21:32", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        elif item == 0:\n            priorities[i] = 0.0\n        else:\n            priorities[i] = 1.0 * (item / sum(bins))\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:21:34", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    max_item = np.max(bins)\n    min_item = np.min(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] == max_item:\n            priorities[i] = 0.8\n        elif bins[i] == min_item:\n            priorities[i] = 0.5\n        else:\n            priorities[i] = 0.3\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:21:44", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.5)))\n        elif ratio >= 0.5 and ratio < 1:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.75)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.25)))\n            \n        if i % 2 == 0:\n            priorities[i] += 0.2\n        else:\n            priorities[i] -= 0.1\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.3)))\n        elif ratio >= 0.3 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.45)))\n        elif ratio >= 0.6 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-3 * (ratio - 0.75)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1.0)))\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-7 * (ratio - 0.3)))\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.5)))\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-3 * (ratio - 0.7)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 0.9)))\n\n        if i % 3 == 0:\n            priorities[i] += 0.3\n        elif i % 3 == 1:\n            priorities[i] += 0.1\n        else:\n            priorities[i] -= 0.2\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:21:47", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.5)))\n        elif ratio >= 0.5 and ratio < 1:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.75)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.25)))\n            \n        if i % 2 == 0:\n            priorities[i] += 0.2\n        else:\n            priorities[i] -= 0.1\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.3)))\n        elif ratio >= 0.3 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.45)))\n        elif ratio >= 0.6 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-3 * (ratio - 0.75)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1.0)))\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.3)))\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.5)))\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-3 * (ratio - 0.7)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.0)))\n            \n        if i % 3 == 0:\n            priorities[i] += 0.1\n        elif i % 3 == 1:\n            priorities[i] -= 0.05\n        else:\n            priorities[i] -= 0.1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:21:52", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.5)))\n        elif ratio >= 0.5 and ratio < 1:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.75)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.25)))\n            \n        if i % 2 == 0:\n            priorities[i] += 0.2\n        else:\n            priorities[i] -= 0.1\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.3)))\n        elif ratio >= 0.3 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.45)))\n        elif ratio >= 0.6 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-3 * (ratio - 0.75)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1.0)))\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-12 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.3)))\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.5)))\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-3 * (ratio - 0.7)))\n        elif ratio >= 0.8 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.85)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 1.0)))\n\n    for j in range(len(priorities)):\n        if priorities[j] < 0.5:\n            priorities[j] += 0.1\n        elif priorities[j] >= 0.5 and priorities[j] < 0.8:\n            priorities[j] -= 0.05\n        else:\n            priorities[j] += 0.15\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:21:56", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.5)))\n        elif ratio >= 0.5 and ratio < 1:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.75)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.25)))\n            \n        if i % 2 == 0:\n            priorities[i] += 0.2\n        else:\n            priorities[i] -= 0.1\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.3)))\n        elif ratio >= 0.3 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.45)))\n        elif ratio >= 0.6 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-3 * (ratio - 0.75)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1.0)))\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.3)))\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-6 * (ratio - 0.5)))\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.7)))\n        elif ratio >= 0.8 and ratio < 1.0:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.9)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1.0)))\n\n        if i % 3 == 0:\n            priorities[i] += 0.1\n        elif i % 3 == 1:\n            priorities[i] -= 0.05\n        else:\n            priorities[i] += 0.02\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:22:11", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            priorities[i] = (bins[i] + diff) / item\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            priorities[i] = (bins[i] + diff) / item\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff % 2 == 0:\n                priorities[i] = (bins[i] + diff) / item + 0.3\n            else:\n                priorities[i] = (bins[i] + diff) / item - 0.2\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:22:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            priorities[i] = (bins[i] + diff) / item\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            priorities[i] = (bins[i] + diff) / item\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i] * (1 + (bins[i] % item) / item)\n        else:\n            diff = item - bins[i]\n            priorities[i] = (bins[i] + diff) / item if diff <= bins[i] else (bins[i] / item) * (diff / item)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:22:17", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            priorities[i] = (bins[i] + diff) / item\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            priorities[i] = (bins[i] + diff) / item\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > item * 0.5:\n                priorities[i] = (bins[i] + diff) / item\n            elif diff > item * 0.3:\n                priorities[i] = (bins[i] + diff) / item - 0.2\n            else:\n                priorities[i] = (bins[i] + diff) / item - 0.5\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:22:19", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            priorities[i] = (bins[i] + diff) / item\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            priorities[i] = (bins[i] + diff) / item\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:22:29", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n            \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] += 0.5\n        elif priorities[j] == min_priority:\n            priorities[j] -= 0.5\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:22:32", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Another improved version with more complex logic.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if item >= bins[i] * 0.8:\n                priorities[i] = count + item / bins[i] + 0.3\n            elif item >= bins[i] * 0.5:\n                priorities[i] = count + item / bins[i] + 0.4\n            else:\n                priorities[i] = count + item / bins[i] + 0.5\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:22:34", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:22:37", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = (count + 1) * item / bins[i] + 0.4\n            else:\n                priorities[i] = (count + 2) * item / bins[i] + 0.5\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:22:45", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_space = bin_capacity - item\n            if remaining_space <= 0:\n                priorities[i] = -np.inf\n            else:\n                priorities[i] = 1 / remaining_space\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:22:47", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_space = bins[i] - item\n            priorities[i] = np.exp(-(remaining_space / item) ** 2)\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:22:49", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    for bin_capacity in bins:\n        if item <= 0 or bin_capacity <= 0:\n            priorities.append(0)\n        elif item <= bin_capacity:\n            priorities.append(1)\n        else:\n            priority = item / bin_capacity\n            priorities.append(priority)\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 06:22:51", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            priority_score = 1 / (1 + utilization_ratio)\n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:22:58", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins, dtype=float)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1.0\n        elif ratio < 0.5:\n            priorities[i] = 0.5\n        else:\n            priorities[i] = 0.1\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:22:59", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1 / bins[i]\n        else:\n            priorities[i] = 0\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:23:01", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            priorities[i] = item / bins[i]\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:23:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        ratio = item / bins[i]\n        if ratio <= 1:\n            priorities[i] = np.log(1/ratio)\n        else:\n            priorities[i] = np.log(ratio)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:23:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            priority_score = 1 / (1 + utilization_ratio)\n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            priority_score = 1 / (1 + utilization_ratio)\n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            if remaining_space < bins[i] * 0.1:\n                priority_score = 0.8\n            elif remaining_space < bins[i] * 0.3:\n                priority_score = 0.6\n            else:\n                priority_score = 1 / (1 + remaining_space)\n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:23:15", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            priority_score = 1 / (1 + utilization_ratio)\n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            priority_score = 1 / (1 + utilization_ratio)\n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Further improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            if remaining_space <= 0.1:\n                priority_score = 0.5\n            elif remaining_space <= 0.3:\n                priority_score = 0.7\n            else:\n                priority_score = 1 / (1 + remaining_space)\n            \n            priorities[i] = priority_score\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:23:17", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            priority_score = 1 / (1 + utilization_ratio)\n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            priority_score = 1 / (1 + utilization_ratio)\n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            if remaining_space > bins[i] * 0.3:\n                priority_score = 1\n            elif remaining_space > bins[i] * 0.1:\n                priority_score = 0.8\n            else:\n                priority_score = 0.5\n            priorities[i] = priority_score\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:23:19", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            priority_score = 1 / (1 + utilization_ratio)\n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            priority_score = 1 / (1 + utilization_ratio)\n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            if utilization_ratio < 0.5:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.5 and utilization_ratio < 0.8:\n                priority_score = 0.8 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.5 / (1 + utilization_ratio)\n                \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:23:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            priorities[i] = 1.0 / (1.0 + remaining_capacity)  # Higher priority for more remaining capacity\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            priorities[i] = 1.0 / (1.0 + remaining_capacity)  # Higher priority for more remaining capacity\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0.5 * bins[i]:\n                priorities[i] = 2.0 / (1.0 + remaining_capacity)\n            elif remaining_capacity > 0.3 * bins[i]:\n                priorities[i] = 1.5 / (1.0 + remaining_capacity)\n            else:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:23:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            priorities[i] = 1.0 / (1.0 + remaining_capacity)  # Higher priority for more remaining capacity\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            priorities[i] = 1.0 / (1.0 + remaining_capacity)  # Higher priority for more remaining capacity\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0.5 * bins[i]:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity)  # Higher priority for more remaining capacity\n            elif remaining_capacity > 0.2 * bins[i]:\n                priorities[i] = 0.5 / (1.0 + remaining_capacity)  # Medium priority\n            else:\n                priorities[i] = 0.2 / (1.0 + remaining_capacity)  # Lower priority for almost full bins\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:23:33", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            priorities[i] = 1.0 / (1.0 + remaining_capacity)  # Higher priority for more remaining capacity\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            priorities[i] = 1.0 / (1.0 + remaining_capacity)  # Higher priority for more remaining capacity\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity < bins[i] * 0.1:  # If remaining capacity is less than 10% of bin size\n                priorities[i] = 0.5  # Medium priority\n            elif remaining_capacity < bins[i] * 0.3:  # If remaining capacity is less than 30% of bin size\n                priorities[i] = 0.75  # High priority\n            else:\n                priorities[i] = 1.0  # Highest priority\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:23:36", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            priorities[i] = 1.0 / (1.0 + remaining_capacity)  # Higher priority for more remaining capacity\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            priorities[i] = 1.0 / (1.0 + remaining_capacity)  # Higher priority for more remaining capacity\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0.5 * bins[i]:\n                priorities[i] = 1.0  # High priority if more than half capacity available\n            elif remaining_capacity > 0.2 * bins[i]:\n                priorities[i] = 0.5  # Medium priority if more than 20% capacity available\n            else:\n                priorities[i] = 0.2  # Low priority if less than 20% capacity available\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:23:43", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            priorities[i] = (bins[i] + diff) / item\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more advanced version of `priority` function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:23:46", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            priorities[i] = (bins[i] + diff) / item\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(bins)):\n        if priorities[j] == max_priority:\n            priorities[j] *= 1.2\n        elif priorities[j] == min_priority:\n            priorities[j] *= 0.8\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:23:49", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            priorities[i] = (bins[i] + diff) / item\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:23:51", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            priorities[i] = (bins[i] + diff) / item\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:24:00", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            priorities[i] = item / bins[i] if item < bins[i] else bins[i] / item\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:24:02", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] <= item:\n            priorities[i] = -1\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.5:\n                priorities[i] = 1 / (1 + np.exp(-10*ratio))\n            else:\n                priorities[i] = np.log(ratio)\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:24:04", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1.0 / ratio\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 0.5 / ratio\n        else:\n            priorities[i] = np.log(ratio)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:24:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = bins[i] - item\n        else:\n            priorities[i] = -item + bins[i]\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:24:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1 / bins[i]\n        else:\n            priorities[i] = 0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            priorities[i] = item / bins[i]\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio >= 0.5:\n                priorities[i] = ratio ** 2\n            elif ratio < 0.1:\n                priorities[i] = 0.1\n            else:\n                priorities[i] = ratio\n                \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:24:17", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1 / bins[i]\n        else:\n            priorities[i] = 0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            priorities[i] = item / bins[i]\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.5:\n                priorities[i] = item / bins[i]\n            elif item >= bins[i] * 0.9:\n                priorities[i] = (bins[i] - item) / bins[i]\n            else:\n                priorities[i] = 0.5\n                \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:24:19", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1 / bins[i]\n        else:\n            priorities[i] = 0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            priorities[i] = item / bins[i]\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 1:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:24:21", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1 / bins[i]\n        else:\n            priorities[i] = 0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            priorities[i] = item / bins[i]\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            priorities[i] = (item + bins[i]) / (2 * bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:24:29", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n            \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] += 0.5\n        elif priorities[j] == min_priority:\n            priorities[j] -= 0.5\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n        \n        if bins[i] % 2 == 0:\n            priorities[i] *= 1.5\n        else:\n            priorities[i] *= 0.9\n        \n        if item < 10:\n            priorities[i] += 0.4\n        elif item > 20:\n            priorities[i] -= 0.2\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:24:32", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n            \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] += 0.5\n        elif priorities[j] == min_priority:\n            priorities[j] -= 0.5\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n        \n        if priorities[i] > 1.5:\n            priorities[i] += 0.5\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.5\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:24:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n            \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] += 0.5\n        elif priorities[j] == min_priority:\n            priorities[j] -= 0.5\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                \n    sorted_priorities = np.sort(priorities)[::-1]\n    for j in range(len(priorities)):\n        if priorities[j] == sorted_priorities[0]:\n            priorities[j] += 0.5\n        elif priorities[j] == sorted_priorities[-1]:\n            priorities[j] -= 0.5\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:24:38", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n            \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] += 0.5\n        elif priorities[j] == min_priority:\n            priorities[j] -= 0.5\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:24:49", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(bins)):\n        if priorities[j] == max_priority:\n            priorities[j] *= 1.2\n        elif priorities[j] == min_priority:\n            priorities[j] *= 0.8\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n    avg_priority = np.mean(priorities)\n    \n    for j in range(len(bins)):\n        if priorities[j] > avg_priority:\n            priorities[j] *= 1.5\n        elif priorities[j] < avg_priority:\n            priorities[j] *= 0.9\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:24:51", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(bins)):\n        if priorities[j] == max_priority:\n            priorities[j] *= 1.2\n        elif priorities[j] == min_priority:\n            priorities[j] *= 0.8\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:24:55", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(bins)):\n        if priorities[j] == max_priority:\n            priorities[j] *= 1.2\n        elif priorities[j] == min_priority:\n            priorities[j] *= 0.8\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(bins)):\n        if priorities[j] == max_priority:\n            priorities[j] *= 1.2\n        elif priorities[j] == min_priority:\n            priorities[j] *= 0.8\n            \n    sorted_indices = np.argsort(priorities)[::-1]\n    \n    for k in range(len(sorted_indices)):\n        priorities[sorted_indices[k]] *= 1.1 * (k + 1)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:24:58", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(bins)):\n        if priorities[j] == max_priority:\n            priorities[j] *= 1.2\n        elif priorities[j] == min_priority:\n            priorities[j] *= 0.8\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n        if priorities[i] < 0.3:\n            priorities[i] *= 1.5\n        elif priorities[i] > 0.7:\n            priorities[i] *= 0.8\n        \n    total_capacity = np.sum(bins)\n    normalized_priorities = priorities / total_capacity\n    \n    return normalized_priorities", "strategy": []}
{"timestamp": "2025-04-27 06:25:11", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 3)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log10(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i] * np.pi / 2)\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.1 and ratios[i] < 0.3:\n            priorities[i] = np.tan(ratios[i])\n        elif ratios[i] >= 0.3 and ratios[i] < 0.5:\n            priorities[i] = np.power(np.e, ratios[i])\n        elif ratios[i] >= 0.5 and ratios[i] < 0.7:\n            priorities[i] = np.arcsin(ratios[i])\n        elif ratios[i] >= 0.7 and ratios[i] < 0.9:\n            priorities[i] = np.cosh(ratios[i])\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:25:15", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 3)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log10(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i] * np.pi / 2)\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more complex version of `priority_v1`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.1:\n            priorities[i] = np.sinh(ratios[i])\n        elif ratios[i] >= 0.1 and ratios[i] < 0.3:\n            priorities[i] = np.cosh(ratios[i])\n        elif ratios[i] >= 0.3 and ratios[i] < 0.5:\n            priorities[i] = np.tanh(ratios[i])\n        elif ratios[i] >= 0.5 and ratios[i] < 0.7:\n            priorities[i] = np.exp(ratios[i])\n        elif ratios[i] >= 0.7 and ratios[i] < 0.9:\n            priorities[i] = np.log(ratios[i])\n        else:\n            priorities[i] = np.arctan(ratios[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:25:18", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 3)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log10(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i] * np.pi / 2)\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 3)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log10(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i] * np.pi / 2)\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n            \n    for i in range(len(bins)):\n        if priorities[i] < 0.5:\n            priorities[i] += np.exp(-ratios[i])\n        elif priorities[i] >= 0.5 and priorities[i] < 0.8:\n            priorities[i] *= 2\n        else:\n            priorities[i] = priorities[i] ** 2\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:25:21", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 3)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log10(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i] * np.pi / 2)\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.1 and ratios[i] < 0.3:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.3 and ratios[i] < 0.5:\n            priorities[i] = np.sinh(ratios[i])\n        elif ratios[i] >= 0.5 and ratios[i] < 0.7:\n            priorities[i] = np.tanh(ratios[i])\n        elif ratios[i] >= 0.7 and ratios[i] < 0.9:\n            priorities[i] = np.cosh(ratios[i])\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:25:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n        \n        if priorities[i] > 1.5:\n            priorities[i] += 0.5\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 1.2 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 1.1 * count + item / bins[i] + 0.3\n        \n        if priorities[i] > 2.0:\n            priorities[i] += 0.6\n        elif priorities[i] > 1.5:\n            priorities[i] += 0.4\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.3\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:25:38", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n        \n        if priorities[i] > 1.5:\n            priorities[i] += 0.5\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n        \n        if item % 3 == 0:\n            priorities[i] = priorities[i] * 1.2\n        elif item % 5 == 0:\n            priorities[i] = priorities[i] * 1.5\n        else:\n            priorities[i] = priorities[i]\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:25:41", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n        \n        if priorities[i] > 1.5:\n            priorities[i] += 0.5\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            remaining = bins[i]\n            while item > remaining:\n                item -= remaining\n                count += 1\n                if count % 2 == 0:\n                    remaining -= 0.1 * item\n                else:\n                    remaining -= 0.2 * item\n            priorities[i] = 0.7 * count + item / bins[i] + 0.3\n        \n        if priorities[i] > 1.5:\n            priorities[i] += 0.5\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.5\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:25:44", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n        \n        if priorities[i] > 1.5:\n            priorities[i] += 0.5\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n        \n        if priorities[i] > 1.5:\n            priorities[i] += 0.6\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.4\n        \n        if bins[i] % 2 == 0:\n            priorities[i] *= 1.2\n        else:\n            priorities[i] *= 0.8\n        \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:25:53", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.3 and ratios[i] < 0.6:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.log(ratios[i] + 1)\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:25:56", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.3 and ratios[i] < 0.6:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.log(ratios[i] + 1)\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i] * np.pi / 2)\n        else:\n            priorities[i] = np.sqrt(ratios[i]) * np.log(ratios[i] + 1)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:25:58", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.3 and ratios[i] < 0.6:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.log(ratios[i] + 1)\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sqrt(ratios[i])\n        else:\n            priorities[i] = np.exp(ratios[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:26:01", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.3 and ratios[i] < 0.6:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.log(ratios[i] + 1)\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.tan(ratios[i])\n        elif ratios[i] >= 0.8 and ratios[i] < 0.9:\n            priorities[i] = np.arctan(ratios[i])\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:26:10", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            if item == bins[i]:\n                priorities[i] = 0.5\n            else:\n                priorities[i] = (item - bins[i]) / item\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:26:12", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:26:15", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n\n    if item > max_bin_capacity * 0.75:\n        for j in range(len(bins)):\n            if bins[j] == max_bin_capacity:\n                priorities[j] *= 1.5\n    elif item < min_bin_capacity * 0.25:\n        for k in range(len(bins)):\n            if bins[k] == min_bin_capacity:\n                priorities[k] *= 0.5\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:26:18", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        elif item == bins[i]:\n            priorities[i] = 0.5\n        else:\n            priorities[i] = (bins[i] - item) / bins[i]\n        \n        if i > 0:\n            if priorities[i] > priorities[i-1]:\n                priorities[i] = priorities[i] * 1.2\n            else:\n                priorities[i] = priorities[i] * 0.8\n                \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:26:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.3)))\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-6 * (ratio - 0.5)))\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.7)))\n        elif ratio >= 0.8 and ratio < 1.0:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.9)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1.0)))\n\n        if i % 3 == 0:\n            priorities[i] += 0.1\n        elif i % 3 == 1:\n            priorities[i] -= 0.05\n        else:\n            priorities[i] += 0.02\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.3)))\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-6 * (ratio - 0.5)))\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.7)))\n        elif ratio >= 0.8 and ratio < 1.0:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.9)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1.0)))\n\n        if i % 3 == 0:\n            priorities[i] += 0.1\n        elif i % 3 == 1:\n            priorities[i] -= 0.05\n        else:\n            priorities[i] += 0.02\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(data)\n    \n    for i in range(len(data)):\n        if data[i] % 2 == 0:\n            result[i] = data[i] * 2\n        elif data[i] % 3 == 0:\n            result[i] = data[i] * 3\n        elif data[i] % 5 == 0:\n            result[i] = data[i] * 5\n        else:\n            result[i] = data[i]\n    \n    for i in range(1, len(data) - 1):\n        if data[i-1] < data[i] > data[i+1]:\n            result[i] += 10\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 06:26:32", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.3)))\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-6 * (ratio - 0.5)))\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.7)))\n        elif ratio >= 0.8 and ratio < 1.0:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.9)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1.0)))\n\n        if i % 3 == 0:\n            priorities[i] += 0.1\n        elif i % 3 == 1:\n            priorities[i] -= 0.05\n        else:\n            priorities[i] += 0.02\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.3)))\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-6 * (ratio - 0.5)))\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.7)))\n        elif ratio >= 0.8 and ratio < 1.0:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.9)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1.0)))\n\n        if i % 3 == 0:\n            priorities[i] += 0.1\n        elif i % 3 == 1:\n            priorities[i] -= 0.05\n        else:\n            priorities[i] += 0.02\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.3))) + 0.1\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-6 * (ratio - 0.5))) - 0.05\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.7))) + 0.02\n        elif ratio >= 0.8 and ratio < 1.0:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.9)) - 0.03)\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1.0)) + 0.05)\n\n        if i % 4 == 0:\n            priorities[i] *= 1.1\n        elif i % 4 == 1:\n            priorities[i] *= 0.9\n        elif i % 4 == 2:\n            priorities[i] *= 1.05\n        else:\n            priorities[i] *= 0.95\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:26:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.3)))\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-6 * (ratio - 0.5)))\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.7)))\n        elif ratio >= 0.8 and ratio < 1.0:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.9)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1.0)))\n\n        if i % 3 == 0:\n            priorities[i] += 0.1\n        elif i % 3 == 1:\n            priorities[i] -= 0.05\n        else:\n            priorities[i] += 0.02\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.3)))\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-6 * (ratio - 0.5)))\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.7)))\n        elif ratio >= 0.8 and ratio < 1.0:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.9)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1.0)))\n\n        if i % 3 == 0:\n            priorities[i] += 0.1\n        elif i % 3 == 1:\n            priorities[i] -= 0.05\n        else:\n            priorities[i] += 0.02\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.5:\n            priorities[i] = 0.8 / (1 + np.exp(-10 * (ratio - 0.3)))\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 0.6 / (1 + np.exp(-10 * (ratio - 0.6)))\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 0.4 / (1 + np.exp(-10 * (ratio - 0.8)))\n        else:\n            priorities[i] = 0.2 / (1 + np.exp(-10 * (ratio - 1.0)))\n\n        if i % 4 == 0:\n            priorities[i] += 0.1\n        elif i % 4 == 1:\n            priorities[i] -= 0.05\n        elif i % 4 == 2:\n            priorities[i] += 0.02\n        else:\n            priorities[i] -= 0.03\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:26:39", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.3)))\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-6 * (ratio - 0.5)))\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.7)))\n        elif ratio >= 0.8 and ratio < 1.0:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.9)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1.0)))\n\n        if i % 3 == 0:\n            priorities[i] += 0.1\n        elif i % 3 == 1:\n            priorities[i] -= 0.05\n        else:\n            priorities[i] += 0.02\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.3)))\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-6 * (ratio - 0.5)))\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.7)))\n        elif ratio >= 0.8 and ratio < 1.0:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.9)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1.0)))\n\n        if i % 3 == 0:\n            priorities[i] += 0.1\n        elif i % 3 == 1:\n            priorities[i] -= 0.05\n        else:\n            priorities[i] += 0.02\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.3)))\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-6 * (ratio - 0.5)))\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.7)))\n        elif ratio >= 0.8 and ratio < 1.0:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.9)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1.0)))\n\n        if i % 4 == 0:\n            priorities[i] += 0.2\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.05\n        else:\n            priorities[i] -= 0.02\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:26:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] < max_priority:\n            priorities[i] = priorities[i] + 0.1\n        else:\n            priorities[i] = priorities[i]\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    avg_priority = np.mean(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] < avg_priority:\n            priorities[i] = priorities[i] + 0.2\n        else:\n            priorities[i] = priorities[i]\n    \n    total_capacity = np.sum(bins)\n    \n    for i in range(len(priorities)):\n        if bins[i] < total_capacity * 0.1:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i]\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:26:52", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] < max_priority:\n            priorities[i] = priorities[i] + 0.1\n        else:\n            priorities[i] = priorities[i]\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n            \n    total_capacity = np.sum(bins)\n    \n    for i in range(len(priorities)):\n        if item < bins[i]:\n            priorities[i] = priorities[i] + (bins[i] / total_capacity)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:26:55", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] < max_priority:\n            priorities[i] = priorities[i] + 0.1\n        else:\n            priorities[i] = priorities[i]\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.1\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i] + 0.05\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:26:57", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] < max_priority:\n            priorities[i] = priorities[i] + 0.1\n        else:\n            priorities[i] = priorities[i]\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] > min_priority:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i]\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:27:09", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even better version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n            \n            if item % 2 == 0:\n                priorities[i] *= 1.5\n            else:\n                priorities[i] *= 0.8\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:27:12", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n            for j in range(1, count):\n                priorities[i] += j * 0.1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:27:15", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Enhanced version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n            if item > 10:\n                priorities[i] += 0.5\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n            if item > 5:\n                priorities[i] -= 0.3\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n                \n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if count == 4:\n                    priorities[i] += 1.0\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if count == 3:\n                    priorities[i] -= 0.5\n                else:\n                    priorities[i] += 0.1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:27:18", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "import numpy as np\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n                \n            if bins[i] % 5 == 0:\n                priorities[i] *= 1.5\n            elif bins[i] % 3 == 0:\n                priorities[i] *= 1.2\n            else:\n                priorities[i] *= 1.0\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:27:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            priorities[i] = item / bins[i]\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 1:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.25:\n                priorities[i] = 0.3\n            elif ratio >= 0.25 and ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 0.75:\n                priorities[i] = 0.7\n            elif ratio >= 0.75 and ratio < 1:\n                priorities[i] = 0.9\n            else:\n                priorities[i] = 1.0\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:27:29", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            priorities[i] = item / bins[i]\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 1:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        ratio = item / bins[i]\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if ratio < 0.3:\n                priorities[i] = 0.3\n            elif ratio >= 0.3 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:27:32", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            priorities[i] = item / bins[i]\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 1:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.2:\n                priorities[i] = 0.2\n            elif ratio >= 0.2 and ratio < 0.4:\n                priorities[i] = 0.4\n            elif ratio >= 0.4 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n                \n            if bins[i] == max_bin_capacity:\n                priorities[i] += 0.2\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:27:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            priorities[i] = item / bins[i]\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 1:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.3:\n                priorities[i] = 0.3\n            elif ratio >= 0.3 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:27:45", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.5:\n                priorities[i] = item / bins[i]\n            elif item >= bins[i] * 0.9:\n                priorities[i] = (bins[i] - item) / bins[i]\n            else:\n                priorities[i] = 0.5\n                \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            priorities[i] = (item + bins[i]) / (2 * bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.3:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n            elif item >= bins[i] * 0.7:\n                priorities[i] = (bins[i] - item) / (2 * bins[i])\n            else:\n                priorities[i] = 0.5 * item / bins[i]\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:27:47", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.5:\n                priorities[i] = item / bins[i]\n            elif item >= bins[i] * 0.9:\n                priorities[i] = (bins[i] - item) / bins[i]\n            else:\n                priorities[i] = 0.5\n                \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            priorities[i] = (item + bins[i]) / (2 * bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        elif item < bins[i] * 0.2:\n            priorities[i] = item / bins[i]\n        elif item >= bins[i] * 0.8:\n            priorities[i] = (bins[i] - item) / bins[i]\n        else:\n            priorities[i] = 0.5 * item / bins[i]\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:27:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.5:\n                priorities[i] = item / bins[i]\n            elif item >= bins[i] * 0.9:\n                priorities[i] = (bins[i] - item) / bins[i]\n            else:\n                priorities[i] = 0.5\n                \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            priorities[i] = (item + bins[i]) / (2 * bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.2:\n                priorities[i] = item / bins[i]\n            elif item >= bins[i] * 0.7:\n                priorities[i] = 0.5\n            else:\n                total = item + bins[i]\n                priorities[i] = (total ** 2) / (4 * bins[i] * item)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:27:52", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.5:\n                priorities[i] = item / bins[i]\n            elif item >= bins[i] * 0.9:\n                priorities[i] = (bins[i] - item) / bins[i]\n            else:\n                priorities[i] = 0.5\n                \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            priorities[i] = (item + bins[i]) / (2 * bins[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.2:\n                priorities[i] = item / bins[i]\n            elif item >= bins[i] * 0.8:\n                priorities[i] = (bins[i] - item) / bins[i]\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:28:02", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.3 and ratios[i] < 0.6:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.log(ratios[i] + 1)\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:28:05", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.3 and ratios[i] < 0.6:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.log(ratios[i] + 1)\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i]) * np.tan(ratios[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:28:08", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.3 and ratios[i] < 0.6:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.log(ratios[i] + 1)\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            if i % 2 == 0:\n                priorities[i] = np.sin(ratios[i])\n            else:\n                priorities[i] = np.tan(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:28:10", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.3 and ratios[i] < 0.6:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.log(ratios[i] + 1)\n        else:\n            priorities[i] = np.sqrt(ratios[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i])\n    \n    return priorities\n", "strategy": []}
{"timestamp": "2025-04-27 06:28:20", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.sqrt(np.power(ratios[i], 3))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2) + np.tan(ratios[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log2(ratios[i] + 1) * np.cosh(ratios[i])\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sinh(ratios[i] * 2) + np.tanh(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi) - np.sin(ratios[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:28:23", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.1:\n            priorities[i] = np.tanh(ratios[i] * np.pi)\n        elif ratios[i] >= 0.1 and ratios[i] < 0.3:\n            priorities[i] = np.arctan(ratios[i])\n        elif ratios[i] >= 0.3 and ratios[i] < 0.5:\n            priorities[i] = 1 / np.sqrt(ratios[i] + 1)\n        elif ratios[i] >= 0.5 and ratios[i] < 0.7:\n            priorities[i] = np.cbrt(ratios[i])\n        elif ratios[i] >= 0.7 and ratios[i] < 0.9:\n            priorities[i] = np.absolute(np.cos(ratios[i]))\n        else:\n            priorities[i] = np.arccos(ratios[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:28:26", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.1 and ratios[i] < 0.3:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.3 and ratios[i] < 0.5:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.5 and ratios[i] < 0.7:\n            priorities[i] = np.sin(ratios[i])\n        elif ratios[i] >= 0.7 and ratios[i] < 0.9:\n            priorities[i] = np.cosh(ratios[i] * np.pi)\n        else:\n            priorities[i] = np.tanh(ratios[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:28:29", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi) * np.tan(ratios[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:28:41", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.5:\n                priorities[i] = item / bins[i]\n            elif item >= bins[i] * 0.9:\n                priorities[i] = (bins[i] - item) / bins[i]\n            else:\n                priorities[i] = 0.5\n                \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.3:\n                priorities[i] = 0.3\n            elif ratio >= 0.3 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.2:\n                priorities[i] = 0.2\n            elif ratio >= 0.2 and ratio < 0.4:\n                priorities[i] = 0.4\n            elif ratio >= 0.4 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.8\n            elif ratio >= 0.8 and ratio < 0.9:\n                priorities[i] = 0.9\n            else:\n                priorities[i] = 1.0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:28:43", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.5:\n                priorities[i] = item / bins[i]\n            elif item >= bins[i] * 0.9:\n                priorities[i] = (bins[i] - item) / bins[i]\n            else:\n                priorities[i] = 0.5\n                \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.3:\n                priorities[i] = 0.3\n            elif ratio >= 0.3 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.2:\n                priorities[i] = 0.2\n            elif ratio >= 0.2 and ratio < 0.4:\n                priorities[i] = 0.4\n            elif ratio >= 0.4 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:28:46", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.5:\n                priorities[i] = item / bins[i]\n            elif item >= bins[i] * 0.9:\n                priorities[i] = (bins[i] - item) / bins[i]\n            else:\n                priorities[i] = 0.5\n                \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.3:\n                priorities[i] = 0.3\n            elif ratio >= 0.3 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.2:\n                priorities[i] = 0.2\n            elif ratio >= 0.2 and ratio < 0.4:\n                priorities[i] = 0.4\n            elif ratio >= 0.4 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n        \n        if item % 2 == 0:\n            priorities[i] *= 1.5\n        else:\n            priorities[i] *= 0.8\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:28:49", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.5:\n                priorities[i] = item / bins[i]\n            elif item >= bins[i] * 0.9:\n                priorities[i] = (bins[i] - item) / bins[i]\n            else:\n                priorities[i] = 0.5\n                \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.3:\n                priorities[i] = 0.3\n            elif ratio >= 0.3 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.2:\n                priorities[i] = 0.2\n            elif ratio >= 0.2 and ratio < 0.4:\n                priorities[i] = 0.4\n            elif ratio >= 0.4 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:28:57", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    for bin_capacity in bins:\n        if bin_capacity >= item:\n            priorities.append(1.0)\n        else:\n            priority = item / bin_capacity\n            if priority < 0.5:\n                priorities.append(0.9)\n            elif priority >= 0.5 and priority < 1.0:\n                priorities.append(0.7)\n            else:\n                priorities.append(0.5)\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            priority = 1 / remaining_capacity\n            priorities[index] = priority if priority > 0 else 0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 1.0:\n                    priorities[index] = 1.0\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.8\n                else:\n                    priorities[index] = 0.6\n            else:\n                priorities[index] = 0.3\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:28:59", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    for bin_capacity in bins:\n        if bin_capacity >= item:\n            priorities.append(1.0)\n        else:\n            priority = item / bin_capacity\n            if priority < 0.5:\n                priorities.append(0.9)\n            elif priority >= 0.5 and priority < 1.0:\n                priorities.append(0.7)\n            else:\n                priorities.append(0.5)\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            priority = 1 / remaining_capacity\n            priorities[index] = priority if priority > 0 else 0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority >= 0.5:\n                    priorities[index] = priority\n                else:\n                    priorities[index] = 0.5\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:29:01", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    for bin_capacity in bins:\n        if bin_capacity >= item:\n            priorities.append(1.0)\n        else:\n            priority = item / bin_capacity\n            if priority < 0.5:\n                priorities.append(0.9)\n            elif priority >= 0.5 and priority < 1.0:\n                priorities.append(0.7)\n            else:\n                priorities.append(0.5)\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            priority = 1 / remaining_capacity\n            priorities[index] = priority if priority > 0 else 0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    priorities[index] = 0.5\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:29:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = []\n    for bin_capacity in bins:\n        if bin_capacity >= item:\n            priorities.append(1.0)\n        else:\n            priority = item / bin_capacity\n            if priority < 0.5:\n                priorities.append(0.9)\n            elif priority >= 0.5 and priority < 1.0:\n                priorities.append(0.7)\n            else:\n                priorities.append(0.5)\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            priority = 1 / remaining_capacity\n            priorities[index] = priority if priority > 0 else 0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Ultimate version of priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                priorities[index] = priority if priority > 0 else 0\n            else:\n                priorities[index] = 0.1 * (item - bin_capacity)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:29:12", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            priorities[i] = item / bins[i] if item < bins[i] else bins[i] / item\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            priorities[i] = item / bins[i] if item < bins[i] else bins[i] / item\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    priorities[i] = item / bins[i] + 0.5\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:29:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            priorities[i] = item / bins[i] if item < bins[i] else bins[i] / item\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            priorities[i] = item / bins[i] if item < bins[i] else bins[i] / item\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = 0.5\n                elif bins[i] % 2 == 0:\n                    priorities[i] = 0.75\n                else:\n                    priorities[i] = 0.25\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:29:16", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            priorities[i] = item / bins[i] if item < bins[i] else bins[i] / item\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            priorities[i] = item / bins[i] if item < bins[i] else bins[i] / item\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.5\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:29:18", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            priorities[i] = item / bins[i] if item < bins[i] else bins[i] / item\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            priorities[i] = item / bins[i] if item < bins[i] else bins[i] / item\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = 0.5\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:29:26", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n                \n            if bins[i] % 5 == 0:\n                priorities[i] *= 1.5\n            elif bins[i] % 3 == 0:\n                priorities[i] *= 1.2\n            else:\n                priorities[i] *= 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n        \n        if priorities[i] > 1.5:\n            priorities[i] += 0.5\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item * 2:\n            priorities[i] = item * 2 / bins[i] + 0.1\n        elif bins[i] >= item:\n            priorities[i] = 0.9 * item / bins[i] + 0.3\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 1.0 * count + item / bins[i] + 0.5\n            else:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.4\n            \n        if priorities[i] > 1.7:\n            priorities[i] += 0.7\n        elif priorities[i] > 1.2:\n            priorities[i] -= 0.3\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:29:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n                \n            if bins[i] % 5 == 0:\n                priorities[i] *= 1.5\n            elif bins[i] % 3 == 0:\n                priorities[i] *= 1.2\n            else:\n                priorities[i] *= 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n        \n        if priorities[i] > 1.5:\n            priorities[i] += 0.5\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Further improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n\n        if priorities[i] > 2.0:\n            priorities[i] += 0.7\n        elif priorities[i] > 1.5:\n            priorities[i] += 0.5\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.5\n        else:\n            priorities[i] += 0.3\n            \n        if bins[i] % 7 == 0:\n            priorities[i] *= 1.8\n        elif bins[i] % 4 == 0:\n            priorities[i] *= 1.4\n        else:\n            priorities[i] *= 1.2\n        \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:29:34", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n                \n            if bins[i] % 5 == 0:\n                priorities[i] *= 1.5\n            elif bins[i] % 3 == 0:\n                priorities[i] *= 1.2\n            else:\n                priorities[i] *= 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n        \n        if priorities[i] > 1.5:\n            priorities[i] += 0.5\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n                \n            if bins[i] % 5 == 0:\n                priorities[i] *= 1.5\n            elif bins[i] % 3 == 0:\n                priorities[i] *= 1.2\n            else:\n                priorities[i] *= 1.0\n                \n            if item % 2 == 0:\n                priorities[i] += 0.2\n            if item % 3 == 0:\n                priorities[i] += 0.3\n            if item % 5 == 0:\n                priorities[i] += 0.5\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:29:37", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n                \n            if bins[i] % 5 == 0:\n                priorities[i] *= 1.5\n            elif bins[i] % 3 == 0:\n                priorities[i] *= 1.2\n            else:\n                priorities[i] *= 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n        \n        if priorities[i] > 1.5:\n            priorities[i] += 0.5\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            \n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.2\n            elif count == 2:\n                priorities[i] -= 0.6\n            else:\n                priorities[i] += 0.2\n                \n            if bins[i] % 5 == 0:\n                priorities[i] *= 1.5\n            elif bins[i] % 3 == 0:\n                priorities[i] *= 1.3\n            else:\n                priorities[i] *= 1.1\n        \n        if priorities[i] > 1.5:\n            priorities[i] += 0.5\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.3\n        \n        if i % 2 == 0:\n            priorities[i] *= 1.8\n        elif i % 3 == 0:\n            priorities[i] *= 1.6\n        else:\n            priorities[i] *= 1.4\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:29:47", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.3))) + 0.1\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-6 * (ratio - 0.5))) - 0.05\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.7))) + 0.02\n        elif ratio >= 0.8 and ratio < 1.0:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.9)) - 0.03)\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1.0)) + 0.05)\n\n        if i % 4 == 0:\n            priorities[i] *= 1.1\n        elif i % 4 == 1:\n            priorities[i] *= 0.9\n        elif i % 4 == 2:\n            priorities[i] *= 1.05\n        else:\n            priorities[i] *= 0.95\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-7 * (ratio - 0.3)))\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.5)))\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-3 * (ratio - 0.7)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 0.9)))\n\n        if i % 3 == 0:\n            priorities[i] += 0.3\n        elif i % 3 == 1:\n            priorities[i] += 0.1\n        else:\n            priorities[i] -= 0.2\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-12 * (ratio - 0.3)))\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.5)))\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.7)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.9)))\n\n        if i % 3 == 0:\n            priorities[i] += 0.2\n        elif i % 3 == 1:\n            priorities[i] += 0.15\n        else:\n            priorities[i] -= 0.1\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:29:51", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.3))) + 0.1\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-6 * (ratio - 0.5))) - 0.05\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.7))) + 0.02\n        elif ratio >= 0.8 and ratio < 1.0:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.9)) - 0.03)\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1.0)) + 0.05)\n\n        if i % 4 == 0:\n            priorities[i] *= 1.1\n        elif i % 4 == 1:\n            priorities[i] *= 0.9\n        elif i % 4 == 2:\n            priorities[i] *= 1.05\n        else:\n            priorities[i] *= 0.95\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-7 * (ratio - 0.3)))\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.5)))\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-3 * (ratio - 0.7)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 0.9)))\n\n        if i % 3 == 0:\n            priorities[i] += 0.3\n        elif i % 3 == 1:\n            priorities[i] += 0.1\n        else:\n            priorities[i] -= 0.2\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-20 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-18 * (ratio - 0.3)))\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-16 * (ratio - 0.5)))\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-14 * (ratio - 0.7)))\n        elif ratio >= 0.8 and ratio < 1.0:\n            priorities[i] = 1 / (1 + np.exp(-12 * (ratio - 0.9)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 1.0)))\n\n        if i % 4 == 0:\n            priorities[i] += 0.2\n        elif i % 4 == 1:\n            priorities[i] += 0.1\n        elif i % 4 == 2:\n            priorities[i] -= 0.1\n        else:\n            priorities[i] -= 0.2\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:29:55", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.3))) + 0.1\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-6 * (ratio - 0.5))) - 0.05\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.7))) + 0.02\n        elif ratio >= 0.8 and ratio < 1.0:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.9)) - 0.03)\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1.0)) + 0.05)\n\n        if i % 4 == 0:\n            priorities[i] *= 1.1\n        elif i % 4 == 1:\n            priorities[i] *= 0.9\n        elif i % 4 == 2:\n            priorities[i] *= 1.05\n        else:\n            priorities[i] *= 0.95\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-7 * (ratio - 0.3)))\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.5)))\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-3 * (ratio - 0.7)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 0.9)))\n\n        if i % 3 == 0:\n            priorities[i] += 0.3\n        elif i % 3 == 1:\n            priorities[i] += 0.1\n        else:\n            priorities[i] -= 0.2\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.15:\n            priorities[i] = 1 / (1 + np.exp(-20 * ratio))\n        elif ratio >= 0.15 and ratio < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-18 * (ratio - 0.2))) + 0.2\n        elif ratio >= 0.3 and ratio < 0.45:\n            priorities[i] = 1 / (1 + np.exp(-16 * (ratio - 0.35))) - 0.1\n        elif ratio >= 0.45 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-14 * (ratio - 0.5))) + 0.15\n        elif ratio >= 0.6 and ratio < 0.75:\n            priorities[i] = 1 / (1 + np.exp(-12 * (ratio - 0.7))) - 0.05\n        else:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.85))) + 0.1\n\n        if i % 5 == 0:\n            priorities[i] *= 1.2\n        elif i % 5 == 1:\n            priorities[i] *= 0.8\n        elif i % 5 == 2:\n            priorities[i] *= 1.1\n        elif i % 5 == 3:\n            priorities[i] *= 0.9\n        else:\n            priorities[i] *= 1.05\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:29:59", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.3))) + 0.1\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-6 * (ratio - 0.5))) - 0.05\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.7))) + 0.02\n        elif ratio >= 0.8 and ratio < 1.0:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.9)) - 0.03)\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1.0)) + 0.05)\n\n        if i % 4 == 0:\n            priorities[i] *= 1.1\n        elif i % 4 == 1:\n            priorities[i] *= 0.9\n        elif i % 4 == 2:\n            priorities[i] *= 1.05\n        else:\n            priorities[i] *= 0.95\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-7 * (ratio - 0.3)))\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.5)))\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-3 * (ratio - 0.7)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 0.9)))\n\n        if i % 3 == 0:\n            priorities[i] += 0.3\n        elif i % 3 == 1:\n            priorities[i] += 0.1\n        else:\n            priorities[i] -= 0.2\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-20 * ratio))\n        elif ratio >= 0.1 and ratio < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-12 * (ratio - 0.2))) + 0.2\n        elif ratio >= 0.3 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.4))) - 0.1\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-6 * (ratio - 0.6))) + 0.1\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.8))) - 0.15\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.0))) + 0.2\n\n        if i % 5 == 0:\n            priorities[i] *= 1.2\n        elif i % 5 == 1:\n            priorities[i] *= 0.8\n        elif i % 5 == 2:\n            priorities[i] *= 1.1\n        elif i % 5 == 3:\n            priorities[i] *= 0.9\n        else:\n            priorities[i] *= 1.05\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:30:11", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        ratio = item / bins[i]\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if ratio < 0.3:\n                priorities[i] = 0.3\n            elif ratio >= 0.3 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.3:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n            elif item >= bins[i] * 0.7:\n                priorities[i] = (bins[i] - item) / (2 * bins[i])\n            else:\n                priorities[i] = 0.5 * item / bins[i]\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.2:\n                priorities[i] = 0.2\n            elif ratio >= 0.2 and ratio < 0.4:\n                priorities[i] = 0.4\n            elif ratio >= 0.4 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n            \n            if item % 2 == 0:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.1\n                \n            priorities[i] = max(0.0, min(1.0, priorities[i]))\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:30:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        ratio = item / bins[i]\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if ratio < 0.3:\n                priorities[i] = 0.3\n            elif ratio >= 0.3 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.3:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n            elif item >= bins[i] * 0.7:\n                priorities[i] = (bins[i] - item) / (2 * bins[i])\n            else:\n                priorities[i] = 0.5 * item / bins[i]\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.3:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n            elif item >= bins[i] * 0.7:\n                priorities[i] = (bins[i] - item) / (2 * bins[i])\n            else:\n                if bins[i] % 2 == 0:\n                    priorities[i] = 0.5 * item / bins[i]\n                else:\n                    priorities[i] = 0.7 * item / bins[i]\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:30:17", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        ratio = item / bins[i]\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if ratio < 0.3:\n                priorities[i] = 0.3\n            elif ratio >= 0.3 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.3:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n            elif item >= bins[i] * 0.7:\n                priorities[i] = (bins[i] - item) / (2 * bins[i])\n            else:\n                priorities[i] = 0.5 * item / bins[i]\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.2:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n            elif item >= bins[i] * 0.8:\n                priorities[i] = (bins[i] - item) / (2 * bins[i])\n            else:\n                if bins[i] % 2 == 0:\n                    priorities[i] = 0.5 * item / bins[i]\n                else:\n                    priorities[i] = 0.75 * item / bins[i]\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:30:19", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        ratio = item / bins[i]\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if ratio < 0.3:\n                priorities[i] = 0.3\n            elif ratio >= 0.3 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.3:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n            elif item >= bins[i] * 0.7:\n                priorities[i] = (bins[i] - item) / (2 * bins[i])\n            else:\n                priorities[i] = 0.5 * item / bins[i]\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.2:\n                priorities[i] = item / bins[i]\n            elif item >= bins[i] * 0.8:\n                priorities[i] = np.sqrt((bins[i] - item) / bins[i])\n            else:\n                priorities[i] = np.log(10 * item / bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:30:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            if utilization_ratio < 0.5:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.5 and utilization_ratio < 0.8:\n                priority_score = 0.8 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.5 / (1 + utilization_ratio)\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            if utilization_ratio < 0.5:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.5 and utilization_ratio < 0.8:\n                priority_score = 0.8 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.5 / (1 + utilization_ratio)\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.3:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.9 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.5 / (1 + utilization_ratio)\n                \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:30:31", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            if utilization_ratio < 0.5:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.5 and utilization_ratio < 0.8:\n                priority_score = 0.8 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.5 / (1 + utilization_ratio)\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            if utilization_ratio < 0.5:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.5 and utilization_ratio < 0.8:\n                priority_score = 0.8 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.5 / (1 + utilization_ratio)\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            if utilization_ratio < 0.3:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.9 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.8 and utilization_ratio < 0.9:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.3 / (1 + utilization_ratio)\n\n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:30:33", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            if utilization_ratio < 0.5:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.5 and utilization_ratio < 0.8:\n                priority_score = 0.8 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.5 / (1 + utilization_ratio)\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            if utilization_ratio < 0.5:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.5 and utilization_ratio < 0.8:\n                priority_score = 0.8 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.5 / (1 + utilization_ratio)\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            if utilization_ratio < 0.4:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.4 and utilization_ratio < 0.6:\n                priority_score = 0.9 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.8 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.6 / (1 + utilization_ratio)\n                \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:30:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            if utilization_ratio < 0.5:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.5 and utilization_ratio < 0.8:\n                priority_score = 0.8 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.5 / (1 + utilization_ratio)\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            if utilization_ratio < 0.5:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.5 and utilization_ratio < 0.8:\n                priority_score = 0.8 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.5 / (1 + utilization_ratio)\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            if remaining_space > 0.2 * bins[i]:\n                priority_score = 1 / (1 + remaining_space / bins[i])\n            else:\n                priority_score = (0.8 + remaining_space / bins[i]) / (1 + remaining_space / bins[i])\n                \n            priorities[i] = priority_score\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:30:43", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            priorities[i] = 1.0 / (1.0 + remaining_capacity)  # Higher priority for more remaining capacity\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            priorities[i] = 1.0 / (1.0 + remaining_capacity)  # Higher priority for more remaining capacity\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity < bins[i]/2:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.2  # Higher priority for slightly more remaining capacity\n            elif remaining_capacity >= bins[i]/2:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.4  # Higher priority for significantly more remaining capacity\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:30:46", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            priorities[i] = 1.0 / (1.0 + remaining_capacity)  # Higher priority for more remaining capacity\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            priorities[i] = 1.0 / (1.0 + remaining_capacity)  # Higher priority for more remaining capacity\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity)  # Higher priority for more remaining capacity\n            else:\n                priorities[i] = 2.0  # Highest priority if capacity exactly matches item size\n                break  # No need to check remaining bins\n        \n        if priorities[i] > 1.0:\n            priorities[i] = 1.0  # Cap priority to 1.0\n        \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:30:48", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            priorities[i] = 1.0 / (1.0 + remaining_capacity)  # Higher priority for more remaining capacity\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            priorities[i] = 1.0 / (1.0 + remaining_capacity)  # Higher priority for more remaining capacity\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity >= 0.5 * bins[i]:\n                priorities[i] = 0.5 / (1.0 + remaining_capacity)\n            elif remaining_capacity >= 0.3 * bins[i]:\n                priorities[i] = 0.3 / (1.0 + remaining_capacity)\n            else:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:30:51", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            priorities[i] = 1.0 / (1.0 + remaining_capacity)  # Higher priority for more remaining capacity\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            priorities[i] = 1.0 / (1.0 + remaining_capacity)  # Higher priority for more remaining capacity\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            priority = 1.0 / (1.0 + remaining_capacity)\n            \n            if priority >= 0.5:\n                priorities[i] = priority * 1.2  # Increase priority by 20% for high capacity bins\n            else:\n                priorities[i] = priority * 0.8  # Decrease priority by 20% for low capacity bins\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:31:01", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.1\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i] + 0.05\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5:\n            priorities[i] = 1.5\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:31:04", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.1\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i] + 0.05\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n\n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.2\n        else:\n            priorities[i] = priorities[i] + 0.1\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:31:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.1\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i] + 0.05\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0\n        elif item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if priorities[i] > 0.8:\n            priorities[i] += 0.2\n        elif priorities[i] > 0.5:\n            priorities[i] += 0.15\n        elif priorities[i] > 0.3:\n            priorities[i] += 0.1\n        else:\n            priorities[i] += 0.05\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:31:09", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.1\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i] + 0.05\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nfrom math import sqrt\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = sqrt(item / bins[i])\n        else:\n            priorities[i] = 1.0\n        \n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.3\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.2\n        else:\n            priorities[i] *= 1.1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:31:16", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff % 2 == 0:\n                priorities[i] = (bins[i] + diff) / item + 0.3\n            else:\n                priorities[i] = (bins[i] + diff) / item - 0.2\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            else:\n                priorities[i] *= 0.9\n                \n            if priority[i] < 0.5:\n                priorities[i] = 0.5\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:31:19", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff % 2 == 0:\n                priorities[i] = (bins[i] + diff) / item + 0.3\n            else:\n                priorities[i] = (bins[i] + diff) / item - 0.2\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.2\n            else:\n                priorities[i] -= 0.1\n                \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:31:22", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff % 2 == 0:\n                priorities[i] = (bins[i] + diff) / item + 0.3\n            else:\n                priorities[i] = (bins[i] + diff) / item - 0.2\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            \n            if item % 2 == 0:\n                priorities[i] += 0.5\n            else:\n                priorities[i] -= 0.5\n                \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:31:25", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff % 2 == 0:\n                priorities[i] = (bins[i] + diff) / item + 0.3\n            else:\n                priorities[i] = (bins[i] + diff) / item - 0.2\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.2\n            elif item + bins[i] > 100:\n                priorities[i] -= 0.1\n            else:\n                priorities[i] += 0.3\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:31:32", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            priority_score = 1 / (1 + utilization_ratio)\n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            priority_score = 1 / (1 + utilization_ratio)\n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            if remaining_space > bins[i] * 0.2:\n                priority_score = 1 / (1 + remaining_space)\n            else:\n                priority_score = 0.5 / (1 + remaining_space)\n                \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:31:34", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            priority_score = 1 / (1 + utilization_ratio)\n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            priority_score = 1 / (1 + utilization_ratio)\n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if bins[i] == max_bin_capacity:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif bins[i] == min_bin_capacity:\n                priority_score = 0.8 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.5 / (1 + utilization_ratio)\n                \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:31:37", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            priority_score = 1 / (1 + utilization_ratio)\n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            priority_score = 1 / (1 + utilization_ratio)\n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            if remaining_space >= bins[i] * 0.5:\n                utilization_ratio = remaining_space / bins[i]\n                priority_score = 1 / (1 + utilization_ratio)\n                priorities[i] = priority_score\n            else:\n                priority_score = 0.5\n                priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:31:39", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            priority_score = 1 / (1 + utilization_ratio)\n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            priority_score = 1 / (1 + utilization_ratio)\n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            if remaining_space > 0.5 * bins[i]:\n                priority_score = 1\n            else:\n                priority_score = 0.5\n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:31:48", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi) * np.tan(ratios[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.1:\n            priorities[i] = np.tanh(ratios[i] * np.pi)\n        elif ratios[i] >= 0.1 and ratios[i] < 0.3:\n            priorities[i] = np.log10(np.abs(ratios[i]) + 1)\n        elif ratios[i] >= 0.3 and ratios[i] < 0.5:\n            priorities[i] = np.arcsin(ratios[i])\n        elif ratios[i] >= 0.5 and ratios[i] < 0.7:\n            priorities[i] = np.cbrt(ratios[i])\n        elif ratios[i] >= 0.7 and ratios[i] < 0.9:\n            priorities[i] = np.cos(ratios[i])\n        else:\n            priorities[i] = np.cosh(np.sinh(ratios[i]))\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:31:51", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi) * np.tan(ratios[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2) + np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.sqrt(ratios[i])\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.tan(ratios[i]) + np.arctan(ratios[i])\n        else:\n            priorities[i] = np.sinh(ratios[i] * np.pi) * np.cosh(ratios[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:31:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi) * np.tan(ratios[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi) * np.tan(ratios[i])\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(bins)):\n        priorities[i] = (priorities[i] - min_priority) / (max_priority - min_priority)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:31:57", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi) * np.tan(ratios[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi) * np.tan(ratios[i]) + np.arctan(ratios[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:32:08", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-20 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-18 * (ratio - 0.3)))\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-16 * (ratio - 0.5)))\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-14 * (ratio - 0.7)))\n        elif ratio >= 0.8 and ratio < 1.0:\n            priorities[i] = 1 / (1 + np.exp(-12 * (ratio - 0.9)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 1.0)))\n\n        if i % 4 == 0:\n            priorities[i] += 0.2\n        elif i % 4 == 1:\n            priorities[i] += 0.1\n        elif i % 4 == 2:\n            priorities[i] -= 0.1\n        else:\n            priorities[i] -= 0.2\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.5:\n            priorities[i] = 0.8 / (1 + np.exp(-10 * (ratio - 0.3)))\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 0.6 / (1 + np.exp(-10 * (ratio - 0.6)))\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 0.4 / (1 + np.exp(-10 * (ratio - 0.8)))\n        else:\n            priorities[i] = 0.2 / (1 + np.exp(-10 * (ratio - 1.0)))\n\n        if i % 4 == 0:\n            priorities[i] += 0.1\n        elif i % 4 == 1:\n            priorities[i] -= 0.05\n        elif i % 4 == 2:\n            priorities[i] += 0.02\n        else:\n            priorities[i] -= 0.03\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 0.8 / (1 + np.exp(-9 * (ratio - 0.3)))\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 0.6 / (1 + np.exp(-8 * (ratio - 0.5)))\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 0.4 / (1 + np.exp(-7 * (ratio - 0.7)))\n        elif ratio >= 0.8 and ratio < 1.0:\n            priorities[i] = 0.2 / (1 + np.exp(-6 * (ratio - 0.9)))\n        else:\n            priorities[i] = 0.1 / (1 + np.exp(-5 * (ratio - 1.0)))\n\n        if i % 4 == 0:\n            priorities[i] += 0.1\n        elif i % 4 == 1:\n            priorities[i] -= 0.05\n        elif i % 4 == 2:\n            priorities[i] += 0.03\n        else:\n            priorities[i] -= 0.02\n\n        if i < len(bins)//2:\n            priorities[i] *= 1.2\n        else:\n            priorities[i] *= 0.8\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:32:12", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-20 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-18 * (ratio - 0.3)))\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-16 * (ratio - 0.5)))\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-14 * (ratio - 0.7)))\n        elif ratio >= 0.8 and ratio < 1.0:\n            priorities[i] = 1 / (1 + np.exp(-12 * (ratio - 0.9)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 1.0)))\n\n        if i % 4 == 0:\n            priorities[i] += 0.2\n        elif i % 4 == 1:\n            priorities[i] += 0.1\n        elif i % 4 == 2:\n            priorities[i] -= 0.1\n        else:\n            priorities[i] -= 0.2\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.5:\n            priorities[i] = 0.8 / (1 + np.exp(-10 * (ratio - 0.3)))\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 0.6 / (1 + np.exp(-10 * (ratio - 0.6)))\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 0.4 / (1 + np.exp(-10 * (ratio - 0.8)))\n        else:\n            priorities[i] = 0.2 / (1 + np.exp(-10 * (ratio - 1.0)))\n\n        if i % 4 == 0:\n            priorities[i] += 0.1\n        elif i % 4 == 1:\n            priorities[i] -= 0.05\n        elif i % 4 == 2:\n            priorities[i] += 0.02\n        else:\n            priorities[i] -= 0.03\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 0.8 / (1 + np.exp(-15 * (ratio - 0.3)))\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 0.6 / (1 + np.exp(-15 * (ratio - 0.5)))\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 0.4 / (1 + np.exp(-15 * (ratio - 0.7)))\n        else:\n            priorities[i] = 0.2 / (1 + np.exp(-15 * (ratio - 0.9)))\n\n        if i % 5 == 0:\n            priorities[i] += 0.08\n        elif i % 5 == 1:\n            priorities[i] -= 0.03\n        elif i % 5 == 2:\n            priorities[i] += 0.05\n        elif i % 5 == 3:\n            priorities[i] -= 0.02\n        else:\n            priorities[i] += 0.1\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:32:16", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-20 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-18 * (ratio - 0.3)))\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-16 * (ratio - 0.5)))\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-14 * (ratio - 0.7)))\n        elif ratio >= 0.8 and ratio < 1.0:\n            priorities[i] = 1 / (1 + np.exp(-12 * (ratio - 0.9)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 1.0)))\n\n        if i % 4 == 0:\n            priorities[i] += 0.2\n        elif i % 4 == 1:\n            priorities[i] += 0.1\n        elif i % 4 == 2:\n            priorities[i] -= 0.1\n        else:\n            priorities[i] -= 0.2\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.5:\n            priorities[i] = 0.8 / (1 + np.exp(-10 * (ratio - 0.3)))\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 0.6 / (1 + np.exp(-10 * (ratio - 0.6)))\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 0.4 / (1 + np.exp(-10 * (ratio - 0.8)))\n        else:\n            priorities[i] = 0.2 / (1 + np.exp(-10 * (ratio - 1.0)))\n\n        if i % 4 == 0:\n            priorities[i] += 0.1\n        elif i % 4 == 1:\n            priorities[i] -= 0.05\n        elif i % 4 == 2:\n            priorities[i] += 0.02\n        else:\n            priorities[i] -= 0.03\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-20 * (ratio - 0.1)))\n        elif ratio >= 0.1 and ratio < 0.3:\n            priorities[i] = 0.9 / (1 + np.exp(-18 * (ratio - 0.2)))\n        elif ratio >= 0.3 and ratio < 0.6:\n            priorities[i] = 0.8 / (1 + np.exp(-16 * (ratio - 0.4)))\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 0.7 / (1 + np.exp(-14 * (ratio - 0.7)))\n        elif ratio >= 0.8 and ratio < 1.0:\n            priorities[i] = 0.6 / (1 + np.exp(-12 * (ratio - 0.9)))\n        else:\n            priorities[i] = 0.5 / (1 + np.exp(-10 * (ratio - 1.0)))\n\n        if i % 5 == 0:\n            priorities[i] += 0.1\n        elif i % 5 == 1:\n            priorities[i] -= 0.05\n        elif i % 5 == 2:\n            priorities[i] += 0.03\n        elif i % 5 == 3:\n            priorities[i] -= 0.02\n        else:\n            priorities[i] += 0.05\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:32:20", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-20 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-18 * (ratio - 0.3)))\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-16 * (ratio - 0.5)))\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-14 * (ratio - 0.7)))\n        elif ratio >= 0.8 and ratio < 1.0:\n            priorities[i] = 1 / (1 + np.exp(-12 * (ratio - 0.9)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 1.0)))\n\n        if i % 4 == 0:\n            priorities[i] += 0.2\n        elif i % 4 == 1:\n            priorities[i] += 0.1\n        elif i % 4 == 2:\n            priorities[i] -= 0.1\n        else:\n            priorities[i] -= 0.2\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.5:\n            priorities[i] = 0.8 / (1 + np.exp(-10 * (ratio - 0.3)))\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 0.6 / (1 + np.exp(-10 * (ratio - 0.6)))\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 0.4 / (1 + np.exp(-10 * (ratio - 0.8)))\n        else:\n            priorities[i] = 0.2 / (1 + np.exp(-10 * (ratio - 1.0)))\n\n        if i % 4 == 0:\n            priorities[i] += 0.1\n        elif i % 4 == 1:\n            priorities[i] -= 0.05\n        elif i % 4 == 2:\n            priorities[i] += 0.02\n        else:\n            priorities[i] -= 0.03\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-12 * (ratio - 0.1)))\n        elif ratio >= 0.1 and ratio < 0.3:\n            priorities[i] = 0.9 / (1 + np.exp(-11 * (ratio - 0.2)))\n        elif ratio >= 0.3 and ratio < 0.5:\n            priorities[i] = 0.7 / (1 + np.exp(-10 * (ratio - 0.4)))\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 0.5 / (1 + np.exp(-9 * (ratio - 0.6)))\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 0.3 / (1 + np.exp(-8 * (ratio - 0.8)))\n        else:\n            priorities[i] = 0.1 / (1 + np.exp(-7 * (ratio - 1.0)))\n\n        if i % 5 == 0:\n            priorities[i] += 0.1\n        elif i % 5 == 1:\n            priorities[i] -= 0.05\n        elif i % 5 == 2:\n            priorities[i] += 0.03\n        elif i % 5 == 3:\n            priorities[i] -= 0.02\n        else:\n            priorities[i] += 0.05\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:32:34", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            priority_score = 1 / (1 + utilization_ratio)\n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            if utilization_ratio < 0.3:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.9 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.8 and utilization_ratio < 0.9:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.3 / (1 + utilization_ratio)\n\n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            if utilization_ratio < 0.2:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.2 and utilization_ratio < 0.4:\n                priority_score = 0.9 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.4 and utilization_ratio < 0.6:\n                priority_score = 0.8 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.8 and utilization_ratio < 0.9:\n                priority_score = 0.6 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.5 / (1 + utilization_ratio)\n\n            priorities[i] = priority_score\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:32:38", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            priority_score = 1 / (1 + utilization_ratio)\n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            if utilization_ratio < 0.3:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.9 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.8 and utilization_ratio < 0.9:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.3 / (1 + utilization_ratio)\n\n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.2:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.2 and utilization_ratio < 0.4:\n                priority_score = 0.9 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.4 and utilization_ratio < 0.6:\n                priority_score = 0.8 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.8 and utilization_ratio < 0.9:\n                priority_score = 0.6 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.5 / (1 + utilization_ratio)\n\n            priorities[i] = priority_score\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:32:41", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            priority_score = 1 / (1 + utilization_ratio)\n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            if utilization_ratio < 0.3:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.9 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.8 and utilization_ratio < 0.9:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.3 / (1 + utilization_ratio)\n\n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            if utilization_ratio < 0.2:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.2 and utilization_ratio < 0.4:\n                priority_score = 0.9 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.4 and utilization_ratio < 0.6:\n                priority_score = 0.8 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.8 and utilization_ratio < 0.9:\n                priority_score = 0.6 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.5 / (1 + utilization_ratio)\n\n            priorities[i] = priority_score * np.sqrt(bins[i])  # Adjusting priority based on bin capacity\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:32:44", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            priority_score = 1 / (1 + utilization_ratio)\n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            if utilization_ratio < 0.3:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.9 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.8 and utilization_ratio < 0.9:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.3 / (1 + utilization_ratio)\n\n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.2:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.2 and utilization_ratio < 0.4:\n                priority_score = 0.8 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.4 and utilization_ratio < 0.6:\n                priority_score = 0.6 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.4 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.2 / (1 + utilization_ratio)\n                \n            if bins[i] >= 10:\n                priority_score *= 1.2\n            elif bins[i] >= 5:\n                priority_score *= 1.1\n                \n            priorities[i] = priority_score\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:32:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity)  # Higher priority for more remaining capacity\n            else:\n                priorities[i] = 2.0  # Highest priority if capacity exactly matches item size\n                break  # No need to check remaining bins\n        \n        if priorities[i] > 1.0:\n            priorities[i] = 1.0  # Cap priority to 1.0\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity)  # Higher priority for more remaining capacity\n            else:\n                priorities[i] = 2.0  # Highest priority if capacity exactly matches item size\n                break  # No need to check remaining bins\n        \n        if priorities[i] > 1.0:\n            priorities[i] = 1.0  # Cap priority to 1.0\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5  # Add a constant to increase priority\n            else:\n                priorities[i] = 2.0  # Highest priority if capacity exactly matches item size\n                break\n        \n        if i % 2 == 0:\n            priorities[i] *= 1.5  # Increase priority for every alternate bin\n        \n        if item % 2 == 0:\n            priorities[i] += 0.25  # Add extra priority for even-sized items\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:32:56", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity)  # Higher priority for more remaining capacity\n            else:\n                priorities[i] = 2.0  # Highest priority if capacity exactly matches item size\n                break  # No need to check remaining bins\n        \n        if priorities[i] > 1.0:\n            priorities[i] = 1.0  # Cap priority to 1.0\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity)  # Higher priority for more remaining capacity\n            else:\n                priorities[i] = 2.0  # Highest priority if capacity exactly matches item size\n                break  # No need to check remaining bins\n        \n        if priorities[i] > 1.0:\n            priorities[i] = 1.0  # Cap priority to 1.0\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity)  # Higher priority for more remaining capacity\n            else:\n                priorities[i] = 2.0  # Highest priority if capacity exactly matches item size\n                continue  # Continue to next iteration instead of breaking\n        \n        if priorities[i] > 1.0:\n            priorities[i] = 1.0  # Cap priority to 1.0\n        elif priorities[i] < 0:\n            priorities[i] = 0.0  # Set negative priorities to 0\n        \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:32:59", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity)  # Higher priority for more remaining capacity\n            else:\n                priorities[i] = 2.0  # Highest priority if capacity exactly matches item size\n                break  # No need to check remaining bins\n        \n        if priorities[i] > 1.0:\n            priorities[i] = 1.0  # Cap priority to 1.0\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity)  # Higher priority for more remaining capacity\n            else:\n                priorities[i] = 2.0  # Highest priority if capacity exactly matches item size\n                break  # No need to check remaining bins\n        \n        if priorities[i] > 1.0:\n            priorities[i] = 1.0  # Cap priority to 1.0\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > item:\n                priorities[i] = 1.0 + 1/(remaining_capacity-item)  # Higher priority for more excess capacity\n            elif remaining_capacity > 0:\n                priorities[i] = 1.0  # Priority 1 for capacity matching item size\n            else:\n                priorities[i] = 2.0  # Highest priority if capacity exactly matches item size\n                break  # No need to check remaining bins\n        \n        if priorities[i] > 1.0:\n            priorities[i] = 1.0  # Cap priority to 1.0\n        \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:33:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity)  # Higher priority for more remaining capacity\n            else:\n                priorities[i] = 2.0  # Highest priority if capacity exactly matches item size\n                break  # No need to check remaining bins\n        \n        if priorities[i] > 1.0:\n            priorities[i] = 1.0  # Cap priority to 1.0\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity)  # Higher priority for more remaining capacity\n            else:\n                priorities[i] = 2.0  # Highest priority if capacity exactly matches item size\n                break  # No need to check remaining bins\n        \n        if priorities[i] > 1.0:\n            priorities[i] = 1.0  # Cap priority to 1.0\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity)  # Higher priority for more remaining capacity\n            else:\n                priorities[i] = 2.0  # Highest priority if capacity exactly matches item size\n                break  # No need to check remaining bins\n        \n        if priorities[i] > 1.0:\n            priorities[i] = 1.0  # Cap priority to 1.0\n    \n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = max_priority * 1.5  # Increase priority of bin with max priority\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:33:11", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            priority = 1 / remaining_capacity\n            priorities[index] = priority if priority > 0 else 0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    priorities[index] = 0.5\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                elif priority >= 1.0 and priority < 2.0:\n                    priorities[index] = 0.5\n                else:\n                    priorities[index] = 0.3\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:33:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            priority = 1 / remaining_capacity\n            priorities[index] = priority if priority > 0 else 0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    priorities[index] = 0.5\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if bin_capacity % 2 == 0:\n                        priorities[index] = 0.6\n                    else:\n                        priorities[index] = 0.8\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:33:15", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            priority = 1 / remaining_capacity\n            priorities[index] = priority if priority > 0 else 0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    priorities[index] = 0.5\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.3:\n                    priorities[index] = 0.9\n                elif priority >= 0.3 and priority < 0.6:\n                    priorities[index] = 0.7\n                elif priority >= 0.6 and priority < 0.9:\n                    priorities[index] = 0.5\n                else:\n                    priorities[index] = 0.3\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:33:18", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            priority = 1 / remaining_capacity\n            priorities[index] = priority if priority > 0 else 0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    priorities[index] = 0.5\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for index, bin_capacity in enumerate(bins):\n        if item <= 0.1 * bin_capacity:\n            priorities[index] = 1.0\n        elif item <= 0.3 * bin_capacity:\n            priorities[index] = 0.8\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 0.8:\n                    priorities[index] = 0.7\n                else:\n                    priorities[index] = 0.5\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:33:26", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            priorities[i] = item / bins[i] if item < bins[i] else bins[i] / item\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = 0.5\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = 0.5\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.1\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:33:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            priorities[i] = item / bins[i] if item < bins[i] else bins[i] / item\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = 0.5\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = 0.5\n        if i % 2 == 0:\n            priorities[i] *= 1.2\n        else:\n            priorities[i] *= 0.8\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:33:31", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            priorities[i] = item / bins[i] if item < bins[i] else bins[i] / item\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = 0.5\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = 0.5\n    return priorities  2", "strategy": []}
{"timestamp": "2025-04-27 06:33:33", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            priorities[i] = item / bins[i] if item < bins[i] else bins[i] / item\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = 0.5\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < 0.5 * bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > 1.5 * bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = item * bins[i] / (item + bins[i])\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:33:41", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi) * np.tan(ratios[i]) + np.arctan(ratios[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi) * np.tan(ratios[i]) + np.arctan(ratios[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            for j in range(1, int(bins[i])+1):\n                if j % 2 == 0:\n                    priorities[i] += j * np.cos(j * ratios[i]) / np.abs(np.tan(j * ratios[i]) + 1)\n                else:\n                    priorities[i] += j * np.sin(j * ratios[i]) / np.abs(np.tan(j * ratios[i]) + 1)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:33:44", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi) * np.tan(ratios[i]) + np.arctan(ratios[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi) * np.tan(ratios[i]) + np.arctan(ratios[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            if ratios[i] % 2 == 0:\n                priorities[i] = np.cosh(ratios[i] * np.pi) + np.tan(ratios[i])\n            else:\n                priorities[i] = np.arctan(ratios[i]) * np.log1p(ratios[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:33:47", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi) * np.tan(ratios[i]) + np.arctan(ratios[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi) * np.tan(ratios[i]) + np.arctan(ratios[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            temp = np.array([np.sqrt(x) if x % 2 == 0 else x ** 2 for x in range(1, int(ratios[i]*10) + 1)])\n            priorities[i] = np.sum(temp)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:33:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi) * np.tan(ratios[i]) + np.arctan(ratios[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi) * np.tan(ratios[i]) + np.arctan(ratios[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.1:\n            priorities[i] = np.exp(-ratios[i])\n        elif ratios[i] >= 0.1 and ratios[i] < 0.3:\n            priorities[i] = np.tanh(ratios[i])\n        elif ratios[i] >= 0.3 and ratios[i] < 0.5:\n            priorities[i] = np.power(np.sin(ratios[i]), 2)\n        elif ratios[i] >= 0.5 and ratios[i] < 0.7:\n            priorities[i] = np.tan(ratios[i]) + np.arcsin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi) * np.tan(ratios[i]) + np.arctan(ratios[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:34:04", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5  # Add a constant to increase priority\n            else:\n                priorities[i] = 2.0  # Highest priority if capacity exactly matches item size\n                break\n        \n        if i % 2 == 0:\n            priorities[i] *= 1.5  # Increase priority for every alternate bin\n        \n        if item % 2 == 0:\n            priorities[i] += 0.25  # Add extra priority for even-sized items\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5  # Add a constant to increase priority\n            else:\n                priorities[i] = 2.0  # Highest priority if capacity exactly matches item size\n                break\n        \n        if i % 2 == 0:\n            priorities[i] *= 1.5  # Increase priority for every alternate bin\n        \n        if item % 2 == 0:\n            priorities[i] += 0.25  # Add extra priority for even-sized items\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5  # Add a constant to increase priority\n            else:\n                priorities[i] = 2.0  # Highest priority if capacity exactly matches item size\n                break\n        \n        if i % 2 == 0:\n            priorities[i] *= 1.5  # Increase priority for every alternate bin\n        \n        if item % 2 == 0:\n            priorities[i] += 0.25  # Add extra priority for even-sized items\n        \n        if item > 10 and bins[i] > 10:\n            priorities[i] += 0.75  # Additional priority for large items and bins\n        \n        if item % 5 == 0:\n            priorities[i] -= 0.1  # Decrease priority for items divisible by 5\n        \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:34:07", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5  # Add a constant to increase priority\n            else:\n                priorities[i] = 2.0  # Highest priority if capacity exactly matches item size\n                break\n        \n        if i % 2 == 0:\n            priorities[i] *= 1.5  # Increase priority for every alternate bin\n        \n        if item % 2 == 0:\n            priorities[i] += 0.25  # Add extra priority for even-sized items\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5  # Add a constant to increase priority\n            else:\n                priorities[i] = 2.0  # Highest priority if capacity exactly matches item size\n                break\n        \n        if i % 2 == 0:\n            priorities[i] *= 1.5  # Increase priority for every alternate bin\n        \n        if item % 2 == 0:\n            priorities[i] += 0.25  # Add extra priority for even-sized items\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5  # Add a constant to increase priority\n            else:\n                priorities[i] = 2.0  # Highest priority if capacity exactly matches item size\n                break\n        \n        if i % 2 == 0:\n            priorities[i] *= 1.5  # Increase priority for every alternate bin\n        \n        if item % 2 == 0:\n            priorities[i] += 0.25  # Add extra priority for even-sized items\n        \n        if item > 5 and remaining_capacity < 10:\n            priorities[i] += 1.0\n        \n        if item % 3 == 0:\n            priorities[i] *= 2.0\n        \n        if i > 0:\n            priorities[i] += priorities[i-1] / 3\n        \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:34:11", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5  # Add a constant to increase priority\n            else:\n                priorities[i] = 2.0  # Highest priority if capacity exactly matches item size\n                break\n        \n        if i % 2 == 0:\n            priorities[i] *= 1.5  # Increase priority for every alternate bin\n        \n        if item % 2 == 0:\n            priorities[i] += 0.25  # Add extra priority for even-sized items\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5  # Add a constant to increase priority\n            else:\n                priorities[i] = 2.0  # Highest priority if capacity exactly matches item size\n                break\n        \n        if i % 2 == 0:\n            priorities[i] *= 1.5  # Increase priority for every alternate bin\n        \n        if item % 2 == 0:\n            priorities[i] += 0.25  # Add extra priority for even-sized items\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5  # Add a constant to increase priority\n            else:\n                priorities[i] = 2.0  # Highest priority if capacity exactly matches item size\n                break\n        \n        if i % 2 == 0:\n            priorities[i] *= 1.5  # Increase priority for every alternate bin\n        \n        if item % 2 == 0:\n            priorities[i] += 0.25  # Add extra priority for even-sized items\n\n        if item > 5 and i % 3 == 0:\n            priorities[i] += 0.75  # Additional priority for items larger than 5 for every third bin\n        \n        if i == len(bins) - 1:\n            priorities[i] += 1.0  # Increase priority for the last bin\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:34:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5  # Add a constant to increase priority\n            else:\n                priorities[i] = 2.0  # Highest priority if capacity exactly matches item size\n                break\n        \n        if i % 2 == 0:\n            priorities[i] *= 1.5  # Increase priority for every alternate bin\n        \n        if item % 2 == 0:\n            priorities[i] += 0.25  # Add extra priority for even-sized items\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5  # Add a constant to increase priority\n            else:\n                priorities[i] = 2.0  # Highest priority if capacity exactly matches item size\n                break\n        \n        if i % 2 == 0:\n            priorities[i] *= 1.5  # Increase priority for every alternate bin\n        \n        if item % 2 == 0:\n            priorities[i] += 0.25  # Add extra priority for even-sized items\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n            continue\n        \n        if bins[i] == max_capacity:\n            priorities[i] = 2.5  # Give higher priority to bins with maximum capacity\n            continue\n        \n        remaining_capacity = bins[i] - item\n        if remaining_capacity > max_capacity / 2:\n            priorities[i] = 1.0 + (max_capacity - remaining_capacity) / max_capacity  # Priority based on remaining capacity vs max capacity\n        else:\n            priorities[i] = 1.0 + (remaining_capacity / max_capacity)  # Priority inversely proportional to remaining capacity\n        \n        if item % 3 == 0:\n            priorities[i] += 0.5  # Additional priority for items divisible by 3\n        \n        if i % 3 == 0:\n            priorities[i] += 0.25  # Additional priority for bins at every third index\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:34:24", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.3:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n            elif item >= bins[i] * 0.7:\n                priorities[i] = (bins[i] - item) / (2 * bins[i])\n            else:\n                priorities[i] = 0.5 * item / bins[i]\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.3:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n            elif item >= bins[i] * 0.7:\n                priorities[i] = (bins[i] - item) / (2 * bins[i])\n            else:\n                priorities[i] = 0.5 * item / bins[i]\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.2:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n            elif item >= bins[i] * 0.8:\n                priorities[i] = (bins[i] - item) / (2 * bins[i])\n            else:\n                priorities[i] = (2 * item) / bins[i]\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:34:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.3:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n            elif item >= bins[i] * 0.7:\n                priorities[i] = (bins[i] - item) / (2 * bins[i])\n            else:\n                priorities[i] = 0.5 * item / bins[i]\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.3:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n            elif item >= bins[i] * 0.7:\n                priorities[i] = (bins[i] - item) / (2 * bins[i])\n            else:\n                priorities[i] = 0.5 * item / bins[i]\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.2:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n            elif item >= bins[i] * 0.8:\n                priorities[i] = (bins[i] - item) / (2 * bins[i])\n            else:\n                if bins[i] % 2 == 0:\n                    priorities[i] = 0.6 * item / bins[i]\n                else:\n                    priorities[i] = 0.8 * item / bins[i]\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:34:29", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.3:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n            elif item >= bins[i] * 0.7:\n                priorities[i] = (bins[i] - item) / (2 * bins[i])\n            else:\n                priorities[i] = 0.5 * item / bins[i]\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.3:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n            elif item >= bins[i] * 0.7:\n                priorities[i] = (bins[i] - item) / (2 * bins[i])\n            else:\n                priorities[i] = 0.5 * item / bins[i]\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.2:\n                priorities[i] = item / bins[i]\n            elif item >= bins[i] * 0.8:\n                priorities[i] = (bins[i] - item) / bins[i]\n            else:\n                priorities[i] = 0.5 * item / bins[i]\n        \n        if i > 0:\n            if priorities[i] == 1.0 and priorities[i-1] != 1.0:\n                priorities[i-1] = 0.8\n            elif priorities[i] < 0.5:\n                priorities[i-1] = max(0.2, priorities[i-1])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:34:32", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.3:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n            elif item >= bins[i] * 0.7:\n                priorities[i] = (bins[i] - item) / (2 * bins[i])\n            else:\n                priorities[i] = 0.5 * item / bins[i]\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.3:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n            elif item >= bins[i] * 0.7:\n                priorities[i] = (bins[i] - item) / (2 * bins[i])\n            else:\n                priorities[i] = 0.5 * item / bins[i]\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.3:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n            elif item >= bins[i] * 0.7:\n                priorities[i] = (bins[i] - item) / (2 * bins[i])\n            else:\n                if item % 2 == 0:\n                    priorities[i] = 0.75 * item / bins[i]\n                else:\n                    priorities[i] = 0.25 * item / bins[i]\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:34:41", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi) * np.tan(ratios[i]) + np.arctan(ratios[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi) * np.tan(ratios[i]) + np.arctan(ratios[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            if bins[i] % 2 == 0:\n                priorities[i] = np.cosh(ratios[i] * np.pi) * np.tan(ratios[i]) + np.arctan(ratios[i])\n            else:\n                priorities[i] = np.arcsin(ratios[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:34:44", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi) * np.tan(ratios[i]) + np.arctan(ratios[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi) * np.tan(ratios[i]) + np.arctan(ratios[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        \n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        \n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        \n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        \n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi) * np.tan(ratios[i]) + np.arctan(ratios[i])\n    \n    # Apply an additional transformation to priorities\n    priorities = np.clip(priorities, 0, 1)  # Clip values between 0 and 1\n    priorities = np.sort(priorities)[::-1]  # Sort priorities in descending order\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:34:47", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi) * np.tan(ratios[i]) + np.arctan(ratios[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi) * np.tan(ratios[i]) + np.arctan(ratios[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.1:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.1 and ratios[i] < 0.3:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.3 and ratios[i] < 0.5:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.5 and ratios[i] < 0.7:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:34:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi) * np.tan(ratios[i]) + np.arctan(ratios[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi) * np.tan(ratios[i]) + np.arctan(ratios[i])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "import numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-ratios[i]))\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.power(ratios[i], 2)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(ratios[i] + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.sin(ratios[i])\n        else:\n            priorities[i] = np.cosh(ratios[i] * np.pi) * np.tan(ratios[i]) + np.arctan(ratios[i])\n    \n    # Adding more complex logic\n    for j in range(len(bins)):\n        if item > bins[j]:\n            priorities[j] *= 1.5\n        else:\n            priorities[j] -= 0.5\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:35:05", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n        \n        if priorities[i] > 1.5:\n            priorities[i] += 0.5\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Further improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n\n        if priorities[i] > 2.0:\n            priorities[i] += 0.7\n        elif priorities[i] > 1.5:\n            priorities[i] += 0.5\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.5\n        else:\n            priorities[i] += 0.3\n            \n        if bins[i] % 7 == 0:\n            priorities[i] *= 1.8\n        elif bins[i] % 4 == 0:\n            priorities[i] *= 1.4\n        else:\n            priorities[i] *= 1.2\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n\n        if priorities[i] > 2.0:\n            priorities[i] += 0.7\n        elif priorities[i] > 1.5:\n            priorities[i] += 0.5\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.5\n        else:\n            priorities[i] += 0.3\n            \n        if bins[i] % 7 == 0:\n            priorities[i] *= 1.8\n        elif bins[i] % 4 == 0:\n            priorities[i] *= 1.4\n        else:\n            priorities[i] *= 1.2\n            \n        if bins[i] < 10:\n            priorities[i] -= 0.3\n        elif bins[i] < 20:\n            priorities[i] += 0.2\n        else:\n            priorities[i] += 0.5\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:35:09", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n        \n        if priorities[i] > 1.5:\n            priorities[i] += 0.5\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Further improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n\n        if priorities[i] > 2.0:\n            priorities[i] += 0.7\n        elif priorities[i] > 1.5:\n            priorities[i] += 0.5\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.5\n        else:\n            priorities[i] += 0.3\n            \n        if bins[i] % 7 == 0:\n            priorities[i] *= 1.8\n        elif bins[i] % 4 == 0:\n            priorities[i] *= 1.4\n        else:\n            priorities[i] *= 1.2\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(param1: float, param2: int, param3: bool, param4: str) -> float:\n    result = 0.0\n    \n    for i in range(param2):\n        if param3 and i % 2 == 0:\n            result += param1 * i\n        elif not param3 and i % 2 != 0:\n            result -= param1 / (i + 1)\n        else:\n            result += (param2 - i) * 0.5\n            \n    if param4 == \"add\":\n        result += 10.0\n    elif param4 == \"subtract\":\n        result -= 5.0\n    else:\n        result *= 2.0\n        \n    return result", "strategy": []}
{"timestamp": "2025-04-27 06:35:11", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n        \n        if priorities[i] > 1.5:\n            priorities[i] += 0.5\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Further improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n\n        if priorities[i] > 2.0:\n            priorities[i] += 0.7\n        elif priorities[i] > 1.5:\n            priorities[i] += 0.5\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.5\n        else:\n            priorities[i] += 0.3\n            \n        if bins[i] % 7 == 0:\n            priorities[i] *= 1.8\n        elif bins[i] % 4 == 0:\n            priorities[i] *= 1.4\n        else:\n            priorities[i] *= 1.2\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_function(input_data: np.ndarray) -> np.ndarray:\n    output_data = np.zeros_like(input_data)\n    \n    for i in range(len(input_data)):\n        if input_data[i] % 2 == 0:\n            output_data[i] = input_data[i] * 2\n        elif input_data[i] % 3 == 0:\n            output_data[i] = input_data[i] * 3\n        else:\n            temp = input_data[i]\n            while temp > 10:\n                temp -= 10\n            output_data[i] = temp * 1.5\n    \n    return output_data\n```", "strategy": []}
{"timestamp": "2025-04-27 06:35:15", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n        \n        if priorities[i] > 1.5:\n            priorities[i] += 0.5\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Further improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n\n        if priorities[i] > 2.0:\n            priorities[i] += 0.7\n        elif priorities[i] > 1.5:\n            priorities[i] += 0.5\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.5\n        else:\n            priorities[i] += 0.3\n            \n        if bins[i] % 7 == 0:\n            priorities[i] *= 1.8\n        elif bins[i] % 4 == 0:\n            priorities[i] *= 1.4\n        else:\n            priorities[i] *= 1.2\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n\n        if item > 10 and bin[i] % 2 == 0:\n            priorities[i] += 0.6\n        elif item > 5 and bin[i] % 3 == 0:\n            priorities[i] += 0.4\n        elif item > 2:\n            priorities[i] += 0.2\n        else:\n            priorities[i] -= 0.1\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:35:20", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.3))) + 0.1\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-6 * (ratio - 0.5))) - 0.05\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.7))) + 0.02\n        elif ratio >= 0.8 and ratio < 1.0:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.9)) - 0.03)\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1.0)) + 0.05)\n\n        if i % 4 == 0:\n            priorities[i] *= 1.1\n        elif i % 4 == 1:\n            priorities[i] *= 0.9\n        elif i % 4 == 2:\n            priorities[i] *= 1.05\n        else:\n            priorities[i] *= 0.95\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.3)))\n        elif ratio >= 0.3 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.45)))\n        elif ratio >= 0.6 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-3 * (ratio - 0.75)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1.0)))\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_function(param1: int, param2: float, param3: str, param4: list) -> dict:\n    result = {}\n    \n    for item in param4:\n        if item % 2 == 0:\n            if param1 > 10 and param2 < 5.0:\n                result[item] = \"high_priority\"\n            else:\n                result[item] = \"medium_priority\"\n        else:\n            if param3 == \"hello\":\n                result[item] = \"low_priority\"\n            else:\n                result[item] = \"medium_priority\"\n    \n    return result\n```", "strategy": []}
{"timestamp": "2025-04-27 06:35:23", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.3))) + 0.1\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-6 * (ratio - 0.5))) - 0.05\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.7))) + 0.02\n        elif ratio >= 0.8 and ratio < 1.0:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.9)) - 0.03)\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1.0)) + 0.05)\n\n        if i % 4 == 0:\n            priorities[i] *= 1.1\n        elif i % 4 == 1:\n            priorities[i] *= 0.9\n        elif i % 4 == 2:\n            priorities[i] *= 1.05\n        else:\n            priorities[i] *= 0.95\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.3)))\n        elif ratio >= 0.3 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.45)))\n        elif ratio >= 0.6 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-3 * (ratio - 0.75)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1.0)))\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(input_data: np.ndarray) -> np.ndarray:\n    output_data = np.zeros_like(input_data)\n\n    for i in range(input_data.shape[0]):\n        for j in range(input_data.shape[1]):\n            if input_data[i, j] < 0.5:\n                output_data[i, j] = input_data[i, j] ** 2\n            elif input_data[i, j] >= 0.5 and input_data[i, j] < 0.8:\n                output_data[i, j] = input_data[i, j] ** 3\n            else:\n                output_data[i, j] = input_data[i, j] ** 4\n\n    return output_data", "strategy": []}
{"timestamp": "2025-04-27 06:35:25", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.3))) + 0.1\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-6 * (ratio - 0.5))) - 0.05\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.7))) + 0.02\n        elif ratio >= 0.8 and ratio < 1.0:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.9)) - 0.03)\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1.0)) + 0.05)\n\n        if i % 4 == 0:\n            priorities[i] *= 1.1\n        elif i % 4 == 1:\n            priorities[i] *= 0.9\n        elif i % 4 == 2:\n            priorities[i] *= 1.05\n        else:\n            priorities[i] *= 0.95\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.3)))\n        elif ratio >= 0.3 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.45)))\n        elif ratio >= 0.6 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-3 * (ratio - 0.75)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1.0)))\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_function(param1: int, param2: str, param3: list) -> dict:\n    result = {}\n\n    for i in range(param1):\n        if i % 2 == 0:\n            result[i] = param2.upper()\n        else:\n            temp_list = []\n            for item in param3:\n                if len(item) > i:\n                    temp_list.append(item[:i])\n            result[i] = temp_list\n\n    return result\n```", "strategy": []}
{"timestamp": "2025-04-27 06:35:29", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.3))) + 0.1\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-6 * (ratio - 0.5))) - 0.05\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.7))) + 0.02\n        elif ratio >= 0.8 and ratio < 1.0:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.9)) - 0.03)\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1.0)) + 0.05)\n\n        if i % 4 == 0:\n            priorities[i] *= 1.1\n        elif i % 4 == 1:\n            priorities[i] *= 0.9\n        elif i % 4 == 2:\n            priorities[i] *= 1.05\n        else:\n            priorities[i] *= 0.95\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.3)))\n        elif ratio >= 0.3 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.45)))\n        elif ratio >= 0.6 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-3 * (ratio - 0.75)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1.0)))\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.3))) + 0.1\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-6 * (ratio - 0.5))) - 0.05\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.7))) + 0.02\n        elif ratio >= 0.8 and ratio < 1.0:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.9)) - 0.03)\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1.0)) + 0.05)\n\n        priorities[i] *= 1.1 - 0.05 * (i % 4)\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:35:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = 0.5\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.1\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            priorities[i] = item / bins[i] if item < bins[i] else bins[i] / item\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            else:\n                priorities[i] = bins[i] / item\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.1\n            if bins[i] % 3 == 0:\n                priorities[i] += 0.2\n            if i % 2 == 0:\n                priorities[i] += 0.05\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:35:37", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = 0.5\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.1\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            priorities[i] = item / bins[i] if item < bins[i] else bins[i] / item\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Another improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item * 2 / bins[i] + 0.2\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item * 1.5\n            else:\n                priorities[i] = 0.5\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:35:40", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = 0.5\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.1\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            priorities[i] = item / bins[i] if item < bins[i] else bins[i] / item\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = 0.5\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.1\n            for j in range(2, int(bins[i] ** 0.5) + 1):\n                if bins[i] % j == 0:\n                    priorities[i] -= 0.1\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:35:43", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = 0.5\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.1\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            priorities[i] = item / bins[i] if item < bins[i] else bins[i] / item\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priority_ratio = item / bins[i]\n                priorities[i] = 1 - priority_ratio if priority_ratio < 0.5 else priority_ratio\n            else:\n                priority_ratio = bins[i] / item\n                priorities[i] = 1 - priority_ratio if priority_ratio < 0.5 else priority_ratio\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.1\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:35:52", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.2:\n                priorities[i] = 0.2\n            elif ratio >= 0.2 and ratio < 0.4:\n                priorities[i] = 0.4\n            elif ratio >= 0.4 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        elif item < bins[i] * 0.2:\n            priorities[i] = item / bins[i]\n        elif item >= bins[i] * 0.8:\n            priorities[i] = (bins[i] - item) / bins[i]\n        else:\n            priorities[i] = 0.5 * item / bins[i]\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.1:\n                priorities[i] = 0.2 * item / bins[i]\n            elif ratio >= 0.1 and ratio < 0.3:\n                priorities[i] = 0.5 * item / bins[i]\n            elif ratio >= 0.3 and ratio < 0.5:\n                priorities[i] = 0.7 * item / bins[i]\n            elif ratio >= 0.5 and ratio < 0.7:\n                priorities[i] = 0.8 * item / bins[i]\n            elif ratio >= 0.7 and ratio < 0.9:\n                priorities[i] = 0.9 * item / bins[i]\n            else:\n                priorities[i] = 1.0 * item / bins[i]\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:35:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.2:\n                priorities[i] = 0.2\n            elif ratio >= 0.2 and ratio < 0.4:\n                priorities[i] = 0.4\n            elif ratio >= 0.4 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        elif item < bins[i] * 0.2:\n            priorities[i] = item / bins[i]\n        elif item >= bins[i] * 0.8:\n            priorities[i] = (bins[i] - item) / bins[i]\n        else:\n            priorities[i] = 0.5 * item / bins[i]\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.3:\n                priorities[i] = ratio\n            elif ratio >= 0.3 and ratio < 0.6:\n                priorities[i] = 0.5 * ratio\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 0.7 * ratio + 0.3\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:35:57", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.2:\n                priorities[i] = 0.2\n            elif ratio >= 0.2 and ratio < 0.4:\n                priorities[i] = 0.4\n            elif ratio >= 0.4 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        elif item < bins[i] * 0.2:\n            priorities[i] = item / bins[i]\n        elif item >= bins[i] * 0.8:\n            priorities[i] = (bins[i] - item) / bins[i]\n        else:\n            priorities[i] = 0.5 * item / bins[i]\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            priority = 0\n            for j in range(1, 6):\n                if item >= bins[i] * (j/10) and item < bins[i] * ((j+1)/10):\n                    priority = j/10\n                    break\n            priorities[i] = priority\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:35:59", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.2:\n                priorities[i] = 0.2\n            elif ratio >= 0.2 and ratio < 0.4:\n                priorities[i] = 0.4\n            elif ratio >= 0.4 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        elif item < bins[i] * 0.2:\n            priorities[i] = item / bins[i]\n        elif item >= bins[i] * 0.8:\n            priorities[i] = (bins[i] - item) / bins[i]\n        else:\n            priorities[i] = 0.5 * item / bins[i]\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        elif item < bins[i] * 0.2:\n            priorities[i] = item / bins[i]\n        elif item >= bins[i] * 0.8:\n            priorities[i] = (bins[i] - item) / bins[i]\n        elif bins[i] % 2 == 0:\n            priorities[i] = 0.7\n        else:\n            priorities[i] = 0.5\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:36:09", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.5)))\n        elif ratio >= 0.5 and ratio < 1:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.75)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.25)))\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.3))) + 0.1\n        elif ratio >= 0.3 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.45))) + 0.2\n        elif ratio >= 0.6 and ratio < 1:\n            priorities[i] = 1 / (1 + np.exp(-3 * (ratio - 0.8))) + 0.3\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.25))) + 0.4\n            \n        if i % 3 == 0:\n            priorities[i] += 0.5\n        elif i % 3 == 1:\n            priorities[i] -= 0.3\n        else:\n            priorities[i] += 0.1\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.2))) + 0.2\n        elif ratio >= 0.2 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-7 * (ratio - 0.35))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.65))) + 0.4\n        elif ratio >= 0.8 and ratio < 1:\n            priorities[i] = 1 / (1 + np.exp(-3 * (ratio - 0.9))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.25))) + 0.6\n            \n        if i % 4 == 0:\n            priorities[i] += 0.6\n        elif i % 4 == 1:\n            priorities[i] -= 0.4\n        elif i % 4 == 2:\n            priorities[i] += 0.2\n        else:\n            priorities[i] -= 0.2\n        \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:36:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.5)))\n        elif ratio >= 0.5 and ratio < 1:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.75)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.25)))\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.3))) + 0.1\n        elif ratio >= 0.3 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.45))) + 0.2\n        elif ratio >= 0.6 and ratio < 1:\n            priorities[i] = 1 / (1 + np.exp(-3 * (ratio - 0.8))) + 0.3\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.25))) + 0.4\n            \n        if i % 3 == 0:\n            priorities[i] += 0.5\n        elif i % 3 == 1:\n            priorities[i] -= 0.3\n        else:\n            priorities[i] += 0.1\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.2))) + 0.15\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-7 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.4 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.55))) + 0.4\n        elif ratio >= 0.7 and ratio < 1:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.85))) + 0.25\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.25))) + 0.2\n            \n        if i % 4 == 0:\n            priorities[i] += 0.3\n        elif i % 4 == 1:\n            priorities[i] -= 0.2\n        elif i % 4 == 2:\n            priorities[i] += 0.1\n        else:\n            priorities[i] -= 0.1\n        \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:36:17", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.5)))\n        elif ratio >= 0.5 and ratio < 1:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.75)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.25)))\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.3))) + 0.1\n        elif ratio >= 0.3 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.45))) + 0.2\n        elif ratio >= 0.6 and ratio < 1:\n            priorities[i] = 1 / (1 + np.exp(-3 * (ratio - 0.8))) + 0.3\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.25))) + 0.4\n            \n        if i % 3 == 0:\n            priorities[i] += 0.5\n        elif i % 3 == 1:\n            priorities[i] -= 0.3\n        else:\n            priorities[i] += 0.1\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.2))) + 0.1\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.3))) + 0.2\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-6 * (ratio - 0.5))) + 0.3\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.7))) + 0.4\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.9))) + 0.5\n            \n        if i % 5 == 0:\n            priorities[i] += 0.4\n        elif i % 5 == 1:\n            priorities[i] -= 0.2\n        elif i % 5 == 2:\n            priorities[i] += 0.1\n        elif i % 5 == 3:\n            priorities[i] -= 0.3\n        else:\n            priorities[i] += 0.2\n        \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:36:21", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.5)))\n        elif ratio >= 0.5 and ratio < 1:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.75)))\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.25)))\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.3))) + 0.1\n        elif ratio >= 0.3 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.45))) + 0.2\n        elif ratio >= 0.6 and ratio < 1:\n            priorities[i] = 1 / (1 + np.exp(-3 * (ratio - 0.8))) + 0.3\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1.25))) + 0.4\n            \n        if i % 3 == 0:\n            priorities[i] += 0.5\n        elif i % 3 == 1:\n            priorities[i] -= 0.3\n        else:\n            priorities[i] += 0.1\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.2))) + 0.2\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.3))) + 0.4\n        elif ratio >= 0.4 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.55))) + 0.6\n        elif ratio >= 0.7 and ratio < 1:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.9))) + 0.8\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1.2))) + 1.0\n            \n        if i % 4 == 0:\n            priorities[i] += 0.3\n        elif i % 4 == 1:\n            priorities[i] -= 0.2\n        elif i % 4 == 2:\n            priorities[i] += 0.1\n        else:\n            priorities[i] -= 0.1\n        \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:36:33", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    priorities[index] = 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Ultimate version of priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                priorities[index] = priority if priority > 0 else 0\n            else:\n                priorities[index] = 0.1 * (item - bin_capacity)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    priorities[index] = 0.5\n            else:\n                if bin_capacity > 0:\n                    priority = 1 / bin_capacity\n                    priorities[index] = priority if priority > 0 else 0.1\n                else:\n                    priorities[index] = 0.2 * item\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:36:36", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    priorities[index] = 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Ultimate version of priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                priorities[index] = priority if priority > 0 else 0\n            else:\n                priorities[index] = 0.1 * (item - bin_capacity)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    priorities[index] = 0.5\n            else:\n                if bin_capacity < 0:\n                    priorities[index] = 0.1\n                else:\n                    priorities[index] = 0.2\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:36:39", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    priorities[index] = 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Ultimate version of priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                priorities[index] = priority if priority > 0 else 0\n            else:\n                priorities[index] = 0.1 * (item - bin_capacity)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 2:\n                    priorities[i] = 0.8\n                elif priority > 1:\n                    priorities[i] = 0.6\n                else:\n                    priorities[i] = 0.4\n            else:\n                for j in range(i, len(bins)):\n                    if bins[j] - item > 0:\n                        priorities[j] = 0.5 * (bins[j] - item)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:36:41", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    priorities[index] = 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Ultimate version of priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                priorities[index] = priority if priority > 0 else 0\n            else:\n                priorities[index] = 0.1 * (item - bin_capacity)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:36:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.2:\n                priorities[i] = item / bins[i]\n            elif item >= bins[i] * 0.7:\n                priorities[i] = 0.5\n            else:\n                total = item + bins[i]\n                priorities[i] = (total ** 2) / (4 * bins[i] * item)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        ratio = item / bins[i]\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if ratio < 0.3:\n                priorities[i] = 0.3\n            elif ratio >= 0.3 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        ratio = item / bins[i]\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if ratio < 0.2:\n                priorities[i] = ratio * 0.1\n            elif ratio >= 0.2 and ratio < 0.4:\n                priorities[i] = ratio * 0.5\n            elif ratio >= 0.4 and ratio < 0.6:\n                priorities[i] = ratio * 0.8\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = ratio * 0.9\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:36:55", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.2:\n                priorities[i] = item / bins[i]\n            elif item >= bins[i] * 0.7:\n                priorities[i] = 0.5\n            else:\n                total = item + bins[i]\n                priorities[i] = (total ** 2) / (4 * bins[i] * item)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        ratio = item / bins[i]\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if ratio < 0.3:\n                priorities[i] = 0.3\n            elif ratio >= 0.3 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        ratio = item / bins[i]\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if ratio < 0.1:\n                priorities[i] = 0.2\n            elif ratio >= 0.1 and ratio < 0.2:\n                priorities[i] = 0.4\n            elif ratio >= 0.2 and ratio < 0.3:\n                priorities[i] = 0.6\n            elif ratio >= 0.3 and ratio < 0.4:\n                priorities[i] = 0.7\n            elif ratio >= 0.4 and ratio < 0.5:\n                priorities[i] = 0.8\n            elif ratio >= 0.5 and ratio < 0.6:\n                priorities[i] = 0.85\n            elif ratio >= 0.6 and ratio < 0.7:\n                priorities[i] = 0.9\n            elif ratio >= 0.7 and ratio < 0.8:\n                priorities[i] = 0.92\n            elif ratio >= 0.8 and ratio < 0.9:\n                priorities[i] = 0.95\n            else:\n                priorities[i] = 0.98\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:36:57", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.2:\n                priorities[i] = item / bins[i]\n            elif item >= bins[i] * 0.7:\n                priorities[i] = 0.5\n            else:\n                total = item + bins[i]\n                priorities[i] = (total ** 2) / (4 * bins[i] * item)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        ratio = item / bins[i]\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if ratio < 0.3:\n                priorities[i] = 0.3\n            elif ratio >= 0.3 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        ratio = item / bins[i]\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if ratio < 0.2:\n                priorities[i] = 0.2\n            elif ratio >= 0.2 and ratio < 0.4:\n                priorities[i] = 0.4\n            elif ratio >= 0.4 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:37:00", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.2:\n                priorities[i] = item / bins[i]\n            elif item >= bins[i] * 0.7:\n                priorities[i] = 0.5\n            else:\n                total = item + bins[i]\n                priorities[i] = (total ** 2) / (4 * bins[i] * item)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        ratio = item / bins[i]\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if ratio < 0.3:\n                priorities[i] = 0.3\n            elif ratio >= 0.3 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.3:\n                priorities[i] = (1 - ratio) + (bins[i] / item)\n            elif ratio >= 0.3 and ratio < 0.6:\n                priorities[i] = (1 - ratio) * 0.5\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = (1 - ratio) * 0.8\n            else:\n                total = item + bins[i]\n                priorities[i] = (total ** 2) / (4 * bins[i] * item)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:37:09", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 1.0:\n                    priorities[index] = 1.0\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.8\n                else:\n                    priorities[index] = 0.6\n            else:\n                priorities[index] = 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            priority = 1 / remaining_capacity\n            priorities[index] = priority if priority > 0 else 0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 1.0:\n                    priorities[index] = 1.0\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.8\n                elif priority >= 0.2 and priority < 0.5:\n                    priorities[index] = 0.5\n                else:\n                    priorities[index] = 0.3\n            else:\n                priorities[index] = 0.1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:37:11", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 1.0:\n                    priorities[index] = 1.0\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.8\n                else:\n                    priorities[index] = 0.6\n            else:\n                priorities[index] = 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            priority = 1 / remaining_capacity\n            priorities[index] = priority if priority > 0 else 0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = (max_capacity - remaining_capacity) / max_capacity\n                priorities[index] = min(1.0, max(0, priority))\n            else:\n                priorities[index] = 0.2\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:37:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 1.0:\n                    priorities[index] = 1.0\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.8\n                else:\n                    priorities[index] = 0.6\n            else:\n                priorities[index] = 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            priority = 1 / remaining_capacity\n            priorities[index] = priority if priority > 0 else 0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > bin_capacity * 0.7:\n                priorities[index] = 0.9\n            elif remaining_capacity > bin_capacity * 0.4:\n                priorities[index] = 0.7\n            else:\n                priority = 1 / remaining_capacity\n                priorities[index] = priority if priority > 0 else 0\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:37:16", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 1.0:\n                    priorities[index] = 1.0\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.8\n                else:\n                    priorities[index] = 0.6\n            else:\n                priorities[index] = 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            priority = 1 / remaining_capacity\n            priorities[index] = priority if priority > 0 else 0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 1.0:\n                    priorities[index] = 1.0\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.8\n                else:\n                    priorities[index] = 0.6\n            else:\n                priorities[index] = 0.3\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = 1.0\n        if priorities[i] == min_priority:\n            priorities[i] = 0.0\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:37:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.1:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.1 and ratios[i] < 0.3:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.3 and ratios[i] < 0.5:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.5 and ratios[i] < 0.7:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.1:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.1 and ratios[i] < 0.3:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.3 and ratios[i] < 0.5:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.5 and ratios[i] < 0.7:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.1:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.1 and ratios[i] < 0.3:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.3 and ratios[i] < 0.5:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.5 and ratios[i] < 0.7:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            if item > bins[i]:\n                priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n            else:\n                priorities[i] = np.arccos(np.abs(item - bins[i]))\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:37:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.1:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.1 and ratios[i] < 0.3:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.3 and ratios[i] < 0.5:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.5 and ratios[i] < 0.7:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.1:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.1 and ratios[i] < 0.3:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.3 and ratios[i] < 0.5:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.5 and ratios[i] < 0.7:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.1:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.1 and ratios[i] < 0.3:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.3 and ratios[i] < 0.5:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.5 and ratios[i] < 0.7:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            if item > bins[i]:\n                priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n            else:\n                priorities[i] = np.sinh(np.exp(ratios[i])) * np.cosh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:37:34", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.1:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.1 and ratios[i] < 0.3:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.3 and ratios[i] < 0.5:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.5 and ratios[i] < 0.7:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.1:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.1 and ratios[i] < 0.3:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.3 and ratios[i] < 0.5:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.5 and ratios[i] < 0.7:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.15:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2) * np.sqrt(item) / np.sqrt(bins[i])\n        elif ratios[i] >= 0.15 and ratios[i] < 0.35:\n            priorities[i] = np.tan(item) + np.tan(bins[i]) + np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.35 and ratios[i] < 0.55:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i])) * np.cosh(np.exp(ratios[i]))\n        elif ratios[i] >= 0.55 and ratios[i] < 0.75:\n            priorities[i] = np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1) + np.cos(item) * np.sin(bins[i])\n        else:\n            priorities[i] = np.sinh(ratios[i]) / np.cosh(ratios[i])**2\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:37:37", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.1:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.1 and ratios[i] < 0.3:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.3 and ratios[i] < 0.5:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.5 and ratios[i] < 0.7:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.1:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.1 and ratios[i] < 0.3:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.3 and ratios[i] < 0.5:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.5 and ratios[i] < 0.7:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2) + np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1) * np.arctan(np.sqrt(item * bins[i]))\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1) + np.sin(item) * np.cos(bins[i])\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.tanh(np.arcsin(np.sqrt(item) + np.sqrt(bins[i]))) + np.e * np.arcsin(ratios[i])\n        else:\n            priorities[i] = np.arccos(np.tan(item - bins[i]) / np.pi * np.exp(ratios[i]))\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:37:56", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.2))) + 0.1\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.3))) + 0.2\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-6 * (ratio - 0.5))) + 0.3\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.7))) + 0.4\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.9))) + 0.5\n            \n        if i % 5 == 0:\n            priorities[i] += 0.4\n        elif i % 5 == 1:\n            priorities[i] -= 0.2\n        elif i % 5 == 2:\n            priorities[i] += 0.1\n        elif i % 5 == 3:\n            priorities[i] -= 0.3\n        else:\n            priorities[i] += 0.2\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.2))) + 0.1\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.3))) + 0.2\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-6 * (ratio - 0.5))) + 0.3\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.7))) + 0.4\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.9))) + 0.5\n            \n        if i % 5 == 0:\n            priorities[i] += 0.4\n        elif i % 5 == 1:\n            priorities[i] -= 0.2\n        elif i % 5 == 2:\n            priorities[i] += 0.1\n        elif i % 5 == 3:\n            priorities[i] -= 0.3\n        else:\n            priorities[i] += 0.2\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if i % 2 == 0:\n            if ratio < 0.3:\n                priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.1\n            elif ratio >= 0.3 and ratio < 0.6:\n                priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.5))) + 0.3\n            else:\n                priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            if ratio < 0.2:\n                priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.2))) + 0.2\n            elif ratio >= 0.2 and ratio < 0.4:\n                priorities[i] = 1 / (1 + np.exp(-6 * (ratio - 0.3))) + 0.4\n            elif ratio >= 0.4 and ratio < 0.6:\n                priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.5))) + 0.6\n            else:\n                priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.7))) + 0.8\n                \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:37:59", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.2))) + 0.1\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.3))) + 0.2\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-6 * (ratio - 0.5))) + 0.3\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.7))) + 0.4\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.9))) + 0.5\n            \n        if i % 5 == 0:\n            priorities[i] += 0.4\n        elif i % 5 == 1:\n            priorities[i] -= 0.2\n        elif i % 5 == 2:\n            priorities[i] += 0.1\n        elif i % 5 == 3:\n            priorities[i] -= 0.3\n        else:\n            priorities[i] += 0.2\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.2))) + 0.1\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.3))) + 0.2\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-6 * (ratio - 0.5))) + 0.3\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.7))) + 0.4\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.9))) + 0.5\n            \n        if i % 5 == 0:\n            priorities[i] += 0.4\n        elif i % 5 == 1:\n            priorities[i] -= 0.2\n        elif i % 5 == 2:\n            priorities[i] += 0.1\n        elif i % 5 == 3:\n            priorities[i] -= 0.3\n        else:\n            priorities[i] += 0.2\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-20 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-12 * (ratio - 0.2))) + 0.2\n        elif ratio >= 0.3 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.4))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.3\n        elif i % 4 == 1:\n            priorities[i] -= 0.15\n        elif i % 4 == 2:\n            priorities[i] += 0.2\n        else:\n            priorities[i] -= 0.25\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:38:04", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.2))) + 0.1\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.3))) + 0.2\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-6 * (ratio - 0.5))) + 0.3\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.7))) + 0.4\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.9))) + 0.5\n            \n        if i % 5 == 0:\n            priorities[i] += 0.4\n        elif i % 5 == 1:\n            priorities[i] -= 0.2\n        elif i % 5 == 2:\n            priorities[i] += 0.1\n        elif i % 5 == 3:\n            priorities[i] -= 0.3\n        else:\n            priorities[i] += 0.2\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.2))) + 0.1\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.3))) + 0.2\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-6 * (ratio - 0.5))) + 0.3\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.7))) + 0.4\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.9))) + 0.5\n            \n        if i % 5 == 0:\n            priorities[i] += 0.4\n        elif i % 5 == 1:\n            priorities[i] -= 0.2\n        elif i % 5 == 2:\n            priorities[i] += 0.1\n        elif i % 5 == 3:\n            priorities[i] -= 0.3\n        else:\n            priorities[i] += 0.2\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.2))) + 0.1\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.3))) + 0.2\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-6 * (ratio - 0.5))) + 0.3\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.7))) + 0.4\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.9))) + 0.5\n            \n        if i % 5 == 0:\n            priorities[i] += 0.4\n        elif i % 5 == 1:\n            priorities[i] -= 0.2\n        elif i % 5 == 2:\n            priorities[i] += 0.1\n        elif i % 5 == 3:\n            priorities[i] -= 0.3\n        else:\n            priorities[i] += 0.2\n        \n        if i > len(bins) / 2:\n            priorities[i] *= 1.5\n        elif i % 3 == 0:\n            priorities[i] -= 0.4\n        elif i % 3 == 1:\n            priorities[i] += 0.3\n        else:\n            priorities[i] *= 1.2\n        \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:38:08", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.2))) + 0.1\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.3))) + 0.2\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-6 * (ratio - 0.5))) + 0.3\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.7))) + 0.4\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.9))) + 0.5\n            \n        if i % 5 == 0:\n            priorities[i] += 0.4\n        elif i % 5 == 1:\n            priorities[i] -= 0.2\n        elif i % 5 == 2:\n            priorities[i] += 0.1\n        elif i % 5 == 3:\n            priorities[i] -= 0.3\n        else:\n            priorities[i] += 0.2\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.2))) + 0.1\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.3))) + 0.2\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-6 * (ratio - 0.5))) + 0.3\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.7))) + 0.4\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.9))) + 0.5\n            \n        if i % 5 == 0:\n            priorities[i] += 0.4\n        elif i % 5 == 1:\n            priorities[i] -= 0.2\n        elif i % 5 == 2:\n            priorities[i] += 0.1\n        elif i % 5 == 3:\n            priorities[i] -= 0.3\n        else:\n            priorities[i] += 0.2\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.2))) + 0.1\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.3))) + 0.2\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-6 * (ratio - 0.5))) + 0.3\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.7))) + 0.4\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.9))) + 0.5\n            \n        for j in range(1, 6):\n            if i % j == 0:\n                priorities[i] += 0.1 * j\n            else:\n                priorities[i] -= 0.1 * j\n        \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:38:21", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.1:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.1 and ratios[i] < 0.3:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.3 and ratios[i] < 0.5:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.5 and ratios[i] < 0.7:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.1:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.1 and ratios[i] < 0.3:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.3 and ratios[i] < 0.5:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.5 and ratios[i] < 0.7:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:38:24", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.1:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.1 and ratios[i] < 0.3:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.3 and ratios[i] < 0.5:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.5 and ratios[i] < 0.7:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.1:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.1 and ratios[i] < 0.3:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.3 and ratios[i] < 0.5:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.5 and ratios[i] < 0.7:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2) + np.log(item) + np.log(bins[i])\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) * np.tan(bins[i]) + np.sqrt(item*bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(item*bins[i]) * np.sqrt(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.exp(np.arctan(item) + np.arctan(bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1) + np.sqrt(ratios[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:38:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.1:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.1 and ratios[i] < 0.3:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.3 and ratios[i] < 0.5:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.5 and ratios[i] < 0.7:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.1:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.1 and ratios[i] < 0.3:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.3 and ratios[i] < 0.5:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.5 and ratios[i] < 0.7:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.1:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.1 and ratios[i] < 0.3:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.3 and ratios[i] < 0.5:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.5 and ratios[i] < 0.7:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:38:31", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.1:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.1 and ratios[i] < 0.3:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.3 and ratios[i] < 0.5:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.5 and ratios[i] < 0.7:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.1:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.1 and ratios[i] < 0.3:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.3 and ratios[i] < 0.5:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.5 and ratios[i] < 0.7:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "import numpy as np\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.1:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.1 and ratios[i] < 0.3:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.3 and ratios[i] < 0.5:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.5 and ratios[i] < 0.7:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    normalized_priorities = priorities / np.sum(priorities)  # Normalizing priorities\n    \n    weighted_priorities = np.zeros_like(bins)\n    for j in range(len(bins)):\n        weighted_priorities[j] = normalized_priorities[j] * ratios[j]  # Applying weights based on ratios\n    \n    return weighted_priorities", "strategy": []}
{"timestamp": "2025-04-27 06:38:47", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > bin_capacity * 0.7:\n                priorities[index] = 0.9\n            elif remaining_capacity > bin_capacity * 0.4:\n                priorities[index] = 0.7\n            else:\n                priority = 1 / remaining_capacity\n                priorities[index] = priority if priority > 0 else 0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        for i in range(index):\n                            if bins[i] >= item:\n                                priorities[index] = 0.6\n                                break\n                        else:\n                            priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:38:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > bin_capacity * 0.7:\n                priorities[index] = 0.9\n            elif remaining_capacity > bin_capacity * 0.4:\n                priorities[index] = 0.7\n            else:\n                priority = 1 / remaining_capacity\n                priorities[index] = priority if priority > 0 else 0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                if item > bin_capacity * 2:\n                    priorities[index] = 0.1\n                else:\n                    priority = 1 / remaining_capacity\n                    if priority < 0.2:\n                        priorities[index] = 0.7\n                    elif priority >= 0.2 and priority < 0.5:\n                        priorities[index] = 0.5\n                    elif priority >= 0.5 and priority < 1.0:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.0\n            else:\n                priorities[index] = 0.0\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:38:53", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > bin_capacity * 0.7:\n                priorities[index] = 0.9\n            elif remaining_capacity > bin_capacity * 0.4:\n                priorities[index] = 0.7\n            else:\n                priority = 1 / remaining_capacity\n                priorities[index] = priority if priority > 0 else 0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n                    \n                if priorities[index] == 0.0:\n                    for i in range(index+1, len(bins)):\n                        if bins[i] >= item:\n                            priorities[i] = 0.6\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:38:57", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > bin_capacity * 0.7:\n                priorities[index] = 0.9\n            elif remaining_capacity > bin_capacity * 0.4:\n                priorities[index] = 0.7\n            else:\n                priority = 1 / remaining_capacity\n                priorities[index] = priority if priority > 0 else 0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n        if item % 2 == 0:\n            priorities[index] += 0.1\n        else:\n            priorities[index] -= 0.1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:39:04", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n\n    if item > max_bin_capacity * 0.75:\n        for j in range(len(bins)):\n            if bins[j] == max_bin_capacity:\n                priorities[j] *= 1.5\n    elif item < min_bin_capacity * 0.25:\n        for k in range(len(bins)):\n            if bins[k] == min_bin_capacity:\n                priorities[k] *= 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n\n    if item > max_bin_capacity * 0.75:\n        for j in range(len(bins)):\n            if bins[j] == max_bin_capacity:\n                priorities[j] *= 1.5\n    elif item < min_bin_capacity * 0.25:\n        for k in range(len(bins)):\n            if bins[k] == min_bin_capacity:\n                priorities[k] *= 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i] * 0.75:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    for j in range(len(bins)):\n        if priorities[j] < 0.5:\n            priorities[j] *= 0.75\n        elif priorities[j] < 0.75:\n            priorities[j] *= 1.25\n        else:\n            priorities[j] = 1.0\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:39:07", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n\n    if item > max_bin_capacity * 0.75:\n        for j in range(len(bins)):\n            if bins[j] == max_bin_capacity:\n                priorities[j] *= 1.5\n    elif item < min_bin_capacity * 0.25:\n        for k in range(len(bins)):\n            if bins[k] == min_bin_capacity:\n                priorities[k] *= 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n\n    if item > max_bin_capacity * 0.75:\n        for j in range(len(bins)):\n            if bins[j] == max_bin_capacity:\n                priorities[j] *= 1.5\n    elif item < min_bin_capacity * 0.25:\n        for k in range(len(bins)):\n            if bins[k] == min_bin_capacity:\n                priorities[k] *= 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n\n    if item > max_bin_capacity * 0.75:\n        for j in range(len(bins)):\n            if bins[j] == max_bin_capacity:\n                priorities[j] *= 1.5\n    elif item < min_bin_capacity * 0.25:\n        for k in range(len(bins)):\n            if bins[k] == min_bin_capacity:\n                priorities[k] *= 0.5\n    \n    sum_priorities = np.sum(priorities)\n    if sum_priorities > 1.5:\n        priorities /= sum_priorities\n    \n    return priorities\n", "strategy": []}
{"timestamp": "2025-04-27 06:39:10", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n\n    if item > max_bin_capacity * 0.75:\n        for j in range(len(bins)):\n            if bins[j] == max_bin_capacity:\n                priorities[j] *= 1.5\n    elif item < min_bin_capacity * 0.25:\n        for k in range(len(bins)):\n            if bins[k] == min_bin_capacity:\n                priorities[k] *= 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n\n    if item > max_bin_capacity * 0.75:\n        for j in range(len(bins)):\n            if bins[j] == max_bin_capacity:\n                priorities[j] *= 1.5\n    elif item < min_bin_capacity * 0.25:\n        for k in range(len(bins)):\n            if bins[k] == min_bin_capacity:\n                priorities[k] *= 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n\n    if item > max_bin_capacity * 0.75:\n        for j in range(len(bins)):\n            if bins[j] == max_bin_capacity:\n                priorities[j] *= 1.5\n    elif item < min_bin_capacity * 0.25:\n        for k in range(len(bins)):\n            if bins[k] == min_bin_capacity:\n                priorities[k] *= 0.5\n\n    sum_priorities = np.sum(priorities)\n    \n    if sum_priorities > 2.0:\n        priorities = priorities / sum_priorities\n    \n    for l in range(len(bins)):\n        if bins[l] < item:\n            priorities[l] = 0.0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:39:12", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n\n    if item > max_bin_capacity * 0.75:\n        for j in range(len(bins)):\n            if bins[j] == max_bin_capacity:\n                priorities[j] *= 1.5\n    elif item < min_bin_capacity * 0.25:\n        for k in range(len(bins)):\n            if bins[k] == min_bin_capacity:\n                priorities[k] *= 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n\n    if item > max_bin_capacity * 0.75:\n        for j in range(len(bins)):\n            if bins[j] == max_bin_capacity:\n                priorities[j] *= 1.5\n    elif item < min_bin_capacity * 0.25:\n        for k in range(len(bins)):\n            if bins[k] == min_bin_capacity:\n                priorities[k] *= 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n            \n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n    \n    if item > max_bin_capacity * 0.75:\n        for j in range(len(bins)):\n            if bins[j] == max_bin_capacity:\n                priorities[j] *= 1.5\n    elif item < min_bin_capacity * 0.25:\n        for k in range(len(bins)):\n            if bins[k] == min_bin_capacity:\n                priorities[k] *= 0.5\n                \n    if np.sum(bins) > 1000:\n        priorities = priorities * 1.2\n    elif np.sum(bins) < 500:\n        priorities = priorities * 0.8\n    \n    for m in range(len(bins)):\n        if bins[m] % 2 == 0:\n            priorities[m] = priorities[m] * 1.1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:39:22", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.2:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.2 and utilization_ratio < 0.4:\n                priority_score = 0.8 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.4 and utilization_ratio < 0.6:\n                priority_score = 0.6 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.4 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.2 / (1 + utilization_ratio)\n                \n            if bins[i] >= 10:\n                priority_score *= 1.2\n            elif bins[i] >= 5:\n                priority_score *= 1.1\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.2:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.2 and utilization_ratio < 0.4:\n                priority_score = 0.8 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.4 and utilization_ratio < 0.6:\n                priority_score = 0.6 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.4 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.2 / (1 + utilization_ratio)\n                \n            if bins[i] >= 10:\n                priority_score *= 1.2\n            elif bins[i] >= 5:\n                priority_score *= 1.1\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.5:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.5 and utilization_ratio < 0.7:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.7 and utilization_ratio < 0.9:\n                priority_score = 0.1 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.05 / (1 + utilization_ratio)\n                \n            if bins[i] >= 15:\n                priority_score *= 1.3\n            elif bins[i] >= 8:\n                priority_score *= 1.2\n            elif bins[i] >= 5:\n                priority_score *= 1.1\n                \n            priorities[i] = priority_score\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:39:26", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.2:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.2 and utilization_ratio < 0.4:\n                priority_score = 0.8 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.4 and utilization_ratio < 0.6:\n                priority_score = 0.6 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.4 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.2 / (1 + utilization_ratio)\n                \n            if bins[i] >= 10:\n                priority_score *= 1.2\n            elif bins[i] >= 5:\n                priority_score *= 1.1\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.2:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.2 and utilization_ratio < 0.4:\n                priority_score = 0.8 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.4 and utilization_ratio < 0.6:\n                priority_score = 0.6 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.4 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.2 / (1 + utilization_ratio)\n                \n            if bins[i] >= 10:\n                priority_score *= 1.2\n            elif bins[i] >= 5:\n                priority_score *= 1.1\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.8 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.5:\n                priority_score = 0.6 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.5 and utilization_ratio < 0.7:\n                priority_score = 0.4 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.7 and utilization_ratio < 0.9:\n                priority_score = 0.2 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n            \n            if bins[i] >= 12:\n                priority_score *= 1.3\n            elif bins[i] >= 8:\n                priority_score *= 1.2\n            elif bins[i] >= 5:\n                priority_score *= 1.1\n                \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:39:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.2:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.2 and utilization_ratio < 0.4:\n                priority_score = 0.8 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.4 and utilization_ratio < 0.6:\n                priority_score = 0.6 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.4 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.2 / (1 + utilization_ratio)\n                \n            if bins[i] >= 10:\n                priority_score *= 1.2\n            elif bins[i] >= 5:\n                priority_score *= 1.1\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.2:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.2 and utilization_ratio < 0.4:\n                priority_score = 0.8 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.4 and utilization_ratio < 0.6:\n                priority_score = 0.6 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.4 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.2 / (1 + utilization_ratio)\n                \n            if bins[i] >= 10:\n                priority_score *= 1.2\n            elif bins[i] >= 5:\n                priority_score *= 1.1\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Further improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n\n            if utilization_ratio < 0.2:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.2 and utilization_ratio < 0.4:\n                priority_score = 0.8 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.4 and utilization_ratio < 0.6:\n                priority_score = 0.6 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.4 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.2 / (1 + utilization_ratio)\n\n            if bins[i] >= 10:\n                priority_score *= 1.2\n            elif bins[i] >= 5:\n                priority_score *= 1.1\n\n            if bins[i] % 2 == 0:  # Check if bin capacity is even\n                priority_score += 0.1\n\n            if bins[i] % 5 == 0:  # Check if bin capacity is divisible by 5\n                priority_score += 0.2\n\n            if item % 2 == 0:  # Check if item size is even\n                priority_score += 0.05\n\n            if item % 3 == 0:  # Check if item size is divisible by 3\n                priority_score += 0.1\n\n            priorities[i] = priority_score\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:39:34", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.2:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.2 and utilization_ratio < 0.4:\n                priority_score = 0.8 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.4 and utilization_ratio < 0.6:\n                priority_score = 0.6 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.4 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.2 / (1 + utilization_ratio)\n                \n            if bins[i] >= 10:\n                priority_score *= 1.2\n            elif bins[i] >= 5:\n                priority_score *= 1.1\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.2:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.2 and utilization_ratio < 0.4:\n                priority_score = 0.8 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.4 and utilization_ratio < 0.6:\n                priority_score = 0.6 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.4 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.2 / (1 + utilization_ratio)\n                \n            if bins[i] >= 10:\n                priority_score *= 1.2\n            elif bins[i] >= 5:\n                priority_score *= 1.1\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.9 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.5:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.5 and utilization_ratio < 0.7:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.7 and utilization_ratio < 0.9:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if bins[i] >= 15:\n                priority_score *= 1.3\n            elif bins[i] >= 8:\n                priority_score *= 1.2\n            elif bins[i] >= 3:\n                priority_score *= 1.1\n                \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:39:44", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = 0.5\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.1\n            for j in range(2, int(bins[i] ** 0.5) + 1):\n                if bins[i] % j == 0:\n                    priorities[i] -= 0.1\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = 0.5\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n                if item % 2 == 0:\n                    priorities[i] += 0.2\n                else:\n                    priorities[i] -= 0.1\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n                if bins[i] % 2 == 0:\n                    priorities[i] += 0.3\n                else:\n                    priorities[i] -= 0.2\n            else:\n                priorities[i] = 0.5\n                for j in range(2, int(bins[i] ** 0.5) + 1):\n                    if bins[i] % j == 0:\n                        priorities[i] -= 0.1\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:39:47", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = 0.5\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.1\n            for j in range(2, int(bins[i] ** 0.5) + 1):\n                if bins[i] % j == 0:\n                    priorities[i] -= 0.1\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = 0.5\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] % 2 == 0:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i] - 0.1\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item - 0.2\n            else:\n                priorities[i] = 0.5\n            for j in range(2, int(bins[i] ** 0.5) + 1):\n                if bins[i] % j == 0:\n                    priorities[i] = priorities[i] / j\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:39:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = 0.5\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.1\n            for j in range(2, int(bins[i] ** 0.5) + 1):\n                if bins[i] % j == 0:\n                    priorities[i] -= 0.1\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = 0.5\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Another improved version of the priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = 0.5\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.1\n            for j in range(2, int(bins[i] ** 0.5) + 1):\n                if bins[i] % j == 0:\n                    priorities[i] -= 0.1\n            if item % 3 == 0:\n                priorities[i] *= 1.5\n            elif item % 5 == 0:\n                priorities[i] *= 0.5\n            elif item % 7 == 0:\n                priorities[i] *= 1.2\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:39:53", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = 0.5\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.1\n            for j in range(2, int(bins[i] ** 0.5) + 1):\n                if bins[i] % j == 0:\n                    priorities[i] -= 0.1\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = 0.5\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = 0.5\n            if item % bins[i] == 0:\n                priorities[i] += 0.1\n                for j in range(2, int(bins[i] ** 0.5) + 1):\n                    if bins[i] % j == 0:\n                        priorities[i] -= 0.05\n            else:\n                priorities[i] -= 0.1\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:40:02", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-20 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-12 * (ratio - 0.2))) + 0.2\n        elif ratio >= 0.3 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.4))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.3\n        elif i % 4 == 1:\n            priorities[i] -= 0.15\n        elif i % 4 == 2:\n            priorities[i] += 0.2\n        else:\n            priorities[i] -= 0.25\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-20 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-12 * (ratio - 0.2))) + 0.2\n        elif ratio >= 0.3 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.4))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.3\n        elif i % 4 == 1:\n            priorities[i] -= 0.15\n        elif i % 4 == 2:\n            priorities[i] += 0.2\n        else:\n            priorities[i] -= 0.25\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.25\n        elif i % 5 == 1:\n            priorities[i] -= 0.1\n        elif i % 5 == 2:\n            priorities[i] += 0.15\n        elif i % 5 == 3:\n            priorities[i] -= 0.2\n        else:\n            priorities[i] += 0.3\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:40:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-20 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-12 * (ratio - 0.2))) + 0.2\n        elif ratio >= 0.3 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.4))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.3\n        elif i % 4 == 1:\n            priorities[i] -= 0.15\n        elif i % 4 == 2:\n            priorities[i] += 0.2\n        else:\n            priorities[i] -= 0.25\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-20 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-12 * (ratio - 0.2))) + 0.2\n        elif ratio >= 0.3 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.4))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.3\n        elif i % 4 == 1:\n            priorities[i] -= 0.15\n        elif i % 4 == 2:\n            priorities[i] += 0.2\n        else:\n            priorities[i] -= 0.25\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-25 * (ratio - 0.2))) + 0.1\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.2\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.5))) + 0.3\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.7))) + 0.4\n        elif ratio >= 0.8 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-3 * (ratio - 0.9))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.4\n        elif i % 5 == 1:\n            priorities[i] -= 0.25\n        elif i % 5 == 2:\n            priorities[i] += 0.3\n        elif i % 5 == 3:\n            priorities[i] -= 0.2\n        else:\n            priorities[i] += 0.1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:40:09", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-20 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-12 * (ratio - 0.2))) + 0.2\n        elif ratio >= 0.3 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.4))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.3\n        elif i % 4 == 1:\n            priorities[i] -= 0.15\n        elif i % 4 == 2:\n            priorities[i] += 0.2\n        else:\n            priorities[i] -= 0.25\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-20 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-12 * (ratio - 0.2))) + 0.2\n        elif ratio >= 0.3 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.4))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.3\n        elif i % 4 == 1:\n            priorities[i] -= 0.15\n        elif i % 4 == 2:\n            priorities[i] += 0.2\n        else:\n            priorities[i] -= 0.25\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef complex_function(data: np.ndarray) -> np.ndarray:\n    output = np.zeros_like(data)\n\n    for i in range(len(data)):\n        if data[i] % 2 == 0:\n            output[i] = data[i] * 2\n        elif data[i] % 3 == 0:\n            output[i] = data[i] * 3\n        else:\n            output[i] = data[i]\n\n    for i in range(1, len(data) - 1):\n        if data[i] > data[i-1] and data[i] > data[i+1]:\n            output[i] += 10\n\n    return output\n```", "strategy": []}
{"timestamp": "2025-04-27 06:40:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-20 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-12 * (ratio - 0.2))) + 0.2\n        elif ratio >= 0.3 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.4))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.3\n        elif i % 4 == 1:\n            priorities[i] -= 0.15\n        elif i % 4 == 2:\n            priorities[i] += 0.2\n        else:\n            priorities[i] -= 0.25\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-20 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-12 * (ratio - 0.2))) + 0.2\n        elif ratio >= 0.3 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.4))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.3\n        elif i % 4 == 1:\n            priorities[i] -= 0.15\n        elif i % 4 == 2:\n            priorities[i] += 0.2\n        else:\n            priorities[i] -= 0.25\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-20 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-12 * (ratio - 0.2))) + 0.2\n        elif ratio >= 0.3 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.4))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.3\n        elif i % 4 == 1:\n            priorities[i] -= 0.15\n        elif i % 4 == 2:\n            priorities[i] += 0.2\n        else:\n            priorities[i] -= 0.25\n\n        if bins[i] > 10:\n            priorities[i] += 0.1\n        else:\n            priorities[i] -= 0.1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:40:24", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more advanced version of `priority_v1`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.1:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.1 and ratios[i] < 0.3:\n            priorities[i] = np.exp(np.tan(item)) - np.cbrt(bins[i])\n        elif ratios[i] >= 0.3 and ratios[i] < 0.5:\n            priorities[i] = np.log(np.abs(np.sin(item) + np.cos(bins[i])) + 1)\n        elif ratios[i] >= 0.5 and ratios[i] < 0.7:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i])) + np.cosh(np.tanh(ratios[i]))\n        else:\n            priorities[i] = np.tan(np.sinh(ratios[i])) * np.arccos(np.log(np.abs(item - bins[i]) + 1))\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:40:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:40:31", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.1:\n            priorities[i] = np.power(np.sin(item) * np.cos(bins[i]), 3)\n        elif ratios[i] >= 0.1 and ratios[i] < 0.3:\n            priorities[i] = np.tan(item) * np.tan(bins[i])\n        elif ratios[i] >= 0.3 and ratios[i] < 0.5:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 2)\n        elif ratios[i] >= 0.5 and ratios[i] < 0.7:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i] + 1))\n        elif ratios[i] >= 0.7 and ratios[i] < 0.9:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 2)\n        else:\n            priorities[i] = np.sinh(np.arcsin(np.sqrt(item))) + np.arctan(np.square(bins[i]))\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:40:34", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            if item < 10:\n                priorities[i] = np.log(np.exp(item) + np.exp(bins[i]))\n            elif item >= 10 and item < 20:\n                priorities[i] = np.cos(item) + np.sin(bins[i])\n            else:\n                priorities[i] = np.power(np.tanh(item) + np.tanh(bins[i]), 2)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:40:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0\n        elif item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if priorities[i] > 0.8:\n            priorities[i] += 0.2\n        elif priorities[i] > 0.5:\n            priorities[i] += 0.15\n        elif priorities[i] > 0.3:\n            priorities[i] += 0.1\n        else:\n            priorities[i] += 0.05\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n\n    if item > max_bin_capacity * 0.75:\n        for j in range(len(bins)):\n            if bins[j] == max_bin_capacity:\n                priorities[j] *= 1.5\n    elif item < min_bin_capacity * 0.25:\n        for k in range(len(bins)):\n            if bins[k] == min_bin_capacity:\n                priorities[k] *= 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n\n    if item > max_bin_capacity * 0.75:\n        for j in range(len(bins)):\n            if bins[j] == max_bin_capacity:\n                priorities[j] *= 1.5\n    elif item < min_bin_capacity * 0.25:\n        for k in range(len(bins)):\n            if bins[k] == min_bin_capacity:\n                priorities[k] *= 0.5\n\n    for m in range(len(bins)):\n        if bins[m] % 2 == 0:\n            priorities[m] += 0.1\n        elif bins[m] % 3 == 0:\n            priorities[m] += 0.2\n        else:\n            priorities[m] += 0.05\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:40:53", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0\n        elif item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if priorities[i] > 0.8:\n            priorities[i] += 0.2\n        elif priorities[i] > 0.5:\n            priorities[i] += 0.15\n        elif priorities[i] > 0.3:\n            priorities[i] += 0.1\n        else:\n            priorities[i] += 0.05\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n\n    if item > max_bin_capacity * 0.75:\n        for j in range(len(bins)):\n            if bins[j] == max_bin_capacity:\n                priorities[j] *= 1.5\n    elif item < min_bin_capacity * 0.25:\n        for k in range(len(bins)):\n            if bins[k] == min_bin_capacity:\n                priorities[k] *= 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    min_bin_capacity = np.min(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0\n        elif item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n            \n        if priorities[i] > 0.8:\n            priorities[i] += 0.2\n        elif priorities[i] > 0.5:\n            priorities[i] += 0.15\n        elif priorities[i] > 0.3:\n            priorities[i] += 0.1\n        else:\n            priorities[i] += 0.05\n                \n        if bins[i] == min_bin_capacity:\n            priorities[i] *= 1.2\n        elif bins[i] == max_bin_capacity:\n            priorities[i] *= 0.8\n        else:\n            priorities[i] *= 1.0\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:40:56", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0\n        elif item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if priorities[i] > 0.8:\n            priorities[i] += 0.2\n        elif priorities[i] > 0.5:\n            priorities[i] += 0.15\n        elif priorities[i] > 0.3:\n            priorities[i] += 0.1\n        else:\n            priorities[i] += 0.05\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n\n    if item > max_bin_capacity * 0.75:\n        for j in range(len(bins)):\n            if bins[j] == max_bin_capacity:\n                priorities[j] *= 1.5\n    elif item < min_bin_capacity * 0.25:\n        for k in range(len(bins)):\n            if bins[k] == min_bin_capacity:\n                priorities[k] *= 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n            \n        if priorities[i] > 0.5:\n            priorities[i] += 0.2\n        else:\n            priorities[i] += 0.1\n            \n        if bins[i] % 2 == 0:\n            priorities[i] += 0.3\n        else:\n            priorities[i] -= 0.1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:40:59", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0\n        elif item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if priorities[i] > 0.8:\n            priorities[i] += 0.2\n        elif priorities[i] > 0.5:\n            priorities[i] += 0.15\n        elif priorities[i] > 0.3:\n            priorities[i] += 0.1\n        else:\n            priorities[i] += 0.05\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n\n    if item > max_bin_capacity * 0.75:\n        for j in range(len(bins)):\n            if bins[j] == max_bin_capacity:\n                priorities[j] *= 1.5\n    elif item < min_bin_capacity * 0.25:\n        for k in range(len(bins)):\n            if bins[k] == min_bin_capacity:\n                priorities[k] *= 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    min_bin_capacity = np.min(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n    if item > max_bin_capacity * 0.75:\n        for j in range(len(bins)):\n            if bins[j] == max_bin_capacity:\n                priorities[j] *= 1.5\n    elif item < min_bin_capacity * 0.25:\n        for k in range(len(bins)):\n            if bins[k] == min_bin_capacity:\n                priorities[k] *= 0.5\n            \n    total_bin_capacity = np.sum(bins)\n    average_bin_capacity = total_bin_capacity / len(bins)\n\n    for l in range(len(bins)):\n        if bins[l] > average_bin_capacity:\n            priorities[l] += 0.2\n        elif bins[l] < average_bin_capacity:\n            priorities[l] -= 0.1\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:41:09", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    priorities[i] = item / bins[i] + 0.5\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    priorities[i] = item / bins[i] + 0.5\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    if bins[i] % 2 == 0:\n                        priorities[i] = 0.5\n                    else:\n                        priorities[i] = 0.25\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:41:11", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    priorities[i] = item / bins[i] + 0.5\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    priorities[i] = item / bins[i] + 0.5\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    if bins[i] > 2 * item:\n                        priorities[i] = item / bins[i] + 0.75\n                    else:\n                        priorities[i] = item / bins[i] + 0.25\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:41:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    priorities[i] = item / bins[i] + 0.5\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    priorities[i] = item / bins[i] + 0.5\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    if bins[i] % 2 == 0:\n                        priorities[i] = item / bins[i] + 0.2\n                    elif bins[i] % 3 == 0:\n                        priorities[i] = item / bins[i] + 0.3\n                    else:\n                        priorities[i] = item / bins[i] + 0.5\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:41:17", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    priorities[i] = item / bins[i] + 0.5\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    priorities[i] = item / bins[i] + 0.5\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    if bins[i] % item < 0.5:\n                        priorities[i] = item / bins[i] + 0.2\n                    elif bins[i] % item < 0.8:\n                        priorities[i] = 0.8 - item / bins[i]\n                    else:\n                        priorities[i] = bins[i] - item / bins[i] + 0.4\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:41:25", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.1\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i] + 0.05\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] == max_bin_capacity:\n            priorities[i] = 1.0\n        elif bins[i] == min_bin_capacity:\n            priorities[i] = 0.5\n        else:\n            priorities[i] = item / bins[i] + (max_bin_capacity - bins[i]) / max_bin_capacity\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:41:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.1\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i] + 0.05\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.1\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i] + 0.05\n            \n    sorted_priorities = sorted(priorities, reverse=True)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == sorted_priorities[0]:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == sorted_priorities[-1]:\n            priorities[i] = priorities[i] - 0.2\n        else:\n            priorities[i] = priorities[i] + 0.1\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:41:32", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.1\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i] + 0.05\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Advanced version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < 0.5 * bins[i]:\n            priorities[i] = item / bins[i]\n        elif item >= 0.5 * bins[i] and item < 0.8 * bins[i]:\n            priorities[i] = 0.8 * (item / bins[i])\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.2\n        else:\n            priorities[i] = priorities[i] + 0.1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:41:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.1\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i] + 0.05\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.1\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i] + 0.05\n        \n    for i in range(1, len(priorities)):\n        if priorities[i] > priorities[i-1]:\n            priorities[i] = priorities[i] + 0.05\n        elif priorities[i] < priorities[i-1]:\n            priorities[i] = priorities[i] - 0.05\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:41:51", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        elif item < bins[i] * 0.2:\n            priorities[i] = item / bins[i]\n        elif item >= bins[i] * 0.8:\n            priorities[i] = (bins[i] - item) / bins[i]\n        elif bins[i] % 2 == 0:\n            priorities[i] = 0.7\n        else:\n            priorities[i] = 0.5\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        ratio = item / bins[i]\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if ratio < 0.2:\n                priorities[i] = 0.2\n            elif ratio >= 0.2 and ratio < 0.4:\n                priorities[i] = 0.4\n            elif ratio >= 0.4 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        ratio = item / bins[i]\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if ratio < 0.1:\n                priorities[i] = 0.1\n            elif ratio >= 0.1 and ratio < 0.2:\n                priorities[i] = 0.2\n            elif ratio >= 0.2 and ratio < 0.3:\n                priorities[i] = 0.3\n            elif ratio >= 0.3 and ratio < 0.4:\n                priorities[i] = 0.4\n            elif ratio >= 0.4 and ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.7:\n                priorities[i] = 0.7\n            elif ratio >= 0.7 and ratio < 0.8:\n                priorities[i] = 0.8\n            elif ratio >= 0.8 and ratio < 0.9:\n                priorities[i] = 0.9\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:41:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        elif item < bins[i] * 0.2:\n            priorities[i] = item / bins[i]\n        elif item >= bins[i] * 0.8:\n            priorities[i] = (bins[i] - item) / bins[i]\n        elif bins[i] % 2 == 0:\n            priorities[i] = 0.7\n        else:\n            priorities[i] = 0.5\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        ratio = item / bins[i]\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if ratio < 0.2:\n                priorities[i] = 0.2\n            elif ratio >= 0.2 and ratio < 0.4:\n                priorities[i] = 0.4\n            elif ratio >= 0.4 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef prioritize(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        ratio = item / bins[i]\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if ratio < 0.2:\n                priorities[i] = 0.2\n            elif ratio >= 0.2 and ratio < 0.4:\n                priorities[i] = 0.4\n            elif ratio >= 0.4 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n                if bins[i] % 2 == 0:\n                    priorities[i] *= 1.1\n                if item > bins[i] / 2:\n                    priorities[i] *= 1.2\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:41:57", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        elif item < bins[i] * 0.2:\n            priorities[i] = item / bins[i]\n        elif item >= bins[i] * 0.8:\n            priorities[i] = (bins[i] - item) / bins[i]\n        elif bins[i] % 2 == 0:\n            priorities[i] = 0.7\n        else:\n            priorities[i] = 0.5\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        ratio = item / bins[i]\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if ratio < 0.2:\n                priorities[i] = 0.2\n            elif ratio >= 0.2 and ratio < 0.4:\n                priorities[i] = 0.4\n            elif ratio >= 0.4 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        ratio = item / bins[i]\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if ratio < 0.1:\n                priorities[i] = 0.1\n            elif ratio >= 0.1 and ratio < 0.2:\n                priorities[i] = 0.2\n            elif ratio >= 0.2 and ratio < 0.3:\n                priorities[i] = 0.3\n            elif ratio >= 0.3 and ratio < 0.4:\n                priorities[i] = 0.4\n            elif ratio >= 0.4 and ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.7:\n                priorities[i] = 0.7\n            elif ratio >= 0.7 and ratio < 0.8:\n                priorities[i] = 0.8\n            elif ratio >= 0.8 and ratio < 0.9:\n                priorities[i] = 0.9\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:42:00", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        elif item < bins[i] * 0.2:\n            priorities[i] = item / bins[i]\n        elif item >= bins[i] * 0.8:\n            priorities[i] = (bins[i] - item) / bins[i]\n        elif bins[i] % 2 == 0:\n            priorities[i] = 0.7\n        else:\n            priorities[i] = 0.5\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        ratio = item / bins[i]\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if ratio < 0.2:\n                priorities[i] = 0.2\n            elif ratio >= 0.2 and ratio < 0.4:\n                priorities[i] = 0.4\n            elif ratio >= 0.4 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.2:\n                priorities[i] = 0.2\n            elif 0.2 <= ratio < 0.4:\n                priorities[i] = 0.4\n            elif 0.4 <= ratio < 0.6:\n                priorities[i] = 0.6\n            elif 0.6 <= ratio < 0.8:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n                \n            if bins[i] % 3 == 0:\n                priorities[i] += 0.1\n            elif bins[i] % 5 == 0:\n                priorities[i] -= 0.1\n                \n            if (item + 10) > bins[i]:\n                priorities[i] *= 0.8\n                \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:42:09", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5  # Add a constant to increase priority\n            else:\n                priorities[i] = 2.0  # Highest priority if capacity exactly matches item size\n                break\n        \n        if i % 2 == 0:\n            priorities[i] *= 1.5  # Increase priority for every alternate bin\n        \n        if item % 2 == 0:\n            priorities[i] += 0.25  # Add extra priority for even-sized items\n        \n        if item > 5 and remaining_capacity < 10:\n            priorities[i] += 1.0\n        \n        if item % 3 == 0:\n            priorities[i] *= 2.0\n        \n        if i > 0:\n            priorities[i] += priorities[i-1] / 3\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5  # Add a constant to increase priority\n            else:\n                priorities[i] = 2.0  # Highest priority if capacity exactly matches item size\n                break\n        \n        if i % 2 == 0:\n            priorities[i] *= 1.5  # Increase priority for every alternate bin\n        \n        if item % 2 == 0:\n            priorities[i] += 0.25  # Add extra priority for even-sized items\n        \n        if item > 5 and remaining_capacity < 10:\n            priorities[i] += 1.0\n        \n        if item % 3 == 0:\n            priorities[i] *= 2.0\n        \n        if i > 0:\n            priorities[i] += priorities[i-1] / 3\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                break\n            \n            if item % 2 == 0:\n                priorities[i] += 0.25\n            \n            if i % 3 == 0:\n                priorities[i] *= 1.5\n            \n            if i > 0:\n                priorities[i] += priorities[i-1] / 2\n            \n            if item > 10:\n                if remaining_capacity < 5:\n                    priorities[i] += 1.0\n                else:\n                    priorities[i] -= 0.5\n        \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:42:12", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5  # Add a constant to increase priority\n            else:\n                priorities[i] = 2.0  # Highest priority if capacity exactly matches item size\n                break\n        \n        if i % 2 == 0:\n            priorities[i] *= 1.5  # Increase priority for every alternate bin\n        \n        if item % 2 == 0:\n            priorities[i] += 0.25  # Add extra priority for even-sized items\n        \n        if item > 5 and remaining_capacity < 10:\n            priorities[i] += 1.0\n        \n        if item % 3 == 0:\n            priorities[i] *= 2.0\n        \n        if i > 0:\n            priorities[i] += priorities[i-1] / 3\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5  # Add a constant to increase priority\n            else:\n                priorities[i] = 2.0  # Highest priority if capacity exactly matches item size\n                break\n        \n        if i % 2 == 0:\n            priorities[i] *= 1.5  # Increase priority for every alternate bin\n        \n        if item % 2 == 0:\n            priorities[i] += 0.25  # Add extra priority for even-sized items\n        \n        if item > 5 and remaining_capacity < 10:\n            priorities[i] += 1.0\n        \n        if item % 3 == 0:\n            priorities[i] *= 2.0\n        \n        if i > 0:\n            priorities[i] += priorities[i-1] / 3\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                break\n        \n        if item % 2 == 0:\n            priorities[i] += 0.25\n        \n        if item > 10:\n            priorities[i] *= 1.5\n        \n        if i % 3 == 0:\n            priorities[i] *= 3.0\n        \n        if item > 5 and remaining_capacity < 15:\n            for _ in range(3):\n                priorities[i] += 1.0\n        \n        if i % 2 == 0 and item % 3 == 0:\n            priorities[i] += 2.0\n        \n        if i > 0:\n            priorities[i] += priorities[i-1] / 2.5\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:42:16", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5  # Add a constant to increase priority\n            else:\n                priorities[i] = 2.0  # Highest priority if capacity exactly matches item size\n                break\n        \n        if i % 2 == 0:\n            priorities[i] *= 1.5  # Increase priority for every alternate bin\n        \n        if item % 2 == 0:\n            priorities[i] += 0.25  # Add extra priority for even-sized items\n        \n        if item > 5 and remaining_capacity < 10:\n            priorities[i] += 1.0\n        \n        if item % 3 == 0:\n            priorities[i] *= 2.0\n        \n        if i > 0:\n            priorities[i] += priorities[i-1] / 3\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5  # Add a constant to increase priority\n            else:\n                priorities[i] = 2.0  # Highest priority if capacity exactly matches item size\n                break\n        \n        if i % 2 == 0:\n            priorities[i] *= 1.5  # Increase priority for every alternate bin\n        \n        if item % 2 == 0:\n            priorities[i] += 0.25  # Add extra priority for even-sized items\n        \n        if item > 5 and remaining_capacity < 10:\n            priorities[i] += 1.0\n        \n        if item % 3 == 0:\n            priorities[i] *= 2.0\n        \n        if i > 0:\n            priorities[i] += priorities[i-1] / 3\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                break\n            \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n            \n            for j in range(i):\n                if bins[i] > 2 * bins[j]:\n                    priorities[i] += 0.5\n                elif bins[i] > 1.5 * bins[j]:\n                    priorities[i] += 0.3\n                    \n            if i % 3 == 0:\n                priorities[i] *= 1.5\n                \n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n        \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:42:19", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5  # Add a constant to increase priority\n            else:\n                priorities[i] = 2.0  # Highest priority if capacity exactly matches item size\n                break\n        \n        if i % 2 == 0:\n            priorities[i] *= 1.5  # Increase priority for every alternate bin\n        \n        if item % 2 == 0:\n            priorities[i] += 0.25  # Add extra priority for even-sized items\n        \n        if item > 5 and remaining_capacity < 10:\n            priorities[i] += 1.0\n        \n        if item % 3 == 0:\n            priorities[i] *= 2.0\n        \n        if i > 0:\n            priorities[i] += priorities[i-1] / 3\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0  # Not enough capacity, lowest priority\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5  # Add a constant to increase priority\n            else:\n                priorities[i] = 2.0  # Highest priority if capacity exactly matches item size\n                break\n        \n        if i % 2 == 0:\n            priorities[i] *= 1.5  # Increase priority for every alternate bin\n        \n        if item % 2 == 0:\n            priorities[i] += 0.25  # Add extra priority for even-sized items\n        \n        if item > 5 and remaining_capacity < 10:\n            priorities[i] += 1.0\n        \n        if item % 3 == 0:\n            priorities[i] *= 2.0\n        \n        if i > 0:\n            priorities[i] += priorities[i-1] / 3\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n        if i % 2 == 0:\n            priorities[i] *= 1.5\n        \n        if item % 2 == 0:\n            priorities[i] += 0.25\n        \n        if item > 5 and remaining_capacity < 10:\n            priorities[i] += 1.0\n        \n        if item % 3 == 0:\n            priorities[i] *= 2.0\n        \n        if i > 0:\n            priorities[i] += priorities[i-1] / 3\n        \n        if item > 10 and bins[i] >= item * 2:\n            priorities[i] += 2.0\n        \n        if i % 3 == 0:\n            priorities[i] -= 0.5\n        \n        if item % 5 == 0:\n            priorities[i] += 1.5\n        \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:43:00", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.3:\n                priorities[i] = 0.3\n            elif ratio >= 0.3 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1 / bins[i]\n        else:\n            priorities[i] = 0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"An even more complex implementation of priority calculation.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1 / bins[i]\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.2:\n                priorities[i] = 0.2\n            elif ratio >= 0.2 and ratio < 0.4:\n                priorities[i] = 0.4\n            elif ratio >= 0.4 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:43:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.3:\n                priorities[i] = 0.3\n            elif ratio >= 0.3 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1 / bins[i]\n        else:\n            priorities[i] = 0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1 / bins[i]\n        else:\n            if item > 0:\n                if bins[i] > 0:\n                    ratio = item / bins[i]\n                    if ratio < 0.3:\n                        priorities[i] = 0.4\n                    elif ratio >= 0.3 and ratio < 0.6:\n                        priorities[i] = 0.7\n                    elif ratio >= 0.6 and ratio < 0.8:\n                        priorities[i] = 0.9\n                    else:\n                        priorities[i] = 1.0\n                else:\n                    priorities[i] = 0.1\n            else:\n                priorities[i] = 0.0\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:43:05", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.3:\n                priorities[i] = 0.3\n            elif ratio >= 0.3 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1 / bins[i]\n        else:\n            priorities[i] = 0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1 / bins[i]\n        else:\n            priorities[i] = 0\n    \n    max_priority = np.max(priorities)\n    \n    for i in range(len(bins)):\n        if priorities[i] == max_priority:\n            priorities[i] = 1.0\n        elif priorities[i] >= 0.5:\n            priorities[i] = 0.9\n        elif priorities[i] >= 0.3:\n            priorities[i] = 0.7\n        else:\n            priorities[i] = 0.5\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:43:08", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.3:\n                priorities[i] = 0.3\n            elif ratio >= 0.3 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1 / bins[i]\n        else:\n            priorities[i] = 0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1 / bins[i]\n        elif bins[i] == 0:\n            priorities[i] = 0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.2:\n                priorities[i] = 0.2\n            elif ratio >= 0.2 and ratio < 0.4:\n                priorities[i] = 0.4\n            elif ratio >= 0.4 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1 / bins[i]\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:43:16", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < 0.5 * bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > 1.5 * bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = item * bins[i] / (item + bins[i])\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = 0.5\n            if item % bins[i] == 0:\n                priorities[i] += 0.1\n                for j in range(2, int(bins[i] ** 0.5) + 1):\n                    if bins[i] % j == 0:\n                        priorities[i] -= 0.05\n            else:\n                priorities[i] -= 0.1\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nfrom typing import List\n\ndef priority_v2(item: float, bins: List[float]) -> List[float]:\n    priorities = []\n    \n    for bin_capacity in bins:\n        priority_score = 0.0\n        \n        if bin_capacity >= item:\n            priority_score = 1.0\n        elif bin_capacity == 0:\n            priority_score = 0.0\n        else:\n            if item < bin_capacity:\n                priority_score = item / bin_capacity\n            elif item > bin_capacity:\n                priority_score = bin_capacity / item\n            else:\n                priority_score = 0.5\n            \n            if item % 2 == 0:\n                priority_score += 0.1\n                for i in range(2, int(bin_capacity ** 0.5) + 1):\n                    if bin_capacity % i == 0:\n                        priority_score -= 0.05\n            else:\n                priority_score -= 0.1\n                \n        priorities.append(priority_score)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:43:19", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < 0.5 * bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > 1.5 * bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = item * bins[i] / (item + bins[i])\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = 0.5\n            if item % bins[i] == 0:\n                priorities[i] += 0.1\n                for j in range(2, int(bins[i] ** 0.5) + 1):\n                    if bins[i] % j == 0:\n                        priorities[i] -= 0.05\n            else:\n                priorities[i] -= 0.1\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item % bins[i] == 0:\n                priorities[i] = 0.7\n            else:\n                priorities[i] = 0.3\n                for j in range(2, int((item + bins[i]) ** 0.5) + 1):\n                    if item % j == 0 and bins[i] % j == 0:\n                        priorities[i] += 0.05\n                    elif item % j == 0 or bins[i] % j == 0:\n                        priorities[i] -= 0.05\n                if item > bins[i]:\n                    priorities[i] -= 0.1\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:43:23", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < 0.5 * bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > 1.5 * bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = item * bins[i] / (item + bins[i])\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = 0.5\n            if item % bins[i] == 0:\n                priorities[i] += 0.1\n                for j in range(2, int(bins[i] ** 0.5) + 1):\n                    if bins[i] % j == 0:\n                        priorities[i] -= 0.05\n            else:\n                priorities[i] -= 0.1\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = 0.5\n            if item % bins[i] == 0:\n                priorities[i] += 0.1\n                for j in range(2, int(bins[i] ** 0.5) + 1):\n                    if bins[i] % j == 0:\n                        priorities[i] -= 0.05\n            else:\n                priorities[i] -= 0.1\n            if item % 2 == 0 and bins[i] % 2 == 0:\n                priorities[i] += 0.2\n            elif item % 3 == 0 or bins[i] % 3 == 0:\n                priorities[i] -= 0.15\n            else:\n                priorities[i] += 0.05\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:43:25", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < 0.5 * bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > 1.5 * bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = item * bins[i] / (item + bins[i])\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = 0.5\n            if item % bins[i] == 0:\n                priorities[i] += 0.1\n                for j in range(2, int(bins[i] ** 0.5) + 1):\n                    if bins[i] % j == 0:\n                        priorities[i] -= 0.05\n            else:\n                priorities[i] -= 0.1\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] > item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = 0.5\n        for j in range(2, int(bins[i] ** 0.5) + 1):\n            if bins[i] % j == 0 and item % j == 0:\n                priorities[i] -= 0.1\n            elif bins[i] % j == 0 or item % j == 0:\n                priorities[i] += 0.1\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:43:39", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    if bins[i] > 2 * item:\n                        priorities[i] = item / bins[i] + 0.75\n                    else:\n                        priorities[i] = item / bins[i] + 0.25\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priority_ratio = item / bins[i]\n                priorities[i] = 1 - priority_ratio if priority_ratio < 0.5 else priority_ratio\n            else:\n                priority_ratio = bins[i] / item\n                priorities[i] = 1 - priority_ratio if priority_ratio < 0.5 else priority_ratio\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.1\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(input_array: np.ndarray) -> np.ndarray:\n    output_array = np.zeros_like(input_array)\n    \n    for i in range(len(input_array)):\n        if input_array[i] % 2 == 0:\n            output_array[i] = input_array[i] / 2\n        else:\n            output_array[i] = input_array[i] * 2\n        \n        if input_array[i] > 10:\n            output_array[i] += 5\n        elif input_array[i] < 5:\n            output_array[i] -= 3\n        \n        if i % 2 == 0:\n            output_array[i] *= 1.5\n        else:\n            output_array[i] /= 1.5\n            \n    return output_array", "strategy": []}
{"timestamp": "2025-04-27 06:43:42", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    if bins[i] > 2 * item:\n                        priorities[i] = item / bins[i] + 0.75\n                    else:\n                        priorities[i] = item / bins[i] + 0.25\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priority_ratio = item / bins[i]\n                priorities[i] = 1 - priority_ratio if priority_ratio < 0.5 else priority_ratio\n            else:\n                priority_ratio = bins[i] / item\n                priorities[i] = 1 - priority_ratio if priority_ratio < 0.5 else priority_ratio\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.1\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priority_ratio = item / bins[i]\n                priorities[i] = 1 - priority_ratio if priority_ratio < 0.5 else priority_ratio\n            else:\n                priority_ratio = bins[i] / item\n                priorities[i] = 1 - priority_ratio if priority_ratio < 0.5 else priority_ratio\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.1\n            if bins[i] - item > 5:\n                priorities[i] *= 1.1\n            else:\n                priorities[i] = priorities[i] / 2\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:43:44", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    if bins[i] > 2 * item:\n                        priorities[i] = item / bins[i] + 0.75\n                    else:\n                        priorities[i] = item / bins[i] + 0.25\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priority_ratio = item / bins[i]\n                priorities[i] = 1 - priority_ratio if priority_ratio < 0.5 else priority_ratio\n            else:\n                priority_ratio = bins[i] / item\n                priorities[i] = 1 - priority_ratio if priority_ratio < 0.5 else priority_ratio\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.1\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(data)\n    for i in range(len(data)):\n        if data[i] % 2 == 0:\n            result[i] = data[i] * 2\n        else:\n            temp_sum = 0\n            for j in range(1, data[i] + 1):\n                if data[i] % j == 0:\n                    temp_sum += j\n            result[i] = temp_sum\n    return result", "strategy": []}
{"timestamp": "2025-04-27 06:43:47", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    if bins[i] > 2 * item:\n                        priorities[i] = item / bins[i] + 0.75\n                    else:\n                        priorities[i] = item / bins[i] + 0.25\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priority_ratio = item / bins[i]\n                priorities[i] = 1 - priority_ratio if priority_ratio < 0.5 else priority_ratio\n            else:\n                priority_ratio = bins[i] / item\n                priorities[i] = 1 - priority_ratio if priority_ratio < 0.5 else priority_ratio\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.1\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v3(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more complex version of priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priority_ratio = item / bins[i]\n                priorities[i] = 1 - priority_ratio if priority_ratio < 0.5 else priority_ratio\n            else:\n                priority_ratio = bins[i] / item\n                priorities[i] = 1 - priority_ratio if priority_ratio < 0.5 else priority_ratio\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.1\n            if item > 10 and bins[i] % 3 == 0:\n                priorities[i] += 0.2\n            if item % 2 == 0:\n                priorities[i] -= 0.05\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:43:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.8 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.5:\n                priority_score = 0.6 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.5 and utilization_ratio < 0.7:\n                priority_score = 0.4 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.7 and utilization_ratio < 0.9:\n                priority_score = 0.2 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n            \n            if bins[i] >= 12:\n                priority_score *= 1.3\n            elif bins[i] >= 8:\n                priority_score *= 1.2\n            elif bins[i] >= 5:\n                priority_score *= 1.1\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.5:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.5 and utilization_ratio < 0.7:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.7 and utilization_ratio < 0.9:\n                priority_score = 0.1 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.05 / (1 + utilization_ratio)\n                \n            if bins[i] >= 15:\n                priority_score *= 1.3\n            elif bins[i] >= 8:\n                priority_score *= 1.2\n            elif bins[i] >= 5:\n                priority_score *= 1.1\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.6 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.5:\n                priority_score = 0.4 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.5 and utilization_ratio < 0.7:\n                priority_score = 0.2 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item >= 5:\n                if bins[i] >= 10:\n                    priority_score *= 1.1\n                else:\n                    priority_score *= 0.9\n                \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:43:57", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.8 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.5:\n                priority_score = 0.6 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.5 and utilization_ratio < 0.7:\n                priority_score = 0.4 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.7 and utilization_ratio < 0.9:\n                priority_score = 0.2 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n            \n            if bins[i] >= 12:\n                priority_score *= 1.3\n            elif bins[i] >= 8:\n                priority_score *= 1.2\n            elif bins[i] >= 5:\n                priority_score *= 1.1\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.5:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.5 and utilization_ratio < 0.7:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.7 and utilization_ratio < 0.9:\n                priority_score = 0.1 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.05 / (1 + utilization_ratio)\n                \n            if bins[i] >= 15:\n                priority_score *= 1.3\n            elif bins[i] >= 8:\n                priority_score *= 1.2\n            elif bins[i] >= 5:\n                priority_score *= 1.1\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.5:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.5 and utilization_ratio < 0.7:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.7 and utilization_ratio < 0.9:\n                priority_score = 0.1 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.05 / (1 + utilization_ratio)\n                \n            if bins[i] >= 15:\n                priority_score *= 1.3\n            elif bins[i] >= 10:\n                priority_score *= 1.2\n            elif bins[i] >= 5:\n                priority_score *= 1.1\n            elif bins[i] >= 3:\n                priority_score *= 1.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:44:01", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.8 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.5:\n                priority_score = 0.6 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.5 and utilization_ratio < 0.7:\n                priority_score = 0.4 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.7 and utilization_ratio < 0.9:\n                priority_score = 0.2 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n            \n            if bins[i] >= 12:\n                priority_score *= 1.3\n            elif bins[i] >= 8:\n                priority_score *= 1.2\n            elif bins[i] >= 5:\n                priority_score *= 1.1\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.5:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.5 and utilization_ratio < 0.7:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.7 and utilization_ratio < 0.9:\n                priority_score = 0.1 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.05 / (1 + utilization_ratio)\n                \n            if bins[i] >= 15:\n                priority_score *= 1.3\n            elif bins[i] >= 8:\n                priority_score *= 1.2\n            elif bins[i] >= 5:\n                priority_score *= 1.1\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.5:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.5 and utilization_ratio < 0.7:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.7 and utilization_ratio < 0.9:\n                priority_score = 0.1 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.05 / (1 + utilization_ratio)\n                \n            if bins[i] >= 15:\n                priority_score *= 1.3\n            elif bins[i] >= 8:\n                priority_score *= 1.2\n            elif bins[i] >= 5:\n                priority_score *= 1.1\n                \n            if item <= 3:\n                priority_score += 0.1\n            elif item > 3 and item <= 6:\n                priority_score += 0.05\n            elif item > 6 and item <= 10:\n                priority_score += 0.03\n            elif item > 10:\n                priority_score += 0.01\n                \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:44:05", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.8 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.5:\n                priority_score = 0.6 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.5 and utilization_ratio < 0.7:\n                priority_score = 0.4 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.7 and utilization_ratio < 0.9:\n                priority_score = 0.2 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n            \n            if bins[i] >= 12:\n                priority_score *= 1.3\n            elif bins[i] >= 8:\n                priority_score *= 1.2\n            elif bins[i] >= 5:\n                priority_score *= 1.1\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.5:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.5 and utilization_ratio < 0.7:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.7 and utilization_ratio < 0.9:\n                priority_score = 0.1 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.05 / (1 + utilization_ratio)\n                \n            if bins[i] >= 15:\n                priority_score *= 1.3\n            elif bins[i] >= 8:\n                priority_score *= 1.2\n            elif bins[i] >= 5:\n                priority_score *= 1.1\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:44:15", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item % 2 == 0:\n                priority_score *= 1.1\n            if item % 3 == 0:\n                priority_score *= 1.2\n            if item % 5 == 0:\n                priority_score *= 1.3\n            \n            priorities[i] = priority_score\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:44:19", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:44:24", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5 and bins[i] < 5:\n                priority_score *= 1.1\n            elif item >= 10 and bins[i] >= 10:\n                priority_score *= 1.3\n            elif item >= 15 and bins[i] >= 15:\n                priority_score *= 1.5\n            \n            priorities[i] = priority_score\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:44:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Enhanced version of priority calculation.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            priority_score = 0\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n            \n            if bins[i] % 2 == 0:\n                priority_score *= 1.1\n            else:\n                priority_score *= 0.9\n            \n            if item % 2 == 0:\n                priority_score *= 1.1\n            else:\n                priority_score *= 0.9\n                \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:44:37", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.3:\n                    priorities[index] = 0.9\n                elif priority >= 0.3 and priority < 0.6:\n                    priorities[index] = 0.7\n                elif priority >= 0.6 and priority < 0.9:\n                    priorities[index] = 0.5\n                else:\n                    priorities[index] = 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Ultimate version of priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                priorities[index] = priority if priority > 0 else 0\n            else:\n                priorities[index] = 0.1 * (item - bin_capacity)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                if remaining_capacity < 0.2 * bin_capacity:\n                    priorities[index] = 0.8\n                elif remaining_capacity >= 0.2 * bin_capacity and remaining_capacity < 0.5 * bin_capacity:\n                    priorities[index] = 0.6\n                elif remaining_capacity >= 0.5 * bin_capacity and remaining_capacity < 0.8 * bin_capacity:\n                    priorities[index] = 0.4\n                else:\n                    priorities[index] = 0.2\n            else:\n                priority = 1 / (-remaining_capacity)\n                priorities[index] = priority if priority > 0 else 0.1 * (item - bin_capacity)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:44:39", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.3:\n                    priorities[index] = 0.9\n                elif priority >= 0.3 and priority < 0.6:\n                    priorities[index] = 0.7\n                elif priority >= 0.6 and priority < 0.9:\n                    priorities[index] = 0.5\n                else:\n                    priorities[index] = 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Ultimate version of priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                priorities[index] = priority if priority > 0 else 0\n            else:\n                priorities[index] = 0.1 * (item - bin_capacity)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(input_data):\n    result = []\n    \n    for data_point in input_data:\n        if data_point % 2 == 0:\n            result.append(data_point * 2)\n        else:\n            if data_point < 0:\n                result.append(data_point ** 3)\n            else:\n                temp = 0\n                for i in range(data_point):\n                    temp += i\n                result.append(temp)\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 06:44:41", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.3:\n                    priorities[index] = 0.9\n                elif priority >= 0.3 and priority < 0.6:\n                    priorities[index] = 0.7\n                elif priority >= 0.6 and priority < 0.9:\n                    priorities[index] = 0.5\n                else:\n                    priorities[index] = 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Ultimate version of priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                priorities[index] = priority if priority > 0 else 0\n            else:\n                priorities[index] = 0.1 * (item - bin_capacity)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(data)\n\n    for i in range(len(data)):\n        if data[i] % 2 == 0:\n            result[i] = data[i] * 2\n        else:\n            total = 0\n            for j in range(1, data[i] + 1):\n                total += j\n            result[i] = total\n\n    return result", "strategy": []}
{"timestamp": "2025-04-27 06:44:43", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.3:\n                    priorities[index] = 0.9\n                elif priority >= 0.3 and priority < 0.6:\n                    priorities[index] = 0.7\n                elif priority >= 0.6 and priority < 0.9:\n                    priorities[index] = 0.5\n                else:\n                    priorities[index] = 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Ultimate version of priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                priorities[index] = priority if priority > 0 else 0\n            else:\n                priorities[index] = 0.1 * (item - bin_capacity)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(data)\n    \n    for i in range(len(data)):\n        if data[i] % 2 == 0:\n            total = 0\n            for j in range(data[i]):\n                if j % 2 == 0:\n                    total += j\n            result[i] = total\n        else:\n            total = 1\n            for j in range(data[i]):\n                if j % 2 != 0:\n                    total *= j\n            result[i] = total\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 06:44:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] % 2 == 0:\n            priorities[j] += 5\n        elif priorities[j] % 2 != 0:\n            priorities[j] *= 3\n        else:\n            priorities[j] /= 2\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:44:55", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:45:00", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if item > bins[j]:\n            priorities[j] *= 1.5\n        else:\n            priorities[j] /= 1.5\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:45:04", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n            \n    filtered_priorities = []\n    for priority in priorities:\n        if priority < 50:\n            filtered_priorities.append(priority)\n    \n    return np.array(filtered_priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 06:45:21", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n        if item % 2 == 0:\n            priorities[index] += 0.1\n        else:\n            priorities[index] -= 0.1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n                    \n                if priorities[index] == 0.0:\n                    for i in range(index+1, len(bins)):\n                        if bins[i] >= item:\n                            priorities[i] = 0.6\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n                    \n                if priorities[index] == 0.0:\n                    for i in range(index+1, len(bins)):\n                        if bins[i] >= item:\n                            priorities[i] = 0.6\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:45:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n        if item % 2 == 0:\n            priorities[index] += 0.1\n        else:\n            priorities[index] -= 0.1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n                    \n                if priorities[index] == 0.0:\n                    for i in range(index+1, len(bins)):\n                        if bins[i] >= item:\n                            priorities[i] = 0.6\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n                    \n                    for i in range(index+1, len(bins)):\n                        if bins[i] >= item * 0.8:\n                            priorities[i] = 0.6\n                        elif bins[i] >= item * 0.6:\n                            priorities[i] = 0.5\n                        elif bins[i] > item * 0.4:\n                            priorities[i] = 0.4\n                        else:\n                            priorities[i] = 0.3\n        if item % 3 == 0:\n            priorities[index] += 0.1\n        else:\n            priorities[index] -= 0.1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:45:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n        if item % 2 == 0:\n            priorities[index] += 0.1\n        else:\n            priorities[index] -= 0.1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n                    \n                if priorities[index] == 0.0:\n                    for i in range(index+1, len(bins)):\n                        if bins[i] >= item:\n                            priorities[i] = 0.6\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.4:\n                    priorities[index] = 0.9\n                elif priority >= 0.4 and priority < 0.7:\n                    priorities[index] = 0.7\n                elif priority >= 0.7 and priority < 1.0:\n                    priorities[index] = 0.5\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.2\n                    else:\n                        priorities[index] = 0.3\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.1\n                else:\n                    priorities[index] = 0.0\n                    \n                if priorities[index] == 0.0:\n                    for i in range(index+1, len(bins)):\n                        if bins[i] >= item:\n                            priorities[i] = 0.6\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:45:33", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n        if item % 2 == 0:\n            priorities[index] += 0.1\n        else:\n            priorities[index] -= 0.1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n                    \n                if priorities[index] == 0.0:\n                    for i in range(index+1, len(bins)):\n                        if bins[i] >= item:\n                            priorities[i] = 0.6\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n                    \n                if priorities[index] == 0.0:\n                    for i in range(index+1, len(bins)):\n                        if bins[i] >= item:\n                            priorities[i] = 0.6\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:45:43", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.1:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 3)\n        elif ratios[i] >= 0.1 and ratios[i] < 0.3:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.3 and ratios[i] < 0.5:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.5 and ratios[i] < 0.7:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 5:\n            priorities[j] *= 4\n        elif priorities[j] >= 5 and priorities[j] < 15:\n            priorities[j] *= 5\n        elif priorities[j] >= 15 and priorities[j] < 25:\n            priorities[j] /= 3\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 3 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:45:46", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        priorities[k] = np.clip(priorities[k], 0, 100)  # Clip values between 0 and 100\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:45:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.3:\n            priorities[i] = np.exp(np.sin(item) + np.cos(bins[i])) * np.sqrt(item)\n        elif ratios[i] >= 0.3 and ratios[i] < 0.6:\n            priorities[i] = np.cosh(item * bins[i]) + np.sinh(item + bins[i])\n        elif ratios[i] >= 0.6 and ratios[i] < 0.9:\n            priorities[i] = np.sin(np.abs(item - bins[i])) * np.cos(item + bins[i])\n        else:\n            priorities[i] = np.tan(np.sqrt(item + bins[i])) + np.arctan(np.sqrt(item * bins[i]))\n    \n    for j in range(len(bins)):\n        if j % 2 == 0:\n            priorities[j] = np.power(priorities[j], 2)\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] < 50:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:45:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n    sorted_indices = np.argsort(ratios)\n    sorted_priorities = np.zeros_like(bins)\n    \n    for idx, val in enumerate(sorted_indices):\n        sorted_priorities[idx] = priorities[val] * (idx + 1)\n        \n    return sorted_priorities", "strategy": []}
{"timestamp": "2025-04-27 06:46:11", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5:\n            priorities[i] = 1.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5:\n            priorities[i] = 1.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5:\n            priorities[i] = 1.5\n\n        if item % bins[i] == 0:\n            priorities[i] += 0.2\n        elif item % bins[i] == 1:\n            priorities[i] += 0.1\n        elif item % bins[i] == 2:\n            priorities[i] += 0.05\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:46:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5:\n            priorities[i] = 1.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5:\n            priorities[i] = 1.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 3 * bins[i]:\n            priorities[i] *= 2.0\n        elif item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 2.0:\n            priorities[i] = 2.0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:46:17", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5:\n            priorities[i] = 1.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5:\n            priorities[i] = 1.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n        else:\n            priorities[i] *= 1.05\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5:\n            priorities[i] = 1.5\n\n        if i % 2 == 0:\n            priorities[i] += 0.1\n        else:\n            priorities[i] -= 0.1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:46:20", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5:\n            priorities[i] = 1.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5:\n            priorities[i] = 1.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < 0.8 * bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2.5 * bins[i]:\n            priorities[i] *= 1.8\n        elif item > 1.8 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.3\n\n        if priorities[i] < 0.3:\n            priorities[i] = 0.3\n        elif priorities[i] > 1.8:\n            priorities[i] = 1.8\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:46:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.25\n        elif i % 5 == 1:\n            priorities[i] -= 0.1\n        elif i % 5 == 2:\n            priorities[i] += 0.15\n        elif i % 5 == 3:\n            priorities[i] -= 0.2\n        else:\n            priorities[i] += 0.3\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.25\n        elif i % 5 == 1:\n            priorities[i] -= 0.1\n        elif i % 5 == 2:\n            priorities[i] += 0.15\n        elif i % 5 == 3:\n            priorities[i] -= 0.2\n        else:\n            priorities[i] += 0.3\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:46:36", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.25\n        elif i % 5 == 1:\n            priorities[i] -= 0.1\n        elif i % 5 == 2:\n            priorities[i] += 0.15\n        elif i % 5 == 3:\n            priorities[i] -= 0.2\n        else:\n            priorities[i] += 0.3\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.25\n        elif i % 5 == 1:\n            priorities[i] -= 0.1\n        elif i % 5 == 2:\n            priorities[i] += 0.15\n        elif i % 5 == 3:\n            priorities[i] -= 0.2\n        else:\n            priorities[i] += 0.3\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n            if i % 3 == 0:\n                priorities[i] += 0.2\n            elif i % 3 == 1:\n                priorities[i] -= 0.15\n            else:\n                priorities[i] += 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n            if i % 4 == 0:\n                priorities[i] += 0.3\n            elif i % 4 == 1:\n                priorities[i] -= 0.2\n            elif i % 4 == 2:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.1\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n            if i % 5 == 0:\n                priorities[i] += 0.1\n            elif i % 5 == 1:\n                priorities[i] -= 0.05\n            elif i % 5 == 2:\n                priorities[i] += 0.15\n            elif i % 5 == 3:\n                priorities[i] += 0.2\n            else:\n                priorities[i] += 0.3\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n            if i % 3 == 0:\n                priorities[i] -= 0.1\n            elif i % 3 == 1:\n                priorities[i] += 0.2\n            else:\n                priorities[i] -= 0.05\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n            if i % 2 == 0:\n                priorities[i] -= 0.3\n            else:\n                priorities[i] += 0.25\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:46:40", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.25\n        elif i % 5 == 1:\n            priorities[i] -= 0.1\n        elif i % 5 == 2:\n            priorities[i] += 0.15\n        elif i % 5 == 3:\n            priorities[i] -= 0.2\n        else:\n            priorities[i] += 0.3\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.25\n        elif i % 5 == 1:\n            priorities[i] -= 0.1\n        elif i % 5 == 2:\n            priorities[i] += 0.15\n        elif i % 5 == 3:\n            priorities[i] -= 0.2\n        else:\n            priorities[i] += 0.3\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.25\n        elif i % 5 == 1:\n            priorities[i] -= 0.1\n        elif i % 5 == 2:\n            priorities[i] += 0.15\n        elif i % 5 == 3:\n            priorities[i] -= 0.2\n        else:\n            priorities[i] += 0.3\n\n        if ratio < 0.3 or (ratio >= 0.6 and ratio < 0.8):\n            priorities[i] *= 1.2\n        elif ratio >= 0.3 and ratio < 0.6:\n            priorities[i] *= 1.5\n        else:\n            priorities[i] *= 1.8\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:46:43", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.25\n        elif i % 5 == 1:\n            priorities[i] -= 0.1\n        elif i % 5 == 2:\n            priorities[i] += 0.15\n        elif i % 5 == 3:\n            priorities[i] -= 0.2\n        else:\n            priorities[i] += 0.3\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.25\n        elif i % 5 == 1:\n            priorities[i] -= 0.1\n        elif i % 5 == 2:\n            priorities[i] += 0.15\n        elif i % 5 == 3:\n            priorities[i] -= 0.2\n        else:\n            priorities[i] += 0.3\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.25\n        elif i % 5 == 1:\n            priorities[i] -= 0.1\n        elif i % 5 == 2:\n            priorities[i] += 0.15\n        elif i % 5 == 3:\n            priorities[i] -= 0.2\n        else:\n            priorities[i] += 0.3\n\n        if i % 2 == 0:\n            priorities[i] *= 1.1\n        elif i % 3 == 0:\n            priorities[i] *= 0.9\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:46:55", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            priority = 1 / remaining_capacity\n            priorities[index] = priority if priority > 0 else 0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 2:\n                    priorities[i] = 0.8\n                elif priority > 1:\n                    priorities[i] = 0.6\n                else:\n                    priorities[i] = 0.4\n            else:\n                for j in range(i, len(bins)):\n                    if bins[j] - item > 0:\n                        priorities[j] = 0.5 * (bins[j] - item)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 2:\n                    priorities[i] = 0.8\n                elif priority > 1:\n                    priorities[i] = 0.6\n                else:\n                    priorities[i] = 0.4\n            else:\n                for j in range(i, len(bins)):\n                    if bins[j] - item > 0:\n                        priorities[j] = (bins[j] - item) / (len(bins) - j)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:46:58", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            priority = 1 / remaining_capacity\n            priorities[index] = priority if priority > 0 else 0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 2:\n                    priorities[i] = 0.8\n                elif priority > 1:\n                    priorities[i] = 0.6\n                else:\n                    priorities[i] = 0.4\n            else:\n                for j in range(i, len(bins)):\n                    if bins[j] - item > 0:\n                        priorities[j] = 0.5 * (bins[j] - item)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 2:\n                    priorities[i] = 0.8\n                elif priority > 1:\n                    priorities[i] = 0.6\n                else:\n                    priorities[i] = 0.4\n            else:\n                for j in range(i, len(bins)):\n                    if bins[j] - item > 0:\n                        priorities[j] = 0.5 * (bins[j] - item)\n                while True:\n                    if sum(priorities) >= 2:\n                        break\n                    else:\n                        priorities[i] += 0.1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:47:01", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            priority = 1 / remaining_capacity\n            priorities[index] = priority if priority > 0 else 0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 2:\n                    priorities[i] = 0.8\n                elif priority > 1:\n                    priorities[i] = 0.6\n                else:\n                    priorities[i] = 0.4\n            else:\n                for j in range(i, len(bins)):\n                    if bins[j] - item > 0:\n                        priorities[j] = 0.5 * (bins[j] - item)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 2:\n                    priorities[i] = 0.8\n                elif priority > 1:\n                    priorities[i] = 0.6\n                else:\n                    priorities[i] = 0.4\n            else:\n                for j in range(i, len(bins)):\n                    if bins[j] - item > 0:\n                        priorities[j] = 0.5 * (bins[j] - item)\n                if priorities[i] == 0:\n                    priorities[i] = -0.2\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:47:04", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            priority = 1 / remaining_capacity\n            priorities[index] = priority if priority > 0 else 0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 2:\n                    priorities[i] = 0.8\n                elif priority > 1:\n                    priorities[i] = 0.6\n                else:\n                    priorities[i] = 0.4\n            else:\n                for j in range(i, len(bins)):\n                    if bins[j] - item > 0:\n                        priorities[j] = 0.5 * (bins[j] - item)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                for j in range(i, len(bins)):\n                    if bins[j] - item > 0:\n                        if priority > 2:\n                            priorities[j] = 0.9\n                        elif priority > 1:\n                            priorities[j] = 0.7\n                        else:\n                            priorities[j] = 0.5\n                        break\n            else:\n                for j in range(i, len(bins)):\n                    if bins[j] - item > 0:\n                        priorities[j] = 0.3 * (bins[j] - item)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:47:12", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    priorities[index] = 0.5\n            else:\n                if bin_capacity > 0:\n                    priority = 1 / bin_capacity\n                    priorities[index] = priority if priority > 0 else 0.1\n                else:\n                    priorities[index] = 0.2 * item\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 2:\n                    priorities[i] = 0.8\n                elif priority > 1:\n                    priorities[i] = 0.6\n                else:\n                    priorities[i] = 0.4\n            else:\n                for j in range(i, len(bins)):\n                    if bins[j] - item > 0:\n                        priorities[j] = (bins[j] - item) / (len(bins) - j)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 2:\n                    priorities[i] = 0.8\n                elif priority > 1:\n                    priorities[i] = 0.6\n                else:\n                    priorities[i] = 0.4\n            else:\n                max_priority = 0\n                for j in range(i, len(bins)):\n                    if bins[j] - item > 0:\n                        priority = (bins[j] - item) / (len(bins) - j)\n                        if priority > max_priority:\n                            max_priority = priority\n                            priorities[j] = priority\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:47:15", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    priorities[index] = 0.5\n            else:\n                if bin_capacity > 0:\n                    priority = 1 / bin_capacity\n                    priorities[index] = priority if priority > 0 else 0.1\n                else:\n                    priorities[index] = 0.2 * item\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 2:\n                    priorities[i] = 0.8\n                elif priority > 1:\n                    priorities[i] = 0.6\n                else:\n                    priorities[i] = 0.4\n            else:\n                for j in range(i, len(bins)):\n                    if bins[j] - item > 0:\n                        priorities[j] = (bins[j] - item) / (len(bins) - j)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more advanced version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 2:\n                    priorities[i] = 0.9\n                elif priority > 1:\n                    priorities[i] = 0.7\n                else:\n                    priorities[i] = 0.5\n            else:\n                for j in range(i+1, len(bins)):\n                    diff_capacity = bins[j] - bins[i] + item\n                    if diff_capacity > 0:\n                        priorities[j] = diff_capacity / len(bins) * 2\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:47:19", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    priorities[index] = 0.5\n            else:\n                if bin_capacity > 0:\n                    priority = 1 / bin_capacity\n                    priorities[index] = priority if priority > 0 else 0.1\n                else:\n                    priorities[index] = 0.2 * item\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 2:\n                    priorities[i] = 0.8\n                elif priority > 1:\n                    priorities[i] = 0.6\n                else:\n                    priorities[i] = 0.4\n            else:\n                for j in range(i, len(bins)):\n                    if bins[j] - item > 0:\n                        priorities[j] = (bins[j] - item) / (len(bins) - j)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 2:\n                    priorities[i] = 0.8\n                elif priority > 1:\n                    priorities[i] = 0.6\n                else:\n                    priorities[i] = 0.4\n            else:\n                min_priority = 0.1\n                for j in range(i, len(bins)):\n                    if bins[j] - item > 0:\n                        priority = (bins[j] - item) / (len(bins) - j)\n                        min_priority = max(priority, min_priority)\n                priorities[i] = min_priority\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:47:22", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    priorities[index] = 0.5\n            else:\n                if bin_capacity > 0:\n                    priority = 1 / bin_capacity\n                    priorities[index] = priority if priority > 0 else 0.1\n                else:\n                    priorities[index] = 0.2 * item\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 2:\n                    priorities[i] = 0.8\n                elif priority > 1:\n                    priorities[i] = 0.6\n                else:\n                    priorities[i] = 0.4\n            else:\n                for j in range(i, len(bins)):\n                    if bins[j] - item > 0:\n                        priorities[j] = (bins[j] - item) / (len(bins) - j)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 2:\n                    priorities[i] = 0.8\n                elif priority > 1:\n                    priorities[i] = 0.6\n                else:\n                    priorities[i] = 0.4\n            else:\n                max_priority = max(priorities)\n                for j, priority in enumerate(priorities):\n                    if priority == max_priority:\n                        priorities[j] = 0.2\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:47:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = 0.5\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.1\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.5\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.5\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.2\n            elif bins[i] % 3 == 0:\n                priorities[i] += 0.3\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:47:33", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = 0.5\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.1\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.5\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.5\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.2\n            if item % 2 == 0:\n                priorities[i] += 0.1\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:47:36", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = 0.5\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.1\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.5\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.05\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:47:39", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = 0.5\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.1\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.5\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.5\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.2\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:47:48", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\n\ndef complex_priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        elif i % 4 == 3:\n            if ratio < 0.8:\n                priorities[i] += 0.2\n            else:\n                priorities[i] -= 0.3\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:47:51", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_function(input_data: np.ndarray) -> np.ndarray:\n    output_data = np.zeros_like(input_data)\n\n    for i in range(len(input_data)):\n        if input_data[i] % 2 == 0:\n            output_data[i] = input_data[i] * 2\n        else:\n            for j in range(1, 5):\n                output_data[i] += j * input_data[i]\n\n        if i % 3 == 0:\n            output_data[i] += 10\n        elif i % 3 == 1:\n            output_data[i] -= 5\n        else:\n            for k in range(2):\n                output_data[i] += k * 1.5\n\n    return output_data\n```", "strategy": []}
{"timestamp": "2025-04-27 06:47:55", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 2 == 0:\n            priorities[i] += 0.2\n        if i % 3 == 1:\n            priorities[i] -= 0.1\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for _ in range(4):\n                priorities[i] -= 0.04\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:47:59", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n        if priorities[i] > 0.7:\n            priorities[i] = 0.7\n        elif priorities[i] < 0.3:\n            priorities[i] = 0.3\n        else:\n            priorities[i] += 0.1\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:48:11", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-40 * (ratio - 0.2))) + 0.1\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-20 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.5))) + 0.4\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.7))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        elif i % 5 == 1:\n            priorities[i] -= 0.2\n        elif i % 5 == 2:\n            priorities[i] += 0.25\n        elif i % 5 == 3:\n            for j in range(2):\n                priorities[i] -= 0.1\n        else:\n            priorities[i] += 0.1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:48:15", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.2))) + 0.2\n        elif ratio >= 0.3 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.4))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-3 * (ratio - 0.7))) + 0.5\n        elif ratio >= 0.8 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.9))) + 0.6\n        else:\n            priorities[i] = 1 / (1 + np.exp(-1 * (ratio - 1))) + 0.7\n\n        if i % 3 == 0:\n            priorities[i] += 0.2\n        elif i % 3 == 1:\n            priorities[i] -= 0.1\n        else:\n            priorities[i] += 0.1\n\n        for j in range(2):\n            if i % 2 == 0:\n                 priorities[i] += 0.05\n            else:\n                 priorities[i] -= 0.03\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:48:19", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.2))) + 0.2\n        elif ratio >= 0.3 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.5))) + 0.3\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.7))) + 0.4\n        elif ratio >= 0.8 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-3 * (ratio - 0.9))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.2\n        elif i % 5 == 1:\n            priorities[i] -= 0.1\n        elif i % 5 == 2:\n            priorities[i] += 0.15\n        elif i % 5 == 3:\n            priorities[i] -= 0.05\n        else:\n            priorities[i] += 0.1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:48:22", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_function(input_data: np.ndarray, thresholds: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(input_data)\n    \n    for i in range(len(input_data)):\n        if input_data[i] < thresholds[0]:\n            result[i] = input_data[i] + 0.2\n        elif thresholds[0] <= input_data[i] < thresholds[1]:\n            result[i] = input_data[i] - 0.1\n        elif thresholds[1] <= input_data[i] < thresholds[2]:\n            result[i] = input_data[i] * 1.5\n        else:\n            result[i] = 0.5 * input_data[i]\n        \n        for j in range(3):\n            if j % 2 == 0:\n                result[i] += 0.1\n            else:\n                result[i] -= 0.05\n    \n    return result\n```", "strategy": []}
{"timestamp": "2025-04-27 06:48:34", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:48:38", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.3:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2) * item\n        elif ratios[i] >= 0.3 and ratios[i] < 0.5:\n            priorities[i] = np.tan(item) * np.tan(bins[i]) + np.log(item + bins[i] + 1)\n        elif ratios[i] >= 0.5 and ratios[i] < 0.7:\n            priorities[i] = np.sqrt(np.abs(item - bins[i]) + 1) + np.arctan(item - bins[i])\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1) + item\n    \n    for j in range(len(bins)):\n        if priorities[j] < 15:\n            priorities[j] *= 2\n        elif priorities[j] >= 15 and priorities[j] < 25:\n            priorities[j] *= 1.5\n        elif priorities[j] >= 25 and priorities[j] < 35:\n            priorities[j] /= 1.5\n        else:\n            priorities[j] = np.sqrt(priorities[j]) + item\n    \n    for k in range(len(bins)):\n        if priorities[k] % 3 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 3\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:48:42", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.log(item) + np.tan(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(np.sin(item)) + np.arctan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.exp(item - bins[i]) - np.cos(item * bins[i])\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arcsin(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i] * np.pi)) * np.tanh(np.cosh(ratios[i] - 1)) - np.log(ratios[i] + 2)\n\n    for j in range(len(bins)):\n        if priorities[j] < 15:\n            priorities[j] = priorities[j] ** 2\n        elif priorities[j] >= 15 and priorities[j] < 25:\n            priorities[j] = np.sqrt(priorities[j]) * 3\n        elif priorities[j] >= 25 and priorities[j] < 35:\n            priorities[j] = priorities[j] / 2\n        else:\n            priorities[j] = np.sinh(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 3 == 0:\n            priorities[k] += item * bins[k]\n        else:\n            priorities[k] -= item / 3\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:48:47", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.25:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2) * np.cos(item) + np.sin(bins[i])\n        elif ratios[i] >= 0.25 and ratios[i] < 0.5:\n            priorities[i] = np.tan(item) + np.tan(bins[i]) * np.log(item) + np.log(bins[i])\n        elif ratios[i] >= 0.5 and ratios[i] < 0.75:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1) + np.sqrt(np.abs(item - bins[i]))\n        elif ratios[i] >= 0.75 and ratios[i] < 1:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i])) * np.tanh(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1) * np.exp(ratios[i])\n    \n    for j in range(len(bins)):\n        if priorities[j] < 15:\n            priorities[j] *= 4\n        elif priorities[j] >= 15 and priorities[j] < 30:\n            priorities[j] *= 5\n        elif priorities[j] >= 30 and priorities[j] < 45:\n            priorities[j] /= 3\n        else:\n            priorities[j] = np.sqrt(priorities[j]) + 10\n    \n    for k in range(len(bins)):\n        if priorities[k] % 3 == 0:\n            priorities[k] += item * 2\n        else:\n            priorities[k] -= item / 3\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:49:04", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "import numpy as np\n\n\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n                \n                if remaining_space >= 5:\n                    priority_score *= 1.2\n                if bins[i] >= 15:\n                    priority_score *= 1.4\n                if item < 5:\n                    priority_score += 0.2\n            \n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n                if remaining_space >= 3:\n                    priority_score *= 1.1\n                if bins[i] >= 10:\n                    priority_score *= 1.3\n                if item >= 5 and item < 10:\n                    priority_score += 0.1\n                    \n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n                if bins[i] >= 5:\n                    priority_score *= 1.2\n                if item >= 10 and item < 15:\n                    priority_score += 0.05\n                    \n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:49:08", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "import numpy as np\n\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if item % 2 == 0:\n                priority_score *= 1.1\n            else:\n                priority_score *= 0.9\n                \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:49:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if item % 2 == 0:\n                priority_score += 0.1\n            if bins[i] % 2 == 0:\n                priority_score += 0.05\n            \n            priorities[i] = priority_score\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:49:17", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "import numpy as np\n\n\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n            \n            if utilization_ratio < 0.2 and item > 10:\n                priority_score *= 1.5\n            elif utilization_ratio >= 0.2 and utilization_ratio < 0.5:\n                priority_score *= 1.3\n            elif utilization_ratio >= 0.5 and utilization_ratio < 0.7:\n                priority_score *= 1.2\n            \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:49:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n            \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] += 0.5\n        elif priorities[j] == min_priority:\n            priorities[j] -= 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                \n    sorted_priorities = np.sort(priorities)[::-1]\n    for j in range(len(priorities)):\n        if priorities[j] == sorted_priorities[0]:\n            priorities[j] += 0.5\n        elif priorities[j] == sorted_priorities[-1]:\n            priorities[j] -= 0.5\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if item % 2 == 0:\n                    priorities[i] *= 1.2\n                else:\n                    priorities[i] *= 0.8\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if item % 2 == 0:\n                    priorities[i] *= 1.1\n                else:\n                    priorities[i] *= 0.9\n                \n    sorted_priorities = np.sort(priorities)[::-1]\n    for j in range(len(priorities)):\n        if priorities[j] == sorted_priorities[0]:\n            priorities[j] += 0.5\n        elif priorities[j] == sorted_priorities[-1]:\n            priorities[j] -= 0.5\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:49:33", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n            \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] += 0.5\n        elif priorities[j] == min_priority:\n            priorities[j] -= 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                \n    sorted_priorities = np.sort(priorities)[::-1]\n    for j in range(len(priorities)):\n        if priorities[j] == sorted_priorities[0]:\n            priorities[j] += 0.5\n        elif priorities[j] == sorted_priorities[-1]:\n            priorities[j] -= 0.5\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                \n    sorted_priorities = np.sort(priorities)[::-1]\n    for j in range(len(priorities)):\n        if priorities[j] == sorted_priorities[0]:\n            priorities[j] += 0.5\n        elif priorities[j] == sorted_priorities[-1]:\n            priorities[j] -= 0.5\n            \n    min_bin_capacity = np.min(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for k in range(len(priorities)):\n        if bins[k] == max_bin_capacity:\n            priorities[k] += 1.0\n        elif bins[k] == min_bin_capacity:\n            priorities[k] -= 1.0\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:49:36", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n            \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] += 0.5\n        elif priorities[j] == min_priority:\n            priorities[j] -= 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                \n    sorted_priorities = np.sort(priorities)[::-1]\n    for j in range(len(priorities)):\n        if priorities[j] == sorted_priorities[0]:\n            priorities[j] += 0.5\n        elif priorities[j] == sorted_priorities[-1]:\n            priorities[j] -= 0.5\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                \n    sorted_priorities = np.sort(priorities)[::-1]\n    for j in range(len(priorities)):\n        if priorities[j] == sorted_priorities[0]:\n            priorities[j] += 0.5\n        elif priorities[j] == sorted_priorities[-1]:\n            priorities[j] -= 0.5\n            \n    # Additional logic for improvement\n    if np.sum(priorities) > 10:\n        priorities /= 2\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:49:39", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n            \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] += 0.5\n        elif priorities[j] == min_priority:\n            priorities[j] -= 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                \n    sorted_priorities = np.sort(priorities)[::-1]\n    for j in range(len(priorities)):\n        if priorities[j] == sorted_priorities[0]:\n            priorities[j] += 0.5\n        elif priorities[j] == sorted_priorities[-1]:\n            priorities[j] -= 0.5\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                \n    sorted_priorities = np.sort(priorities)[::-1]\n    max_val = sorted_priorities[0]\n    for j in range(len(priorities)):\n        if priorities[j] == max_val:\n            priorities[j] += 0.5\n        elif 0.5 * max_val <= priorities[j] <= max_val - 0.5:\n            priorities[j] += 0.3\n        else:\n            priorities[j] -= 0.2\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:49:56", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n        if i % 2 == 0:\n            priorities[i] *= 1.5\n        \n        if item % 2 == 0:\n            priorities[i] += 0.25\n        \n        if item > 5 and remaining_capacity < 10:\n            priorities[i] += 1.0\n        \n        if item % 3 == 0:\n            priorities[i] *= 2.0\n        \n        if i > 0:\n            priorities[i] += priorities[i-1] / 3\n        \n        if item > 10 and bins[i] >= item * 2:\n            priorities[i] += 2.0\n        \n        if i % 3 == 0:\n            priorities[i] -= 0.5\n        \n        if item % 5 == 0:\n            priorities[i] += 1.5\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n        if i % 2 == 0:\n            priorities[i] *= 1.5\n        \n        if item % 2 == 0:\n            priorities[i] += 0.25\n        \n        if item > 5 and remaining_capacity < 10:\n            priorities[i] += 1.0\n        \n        if item % 3 == 0:\n            priorities[i] *= 2.0\n        \n        if i > 0:\n            priorities[i] += priorities[i-1] / 3\n        \n        if item > 10 and bins[i] >= item * 2:\n            priorities[i] += 2.0\n        \n        if i % 3 == 0:\n            priorities[i] -= 0.5\n        \n        if item % 5 == 0:\n            priorities[i] += 1.5\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n        if i % 2 == 0:\n            priorities[i] *= 1.5\n        \n        if item % 2 == 0:\n            priorities[i] += 0.25\n        \n        if item > 5 and remaining_capacity < 10:\n            priorities[i] += 1.0\n        \n        if item % 3 == 0:\n            priorities[i] *= 2.0\n        \n        if i > 0:\n            priorities[i] += priorities[i-1] / 3\n        \n        if item > 10 and bins[i] >= item * 2:\n            priorities[i] += 2.0\n        \n        if i % 3 == 0:\n            priorities[i] -= 0.5\n        \n        if item % 5 == 0:\n            priorities[i] += 1.5\n        \n        if item % 2 != 0 and remaining_capacity % 2 == 0:\n            priorities[i] += 0.75\n        \n        if item < 5:\n            priorities[i] -= 0.5\n        \n        if item == 8:\n            priorities[i] += 2.0\n        \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:50:00", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n        if i % 2 == 0:\n            priorities[i] *= 1.5\n        \n        if item % 2 == 0:\n            priorities[i] += 0.25\n        \n        if item > 5 and remaining_capacity < 10:\n            priorities[i] += 1.0\n        \n        if item % 3 == 0:\n            priorities[i] *= 2.0\n        \n        if i > 0:\n            priorities[i] += priorities[i-1] / 3\n        \n        if item > 10 and bins[i] >= item * 2:\n            priorities[i] += 2.0\n        \n        if i % 3 == 0:\n            priorities[i] -= 0.5\n        \n        if item % 5 == 0:\n            priorities[i] += 1.5\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n        if i % 2 == 0:\n            priorities[i] *= 1.5\n        \n        if item % 2 == 0:\n            priorities[i] += 0.25\n        \n        if item > 5 and remaining_capacity < 10:\n            priorities[i] += 1.0\n        \n        if item % 3 == 0:\n            priorities[i] *= 2.0\n        \n        if i > 0:\n            priorities[i] += priorities[i-1] / 3\n        \n        if item > 10 and bins[i] >= item * 2:\n            priorities[i] += 2.0\n        \n        if i % 3 == 0:\n            priorities[i] -= 0.5\n        \n        if item % 5 == 0:\n            priorities[i] += 1.5\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n        if i % 2 == 0:\n            priorities[i] *= 1.5\n        \n        if item % 2 == 0:\n            priorities[i] += 0.25\n        \n        if item > 5 and remaining_capacity < 10:\n            priorities[i] += 1.0\n        \n        if item % 3 == 0:\n            priorities[i] *= 2.0\n        \n        if i > 0:\n            priorities[i] += priorities[i-1] / 3\n        \n        if item > 10 and bins[i] >= item * 2:\n            priorities[i] += 2.0\n        \n        if i % 3 == 0:\n            priorities[i] -= 0.5\n        \n        if item % 5 == 0:\n            priorities[i] += 1.5\n        \n        if item % 2 == 0 and item < 10:\n            priorities[i] -= 0.75\n        \n        if item > 15:\n            priorities[i] += 3.0\n        \n        if i % 4 == 0 and item >= 6:\n            priorities[i] -= 0.25\n        \n        if item % 4 == 0 and item < 10:\n            priorities[i] += 0.5\n        \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:50:04", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n        if i % 2 == 0:\n            priorities[i] *= 1.5\n        \n        if item % 2 == 0:\n            priorities[i] += 0.25\n        \n        if item > 5 and remaining_capacity < 10:\n            priorities[i] += 1.0\n        \n        if item % 3 == 0:\n            priorities[i] *= 2.0\n        \n        if i > 0:\n            priorities[i] += priorities[i-1] / 3\n        \n        if item > 10 and bins[i] >= item * 2:\n            priorities[i] += 2.0\n        \n        if i % 3 == 0:\n            priorities[i] -= 0.5\n        \n        if item % 5 == 0:\n            priorities[i] += 1.5\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n        if i % 2 == 0:\n            priorities[i] *= 1.5\n        \n        if item % 2 == 0:\n            priorities[i] += 0.25\n        \n        if item > 5 and remaining_capacity < 10:\n            priorities[i] += 1.0\n        \n        if item % 3 == 0:\n            priorities[i] *= 2.0\n        \n        if i > 0:\n            priorities[i] += priorities[i-1] / 3\n        \n        if item > 10 and bins[i] >= item * 2:\n            priorities[i] += 2.0\n        \n        if i % 3 == 0:\n            priorities[i] -= 0.5\n        \n        if item % 5 == 0:\n            priorities[i] += 1.5\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n        if i % 2 == 0:\n            priorities[i] *= 1.5\n        \n        if item % 2 == 0:\n            priorities[i] += 0.25\n        \n        if item > 5 and remaining_capacity < 10:\n            priorities[i] += 1.0\n        \n        if item % 3 == 0:\n            priorities[i] *= 2.0\n\n        if i > 0:\n            priorities[i] += priorities[i-1] / 3\n        \n        if item > 10 and bins[i] >= item * 2:\n            priorities[i] += 2.0\n        \n        if i % 3 == 0:\n            priorities[i] -= 0.5\n        \n        if item % 5 == 0:\n            priorities[i] += 1.5\n        \n        if item > 15:\n            priorities[i] += 3.0\n        \n        if bins[i] % 7 == 0:\n            priorities[i] += 2.0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:50:08", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n        if i % 2 == 0:\n            priorities[i] *= 1.5\n        \n        if item % 2 == 0:\n            priorities[i] += 0.25\n        \n        if item > 5 and remaining_capacity < 10:\n            priorities[i] += 1.0\n        \n        if item % 3 == 0:\n            priorities[i] *= 2.0\n        \n        if i > 0:\n            priorities[i] += priorities[i-1] / 3\n        \n        if item > 10 and bins[i] >= item * 2:\n            priorities[i] += 2.0\n        \n        if i % 3 == 0:\n            priorities[i] -= 0.5\n        \n        if item % 5 == 0:\n            priorities[i] += 1.5\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n        if i % 2 == 0:\n            priorities[i] *= 1.5\n        \n        if item % 2 == 0:\n            priorities[i] += 0.25\n        \n        if item > 5 and remaining_capacity < 10:\n            priorities[i] += 1.0\n        \n        if item % 3 == 0:\n            priorities[i] *= 2.0\n        \n        if i > 0:\n            priorities[i] += priorities[i-1] / 3\n        \n        if item > 10 and bins[i] >= item * 2:\n            priorities[i] += 2.0\n        \n        if i % 3 == 0:\n            priorities[i] -= 0.5\n        \n        if item % 5 == 0:\n            priorities[i] += 1.5\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:50:26", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if bins[i] % 2 == 0:\n                priority_score *= 1.1\n            elif bins[i] % 3 == 0:\n                priority_score *= 1.2\n            elif bins[i] % 5 == 0:\n                priority_score *= 1.3\n                \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:50:29", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n            \n            if priority_score > 0.5:\n                priority_score *= 1.2\n            else:\n                priority_score *= 0.8\n                \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:50:33", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            # Adding more complexity\n            if bins[i] % 2 == 0:\n                priority_score *= 1.1\n            elif bins[i] % 3 == 0:\n                priority_score *= 1.2\n            elif bins[i] % 5 == 0:\n                priority_score *= 1.3\n            elif bins[i] % 7 == 0:\n                priority_score *= 1.4\n                \n            priorities[i] = priority_score\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:50:37", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif 0.1 <= utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif 0.3 <= utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif 0.6 <= utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if utilization_ratio < 0.5 and bins[i] >= 7:\n                priority_score *= 1.5\n            elif utilization_ratio >= 0.5 and bins[i] < 7:\n                priority_score *= 0.7\n                \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:50:49", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.25\n        elif i % 5 == 1:\n            priorities[i] -= 0.1\n        elif i % 5 == 2:\n            priorities[i] += 0.15\n        elif i % 5 == 3:\n            priorities[i] -= 0.2\n        else:\n            priorities[i] += 0.3\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.25\n        elif i % 5 == 1:\n            priorities[i] -= 0.1\n        elif i % 5 == 2:\n            priorities[i] += 0.15\n        elif i % 5 == 3:\n            priorities[i] -= 0.2\n        else:\n            priorities[i] += 0.3\n\n        if ratio < 0.3 or (ratio >= 0.6 and ratio < 0.8):\n            priorities[i] *= 1.2\n        elif ratio >= 0.3 and ratio < 0.6:\n            priorities[i] *= 1.5\n        else:\n            priorities[i] *= 1.8\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.25\n        elif i % 5 == 1:\n            priorities[i] -= 0.1\n        elif i % 5 == 2:\n            priorities[i] += 0.15\n        elif i % 5 == 3:\n            priorities[i] -= 0.2\n        else:\n            priorities[i] += 0.3\n\n        if ratio < 0.3 or (ratio >= 0.6 and ratio < 0.8):\n            priorities[i] *= 1.2\n        elif ratio >= 0.3 and ratio < 0.6:\n            priorities[i] *= 1.5\n        else:\n            priorities[i] *= 1.8\n\n        if i % 2 == 0:\n            priorities[i] = np.log(priorities[i] + 1)\n        else:\n            priorities[i] = np.log(priorities[i] + 2)\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:50:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.25\n        elif i % 5 == 1:\n            priorities[i] -= 0.1\n        elif i % 5 == 2:\n            priorities[i] += 0.15\n        elif i % 5 == 3:\n            priorities[i] -= 0.2\n        else:\n            priorities[i] += 0.3\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.25\n        elif i % 5 == 1:\n            priorities[i] -= 0.1\n        elif i % 5 == 2:\n            priorities[i] += 0.15\n        elif i % 5 == 3:\n            priorities[i] -= 0.2\n        else:\n            priorities[i] += 0.3\n\n        if ratio < 0.3 or (ratio >= 0.6 and ratio < 0.8):\n            priorities[i] *= 1.2\n        elif ratio >= 0.3 and ratio < 0.6:\n            priorities[i] *= 1.5\n        else:\n            priorities[i] *= 1.8\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\n\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.25\n        elif i % 5 == 1:\n            priorities[i] -= 0.1\n        elif i % 5 == 2:\n            priorities[i] += 0.15\n        elif i % 5 == 3:\n            priorities[i] -= 0.2\n        else:\n            priorities[i] += 0.3\n\n        if ratio < 0.3:\n            priorities[i] *= 1.2\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] *= 1.2\n        elif ratio >= 0.3 and ratio < 0.6:\n            priorities[i] *= 1.5\n        elif ratio >= 0.8:\n            priorities[i] *= 1.8\n\n        if ratio < 0.2 or (ratio >= 0.4 and ratio < 0.6):\n            priorities[i] += 0.2\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] -= 0.1\n        elif ratio >= 0.6:\n            priorities[i] += 0.3\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:50:59", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.25\n        elif i % 5 == 1:\n            priorities[i] -= 0.1\n        elif i % 5 == 2:\n            priorities[i] += 0.15\n        elif i % 5 == 3:\n            priorities[i] -= 0.2\n        else:\n            priorities[i] += 0.3\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.25\n        elif i % 5 == 1:\n            priorities[i] -= 0.1\n        elif i % 5 == 2:\n            priorities[i] += 0.15\n        elif i % 5 == 3:\n            priorities[i] -= 0.2\n        else:\n            priorities[i] += 0.3\n\n        if ratio < 0.3 or (ratio >= 0.6 and ratio < 0.8):\n            priorities[i] *= 1.2\n        elif ratio >= 0.3 and ratio < 0.6:\n            priorities[i] *= 1.5\n        else:\n            priorities[i] *= 1.8\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-40 * (ratio - 0.2))) + 0.2\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-20 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.5))) + 0.4\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.7))) + 0.5\n        elif ratio >= 0.8 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.9))) + 0.6\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.7\n\n        if i % 3 == 0:\n            priorities[i] += 0.4\n        elif i % 3 == 1:\n            priorities[i] -= 0.2\n        else:\n            priorities[i] += 0.3\n\n        if ratio < 0.5 or (ratio >= 0.7 and ratio < 0.9):\n            priorities[i] *= 1.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] *= 1.6\n        else:\n            priorities[i] *= 2.0\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:51:04", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.25\n        elif i % 5 == 1:\n            priorities[i] -= 0.1\n        elif i % 5 == 2:\n            priorities[i] += 0.15\n        elif i % 5 == 3:\n            priorities[i] -= 0.2\n        else:\n            priorities[i] += 0.3\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.25\n        elif i % 5 == 1:\n            priorities[i] -= 0.1\n        elif i % 5 == 2:\n            priorities[i] += 0.15\n        elif i % 5 == 3:\n            priorities[i] -= 0.2\n        else:\n            priorities[i] += 0.3\n\n        if ratio < 0.3 or (ratio >= 0.6 and ratio < 0.8):\n            priorities[i] *= 1.2\n        elif ratio >= 0.3 and ratio < 0.6:\n            priorities[i] *= 1.5\n        else:\n            priorities[i] *= 1.8\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.25\n        elif i % 5 == 1:\n            priorities[i] -= 0.1\n        elif i % 5 == 2:\n            priorities[i] += 0.15\n        elif i % 5 == 3:\n            priorities[i] -= 0.2\n        else:\n            priorities[i] += 0.3\n\n        if ratio < 0.3 or (ratio >= 0.6 and ratio < 0.8):\n            priorities[i] *= 1.2\n        elif ratio >= 0.3 and ratio < 0.6:\n            priorities[i] *= 1.5\n        else:\n            priorities[i] *= 1.8\n\n        if ratio < 0.2:\n            priorities[i] += 0.1\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] -= 0.05\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] += 0.2\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] -= 0.15\n        else:\n            priorities[i] += 0.3\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:51:19", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Enhanced version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n            if item > 10:\n                priorities[i] += 0.5\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n            if item > 5:\n                priorities[i] -= 0.3\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n                \n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if count == 4:\n                    priorities[i] += 1.0\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if count == 3:\n                    priorities[i] -= 0.5\n                else:\n                    priorities[i] += 0.1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n            \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] += 0.5\n        elif priorities[j] == min_priority:\n            priorities[j] -= 0.5\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n\n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] += 0.5\n        elif priorities[j] == min_priority:\n            priorities[j] -= 0.5\n\n    for k in range(len(priorities)):\n        if bins[k] > 20:\n            priorities[k] += 1.0\n        elif bins[k] < 5:\n            priorities[k] -= 0.5\n        else:\n            priorities[k] += 0.1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:51:22", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Enhanced version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n            if item > 10:\n                priorities[i] += 0.5\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n            if item > 5:\n                priorities[i] -= 0.3\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n                \n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if count == 4:\n                    priorities[i] += 1.0\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if count == 3:\n                    priorities[i] -= 0.5\n                else:\n                    priorities[i] += 0.1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n            \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] += 0.5\n        elif priorities[j] == min_priority:\n            priorities[j] -= 0.5\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more enhanced version of priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            \n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count >= 2:\n                priorities[i] += 0.2\n            elif count == 1:\n                priorities[i] -= 0.1\n                \n            if item >= 5:\n                priorities[i] += 0.3\n            elif item < 3:\n                priorities[i] -= 0.2\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:51:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Enhanced version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n            if item > 10:\n                priorities[i] += 0.5\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n            if item > 5:\n                priorities[i] -= 0.3\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n                \n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if count == 4:\n                    priorities[i] += 1.0\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if count == 3:\n                    priorities[i] -= 0.5\n                else:\n                    priorities[i] += 0.1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n            \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] += 0.5\n        elif priorities[j] == min_priority:\n            priorities[j] -= 0.5\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n            if item <= 20:\n                priorities[i] += 0.2\n            else:\n                priorities[i] += 0.5\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n            if item > 5:\n                priorities[i] -= 0.1\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n                \n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if count == 6:\n                    priorities[i] += 0.8\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if count == 4:\n                    priorities[i] -= 0.5\n                else:\n                    priorities[i] += 0.2\n            else:\n                priorities[i] = 0.9 * count + item / bins[i] + 0.3\n                if count == 3:\n                    priorities[i] -= 0.3\n                elif count == 5:\n                    priorities[i] += 0.4\n                \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:51:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Enhanced version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n            if item > 10:\n                priorities[i] += 0.5\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n            if item > 5:\n                priorities[i] -= 0.3\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n                \n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if count == 4:\n                    priorities[i] += 1.0\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if count == 3:\n                    priorities[i] -= 0.5\n                else:\n                    priorities[i] += 0.1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n            \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] += 0.5\n        elif priorities[j] == min_priority:\n            priorities[j] -= 0.5\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"More complex version of priority calculation.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if item % 2 == 0:\n                priorities[i] = item / bins[i] + 0.1\n            else:\n                priorities[i] = item / bins[i] + 0.3\n            if item > 10:\n                priorities[i] += 0.5\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if count == 4:\n                    priorities[i] += 1.0\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if count == 3:\n                    priorities[i] -= 0.5\n                else:\n                    priorities[i] += 0.1\n\n            if item % 2 == 0:\n                priorities[i] += 0.2\n                \n            if bins[i] % 3 == 0:\n                priorities[i] -= 0.1\n            elif bins[i] % 2 == 0:\n                priorities[i] += 0.1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:51:43", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:51:47", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n            if item % 7 == 0:\n                priorities[i] += 2.5\n\n            if item > 20:\n                if remaining_capacity % 2 == 0:\n                    priorities[i] += 1.75\n                else:\n                    priorities[i] -= 1.25\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:51:53", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n            if item < 30:\n                if i % 5 == 0:\n                    priorities[i] -= 0.5\n                elif i % 5 == 1:\n                    priorities[i] += 0.7\n                elif i % 5 == 2:\n                    priorities[i] -= 0.3\n                elif i % 5 == 3:\n                    priorities[i] += 0.9\n                else:\n                    priorities[i] -= 0.1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:51:57", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n            if item % 4 == 0:\n                priorities[i] += 2.0\n            elif item % 4 == 1:\n                priorities[i] -= 1.5\n            else:\n                priorities[i] += 0.75\n\n            if item > 20:\n                priorities[i] *= 1.5\n                priorities[i] += 2.5\n                priorities[i] /= 2.0\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:52:20", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1 / bins[i]\n        else:\n            if item > 0:\n                if bins[i] > 0:\n                    ratio = item / bins[i]\n                    if ratio < 0.3:\n                        priorities[i] = 0.4\n                    elif ratio >= 0.3 and ratio < 0.6:\n                        priorities[i] = 0.7\n                    elif ratio >= 0.6 and ratio < 0.8:\n                        priorities[i] = 0.9\n                    else:\n                        priorities[i] = 1.0\n                else:\n                    priorities[i] = 0.1\n            else:\n                priorities[i] = 0.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.2:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n            elif item >= bins[i] * 0.8:\n                priorities[i] = (bins[i] - item) / (2 * bins[i])\n            else:\n                if bins[i] % 2 == 0:\n                    priorities[i] = 0.6 * item / bins[i]\n                else:\n                    priorities[i] = 0.8 * item / bins[i]\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.2:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n            elif item >= bins[i] * 0.8:\n                priorities[i] = (bins[i] - item) / (2 * bins[i])\n            else:\n                if bins[i] % 2 == 0:\n                    if item % 2 == 0:\n                        priorities[i] = 0.6 * item / bins[i]\n                    else:\n                        priorities[i] = 0.7 * item / bins[i]\n                else:\n                    if item % 2 == 0:\n                        priorities[i] = 0.8 * item / bins[i]\n                    else:\n                        priorities[i] = 0.9 * item / bins[i]\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:52:23", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1 / bins[i]\n        else:\n            if item > 0:\n                if bins[i] > 0:\n                    ratio = item / bins[i]\n                    if ratio < 0.3:\n                        priorities[i] = 0.4\n                    elif ratio >= 0.3 and ratio < 0.6:\n                        priorities[i] = 0.7\n                    elif ratio >= 0.6 and ratio < 0.8:\n                        priorities[i] = 0.9\n                    else:\n                        priorities[i] = 1.0\n                else:\n                    priorities[i] = 0.1\n            else:\n                priorities[i] = 0.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.2:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n            elif item >= bins[i] * 0.8:\n                priorities[i] = (bins[i] - item) / (2 * bins[i])\n            else:\n                if bins[i] % 2 == 0:\n                    priorities[i] = 0.6 * item / bins[i]\n                else:\n                    priorities[i] = 0.8 * item / bins[i]\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.2:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n            elif item >= bins[i] * 0.8:\n                priorities[i] = (bins[i] - item) / (2 * bins[i])\n            else:\n                if bins[i] % 2 == 0:\n                    priorities[i] = 0.6 * item / bins[i]\n                else:\n                    priorities[i] = 0.8 * item / bins[i]\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:52:26", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1 / bins[i]\n        else:\n            if item > 0:\n                if bins[i] > 0:\n                    ratio = item / bins[i]\n                    if ratio < 0.3:\n                        priorities[i] = 0.4\n                    elif ratio >= 0.3 and ratio < 0.6:\n                        priorities[i] = 0.7\n                    elif ratio >= 0.6 and ratio < 0.8:\n                        priorities[i] = 0.9\n                    else:\n                        priorities[i] = 1.0\n                else:\n                    priorities[i] = 0.1\n            else:\n                priorities[i] = 0.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.2:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n            elif item >= bins[i] * 0.8:\n                priorities[i] = (bins[i] - item) / (2 * bins[i])\n            else:\n                if bins[i] % 2 == 0:\n                    priorities[i] = 0.6 * item / bins[i]\n                else:\n                    priorities[i] = 0.8 * item / bins[i]\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            if item > 0:\n                if bins[i] > 0:\n                    if bins[i] % 2 == 0:\n                        priorities[i] = (2 * item) / (3 * bins[i])\n                    else:\n                        if item < bins[i] * 0.5:\n                            priorities[i] = (bins[i] - item) / bins[i]\n                        else:\n                            if bins[i] % 3 == 0:\n                                priorities[i] = 0.7 * item / bins[i]\n                            else:\n                                priorities[i] = 0.8 * item / bins[i]\n                else:\n                    priorities[i] = 0.3\n            else:\n                priorities[i] = 0.0\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:52:29", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1 / bins[i]\n        else:\n            if item > 0:\n                if bins[i] > 0:\n                    ratio = item / bins[i]\n                    if ratio < 0.3:\n                        priorities[i] = 0.4\n                    elif ratio >= 0.3 and ratio < 0.6:\n                        priorities[i] = 0.7\n                    elif ratio >= 0.6 and ratio < 0.8:\n                        priorities[i] = 0.9\n                    else:\n                        priorities[i] = 1.0\n                else:\n                    priorities[i] = 0.1\n            else:\n                priorities[i] = 0.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.2:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n            elif item >= bins[i] * 0.8:\n                priorities[i] = (bins[i] - item) / (2 * bins[i])\n            else:\n                if bins[i] % 2 == 0:\n                    priorities[i] = 0.6 * item / bins[i]\n                else:\n                    priorities[i] = 0.8 * item / bins[i]\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i] * 0.2:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n            elif item >= bins[i] * 0.8:\n                priorities[i] = (bins[i] - item) / (2 * bins[i])\n            else:\n                if bins[i] % 2 == 0:\n                    priorities[i] = 0.6 * item / bins[i]\n                else:\n                    priorities[i] = 0.8 * item / bins[i]\n                \n                if item > 100 and bins[i] < 100:\n                    priorities[i] *= 1.2\n                else:\n                    if item < 50 and bins[i] > 50:\n                        priorities[i] -= 0.2\n                    elif item > 70 and bins[i] < 70:\n                        priorities[i] += 0.3\n                    else:\n                        priorities[i] = 1.0 - priorities[i]\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:52:39", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            priorities[i] = (item + bins[i]) / (2 * bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.25:\n                priorities[i] = 0.3\n            elif ratio >= 0.25 and ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 0.75:\n                priorities[i] = 0.7\n            elif ratio >= 0.75 and ratio < 1:\n                priorities[i] = 0.9\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.2:\n                priorities[i] = 0.2\n            elif ratio >= 0.2 and ratio < 0.4:\n                priorities[i] = 0.4\n            elif ratio >= 0.4 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:52:42", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            priorities[i] = (item + bins[i]) / (2 * bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.25:\n                priorities[i] = 0.3\n            elif ratio >= 0.25 and ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 0.75:\n                priorities[i] = 0.7\n            elif ratio >= 0.75 and ratio < 1:\n                priorities[i] = 0.9\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            remaining_capacity_ratio = (max_bin_capacity - bins[i]) / max_bin_capacity\n            item_ratio = item / bins[i]\n            \n            if remaining_capacity_ratio < 0.2:\n                priorities[i] = 0.2\n            elif item_ratio < 0.25:\n                priorities[i] = 0.3\n            elif item_ratio >= 0.25 and item_ratio < 0.5:\n                priorities[i] = 0.5\n            elif item_ratio >= 0.5 and item_ratio < 0.75:\n                priorities[i] = 0.7\n            elif item_ratio >= 0.75 and item_ratio < 1:\n                priorities[i] = 0.9\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:52:45", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            priorities[i] = (item + bins[i]) / (2 * bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.25:\n                priorities[i] = 0.3\n            elif ratio >= 0.25 and ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 0.75:\n                priorities[i] = 0.7\n            elif ratio >= 0.75 and ratio < 1:\n                priorities[i] = 0.9\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.25:\n                priorities[i] = 0.3\n            elif ratio >= 0.25 and ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 0.75:\n                priorities[i] = 0.7\n            elif ratio >= 0.75 and ratio < 1:\n                priorities[i] = 0.9\n            else:\n                priorities[i] = 1.0\n            if bins[i] % 2 == 0:\n                priorities[i] = priorities[i] * 1.2\n            else:\n                priorities[i] = priorities[i] * 0.8\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:52:48", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            priorities[i] = (item + bins[i]) / (2 * bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.25:\n                priorities[i] = 0.3\n            elif ratio >= 0.25 and ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 0.75:\n                priorities[i] = 0.7\n            elif ratio >= 0.75 and ratio < 1:\n                priorities[i] = 0.9\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:52:58", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < 0.5 * bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > 1.5 * bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = item * bins[i] / (item + bins[i])\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    if bins[i] % 2 == 0:\n                        priorities[i] = 0.5\n                    else:\n                        priorities[i] = 0.25\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    if bins[i] % 2 == 0:\n                        priorities[i] = 0.5\n                    else:\n                        if item < 0.5 * bins[i]:\n                            priorities[i] = item / bins[i]\n                        else:\n                            if item > 1.5 * bins[i]:\n                                priorities[i] = bins[i] / item\n                            else:\n                                priorities[i] = item * bins[i] / (item + bins[i])\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:53:01", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < 0.5 * bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > 1.5 * bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = item * bins[i] / (item + bins[i])\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    if bins[i] % 2 == 0:\n                        priorities[i] = 0.5\n                    else:\n                        priorities[i] = 0.25\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            if item < 0.5 * bins[i]:\n                priorities[i] = item / bins[i] * 0.75\n            elif item > 1.5 * bins[i]:\n                priorities[i] = bins[i] / item * 0.5\n            else:\n                if bins[i] % 2 == 0:\n                    priorities[i] = 0.8\n                else:\n                    priorities[i] = 0.6\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:53:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < 0.5 * bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > 1.5 * bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = item * bins[i] / (item + bins[i])\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    if bins[i] % 2 == 0:\n                        priorities[i] = 0.5\n                    else:\n                        priorities[i] = 0.25\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            else:\n                if bins[i] % 2 == 0:\n                    priorities[i] = 0.5 * (item / bins[i])\n                else:\n                    if item > 1.5 * bins[i]:\n                        priorities[i] = bins[i] / item\n                    else:\n                        for j in range(1, int(bins[i])):\n                            if item % j == 0:\n                                priorities[i] = j / bins[i]\n                                break\n                            else:\n                                priorities[i] = 0.1\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:53:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < 0.5 * bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > 1.5 * bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = item * bins[i] / (item + bins[i])\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    if bins[i] % 2 == 0:\n                        priorities[i] = 0.5\n                    else:\n                        priorities[i] = 0.25\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < 0.5 * bins[i]:\n                priorities[i] = (item / bins[i]) * (1 - 0.1 * i)\n            elif item > 1.5 * bins[i]:\n                priorities[i] = (bins[i] / item) * (1 + 0.05 * i)\n            else:\n                if bins[i] % 2 == 0:\n                    priorities[i] = (item * bins[i] / (item + bins[i])) + 0.2\n                else:\n                    priorities[i] = (item * bins[i] / (item + bins[i])) - 0.1\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:53:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5:\n            priorities[i] = 1.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5 and item < 3 * bins[i]:\n            priorities[i] = 1.5\n        elif item >= 3 * bins[i] and item < 4 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 3.0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:53:16", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5:\n            priorities[i] = 1.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        if bins[i] % 2 == 0:\n            priorities[i] += 0.2\n        else:\n            priorities[i] = 1.0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:53:19", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5:\n            priorities[i] = 1.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 2.0\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.2\n        else:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.4:\n            priorities[i] = 0.4\n        elif priorities[i] > 2.0:\n            priorities[i] = 2.0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:53:22", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5:\n            priorities[i] = 1.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5:\n            priorities[i] = 1.5\n\n    priorities = np.where(bins < np.mean(bins), priorities * 1.2, priorities)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:53:34", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n            \n            # Adding a secondary adjustment based on bin capacity\n            if bins[i] < 0.5 * item:\n                priorities[i] *= 0.8\n            elif bins[i] < item:\n                priorities[i] *= 0.6\n            elif bins[i] > 1.5 * item:\n                priorities[i] *= 1.2\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:53:37", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n        \n        if bins[i] % 2 == 0:\n            priorities[i] *= 1.1\n        else:\n            priorities[i] *= 0.9\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:53:40", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.25:\n                priorities[i] = 0.3\n            elif ratio >= 0.25 and ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 0.75:\n                priorities[i] = 0.7\n            else:\n                priorities[i] = 0.9\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:53:43", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n                \n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:53:55", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    # Additional and more complex logic\n    for i in range(len(priorities)):\n        if item % 7 == 0:\n            priorities[i] += 2.0\n        elif item % 6 == 0:\n            priorities[i] -= 1.0\n\n    for i in range(len(priorities)):\n        if i % 5 == 0:\n            priorities[i] += 0.5\n        elif i % 5 == 1:\n            priorities[i] -= 0.25\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:54:00", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    # New complex logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.5\n        elif priorities[i] < 1.0:\n            priorities[i] += 0.5\n        else:\n            priorities[i] += 1.5\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:54:04", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n            if item % 7 == 0:\n                priorities[i] += 2.0\n\n            if i % 5 == 0:\n                priorities[i] *= 1.25\n\n            if item % 11 == 0:\n                priorities[i] -= 0.75\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:54:09", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if item % 2 == 0 and item < 20:\n                priorities[i] += 0.5\n\n            if item > 5:\n                priorities[i] += 0.75\n\n            if item % 3 == 0:\n                priorities[i] *= 1.5\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 2\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.25\n\n            if item % 5 == 0:\n                priorities[i] += 1.0\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:54:31", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n            if ratio < 0.2:\n                priorities[i] += 0.1\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n            if ratio >= 0.4 and ratio < 0.6:\n                priorities[i] -= 0.2\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n            if ratio >= 0.6 and ratio < 0.8:\n                priorities[i] += 0.3\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n                if ratio >= 0.7:\n                    priorities[i] -= 0.1\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:54:34", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-20 * (ratio - 0.3))) + 0.2\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.5))) + 0.3\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.7))) + 0.4\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.5\n\n        if i % 2 == 0:\n            priorities[i] += 0.1\n        elif i % 3 == 1:\n            priorities[i] -= 0.05\n        else:\n            priorities[i] += 0.2\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:54:38", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        elif i % 5 == 1:\n            priorities[i] -= 0.15\n        elif i % 5 == 2:\n            priorities[i] += 0.2\n        elif i % 5 == 3:\n            for j in range(2):\n                priorities[i] -= 0.05\n        else:\n            priorities[i] *= 1.5\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:54:43", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n        if priorities[i] > 0.8:\n            priorities[i] *= 1.2\n        elif 0.6 < priorities[i] <= 0.8:\n            priorities[i] *= 1.1\n        else:\n            priorities[i] *= 0.9\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:54:57", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 2:\n                    priorities[i] = 0.8\n                elif priority > 1:\n                    priorities[i] = 0.6\n                else:\n                    priorities[i] = 0.4\n            else:\n                for j in range(i, len(bins)):\n                    if bins[j] - item > 0:\n                        priorities[j] = 0.5 * (bins[j] - item)\n                if priorities[i] == 0:\n                    priorities[i] = -0.2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n        if item % 2 == 0:\n            priorities[index] += 0.1\n        else:\n            priorities[index] -= 0.1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(input_array: np.ndarray) -> np.ndarray:\n    output_array = np.zeros_like(input_array)\n\n    for i in range(len(input_array)):\n        if input_array[i] % 2 == 0:\n            output_array[i] = input_array[i] * 2\n        else:\n            for j in range(1, input_array[i] + 1):\n                if j % 2 == 0:\n                    output_array[i] += j\n                else:\n                    output_array[i] -= j\n\n    return output_array", "strategy": []}
{"timestamp": "2025-04-27 06:54:59", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 2:\n                    priorities[i] = 0.8\n                elif priority > 1:\n                    priorities[i] = 0.6\n                else:\n                    priorities[i] = 0.4\n            else:\n                for j in range(i, len(bins)):\n                    if bins[j] - item > 0:\n                        priorities[j] = 0.5 * (bins[j] - item)\n                if priorities[i] == 0:\n                    priorities[i] = -0.2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n        if item % 2 == 0:\n            priorities[index] += 0.1\n        else:\n            priorities[index] -= 0.1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def more_complex_function(var1: int, var2: str, var3: float, var4: list) -> str:\n    \n    result = \"\"\n    \n    if var1 % 2 == 0:\n        for i in range(var1):\n            if i % 2 == 0:\n                result += var2.upper()\n            else:\n                result += var2.lower()\n    else:\n        for item in var4:\n            if item > var3:\n                result += str(item) + \" \"\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 06:55:02", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 2:\n                    priorities[i] = 0.8\n                elif priority > 1:\n                    priorities[i] = 0.6\n                else:\n                    priorities[i] = 0.4\n            else:\n                for j in range(i, len(bins)):\n                    if bins[j] - item > 0:\n                        priorities[j] = 0.5 * (bins[j] - item)\n                if priorities[i] == 0:\n                    priorities[i] = -0.2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n        if item % 2 == 0:\n            priorities[index] += 0.1\n        else:\n            priorities[index] -= 0.1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v3(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"An advanced version of the priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[i] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[i] = 0.7\n                elif priority >= 1.0 and priority < 2.0:\n                    priorities[i] = 0.5\n                else:\n                    priorities[i] = 0.3\n            else:\n                for j in range(i, len(bins)):\n                    if bins[j] - item > 0:\n                        priorities[j] = 0.5 * (bins[j] - item)\n                if priorities[i] == 0:\n                    priorities[i] = -0.2\n        \n        if item % 3 == 0:\n            priorities[i] += 0.2\n        elif item % 2 == 0:\n            priorities[i] += 0.1\n        else:\n            priorities[i] -= 0.1\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:55:04", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 2:\n                    priorities[i] = 0.8\n                elif priority > 1:\n                    priorities[i] = 0.6\n                else:\n                    priorities[i] = 0.4\n            else:\n                for j in range(i, len(bins)):\n                    if bins[j] - item > 0:\n                        priorities[j] = 0.5 * (bins[j] - item)\n                if priorities[i] == 0:\n                    priorities[i] = -0.2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n        if item % 2 == 0:\n            priorities[index] += 0.1\n        else:\n            priorities[index] -= 0.1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray, target: float) -> float:\n    result = 0.0\n    for i in range(len(data)):\n        if data[i] == target:\n            result += data[i] * 2\n        elif data[i] < target:\n            result += data[i] * 1.5\n        else:\n            result += data[i] * 0.5\n    \n    if result > 100:\n        result *= 0.9\n    elif result > 50:\n        result *= 0.8\n    else:\n        result *= 0.7\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 06:55:11", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Further improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n\n        if priorities[i] > 2.0:\n            priorities[i] += 0.7\n        elif priorities[i] > 1.5:\n            priorities[i] += 0.5\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.5\n        else:\n            priorities[i] += 0.3\n            \n        if bins[i] % 7 == 0:\n            priorities[i] *= 1.8\n        elif bins[i] % 4 == 0:\n            priorities[i] *= 1.4\n        else:\n            priorities[i] *= 1.2\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "import numpy as np\n\n\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n        \n        if item % 5 == 0:\n            priorities[i] *= 1.3\n        elif item % 3 == 0:\n            priorities[i] *= 1.1\n        else:\n            priorities[i] *= 1.0\n        \n        if bins[i] > 10:\n            priorities[i] += 0.5\n        elif bins[i] < 5:\n            priorities[i] -= 0.3\n        else:\n            priorities[i] += 0.1\n        \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:55:15", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Further improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n\n        if priorities[i] > 2.0:\n            priorities[i] += 0.7\n        elif priorities[i] > 1.5:\n            priorities[i] += 0.5\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.5\n        else:\n            priorities[i] += 0.3\n            \n        if bins[i] % 7 == 0:\n            priorities[i] *= 1.8\n        elif bins[i] % 4 == 0:\n            priorities[i] *= 1.4\n        else:\n            priorities[i] *= 1.2\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Complex priority algorithm.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n                \n            if bins[i] % 7 == 0:\n                priorities[i] *= 1.8\n            elif bins[i] % 4 == 0:\n                priorities[i] *= 1.4\n            else:\n                priorities[i] *= 1.2\n            \n            if item % 3 == 0:\n                priorities[i] -= 0.2\n            elif item % 5 == 0:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:55:18", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Further improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n\n        if priorities[i] > 2.0:\n            priorities[i] += 0.7\n        elif priorities[i] > 1.5:\n            priorities[i] += 0.5\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.5\n        else:\n            priorities[i] += 0.3\n            \n        if bins[i] % 7 == 0:\n            priorities[i] *= 1.8\n        elif bins[i] % 4 == 0:\n            priorities[i] *= 1.4\n        else:\n            priorities[i] *= 1.2\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n            \n            if item % 10 == 0:\n                priorities[i] *= 1.8\n            elif item % 5 == 0:\n                priorities[i] *= 1.5\n            else:\n                priorities[i] *= 1.2\n        \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:55:20", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Further improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n\n        if priorities[i] > 2.0:\n            priorities[i] += 0.7\n        elif priorities[i] > 1.5:\n            priorities[i] += 0.5\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.5\n        else:\n            priorities[i] += 0.3\n            \n        if bins[i] % 7 == 0:\n            priorities[i] *= 1.8\n        elif bins[i] % 4 == 0:\n            priorities[i] *= 1.4\n        else:\n            priorities[i] *= 1.2\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_function(input_data: np.ndarray) -> np.ndarray:\n    output_data = np.zeros_like(input_data)\n    \n    for i in range(len(input_data)):\n        if input_data[i] % 2 == 0:\n            output_data[i] = input_data[i] * 2\n        elif input_data[i] % 3 == 0:\n            output_data[i] = input_data[i] * 3\n        else:\n            temp = input_data[i]\n            count = 0\n            while temp > 1:\n                temp /= 2\n                count += 1\n            output_data[i] = count * input_data[i]\n            \n            if count > 5:\n                output_data[i] += 10\n            elif count > 3:\n                output_data[i] -= 5\n    \n    return output_data\n```", "strategy": []}
{"timestamp": "2025-04-27 06:55:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.25:\n                priorities[i] = 0.3\n            elif ratio >= 0.25 and ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 0.75:\n                priorities[i] = 0.7\n            else:\n                priorities[i] = 0.9\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            capacity_ratio = bins[i] / item\n            if capacity_ratio < 0.5:\n                priorities[i] = 0.5\n            else:\n                priority_diff = (item - bins[i]) / item\n                if priority_diff < 0.1:\n                    priorities[i] = 0.2\n                elif priority_diff >= 0.1 and priority_diff < 0.3:\n                    priorities[i] = 0.4\n                elif priority_diff >= 0.3 and priority_diff < 0.5:\n                    priorities[i] = 0.6\n                elif priority_diff >= 0.5 and priority_diff < 0.7:\n                    priorities[i] = 0.8\n                else:\n                    priorities[i] = 1.0\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:55:31", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.25:\n                priorities[i] = 0.3\n            elif ratio >= 0.25 and ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 0.75:\n                priorities[i] = 0.7\n            else:\n                priorities[i] = 0.9\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            remaining_space = bins[i]\n            priority = 0.0\n            while remaining_space < item:\n                if priority < 1.0:\n                    priority += 0.1\n                remaining_space += bins[i]\n            priorities[i] = priority\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:55:34", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.25:\n                priorities[i] = 0.3\n            elif ratio >= 0.25 and ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 0.75:\n                priorities[i] = 0.7\n            else:\n                priorities[i] = 0.9\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Further improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            remaining_space = bins[i] - item\n            if remaining_space <= 0.1 * bins[i]:\n                priorities[i] = 0.2\n            elif remaining_space > 0.1 * bins[i] and remaining_space <= 0.3 * bins[i]:\n                priorities[i] = 0.4\n            elif remaining_space > 0.3 * bins[i] and remaining_space <= 0.5 * bins[i]:\n                priorities[i] = 0.6\n            elif remaining_space > 0.5 * bins[i] and remaining_space <= 0.7 * bins[i]:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:55:37", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.25:\n                priorities[i] = 0.3\n            elif ratio >= 0.25 and ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 0.75:\n                priorities[i] = 0.7\n            else:\n                priorities[i] = 0.9\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.05:\n                priorities[i] = 0.1\n            elif priority_diff >= 0.05 and priority_diff < 0.2:\n                priorities[i] = 0.3\n            elif priority_diff >= 0.2 and priority_diff < 0.4:\n                priorities[i] = 0.5\n            elif priority_diff >= 0.4 and priority_diff < 0.6:\n                priorities[i] = 0.7\n            elif priority_diff >= 0.6 and priority_diff < 0.8:\n                priorities[i] = 0.9\n            else:\n                priorities[i] = 0.95\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:55:45", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more advanced version of `priority` function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray, target: float) -> np.ndarray:\n    result = np.zeros_like(data)\n\n    for i in range(len(data)):\n        if data[i] == target:\n            result[i] = 1.0\n        elif data[i] < target:\n            result[i] = 0.5\n        else:\n            count = 0\n            for val in data:\n                if val < target:\n                    count += 1\n            result[i] = count / len(data)\n\n    return result", "strategy": []}
{"timestamp": "2025-04-27 06:55:48", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more advanced version of `priority` function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more advanced version of `priority` function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:55:51", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more advanced version of `priority` function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"An even more advanced and complex version of the priority calculation function.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:55:53", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more advanced version of `priority` function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = item / bins[i] if bins[i] % item == 0 else item / bins[i] + 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            priorities[i] = priorities[i] + (0.2 if priorities[i] < 0.3 else (0.4 if priorities[i] < 0.6 else 0.6))\n            priorities[i] = min(priorities[i], 1.0)\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:56:01", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n    \n    # Adding additional logic to further refine the priorities\n    for j in range(len(priorities)):\n        if priorities[j] > 1.5:\n            priorities[j] *= 0.9\n        elif priorities[j] < 0.5:\n            priorities[j] *= 1.1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:56:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count > 2:\n                priorities[i] = count + item / bins[i] + 0.5\n            elif count == 1:\n                priorities[i] = count + item / bins[i] + 0.4\n            else:\n                priorities[i] = count + item / bins[i] + 0.3\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:56:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n            priorities[i] *= 1.1\n    \n    priorities = np.clip(priorities, 0, 2)  # Clip priorities between 0 and 2\n    priorities = np.sort(priorities)[::-1]  # Sort priorities in descending order\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:56:09", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = count * (item / bins[i]) + 0.4\n            else:\n                priorities[i] = np.sqrt(count * item / bins[i]) + 0.5\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:56:21", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    if bins[i] % 2 == 0:\n                        priorities[i] = item / bins[i] + 0.2\n                    elif bins[i] % 3 == 0:\n                        priorities[i] = item / bins[i] + 0.3\n                    else:\n                        priorities[i] = item / bins[i] + 0.5\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.5\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.2\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.5\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.2\n            if bins[i] % 3 == 0:\n                priorities[i] += 0.3\n            if bins[i] % item == 0:\n                priorities[i] += 0.1\n            if item > bins[i]/2:\n                priorities[i] -= 0.2\n            if item > bins[i]/3:\n                priorities[i] -= 0.1\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:56:24", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    if bins[i] % 2 == 0:\n                        priorities[i] = item / bins[i] + 0.2\n                    elif bins[i] % 3 == 0:\n                        priorities[i] = item / bins[i] + 0.3\n                    else:\n                        priorities[i] = item / bins[i] + 0.5\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.5\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.2\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif item < bins[i]:\n            priorities[i] = min(item / bins[i], 0.7)\n        else:\n            remainder = bins[i] % item\n            if remainder == 0:\n                priorities[i] = max((bins[i] - item) / bins[i], 0.3)\n            else:\n                if remainder % 2 == 0:\n                    priorities[i] = min(item / bins[i] + 0.1, 0.8)\n                elif remainder % 3 == 0:\n                    priorities[i] = min(item / bins[i] + 0.2, 0.9)\n                else:\n                    priorities[i] = min(item / bins[i] + 0.3, 1.0)\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:56:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    if bins[i] % 2 == 0:\n                        priorities[i] = item / bins[i] + 0.2\n                    elif bins[i] % 3 == 0:\n                        priorities[i] = item / bins[i] + 0.3\n                    else:\n                        priorities[i] = item / bins[i] + 0.5\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.5\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.2\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.1\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.2\n            if item % 2 == 0:\n                priorities[i] += 0.1\n            if item > 5:\n                priorities[i] += 0.3\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:56:29", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    if bins[i] % 2 == 0:\n                        priorities[i] = item / bins[i] + 0.2\n                    elif bins[i] % 3 == 0:\n                        priorities[i] = item / bins[i] + 0.3\n                    else:\n                        priorities[i] = item / bins[i] + 0.5\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.5\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.2\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.5\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.2\n            if bins[i] % 3 == 0:\n                priorities[i] += 0.3\n            if item % 2 == 0:\n                priorities[i] += 0.1\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:56:39", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n            if ratio < 0.2:\n                priorities[i] += 0.1\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n            if ratio >= 0.4 and ratio < 0.6:\n                priorities[i] -= 0.2\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n            if ratio >= 0.6 and ratio < 0.8:\n                priorities[i] += 0.3\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n                if ratio >= 0.7:\n                    priorities[i] -= 0.1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n            if ratio < 0.2:\n                priorities[i] += 0.1\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n            if ratio >= 0.4 and ratio < 0.6:\n                priorities[i] -= 0.2\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n            if ratio >= 0.6 and ratio < 0.8:\n                priorities[i] += 0.3\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n                if ratio >= 0.7:\n                    priorities[i] -= 0.1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:56:43", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n            if ratio < 0.2:\n                priorities[i] += 0.1\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n            if ratio >= 0.4 and ratio < 0.6:\n                priorities[i] -= 0.2\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n            if ratio >= 0.6 and ratio < 0.8:\n                priorities[i] += 0.3\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n                if ratio >= 0.7:\n                    priorities[i] -= 0.1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n            if ratio < 0.2:\n                priorities[i] += 0.1\n        elif i % 5 == 1:\n            priorities[i] -= 0.15\n            if ratio >= 0.4 and ratio < 0.6:\n                priorities[i] -= 0.2\n        elif i % 5 == 2:\n            priorities[i] += 0.2\n            if ratio >= 0.6 and ratio < 0.8:\n                priorities[i] += 0.3\n        elif i % 5 == 3:\n            priorities[i] -= 0.1\n            if ratio >= 0.7:\n                priorities[i] += 0.1\n        else:\n            for j in range(4):\n                priorities[i] -= 0.05\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:56:47", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n            if ratio < 0.2:\n                priorities[i] += 0.1\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n            if ratio >= 0.4 and ratio < 0.6:\n                priorities[i] -= 0.2\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n            if ratio >= 0.6 and ratio < 0.8:\n                priorities[i] += 0.3\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n                if ratio >= 0.7:\n                    priorities[i] -= 0.1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 3 == 0:\n            priorities[i] += 0.2\n            if ratio < 0.2:\n                priorities[i] += 0.1\n        elif i % 3 == 1:\n            priorities[i] -= 0.1\n            if ratio >= 0.4 and ratio < 0.6:\n                priorities[i] -= 0.2\n        else:\n            priorities[i] += 0.1\n            for j in range(2):\n                priorities[i] -= 0.05\n                if ratio >= 0.7:\n                    priorities[i] -= 0.1\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:56:51", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n            if ratio < 0.2:\n                priorities[i] += 0.1\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n            if ratio >= 0.4 and ratio < 0.6:\n                priorities[i] -= 0.2\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n            if ratio >= 0.6 and ratio < 0.8:\n                priorities[i] += 0.3\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n                if ratio >= 0.7:\n                    priorities[i] -= 0.1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "from typing import List\n\ndef complex_priority(item: float, bins: List[float]) -> List[float]:\n    priorities = []\n    for i, bin_capacity in enumerate(bins):\n        ratio = item / bin_capacity\n        priority = 0\n\n        if ratio < 0.1:\n            priority = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priority = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priority = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priority = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priority = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priority += 0.25\n            if ratio < 0.2:\n                priority += 0.1\n        elif i % 4 == 1:\n            priority -= 0.1\n            if ratio >= 0.4 and ratio < 0.6:\n                priority -= 0.2\n        elif i % 4 == 2:\n            priority += 0.15\n            if ratio >= 0.6 and ratio < 0.8:\n                priority += 0.3\n        else:\n            for j in range(3):\n                priority -= 0.05\n                if ratio >= 0.7:\n                    priority -= 0.1\n        \n        priorities.append(priority)\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:57:08", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.2\n            elif item + bins[i] > 100:\n                priorities[i] -= 0.1\n            else:\n                priorities[i] += 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.2\n            elif item + bins[i] > 100:\n                priorities[i] -= 0.1\n            else:\n                priorities[i] += 0.3\n                \n            if item + bins[i] < 50:\n                priorities[i] *= 1.2\n            elif item + bins[i] < 100:\n                priorities[i] *= 1.1\n            else:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.1\n            elif item % 3 == 0:\n                priorities[i] += 0.2\n            else:\n                priorities[i] -= 0.1\n                \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:57:12", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.2\n            elif item + bins[i] > 100:\n                priorities[i] -= 0.1\n            else:\n                priorities[i] += 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.2\n            elif item + bins[i] > 100:\n                priorities[i] -= 0.1\n            else:\n                priorities[i] += 0.3\n        \n        if bins[i] < 50:\n            priorities[i] *= 1.2\n        elif bins[i] < 30:\n            priorities[i] *= 1.5\n        elif bins[i] < 20:\n            priorities[i] *= 2.0\n        \n        for j in range(i):\n            if bins[i] > bins[j]:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:57:17", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.2\n            elif item + bins[i] > 100:\n                priorities[i] -= 0.1\n            else:\n                priorities[i] += 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.2\n            elif item + bins[i] > 100:\n                priorities[i] -= 0.1\n            else:\n                priorities[i] += 0.3\n            \n            if item > bins[i] + 50:\n                priorities[i] *= 1.7\n            elif item > bins[i] + 30:\n                priorities[i] *= 1.4\n            elif item > bins[i] + 20:\n                priorities[i] *= 1.2\n            \n            if item % bins[i] == 1:\n                priorities[i] += 0.1\n            elif item + bins[i] > 150:\n                priorities[i] -= 0.2\n            else:\n                priorities[i] += 0.4\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:57:20", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.2\n            elif item + bins[i] > 100:\n                priorities[i] -= 0.1\n            else:\n                priorities[i] += 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.2\n            elif item + bins[i] > 100:\n                priorities[i] -= 0.1\n            else:\n                priorities[i] += 0.3\n                \n            if item % 2 == 0:\n                priorities[i] += 0.5\n            else:\n                priorities[i] -= 0.2\n                \n            if item < 10 and bins[i] < 5:\n                priorities[i] += 0.7\n            elif item > 50 or bins[i] > 30:\n                priorities[i] -= 0.4\n            else:\n                priorities[i] += 0.1\n    \n    return priorities  ", "strategy": []}
{"timestamp": "2025-04-27 06:58:00", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    # New complex logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.5\n        elif priorities[i] < 1.0:\n            priorities[i] += 0.5\n        else:\n            priorities[i] += 1.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n            \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n            \n            if item % 2 == 0:\n                priorities[i] += 0.25\n            \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n            \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n            \n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n            \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n            \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n            \n            if item % 5 == 0:\n                priorities[i] += 1.5\n            \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n    \n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n    \n    # New complex logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.5\n        elif priorities[i] < 1.0:\n            priorities[i] += 0.5\n        else:\n            priorities[i] += 1.5\n    \n    # Additional complex logic\n    for i in range(len(priorities)):\n        if i % 5 == 0:\n            priorities[i] += 2.0\n        elif i % 5 == 1:\n            priorities[i] -= 1.0\n        elif i % 5 == 2:\n            priorities[i] += 1.5\n        elif i % 5 == 3:\n            priorities[i] -= 0.5\n        else:\n            priorities[i] += 0.75\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:58:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    # New complex logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.5\n        elif priorities[i] < 1.0:\n            priorities[i] += 0.5\n        else:\n            priorities[i] += 1.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    # New complex logic\n    new_priorities = np.zeros_like(priorities)\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            new_priorities[i] = priorities[i] - 0.5\n        elif priorities[i] < 1.0:\n            new_priorities[i] = priorities[i] + 0.5\n        else:\n            new_priorities[i] = priorities[i] + 1.5\n\n    return new_priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:58:12", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    # New complex logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.5\n        elif priorities[i] < 1.0:\n            priorities[i] += 0.5\n        else:\n            priorities[i] += 1.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.5\n        elif priorities[i] < 1.0:\n            priorities[i] += 0.5\n        else:\n            priorities[i] += 1.5\n\n    # New complex logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.25:\n            priorities[i] -= 0.75\n        elif priorities[i] < 0.75:\n            priorities[i] += 0.25\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:58:18", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    # New complex logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.5\n        elif priorities[i] < 1.0:\n            priorities[i] += 0.5\n        else:\n            priorities[i] += 1.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    # New complex logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.5\n        elif priorities[i] < 1.0:\n            priorities[i] += 0.5\n        else:\n            priorities[i] += 1.5\n\n    # Extra complex logic\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:58:37", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n        if item % 2 == 0:\n            priorities[index] += 0.1\n        else:\n            priorities[index] -= 0.1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n        if item % 2 == 0:\n            priorities[index] += 0.1\n        else:\n            priorities[index] -= 0.1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "import numpy as np\n\n\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"A complex function to determine priority for each bin based on item size and bin capacities.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n        if item % 2 == 0:\n            priorities[index] += 0.1\n        else:\n            priorities[index] -= 0.1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:58:40", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n        if item % 2 == 0:\n            priorities[index] += 0.1\n        else:\n            priorities[index] -= 0.1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n        if item % 2 == 0:\n            priorities[index] += 0.1\n        else:\n            priorities[index] -= 0.1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.3:\n                    priorities[index] = 0.9\n                elif priority >= 0.3 and priority < 0.6:\n                    priorities[index] = 0.7\n                elif priority >= 0.6 and priority < 0.9:\n                    priorities[index] = 0.5\n                else:\n                    priorities[index] = 0.3\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.1\n                else:\n                    priorities[index] = 0.0\n        if item % 2 == 0:\n            priorities[index] += 0.2\n        else:\n            priorities[index] -= 0.2\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:58:43", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n        if item % 2 == 0:\n            priorities[index] += 0.1\n        else:\n            priorities[index] -= 0.1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n        if item % 2 == 0:\n            priorities[index] += 0.1\n        else:\n            priorities[index] -= 0.1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(data)\n    \n    for i in range(len(data)):\n        if data[i] % 2 == 0:\n            result[i] = data[i] * 2\n        else:\n            result[i] = data[i] + 1\n        \n        if data[i] > 10:\n            result[i] -= 5\n        elif data[i] < 5:\n            result[i] += 5\n        \n        if data[i] == 0:\n            result[i] = 0\n        elif data[i] == 1:\n            result[i] = 1\n        \n    return result\n```", "strategy": []}
{"timestamp": "2025-04-27 06:58:46", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n        if item % 2 == 0:\n            priorities[index] += 0.1\n        else:\n            priorities[index] -= 0.1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n        if item % 2 == 0:\n            priorities[index] += 0.1\n        else:\n            priorities[index] -= 0.1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "import math\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n        if item % 2 == 0:\n            priorities[index] += 0.1\n        else:\n            priorities[index] -= 0.1\n        if bin_capacity % 2 == 0:\n            priorities[index] += 0.05\n        else:\n            priorities[index] -= 0.05\n        priorities[index] = round(priorities[index], 2)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:58:56", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.5\n        elif priorities[i] < 1.0:\n            priorities[i] += 0.5\n        else:\n            priorities[i] += 1.5\n\n    # New complex logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.25:\n            priorities[i] -= 0.75\n        elif priorities[i] < 0.75:\n            priorities[i] += 0.25\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    # New complex logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.5\n        elif priorities[i] < 1.0:\n            priorities[i] += 0.5\n        else:\n            priorities[i] += 1.5\n\n    # Extra complex logic\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    # New complex logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.25:\n            priorities[i] -= 0.5\n        elif priorities[i] < 1.0:\n            priorities[i] += 0.5\n        else:\n            priorities[i] += 1.5\n\n    # Extra complex logic\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:59:01", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.5\n        elif priorities[i] < 1.0:\n            priorities[i] += 0.5\n        else:\n            priorities[i] += 1.5\n\n    # New complex logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.25:\n            priorities[i] -= 0.75\n        elif priorities[i] < 0.75:\n            priorities[i] += 0.25\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    # New complex logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.5\n        elif priorities[i] < 1.0:\n            priorities[i] += 0.5\n        else:\n            priorities[i] += 1.5\n\n    # Extra complex logic\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.5\n        elif priorities[i] < 1.0:\n            priorities[i] += 0.5\n        else:\n            priorities[i] += 1.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    # Brand new logic\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:59:08", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.5\n        elif priorities[i] < 1.0:\n            priorities[i] += 0.5\n        else:\n            priorities[i] += 1.5\n\n    # New complex logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.25:\n            priorities[i] -= 0.75\n        elif priorities[i] < 0.75:\n            priorities[i] += 0.25\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    # New complex logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.5\n        elif priorities[i] < 1.0:\n            priorities[i] += 0.5\n        else:\n            priorities[i] += 1.5\n\n    # Extra complex logic\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    # New complex logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.5\n        elif priorities[i] < 1.0:\n            priorities[i] += 0.5\n        else:\n            priorities[i] += 1.5\n\n    # Extra complex logic\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    # Additional very complex logic\n    for i in range(len(priorities)):\n        if i % 2 == 0:\n            priorities[i] *= 1.5\n        else:\n            priorities[i] = priorities[i] ** 2\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:59:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.5\n        elif priorities[i] < 1.0:\n            priorities[i] += 0.5\n        else:\n            priorities[i] += 1.5\n\n    # New complex logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.25:\n            priorities[i] -= 0.75\n        elif priorities[i] < 0.75:\n            priorities[i] += 0.25\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    # New complex logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.5\n        elif priorities[i] < 1.0:\n            priorities[i] += 0.5\n        else:\n            priorities[i] += 1.5\n\n    # Extra complex logic\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    # New complex logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.25:\n            priorities[i] -= 0.75\n        elif priorities[i] < 0.75:\n            priorities[i] += 0.25\n        else:\n            priorities[i] += 1.0\n\n    # More complex logic\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:59:32", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                \n    sorted_priorities = np.sort(priorities)[::-1]\n    max_val = sorted_priorities[0]\n    for j in range(len(priorities)):\n        if priorities[j] == max_val:\n            priorities[j] += 0.5\n        elif 0.5 * max_val <= priorities[j] <= max_val - 0.5:\n            priorities[j] += 0.3\n        else:\n            priorities[j] -= 0.2\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 1.2 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 1.1 * count + item / bins[i] + 0.3\n        \n        if priorities[i] > 2.0:\n            priorities[i] += 0.6\n        elif priorities[i] > 1.5:\n            priorities[i] += 0.4\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 1.3 * count + item / bins[i] + 0.4\n            else:\n                priorities[i] = 1.2 * count + item / bins[i] + 0.4\n        \n        if priorities[i] > 2.0:\n            priorities[i] += 0.6\n        elif priorities[i] > 1.5:\n            priorities[i] += 0.4\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.3\n        else:\n            priorities[i] -= 0.1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:59:36", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                \n    sorted_priorities = np.sort(priorities)[::-1]\n    max_val = sorted_priorities[0]\n    for j in range(len(priorities)):\n        if priorities[j] == max_val:\n            priorities[j] += 0.5\n        elif 0.5 * max_val <= priorities[j] <= max_val - 0.5:\n            priorities[j] += 0.3\n        else:\n            priorities[j] -= 0.2\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 1.2 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 1.1 * count + item / bins[i] + 0.3\n        \n        if priorities[i] > 2.0:\n            priorities[i] += 0.6\n        elif priorities[i] > 1.5:\n            priorities[i] += 0.4\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 1.2 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 1.1 * count + item / bins[i] + 0.3\n        \n        if priorities[i] > 2.0:\n            priorities[i] += 0.6\n        elif priorities[i] > 1.5:\n            priorities[i] += 0.4\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.3\n        \n        if bins[i] % 2 == 0:\n            priorities[i] *= 1.1\n        else:\n            priorities[i] *= 1.2\n        \n        if i % 2 == 0:\n            priorities[i] *= 1.5\n        else:\n            priorities[i] *= 1.3\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:59:39", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                \n    sorted_priorities = np.sort(priorities)[::-1]\n    max_val = sorted_priorities[0]\n    for j in range(len(priorities)):\n        if priorities[j] == max_val:\n            priorities[j] += 0.5\n        elif 0.5 * max_val <= priorities[j] <= max_val - 0.5:\n            priorities[j] += 0.3\n        else:\n            priorities[j] -= 0.2\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 1.2 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 1.1 * count + item / bins[i] + 0.3\n        \n        if priorities[i] > 2.0:\n            priorities[i] += 0.6\n        elif priorities[i] > 1.5:\n            priorities[i] += 0.4\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 1.3 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 1.2 * count + item / bins[i] + 0.3\n        \n        if priorities[i] > 2.5:\n            priorities[i] += 0.7\n        elif priorities[i] > 2.0:\n            priorities[i] += 0.6\n        elif priorities[i] > 1.5:\n            priorities[i] += 0.4\n        elif priorities[i] > 1.0:\n            priorities[i] += 0.2\n        else:\n            priorities[i] -= 0.1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:59:43", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                \n    sorted_priorities = np.sort(priorities)[::-1]\n    max_val = sorted_priorities[0]\n    for j in range(len(priorities)):\n        if priorities[j] == max_val:\n            priorities[j] += 0.5\n        elif 0.5 * max_val <= priorities[j] <= max_val - 0.5:\n            priorities[j] += 0.3\n        else:\n            priorities[j] -= 0.2\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 1.2 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 1.1 * count + item / bins[i] + 0.3\n        \n        if priorities[i] > 2.0:\n            priorities[i] += 0.6\n        elif priorities[i] > 1.5:\n            priorities[i] += 0.4\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 1.2 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 1.1 * count + item / bins[i] + 0.3\n                \n        if item % 2 == 0:\n            priorities[i] += 0.1\n        else:\n            priorities[i] -= 0.1\n        \n        if bins[i] % 2 == 0:\n            priorities[i] += 0.2\n        else:\n            priorities[i] -= 0.2\n        \n        if item / bins[i] > 0.5:\n            priorities[i] += 0.3\n        else:\n            priorities[i] -= 0.3\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 06:59:53", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n            if ratio < 0.2:\n                priorities[i] += 0.1\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n            if ratio >= 0.4 and ratio < 0.6:\n                priorities[i] -= 0.2\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n            if ratio >= 0.6 and ratio < 0.8:\n                priorities[i] += 0.3\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n                if ratio >= 0.7:\n                    priorities[i] -= 0.1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n            if ratio < 0.2:\n                priorities[i] += 0.1\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n            if ratio >= 0.4 and ratio < 0.6:\n                priorities[i] -= 0.2\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n            if ratio >= 0.6 and ratio < 0.8:\n                priorities[i] += 0.3\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n                if ratio >= 0.7:\n                    priorities[i] -= 0.1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n            if ratio < 0.2:\n                priorities[i] += 0.1\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n            if ratio >= 0.4 and ratio < 0.6:\n                priorities[i] -= 0.2\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n            if ratio >= 0.6 and ratio < 0.8:\n                priorities[i] += 0.3\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n                if ratio >= 0.7:\n                    priorities[i] -= 0.1\n                if j == 2 and ratio < 0.5:\n                    priorities[i] += 0.2\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 06:59:58", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n            if ratio < 0.2:\n                priorities[i] += 0.1\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n            if ratio >= 0.4 and ratio < 0.6:\n                priorities[i] -= 0.2\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n            if ratio >= 0.6 and ratio < 0.8:\n                priorities[i] += 0.3\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n                if ratio >= 0.7:\n                    priorities[i] -= 0.1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n            if ratio < 0.2:\n                priorities[i] += 0.1\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n            if ratio >= 0.4 and ratio < 0.6:\n                priorities[i] -= 0.2\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n            if ratio >= 0.6 and ratio < 0.8:\n                priorities[i] += 0.3\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n                if ratio >= 0.7:\n                    priorities[i] -= 0.1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n            if ratio < 0.2:\n                priorities[i] += 0.1\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n            if ratio >= 0.4 and ratio < 0.6:\n                priorities[i] -= 0.2\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n            if ratio >= 0.6 and ratio < 0.8:\n                priorities[i] += 0.3\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n                if ratio >= 0.7:\n                    priorities[i] -= 0.1\n                if j % 2 == 0:\n                    priorities[i] += 0.05\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:00:01", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n            if ratio < 0.2:\n                priorities[i] += 0.1\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n            if ratio >= 0.4 and ratio < 0.6:\n                priorities[i] -= 0.2\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n            if ratio >= 0.6 and ratio < 0.8:\n                priorities[i] += 0.3\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n                if ratio >= 0.7:\n                    priorities[i] -= 0.1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n            if ratio < 0.2:\n                priorities[i] += 0.1\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n            if ratio >= 0.4 and ratio < 0.6:\n                priorities[i] -= 0.2\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n            if ratio >= 0.6 and ratio < 0.8:\n                priorities[i] += 0.3\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n                if ratio >= 0.7:\n                    priorities[i] -= 0.1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 3 == 0:\n            priorities[i] += 0.2\n            if ratio < 0.3:\n                priorities[i] += 0.15\n        elif i % 3 == 1:\n            priorities[i] -= 0.1\n            if ratio >= 0.4 and ratio < 0.6:\n                priorities[i] -= 0.25\n        else:\n            for j in range(2):\n                priorities[i] -= 0.05\n                if ratio >= 0.7:\n                    priorities[i] -= 0.1\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:00:07", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n            if ratio < 0.2:\n                priorities[i] += 0.1\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n            if ratio >= 0.4 and ratio < 0.6:\n                priorities[i] -= 0.2\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n            if ratio >= 0.6 and ratio < 0.8:\n                priorities[i] += 0.3\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n                if ratio >= 0.7:\n                    priorities[i] -= 0.1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n            if ratio < 0.2:\n                priorities[i] += 0.1\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n            if ratio >= 0.4 and ratio < 0.6:\n                priorities[i] -= 0.2\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n            if ratio >= 0.6 and ratio < 0.8:\n                priorities[i] += 0.3\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n                if ratio >= 0.7:\n                    priorities[i] -= 0.1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n            if ratio < 0.3:\n                priorities[i] += 0.2\n        elif i % 5 == 1:\n            priorities[i] -= 0.15\n            if ratio >= 0.4 and ratio < 0.5:\n                priorities[i] -= 0.1\n        elif i % 5 == 2:\n            priorities[i] += 0.2\n            if ratio >= 0.6 and ratio < 0.7:\n                priorities[i] += 0.4\n        elif i % 5 == 3:\n            for j in range(2):\n                priorities[i] -= 0.1\n                if ratio >= 0.7:\n                    priorities[i] -= 0.2\n        else:\n            priorities[i] -= 0.05\n            if ratio >= 0.8:\n                priorities[i] -= 0.3\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:00:22", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            priorities[i] = (bins[i] + diff) / item\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n                \n        if priorities[i] > 1.2:\n            priorities[i] = 1.2\n        elif priorities[i] < 0.7:\n            priorities[i] = 0.7\n        \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:00:25", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            priorities[i] = (bins[i] + diff) / item\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if bins[i] % 2 == 0:\n                priorities[i] += 0.3\n            else:\n                priorities[i] -= 0.2\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:00:29", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            priorities[i] = (bins[i] + diff) / item\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            # Add additional condition based on bin size\n            if bins[i] >= 50:\n                priorities[i] *= 1.3\n            elif bins[i] <= 10:\n                priorities[i] *= 0.7\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:00:32", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            priorities[i] = (bins[i] + diff) / item\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.3\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:00:42", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            \n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.2\n            elif count == 2:\n                priorities[i] -= 0.6\n            else:\n                priorities[i] += 0.2\n                \n            if bins[i] % 5 == 0:\n                priorities[i] *= 1.5\n            elif bins[i] % 3 == 0:\n                priorities[i] *= 1.3\n            else:\n                priorities[i] *= 1.1\n        \n        if priorities[i] > 1.5:\n            priorities[i] += 0.5\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.3\n        \n        if i % 2 == 0:\n            priorities[i] *= 1.8\n        elif i % 3 == 0:\n            priorities[i] *= 1.6\n        else:\n            priorities[i] *= 1.4\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 1.2 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 1.1 * count + item / bins[i] + 0.3\n        \n        if priorities[i] > 2.0:\n            priorities[i] += 0.6\n        elif priorities[i] > 1.5:\n            priorities[i] += 0.4\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.3\n        \n        if bins[i] % 2 == 0:\n            priorities[i] *= 1.1\n        else:\n            priorities[i] *= 1.2\n        \n        if i % 2 == 0:\n            priorities[i] *= 1.5\n        else:\n            priorities[i] *= 1.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 1.3 * count + 0.7 * item / bins[i] + 0.4\n            else:\n                priorities[i] = 1.4 * count + 0.6 * item / bins[i] + 0.5\n        \n        if priorities[i] > 2.0:\n            priorities[i] += 0.8\n        elif priorities[i] > 1.5:\n            priorities[i] += 0.6\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.4\n        \n        if bins[i] % 3 == 0:\n            priorities[i] *= 1.2\n        else:\n            priorities[i] *= 1.1\n        \n        if i % 3 == 0:\n            priorities[i] *= 1.6\n        else:\n            priorities[i] *= 1.4\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:00:46", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            \n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.2\n            elif count == 2:\n                priorities[i] -= 0.6\n            else:\n                priorities[i] += 0.2\n                \n            if bins[i] % 5 == 0:\n                priorities[i] *= 1.5\n            elif bins[i] % 3 == 0:\n                priorities[i] *= 1.3\n            else:\n                priorities[i] *= 1.1\n        \n        if priorities[i] > 1.5:\n            priorities[i] += 0.5\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.3\n        \n        if i % 2 == 0:\n            priorities[i] *= 1.8\n        elif i % 3 == 0:\n            priorities[i] *= 1.6\n        else:\n            priorities[i] *= 1.4\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 1.2 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 1.1 * count + item / bins[i] + 0.3\n        \n        if priorities[i] > 2.0:\n            priorities[i] += 0.6\n        elif priorities[i] > 1.5:\n            priorities[i] += 0.4\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.3\n        \n        if bins[i] % 2 == 0:\n            priorities[i] *= 1.1\n        else:\n            priorities[i] *= 1.2\n        \n        if i % 2 == 0:\n            priorities[i] *= 1.5\n        else:\n            priorities[i] *= 1.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 1.2 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 1.1 * count + item / bins[i] + 0.3\n        \n        if priorities[i] > 2.0:\n            priorities[i] += 0.6\n        elif priorities[i] > 1.5:\n            priorities[i] += 0.4\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.3\n        \n        if i % 2 == 0:\n            priorities[i] *= 1.5\n        elif i % 3 == 0:\n            priorities[i] *= 1.7\n        else:\n            priorities[i] *= 1.4\n        \n        if bins[i] % 6 == 0:\n            priorities[i] += 1.0\n        elif bins[i] % 4 == 0:\n            priorities[i] += 0.8\n        else:\n            priorities[i] += 0.5\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:00:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            \n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.2\n            elif count == 2:\n                priorities[i] -= 0.6\n            else:\n                priorities[i] += 0.2\n                \n            if bins[i] % 5 == 0:\n                priorities[i] *= 1.5\n            elif bins[i] % 3 == 0:\n                priorities[i] *= 1.3\n            else:\n                priorities[i] *= 1.1\n        \n        if priorities[i] > 1.5:\n            priorities[i] += 0.5\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.3\n        \n        if i % 2 == 0:\n            priorities[i] *= 1.8\n        elif i % 3 == 0:\n            priorities[i] *= 1.6\n        else:\n            priorities[i] *= 1.4\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 1.2 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 1.1 * count + item / bins[i] + 0.3\n        \n        if priorities[i] > 2.0:\n            priorities[i] += 0.6\n        elif priorities[i] > 1.5:\n            priorities[i] += 0.4\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.3\n        \n        if bins[i] % 2 == 0:\n            priorities[i] *= 1.1\n        else:\n            priorities[i] *= 1.2\n        \n        if i % 2 == 0:\n            priorities[i] *= 1.5\n        else:\n            priorities[i] *= 1.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.6 * item / bins[i] + 0.4\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            \n            if count % 3 == 0:\n                priorities[i] = 1.5 * count + item / bins[i] + 0.4\n            else:\n                priorities[i] = 1.3 * count + item / bins[i] + 0.4\n            \n            if count > 4:\n                priorities[i] += 1.8\n            elif count == 3:\n                priorities[i] -= 0.7\n            else:\n                priorities[i] += 0.3\n                \n            if bins[i] % 4 == 0:\n                priorities[i] *= 1.6\n            elif bins[i] % 3 == 0:\n                priorities[i] *= 1.4\n            else:\n                priorities[i] *= 1.2\n        \n        if priorities[i] > 2.5:\n            priorities[i] += 0.7\n        elif priorities[i] > 1.8:\n            priorities[i] += 0.5\n        elif priorities[i] > 1.2:\n            priorities[i] -= 0.4\n        \n        if i % 2 == 0:\n            priorities[i] *= 1.7\n        elif i % 3 == 0:\n            priorities[i] *= 1.6\n        else:\n            priorities[i] *= 1.3\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:00:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            \n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.2\n            elif count == 2:\n                priorities[i] -= 0.6\n            else:\n                priorities[i] += 0.2\n                \n            if bins[i] % 5 == 0:\n                priorities[i] *= 1.5\n            elif bins[i] % 3 == 0:\n                priorities[i] *= 1.3\n            else:\n                priorities[i] *= 1.1\n        \n        if priorities[i] > 1.5:\n            priorities[i] += 0.5\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.3\n        \n        if i % 2 == 0:\n            priorities[i] *= 1.8\n        elif i % 3 == 0:\n            priorities[i] *= 1.6\n        else:\n            priorities[i] *= 1.4\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 1.2 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 1.1 * count + item / bins[i] + 0.3\n        \n        if priorities[i] > 2.0:\n            priorities[i] += 0.6\n        elif priorities[i] > 1.5:\n            priorities[i] += 0.4\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.3\n        \n        if bins[i] % 2 == 0:\n            priorities[i] *= 1.1\n        else:\n            priorities[i] *= 1.2\n        \n        if i % 2 == 0:\n            priorities[i] *= 1.5\n        else:\n            priorities[i] *= 1.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 1.2 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 1.1 * count + item / bins[i] + 0.3\n        \n        if priorities[i] > 2.0:\n            priorities[i] += 0.6\n        elif priorities[i] > 1.5:\n            priorities[i] += 0.4\n        elif priorities[i] > 1.0:\n            priorities[i] -= 0.3\n        \n        if bins[i] % 2 == 0:\n            priorities[i] *= 1.1\n        else:\n            priorities[i] *= 1.2\n        \n        if i % 2 == 0:\n            priorities[i] *= 1.5\n        else:\n            priorities[i] *= 1.3\n        \n        # Additional complexity with more conditions\n        if bins[i] % 2 == 0 and item % 2 == 0:\n            priorities[i] *= 1.2\n        elif bins[i] % 3 == 0:\n            priorities[i] *= 1.4\n        else:\n            priorities[i] *= 1.1\n        \n        if item > 5 and bins[i] < 10:\n            priorities[i] += 0.8\n        elif item < 3 and bins[i] > 5:\n            priorities[i] -= 0.5\n        \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:01:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if priority_score > 0.5:\n                priority_score *= 1.5\n            elif priority_score < 0.3:\n                priority_score *= 0.8\n                \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:01:10", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v3(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v2`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 20:\n                priority_score *= 1.5\n            elif bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n            elif item >= 15 and item < 20:\n                priority_score += 0.03\n                \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:01:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "import math\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            priority_score = math.ceil(priority_score) if priority_score > 0.5 else math.floor(priority_score)\n            \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:01:19", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "import numpy as np\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n\n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n                \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10 and bins[i] < 15:\n                priority_score *= 1.3\n            elif bins[i] >= 5 and bins[i] < 10:\n                priority_score *= 1.2\n            \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if utilization_ratio < 0.5:\n                priority_score += 0.1\n            elif utilization_ratio >= 0.5 and utilization_ratio < 0.8:\n                priority_score += 0.05\n\n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:01:29", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n                if item % 2 == 0:\n                    priorities[i] += 0.2\n                else:\n                    priorities[i] -= 0.1\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n                if bins[i] % 2 == 0:\n                    priorities[i] += 0.3\n                else:\n                    priorities[i] -= 0.2\n            else:\n                priorities[i] = 0.5\n                for j in range(2, int(bins[i] ** 0.5) + 1):\n                    if bins[i] % j == 0:\n                        priorities[i] -= 0.1\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    if bins[i] % item < 0.5:\n                        priorities[i] = item / bins[i] + 0.2\n                    elif bins[i] % item < 0.8:\n                        priorities[i] = 0.8 - item / bins[i]\n                    else:\n                        priorities[i] = bins[i] - item / bins[i] + 0.4\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    if bins[i] % item < 0.5:\n                        priorities[i] = item / bins[i] + 0.2\n                    elif bins[i] % item < 0.8:\n                        priorities[i] = 0.8 - item / bins[i]\n                    else:\n                        priorities[i] = bins[i] - item / bins[i] + 0.4\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:01:33", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n                if item % 2 == 0:\n                    priorities[i] += 0.2\n                else:\n                    priorities[i] -= 0.1\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n                if bins[i] % 2 == 0:\n                    priorities[i] += 0.3\n                else:\n                    priorities[i] -= 0.2\n            else:\n                priorities[i] = 0.5\n                for j in range(2, int(bins[i] ** 0.5) + 1):\n                    if bins[i] % j == 0:\n                        priorities[i] -= 0.1\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    if bins[i] % item < 0.5:\n                        priorities[i] = item / bins[i] + 0.2\n                    elif bins[i] % item < 0.8:\n                        priorities[i] = 0.8 - item / bins[i]\n                    else:\n                        priorities[i] = bins[i] - item / bins[i] + 0.4\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n                if item % 3 == 0:\n                    priorities[i] += 0.3\n                elif item % 5 == 0:\n                    priorities[i] += 0.5\n                else:\n                    priorities[i] -= 0.1\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                    if bins[i] % 2 == 0:\n                        priorities[i] += 0.4\n                    else:\n                        priorities[i] -= 0.2\n                else:\n                    if bins[i] % item < 0.5:\n                        priorities[i] = item / bins[i] + 0.2\n                    elif bins[i] % item < 0.8:\n                        priorities[i] = 0.8 - item / bins[i]\n                    else:\n                        priorities[i] = bins[i] - item / bins[i] + 0.4\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:01:36", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n                if item % 2 == 0:\n                    priorities[i] += 0.2\n                else:\n                    priorities[i] -= 0.1\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n                if bins[i] % 2 == 0:\n                    priorities[i] += 0.3\n                else:\n                    priorities[i] -= 0.2\n            else:\n                priorities[i] = 0.5\n                for j in range(2, int(bins[i] ** 0.5) + 1):\n                    if bins[i] % j == 0:\n                        priorities[i] -= 0.1\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    if bins[i] % item < 0.5:\n                        priorities[i] = item / bins[i] + 0.2\n                    elif bins[i] % item < 0.8:\n                        priorities[i] = 0.8 - item / bins[i]\n                    else:\n                        priorities[i] = bins[i] - item / bins[i] + 0.4\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n                if item % 2 == 0:\n                    priorities[i] += 0.2\n                else:\n                    priorities[i] -= 0.1\n                for j in range(2, int(bins[i] ** 0.5) + 1):\n                    if bins[i] % j == 0:\n                        priorities[i] += 0.1\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    if bins[i] % item < 0.5:\n                        priorities[i] = item / bins[i] + 0.2\n                    elif bins[i] % item < 0.8:\n                        priorities[i] = 0.8 - item / bins[i]\n                    else:\n                        priorities[i] = bins[i] - item / bins[i] + 0.4\n                for k in range(2, int(item ** 0.5) + 1):\n                    if item % k == 0:\n                        priorities[i] -= 0.05\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:01:40", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n                if item % 2 == 0:\n                    priorities[i] += 0.2\n                else:\n                    priorities[i] -= 0.1\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n                if bins[i] % 2 == 0:\n                    priorities[i] += 0.3\n                else:\n                    priorities[i] -= 0.2\n            else:\n                priorities[i] = 0.5\n                for j in range(2, int(bins[i] ** 0.5) + 1):\n                    if bins[i] % j == 0:\n                        priorities[i] -= 0.1\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    if bins[i] % item < 0.5:\n                        priorities[i] = item / bins[i] + 0.2\n                    elif bins[i] % item < 0.8:\n                        priorities[i] = 0.8 - item / bins[i]\n                    else:\n                        priorities[i] = bins[i] - item / bins[i] + 0.4\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n                if item % 3 == 0:\n                    priorities[i] += 0.5\n                elif item % 2 == 0:\n                    priorities[i] += 0.3\n                else:\n                    priorities[i] += 0.1\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n                if bins[i] % 3 == 0:\n                    priorities[i] += 0.7\n                elif bins[i] % 2 == 0:\n                    priorities[i] += 0.4\n                else:\n                    priorities[i] -= 0.2\n            else:\n                priorities[i] = 0.5\n                for j in range(2, int(bins[i] ** 0.5) + 1):\n                    if bins[i] % j == 0:\n                        priorities[i] -= 0.1\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:01:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item >= 8 and item <= 12:\n                priority_score *= 1.2\n            elif item > 12:\n                priority_score *= 1.5\n            elif item < 5:\n                priority_score *= 0.8\n                \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:01:55", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n            \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n\n            # New conditions added for priority_v2\n            if priority_score > 0.5:\n                priority_score *= 1.1\n            else:\n                priority_score *= 0.9\n                \n            priorities[i] = priority_score\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:01:59", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n\n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n\n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n\n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n\n            if bins[i] % 2 == 0:\n                priority_score *= 1.1\n            elif bins[i] % 3 == 0:\n                priority_score *= 1.2\n\n            priorities[i] = priority_score\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:02:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n            \n            if remaining_space >= 7:\n                priority_score *= 1.5\n                if bins[i] >= 12:\n                    priority_score *= 1.3\n                elif bins[i] >= 8:\n                    priority_score *= 1.2\n            elif remaining_space >= 5:\n                priority_score *= 1.2\n                if bins[i] >= 10:\n                    priority_score *= 1.1\n            \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:02:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.1\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i] + 0.05\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 2.0\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.2\n        else:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.4:\n            priorities[i] = 0.4\n        elif priorities[i] > 2.0:\n            priorities[i] = 2.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 3.0\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 2.0\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > bins[i]:\n            priorities[i] *= 1.2\n        else:\n            priorities[i] *= 1.1\n\n        if item % 2 == 0:\n            priorities[i] += 0.5\n        else:\n            priorities[i] -= 0.5\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 3.0:\n            priorities[i] = 3.0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:02:16", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.1\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i] + 0.05\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 2.0\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.2\n        else:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.4:\n            priorities[i] = 0.4\n        elif priorities[i] > 2.0:\n            priorities[i] = 2.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 3 * bins[i]:\n            priorities[i] *= 3.0\n        elif item > 2 * bins[i]:\n            priorities[i] *= 2.0\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.2\n        else:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.3:\n            priorities[i] = 0.3\n        elif priorities[i] > 3.0:\n            priorities[i] = 3.0\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:02:20", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.1\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i] + 0.05\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 2.0\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.2\n        else:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.4:\n            priorities[i] = 0.4\n        elif priorities[i] > 2.0:\n            priorities[i] = 2.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n        if item > 2 * bins[i]:\n            priorities[i] *= 2.0\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.2\n        else:\n            priorities[i] *= 1.1\n        \n        if priorities[i] < 0.4:\n            priorities[i] = 0.4\n        elif priorities[i] > 2.0:\n            priorities[i] = 2.0\n        \n        if bins[i] % 2 == 0:\n            priorities[i] += 0.2\n        else:\n            priorities[i] -= 0.2\n            \n        if item % 3 == 0:\n            priorities[i] *= 1.5\n        elif item % 2 == 0:\n            priorities[i] *= 1.2\n        else:\n            priorities[i] *= 1.1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:02:24", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.1\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i] + 0.05\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 2.0\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.2\n        else:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.4:\n            priorities[i] = 0.4\n        elif priorities[i] > 2.0:\n            priorities[i] = 2.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 2.0\n        elif item > 1.5 * bins[i] and item <= 2 * bins[i]:\n            priorities[i] *= 1.8\n        elif item > 1.2 * bins[i] and item <= 1.5 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.0 * bins[i] and item <= 1.2 * bins[i]:\n            priorities[i] *= 1.3\n        else:\n            priorities[i] *= 1.1\n\n        if item >= 0.9 * bins[i] and item < 1.0 * bins[i]:\n            priorities[i] *= 0.9\n        elif item >= 0.8 * bins[i] and item < 0.9 * bins[i]:\n            priorities[i] *= 0.8\n        elif item >= 0.7 * bins[i] and item < 0.8 * bins[i]:\n            priorities[i] *= 0.7\n        elif item >= 0.6 * bins[i] and item < 0.7 * bins[i]:\n            priorities[i] *= 0.6\n        elif item >= 0.5 * bins[i] and item < 0.6 * bins[i]:\n            priorities[i] *= 0.5\n        else:\n            priorities[i] *= 0.4\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:02:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n                    \n                if priorities[index] == 0.0:\n                    for i in range(index+1, len(bins)):\n                        if bins[i] >= item:\n                            priorities[i] = 0.6\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.3:\n                    priorities[index] = 0.9\n                elif priority >= 0.3 and priority < 0.6:\n                    priorities[index] = 0.7\n                elif priority >= 0.6 and priority < 0.9:\n                    priorities[index] = 0.5\n                else:\n                    priorities[index] = 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.3:\n                    priorities[index] = 0.9\n                elif priority >= 0.3 and priority < 0.6:\n                    priorities[index] = 0.7\n                elif priority >= 0.6 and priority < 0.9:\n                    priorities[index] = 0.5\n                else:\n                    if item % 2 == 0:\n                        priorities[index] = 0.4\n                    else:\n                        priorities[index] = 0.3\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:02:38", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n                    \n                if priorities[index] == 0.0:\n                    for i in range(index+1, len(bins)):\n                        if bins[i] >= item:\n                            priorities[i] = 0.6\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.3:\n                    priorities[index] = 0.9\n                elif priority >= 0.3 and priority < 0.6:\n                    priorities[index] = 0.7\n                elif priority >= 0.6 and priority < 0.9:\n                    priorities[index] = 0.5\n                else:\n                    priorities[index] = 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        remaining_capacity = bin_capacity - item\n        if remaining_capacity <= 0:\n            priorities[index] = 0\n        else:\n            priority = 1 / remaining_capacity\n            if priority < 0.2:\n                priorities[index] = 1.0\n            elif priority >= 0.2 and priority < 0.4:\n                priorities[index] = 0.8\n            elif priority >= 0.4 and priority < 0.6:\n                priorities[index] = 0.6\n            elif priority >= 0.6 and priority < 0.8:\n                priorities[index] = 0.4\n            else:\n                priorities[index] = 0.2\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:02:41", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n                    \n                if priorities[index] == 0.0:\n                    for i in range(index+1, len(bins)):\n                        if bins[i] >= item:\n                            priorities[i] = 0.6\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.3:\n                    priorities[index] = 0.9\n                elif priority >= 0.3 and priority < 0.6:\n                    priorities[index] = 0.7\n                elif priority >= 0.6 and priority < 0.9:\n                    priorities[index] = 0.5\n                else:\n                    priorities[index] = 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                if item > bin_capacity * 2:\n                    priorities[index] = 0.2\n                    for i in range(index+1, len(bins)):\n                        if bins[i] >= item:\n                            priorities[i] = 0.6\n                else:\n                    priority = (bin_capacity - item) / bin_capacity\n                    if priority < 0.2:\n                        priorities[index] = 0.9\n                    elif priority >= 0.2 and priority < 0.4:\n                        priorities[index] = 0.7\n                    elif priority >= 0.4 and priority < 0.6:\n                        priorities[index] = 0.5\n                    else:\n                        priorities[index] = 0.3\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:02:44", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n                    \n                if priorities[index] == 0.0:\n                    for i in range(index+1, len(bins)):\n                        if bins[i] >= item:\n                            priorities[i] = 0.6\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.3:\n                    priorities[index] = 0.9\n                elif priority >= 0.3 and priority < 0.6:\n                    priorities[index] = 0.7\n                elif priority >= 0.6 and priority < 0.9:\n                    priorities[index] = 0.5\n                else:\n                    priorities[index] = 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.2:\n                    priorities[index] = 0.9\n                elif priority >= 0.2 and priority < 0.4:\n                    priorities[index] = 0.8\n                elif priority >= 0.4 and priority < 0.6:\n                    priorities[index] = 0.7\n                elif priority >= 0.6 and priority < 0.8:\n                    priorities[index] = 0.6\n                elif priority >= 0.8 and priority < 1.0:\n                    priorities[index] = 0.5\n                else:\n                    priorities[index] = 0.3\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:02:52", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.1\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i] + 0.05\n            \n    sorted_priorities = sorted(priorities, reverse=True)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == sorted_priorities[0]:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == sorted_priorities[-1]:\n            priorities[i] = priorities[i] - 0.2\n        else:\n            priorities[i] = priorities[i] + 0.1\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i] * 2\n        else:\n            priorities[i] = 1.0 - (item - bins[i]) / item\n            \n    for i in range(len(priorities)):\n        if i % 2 == 0:\n            priorities[i] = priorities[i] + 0.1\n        else:\n            priorities[i] = priorities[i] - 0.1\n            \n    for i in range(1, len(priorities)):\n        if priorities[i] > priorities[i-1]:\n            priorities[i] = priorities[i] + 0.3\n        else:\n            priorities[i] = priorities[i] - 0.3\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:02:55", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.1\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i] + 0.05\n            \n    sorted_priorities = sorted(priorities, reverse=True)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == sorted_priorities[0]:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == sorted_priorities[-1]:\n            priorities[i] = priorities[i] - 0.2\n        else:\n            priorities[i] = priorities[i] + 0.1\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.2\n        elif priorities[i] >= 0.5:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i] + 0.1\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:02:58", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.1\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i] + 0.05\n            \n    sorted_priorities = sorted(priorities, reverse=True)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == sorted_priorities[0]:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == sorted_priorities[-1]:\n            priorities[i] = priorities[i] - 0.2\n        else:\n            priorities[i] = priorities[i] + 0.1\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.2\n        elif priorities[i] >= 0.5:\n            priorities[i] = priorities[i] + 0.1\n        else:\n            priorities[i] = priorities[i] - 0.1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:03:01", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.1\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i] + 0.05\n            \n    sorted_priorities = sorted(priorities, reverse=True)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == sorted_priorities[0]:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == sorted_priorities[-1]:\n            priorities[i] = priorities[i] - 0.2\n        else:\n            priorities[i] = priorities[i] + 0.1\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority_index = np.argmax(priorities)\n    min_priority_index = np.argmin(priorities)\n    \n    for i in range(len(priorities)):\n        if i == max_priority_index:\n            priorities[i] = priorities[i] * 1.1\n        elif i == min_priority_index:\n            priorities[i] = priorities[i] * 0.9\n        else:\n            priorities[i] = priorities[i] * 1.05\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:03:12", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "import numpy as np\n\ndef more_complex_function(matrix: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(matrix)\n    \n    for i in range(matrix.shape[0]):\n        for j in range(matrix.shape[1]):\n            if matrix[i, j] % 2 == 0:\n                result[i, j] = matrix[i, j] * 2\n            else:\n                if matrix[i, j] < 5:\n                    result[i, j] = matrix[i, j] + 5\n                elif matrix[i, j] >= 5 and matrix[i, j] < 10:\n                    result[i, j] = matrix[i, j] + 10\n                elif matrix[i, j] >= 10 and matrix[i, j] < 15:\n                    result[i, j] = matrix[i, j] + 15\n                else:\n                    result[i, j] = matrix[i, j] + 20\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 07:03:16", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if bins[i] % 2 == 0:\n                priority_score *= 1.1\n            elif bins[i] % 3 == 0:\n                priority_score *= 1.2\n            else:\n                priority_score *= 0.9\n                \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:03:21", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n            \n            if i % 2 == 0:\n                priority_score *= 1.1\n            elif i % 3 == 0:\n                priority_score *= 1.2\n            elif i % 5 == 0:\n                priority_score *= 1.3\n            elif i % 7 == 0:\n                priority_score *= 1.4\n            \n            priorities[i] = priority_score\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:03:26", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:03:36", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.3\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more advanced version of `priority` function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n                \n            if item > bins[i] * 1.2:\n                priorities[i] -= 0.3\n            elif item < bins[i] * 0.7:\n                priorities[i] += 0.2\n                \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:03:42", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.3\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more advanced version of `priority` function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.1\n            elif item % bins[i] == 1:\n                priorities[i] -= 0.1\n                \n            if item - bins[i] >= 10:\n                priorities[i] += 0.2\n            elif item - bins[i] <= 5:\n                priorities[i] -= 0.2\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:03:46", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.3\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more advanced version of `priority` function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.3\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.1\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n            \n            if item % 3 == 0:\n                priorities[i] += 0.5\n            \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:03:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.3\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more advanced version of `priority` function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.3\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n                \n            if item % 2 == 0:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.1\n                \n            if item > 3 * np.median(bins):\n                priorities[i] += 0.4\n            elif item < np.min(bins):\n                priorities[i] -= 0.3\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:04:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"An advanced version of the priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[i] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[i] = 0.7\n                elif priority >= 1.0 and priority < 2.0:\n                    priorities[i] = 0.5\n                else:\n                    priorities[i] = 0.3\n            else:\n                for j in range(i, len(bins)):\n                    if bins[j] - item > 0:\n                        priorities[j] = 0.5 * (bins[j] - item)\n                if priorities[i] == 0:\n                    priorities[i] = -0.2\n        \n        if item % 3 == 0:\n            priorities[i] += 0.2\n        elif item % 2 == 0:\n            priorities[i] += 0.1\n        else:\n            priorities[i] -= 0.1\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.4:\n                    priorities[index] = 0.9\n                elif priority >= 0.4 and priority < 0.7:\n                    priorities[index] = 0.7\n                elif priority >= 0.7 and priority < 1.0:\n                    priorities[index] = 0.5\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.2\n                    else:\n                        priorities[index] = 0.3\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.1\n                else:\n                    priorities[index] = 0.0\n                    \n                if priorities[index] == 0.0:\n                    for i in range(index+1, len(bins)):\n                        if bins[i] >= item:\n                            priorities[i] = 0.6\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more advanced version of the priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.25:\n                    priorities[index] = 0.9\n                elif priority >= 0.25 and priority < 0.5:\n                    priorities[index] = 0.7\n                elif priority >= 0.5 and priority < 0.75:\n                    priorities[index] = 0.5\n                else:\n                    priorities[index] = 0.3\n            else:\n                for i in range(index+1, len(bins)):\n                    if bins[i] >= item:\n                        priorities[i] = 0.6\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:04:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"An advanced version of the priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[i] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[i] = 0.7\n                elif priority >= 1.0 and priority < 2.0:\n                    priorities[i] = 0.5\n                else:\n                    priorities[i] = 0.3\n            else:\n                for j in range(i, len(bins)):\n                    if bins[j] - item > 0:\n                        priorities[j] = 0.5 * (bins[j] - item)\n                if priorities[i] == 0:\n                    priorities[i] = -0.2\n        \n        if item % 3 == 0:\n            priorities[i] += 0.2\n        elif item % 2 == 0:\n            priorities[i] += 0.1\n        else:\n            priorities[i] -= 0.1\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.4:\n                    priorities[index] = 0.9\n                elif priority >= 0.4 and priority < 0.7:\n                    priorities[index] = 0.7\n                elif priority >= 0.7 and priority < 1.0:\n                    priorities[index] = 0.5\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.2\n                    else:\n                        priorities[index] = 0.3\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.1\n                else:\n                    priorities[index] = 0.0\n                    \n                if priorities[index] == 0.0:\n                    for i in range(index+1, len(bins)):\n                        if bins[i] >= item:\n                            priorities[i] = 0.6\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.3:\n                    priorities[i] = 0.9\n                elif priority >= 0.3 and priority < 0.6:\n                    priorities[i] = 0.7\n                elif priority >= 0.6 and priority < 0.9:\n                    priorities[i] = 0.5\n                else:\n                    priorities[i] = 0.3\n            else:\n                for j in range(i, len(bins)):\n                    if bins[j] - item > 0:\n                        priorities[j] = 0.6 * (bins[j] - item)\n                if priorities[i] == 0:\n                    priorities[i] = -0.1\n        \n        if item % 4 == 0:\n            priorities[i] += 0.3\n        elif item % 3 == 0:\n            priorities[i] += 0.2\n        elif item % 2 == 0:\n            priorities[i] += 0.1\n        else:\n            priorities[i] -= 0.2\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:04:10", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"An advanced version of the priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[i] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[i] = 0.7\n                elif priority >= 1.0 and priority < 2.0:\n                    priorities[i] = 0.5\n                else:\n                    priorities[i] = 0.3\n            else:\n                for j in range(i, len(bins)):\n                    if bins[j] - item > 0:\n                        priorities[j] = 0.5 * (bins[j] - item)\n                if priorities[i] == 0:\n                    priorities[i] = -0.2\n        \n        if item % 3 == 0:\n            priorities[i] += 0.2\n        elif item % 2 == 0:\n            priorities[i] += 0.1\n        else:\n            priorities[i] -= 0.1\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.4:\n                    priorities[index] = 0.9\n                elif priority >= 0.4 and priority < 0.7:\n                    priorities[index] = 0.7\n                elif priority >= 0.7 and priority < 1.0:\n                    priorities[index] = 0.5\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.2\n                    else:\n                        priorities[index] = 0.3\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.1\n                else:\n                    priorities[index] = 0.0\n                    \n                if priorities[index] == 0.0:\n                    for i in range(index+1, len(bins)):\n                        if bins[i] >= item:\n                            priorities[i] = 0.6\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"More complex version of the priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.4:\n                    priorities[i] = 0.9\n                elif priority >= 0.4 and priority < 0.7:\n                    priorities[i] = 0.7\n                elif priority >= 0.7 and priority < 1.0:\n                    priorities[i] = 0.5\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[i] = 0.2\n                    else:\n                        priorities[i] = 0.3\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[i] = 0.1\n                else:\n                    priorities[i] = 0.0\n                    \n                if priorities[i] == 0.0:\n                    for j in range(i+1, len(bins)):\n                        if bins[j] >= item:\n                            priorities[j] = 0.6\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:04:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"An advanced version of the priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[i] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[i] = 0.7\n                elif priority >= 1.0 and priority < 2.0:\n                    priorities[i] = 0.5\n                else:\n                    priorities[i] = 0.3\n            else:\n                for j in range(i, len(bins)):\n                    if bins[j] - item > 0:\n                        priorities[j] = 0.5 * (bins[j] - item)\n                if priorities[i] == 0:\n                    priorities[i] = -0.2\n        \n        if item % 3 == 0:\n            priorities[i] += 0.2\n        elif item % 2 == 0:\n            priorities[i] += 0.1\n        else:\n            priorities[i] -= 0.1\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.4:\n                    priorities[index] = 0.9\n                elif priority >= 0.4 and priority < 0.7:\n                    priorities[index] = 0.7\n                elif priority >= 0.7 and priority < 1.0:\n                    priorities[index] = 0.5\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.2\n                    else:\n                        priorities[index] = 0.3\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.1\n                else:\n                    priorities[index] = 0.0\n                    \n                if priorities[index] == 0.0:\n                    for i in range(index+1, len(bins)):\n                        if bins[i] >= item:\n                            priorities[i] = 0.6\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.3:\n                    priorities[index] = 0.9\n                elif priority >= 0.3 and priority < 0.6:\n                    priorities[index] = 0.7\n                elif priority >= 0.6 and priority < 0.9:\n                    priorities[index] = 0.5\n                else:\n                    if item > bin_capacity * 1.5:\n                        priorities[index] = 0.4\n                    elif item > bin_capacity * 1.2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.2\n            else:\n                if item > bin_capacity * 1.5:\n                    priorities[index] = 0.1\n                elif item > bin_capacity:\n                    priorities[index] = 0.0\n                else:\n                    priorities[index] = 0.1\n                    \n                if priorities[index] == 0.0:\n                    for i in range(index+1, len(bins)):\n                        if bins[i] >= item:\n                            if bins[i] - item < 0.5:\n                                priorities[i] = 0.8\n                            elif bins[i] - item < 1:\n                                priorities[i] = 0.6\n                            else:\n                                priorities[i] = 0.4\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:04:24", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tanh(np.sinh(item) * np.cosh(bins[i]))\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.exp(item) + np.exp(bins[i])\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arcsinh(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] **= 3\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] = np.abs(np.log(priorities[j]))\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 4\n        else:\n            priorities[j] = np.cbrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item / 3\n        else:\n            priorities[k] -= item / 4\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:04:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:04:31", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] % 2 == 0:\n            priorities[i] = np.exp(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.log(item + bins[i]) + np.sqrt(item) + bins[i]\n    \n    for j in range(len(bins)):\n        if priorities[j] < 50:\n            priorities[j] *= 1.5\n        elif priorities[j] >= 50 and priorities[j] < 100:\n            priorities[j] *= 2\n        elif priorities[j] >= 100 and priorities[j] < 150:\n            priorities[j] /= 1.5\n        else:\n            priorities[j] = np.cbrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if k % 2 == 0:\n            priorities[k] += item * 2\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:04:37", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.1:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.1 and ratios[i] < 0.3:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.3 and ratios[i] < 0.5:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.5 and ratios[i] < 0.7:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        elif ratios[i] >= 0.7 and ratios[i] < 0.9:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n        else:\n            priorities[i] = np.sinh(np.cbrt(item * bins[i])) + np.tanh(np.cosh(ratios[i])) - np.exp(ratios[i])\n    \n    for j in range(len(bins)):\n        if priorities[j] < 5:\n            priorities[j] *= 2\n        elif priorities[j] >= 5 and priorities[j] < 15:\n            priorities[j] *= 4\n        elif priorities[j] >= 15 and priorities[j] < 25:\n            priorities[j] /= 3\n        elif priorities[j] >= 25 and priorities[j] < 35:\n            priorities[j] = np.power(priorities[j], 2)\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 3 == 0:\n            priorities[k] += item\n        elif priorities[k] % 3 == 1:\n            priorities[k] -= bins[k]\n        else:\n            priorities[k] += priorities[k] * 0.5\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:04:55", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = (count + 1) * item / bins[i] + 0.4\n            else:\n                priorities[i] = (count + 2) * item / bins[i] + 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n            \n            if item % 10 == 0:\n                priorities[i] *= 1.8\n            elif item % 5 == 0:\n                priorities[i] *= 1.5\n            else:\n                priorities[i] *= 1.2\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priority_factor = 0.8\n                if count > 3:\n                    priority_factor += 1.0\n                elif count == 2:\n                    priority_factor -= 0.5\n                else:\n                    priority_factor += 0.1\n                \n                if item % 10 == 0:\n                    priorities[i] = priority_factor * (0.8 * count + item / bins[i] + 0.3) * 1.8\n                elif item % 5 == 0:\n                    priorities[i] = priority_factor * (0.8 * count + item / bins[i] + 0.3) * 1.5\n                else:\n                    priorities[i] = priority_factor * (0.8 * count + item / bins[i] + 0.3) * 1.2\n            else:\n                priority_factor = 0.7\n                if count > 3:\n                    priority_factor += 1.0\n                elif count == 2:\n                    priority_factor -= 0.5\n                else:\n                    priority_factor += 0.1\n                \n                if item % 10 == 0:\n                    priorities[i] = priority_factor * (0.7 * count + item / bins[i] + 0.3) * 1.8\n                elif item % 5 == 0:\n                    priorities[i] = priority_factor * (0.7 * count + item / bins[i] + 0.3) * 1.5\n                else:\n                    priorities[i] = priority_factor * (0.7 * count + item / bins[i] + 0.3) * 1.2\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:05:00", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = (count + 1) * item / bins[i] + 0.4\n            else:\n                priorities[i] = (count + 2) * item / bins[i] + 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n            \n            if item % 10 == 0:\n                priorities[i] *= 1.8\n            elif item % 5 == 0:\n                priorities[i] *= 1.5\n            else:\n                priorities[i] *= 1.2\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n            \n            if item % 10 == 0:\n                priorities[i] *= 1.8\n            elif item % 5 == 0:\n                priorities[i] *= 1.5\n            else:\n                priorities[i] *= 1.2\n            \n            if item > 20:\n                priorities[i] += 2.0\n            elif item < 5:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n            \n            if count > 4 and item > 15:\n                priorities[i] *= 2.0\n            elif count < 2 and item < 10:\n                priorities[i] *= 0.5\n            else:\n                priorities[i] *= 1.0\n        \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:05:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = (count + 1) * item / bins[i] + 0.4\n            else:\n                priorities[i] = (count + 2) * item / bins[i] + 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n            \n            if item % 10 == 0:\n                priorities[i] *= 1.8\n            elif item % 5 == 0:\n                priorities[i] *= 1.5\n            else:\n                priorities[i] *= 1.2\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n            \n            if item % 10 == 0:\n                priorities[i] *= 1.8\n            elif item % 5 == 0:\n                priorities[i] *= 1.5\n            else:\n                priorities[i] *= 1.2\n            \n            if bins[i] % 2 == 0:\n                priorities[i] *= 2.0\n            elif bins[i] % 3 == 0:\n                priorities[i] *= 2.5\n            else:\n                priorities[i] *= 1.7\n            \n            if count >= 4 and item >= 10:\n                priorities[i] += 2.0\n            elif count <= 2 or item < 5:\n                priorities[i] -= 1.0\n        \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:05:07", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = (count + 1) * item / bins[i] + 0.4\n            else:\n                priorities[i] = (count + 2) * item / bins[i] + 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n            \n            if item % 10 == 0:\n                priorities[i] *= 1.8\n            elif item % 5 == 0:\n                priorities[i] *= 1.5\n            else:\n                priorities[i] *= 1.2\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n            \n            if item % 10 == 0:\n                priorities[i] *= 1.8\n            elif item % 5 == 0:\n                priorities[i] *= 1.5\n            else:\n                priorities[i] *= 1.2\n            \n            if bins[i] % 2 == 0:\n                priorities[i] *= 1.1\n            else:\n                priorities[i] *= 0.9\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:05:17", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if bins[i] < 5:\n                priority_score += 0.1\n            elif bins[i] >= 5 and bins[i] < 10:\n                priority_score += 0.05\n            \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:05:22", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef complex_priority_function(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >=0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio<0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n        \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 7:\n                priority_score += 0.3\n            elif remaining_space > 4:\n                priority_score += 0.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:05:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if item % 2 == 0:\n                priority_score *= 1.1\n            else:\n                priority_score *= 0.9\n                \n            priorities[i] = priority_score\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:05:31", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_function(input_data: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(input_data)\n    \n    for i in range(len(input_data)):\n        if input_data[i] % 2 == 0:\n            result[i] = input_data[i] * 2\n        else:\n            result[i] = input_data[i] * 3\n    \n    for i in range(1, len(result)):\n        if result[i] > result[i - 1] and result[i] % 3 == 0:\n            result[i] += 10\n        elif result[i] < result[i - 1] and result[i] % 2 == 0:\n            result[i] -= 5\n    \n    for i in range(len(result)):\n        if result[i] < 10:\n            result[i] = 0\n        elif result[i] >= 10 and result[i] < 20:\n            result[i] = 1\n        else:\n            result[i] = 2\n    \n    return result\n```", "strategy": []}
{"timestamp": "2025-04-27 07:05:39", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                \n    sorted_priorities = np.sort(priorities)[::-1]\n    max_val = sorted_priorities[0]\n    for j in range(len(priorities)):\n        if priorities[j] == max_val:\n            priorities[j] += 0.5\n        elif 0.5 * max_val <= priorities[j] <= max_val - 0.5:\n            priorities[j] += 0.3\n        else:\n            priorities[j] -= 0.2\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n            if item <= 20:\n                priorities[i] += 0.2\n            else:\n                priorities[i] += 0.5\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n            if item > 5:\n                priorities[i] -= 0.1\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n                \n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if count == 6:\n                    priorities[i] += 0.8\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if count == 4:\n                    priorities[i] -= 0.5\n                else:\n                    priorities[i] += 0.2\n            else:\n                priorities[i] = 0.9 * count + item / bins[i] + 0.3\n                if count == 3:\n                    priorities[i] -= 0.3\n                elif count == 5:\n                    priorities[i] += 0.4\n                \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n            if item <= 20:\n                priorities[i] += 0.2\n            else:\n                priorities[i] += 0.5\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n            if item > 5:\n                priorities[i] -= 0.1\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n                \n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if count == 6:\n                    priorities[i] += 0.8\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if count == 4:\n                    priorities[i] -= 0.5\n                else:\n                    priorities[i] += 0.2\n            else:\n                priorities[i] = 0.9 * count + item / bins[i] + 0.3\n                if count == 3:\n                    priorities[i] -= 0.3\n                elif count == 5:\n                    priorities[i] += 0.4\n                \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:05:43", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                \n    sorted_priorities = np.sort(priorities)[::-1]\n    max_val = sorted_priorities[0]\n    for j in range(len(priorities)):\n        if priorities[j] == max_val:\n            priorities[j] += 0.5\n        elif 0.5 * max_val <= priorities[j] <= max_val - 0.5:\n            priorities[j] += 0.3\n        else:\n            priorities[j] -= 0.2\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n            if item <= 20:\n                priorities[i] += 0.2\n            else:\n                priorities[i] += 0.5\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n            if item > 5:\n                priorities[i] -= 0.1\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n                \n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if count == 6:\n                    priorities[i] += 0.8\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if count == 4:\n                    priorities[i] -= 0.5\n                else:\n                    priorities[i] += 0.2\n            else:\n                priorities[i] = 0.9 * count + item / bins[i] + 0.3\n                if count == 3:\n                    priorities[i] -= 0.3\n                elif count == 5:\n                    priorities[i] += 0.4\n                \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n            if item <= 20:\n                priorities[i] += 0.2\n            else:\n                priorities[i] += 0.5\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n            if item > 5:\n                priorities[i] -= 0.1\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n                \n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if count == 6:\n                    priorities[i] += 0.8\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if count == 4:\n                    priorities[i] -= 0.5\n                else:\n                    priorities[i] += 0.2\n            else:\n                priorities[i] = 0.9 * count + item / bins[i] + 0.3\n                if count == 3:\n                    priorities[i] -= 0.3\n                elif count == 5:\n                    priorities[i] += 0.4\n                elif count == 7:\n                    priorities[i] -= 0.2\n                elif count == 9:\n                    priorities[i] += 0.7\n                \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:05:47", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                \n    sorted_priorities = np.sort(priorities)[::-1]\n    max_val = sorted_priorities[0]\n    for j in range(len(priorities)):\n        if priorities[j] == max_val:\n            priorities[j] += 0.5\n        elif 0.5 * max_val <= priorities[j] <= max_val - 0.5:\n            priorities[j] += 0.3\n        else:\n            priorities[j] -= 0.2\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n            if item <= 20:\n                priorities[i] += 0.2\n            else:\n                priorities[i] += 0.5\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n            if item > 5:\n                priorities[i] -= 0.1\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n                \n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if count == 6:\n                    priorities[i] += 0.8\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if count == 4:\n                    priorities[i] -= 0.5\n                else:\n                    priorities[i] += 0.2\n            else:\n                priorities[i] = 0.9 * count + item / bins[i] + 0.3\n                if count == 3:\n                    priorities[i] -= 0.3\n                elif count == 5:\n                    priorities[i] += 0.4\n                \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n            if item <= 20:\n                priorities[i] += 0.2\n            else:\n                priorities[i] += 0.5\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n            if item > 5:\n                priorities[i] -= 0.1\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n                \n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if count == 6:\n                    priorities[i] += 0.8\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if count == 4:\n                    priorities[i] -= 0.5\n                else:\n                    priorities[i] += 0.2\n            else:\n                priorities[i] = 0.9 * count + item / bins[i] + 0.3\n                if count == 3:\n                    priorities[i] -= 0.3\n                elif count == 5:\n                    priorities[i] += 0.4\n                else:\n                    priorities[i] += 0.1 if item > 10 else 0.05\n                \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:05:53", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                \n    sorted_priorities = np.sort(priorities)[::-1]\n    max_val = sorted_priorities[0]\n    for j in range(len(priorities)):\n        if priorities[j] == max_val:\n            priorities[j] += 0.5\n        elif 0.5 * max_val <= priorities[j] <= max_val - 0.5:\n            priorities[j] += 0.3\n        else:\n            priorities[j] -= 0.2\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n            if item <= 20:\n                priorities[i] += 0.2\n            else:\n                priorities[i] += 0.5\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n            if item > 5:\n                priorities[i] -= 0.1\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n                \n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if count == 6:\n                    priorities[i] += 0.8\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if count == 4:\n                    priorities[i] -= 0.5\n                else:\n                    priorities[i] += 0.2\n            else:\n                priorities[i] = 0.9 * count + item / bins[i] + 0.3\n                if count == 3:\n                    priorities[i] -= 0.3\n                elif count == 5:\n                    priorities[i] += 0.4\n                \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n            if item <= 20:\n                priorities[i] += 0.2\n            else:\n                priorities[i] += 0.5\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n            if item > 5:\n                priorities[i] -= 0.1\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n                \n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if count == 6:\n                    priorities[i] += 0.8\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if count == 4:\n                    priorities[i] -= 0.5\n                else:\n                    priorities[i] += 0.2\n            else:\n                priorities[i] = 0.9 * count + item / bins[i] + 0.3\n                if count == 3:\n                    priorities[i] -= 0.3\n                elif count == 5:\n                    priorities[i] += 0.4\n                else:\n                    priorities[i] += 0.1\n    \n    sorted_priorities = np.sort(priorities)[::-1]\n    max_val = sorted_priorities[0]\n    for j in range(len(priorities)):\n        if priorities[j] == max_val:\n            priorities[j] += 0.5\n        elif 0.5 * max_val <= priorities[j] <= max_val - 0.5:\n            priorities[j] += 0.3\n        else:\n            priorities[j] -= 0.2\n                \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:06:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(input_list: list) -> list:\n    output_list = []\n\n    for i in range(len(input_list)):\n        if input_list[i] % 2 == 0:\n            output_list.append(input_list[i] * 2)\n        else:\n            output_list.append(input_list[i] * 3)\n\n    for i in range(len(output_list)):\n        if output_list[i] < 10:\n            output_list[i] += 5\n        elif output_list[i] >= 10 and output_list[i] < 20:\n            output_list[i] += 3\n        else:\n            output_list[i] += 1\n\n    for i in range(len(output_list)):\n        if i % 2 == 0:\n            output_list[i] = max(0, output_list[i] - 10)\n        else:\n            output_list[i] = min(20, output_list[i])\n\n    return output_list", "strategy": []}
{"timestamp": "2025-04-27 07:06:08", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if bins[i] % 2 == 0:\n                priority_score += 0.1\n            elif bins[i] % 3 == 0:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:06:12", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n            \n            priority_score *= 1 + (i+1) * 0.1  # Increase priority based on bin index\n            \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:06:16", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more advanced version of priority calculation.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if bins[i] >= 20:\n                priority_score *= 1.5\n            elif bins[i] >= 25:\n                priority_score *= 1.6\n            elif bins[i] >= 30:\n                priority_score *= 1.7\n                \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:06:26", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.2\n            elif item + bins[i] > 100:\n                priorities[i] -= 0.1\n            else:\n                priorities[i] += 0.3\n            \n            if item > bins[i] + 50:\n                priorities[i] *= 1.7\n            elif item > bins[i] + 30:\n                priorities[i] *= 1.4\n            elif item > bins[i] + 20:\n                priorities[i] *= 1.2\n            \n            if item % bins[i] == 1:\n                priorities[i] += 0.1\n            elif item + bins[i] > 150:\n                priorities[i] -= 0.2\n            else:\n                priorities[i] += 0.4\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n            if item > 1.5 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.3\n            else:\n                priorities[i] *= 1.1\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            if item > 2 * bins[i]:\n                priorities[i] *= 1.7\n            elif item > 1.7 * bins[i]:\n                priorities[i] *= 1.4\n            elif item > 1.3 * bins[i]:\n                priorities[i] *= 1.2\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:06:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.2\n            elif item + bins[i] > 100:\n                priorities[i] -= 0.1\n            else:\n                priorities[i] += 0.3\n            \n            if item > bins[i] + 50:\n                priorities[i] *= 1.7\n            elif item > bins[i] + 30:\n                priorities[i] *= 1.4\n            elif item > bins[i] + 20:\n                priorities[i] *= 1.2\n            \n            if item % bins[i] == 1:\n                priorities[i] += 0.1\n            elif item + bins[i] > 150:\n                priorities[i] -= 0.2\n            else:\n                priorities[i] += 0.4\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.2\n            elif item + bins[i] > 100:\n                priorities[i] -= 0.1\n            else:\n                priorities[i] += 0.3\n            \n            if item > bins[i] + 50:\n                priorities[i] *= 1.7\n            elif item > bins[i] + 30:\n                priorities[i] *= 1.4\n            elif item > bins[i] + 20:\n                priorities[i] *= 1.2\n            \n            if item % bins[i] == 1:\n                priorities[i] += 0.1\n            elif item + bins[i] > 150:\n                priorities[i] -= 0.2\n            else:\n                priorities[i] += 0.4\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:06:34", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.2\n            elif item + bins[i] > 100:\n                priorities[i] -= 0.1\n            else:\n                priorities[i] += 0.3\n            \n            if item > bins[i] + 50:\n                priorities[i] *= 1.7\n            elif item > bins[i] + 30:\n                priorities[i] *= 1.4\n            elif item > bins[i] + 20:\n                priorities[i] *= 1.2\n            \n            if item % bins[i] == 1:\n                priorities[i] += 0.1\n            elif item + bins[i] > 150:\n                priorities[i] -= 0.2\n            else:\n                priorities[i] += 0.4\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n        \n        if item % bins[i] == 0:\n            priorities[i] += 0.2\n        elif item + bins[i] > 100:\n            priorities[i] -= 0.1\n        else:\n            priorities[i] += 0.3\n        \n        if item > bins[i] + 50:\n            priorities[i] *= 1.7\n        elif item > bins[i] + 30:\n            priorities[i] *= 1.4\n        elif item > bins[i] + 20:\n            priorities[i] *= 1.2\n        \n        if item % bins[i] == 1:\n            priorities[i] += 0.1\n        elif item + bins[i] > 150:\n            priorities[i] -= 0.2\n        else:\n            priorities[i] += 0.4\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:06:39", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.2\n            elif item + bins[i] > 100:\n                priorities[i] -= 0.1\n            else:\n                priorities[i] += 0.3\n            \n            if item > bins[i] + 50:\n                priorities[i] *= 1.7\n            elif item > bins[i] + 30:\n                priorities[i] *= 1.4\n            elif item > bins[i] + 20:\n                priorities[i] *= 1.2\n            \n            if item % bins[i] == 1:\n                priorities[i] += 0.1\n            elif item + bins[i] > 150:\n                priorities[i] -= 0.2\n            else:\n                priorities[i] += 0.4\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.2\n            elif item + bins[i] > 100:\n                priorities[i] -= 0.1\n            else:\n                priorities[i] += 0.3\n            \n            if item > bins[i] + 50:\n                priorities[i] *= 1.7\n            elif item > bins[i] + 30:\n                priorities[i] *= 1.4\n            elif item > bins[i] + 20:\n                priorities[i] *= 1.2\n            \n            if item % bins[i] == 1:\n                priorities[i] += 0.1\n            elif item + bins[i] > 150:\n                priorities[i] -= 0.2\n            else:\n                priorities[i] += 0.4\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:06:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n        \n    priorities = np.where(priorities > 50, priorities * 0.8, priorities)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:06:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    priorities = np.where(priorities > 100, priorities * 0.5, priorities)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:07:00", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities", "strategy": []}
{"timestamp": "2025-04-27 07:07:04", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if item > 20:\n            priorities[j] *= 5\n        elif item > 10:\n            priorities[j] *= 3\n        elif item < 5:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 4 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 3\n        \n        if ratios[k] > 0.5:\n            priorities[k] = np.log1p(priorities[k])\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:07:26", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.05\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = 0.5\n        if i % 2 == 0:\n            priorities[i] *= 1.2\n        else:\n            priorities[i] *= 0.8\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = 0.5\n        if i % 2 == 0:\n            priorities[i] *= 1.2\n        else:\n            priorities[i] *= 0.8\n        if priorities[i] > 0.5:\n            priorities[i] += 0.1\n        elif priorities[i] < 0.3:\n            priorities[i] -= 0.1\n        else:\n            priorities[i] = priorities[i]\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:07:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.05\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = 0.5\n        if i % 2 == 0:\n            priorities[i] *= 1.2\n        else:\n            priorities[i] *= 0.8\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.05\n        \n        if i % 3 == 0:\n            priorities[i] *= 1.3\n        elif i % 2 == 0:\n            priorities[i] *= 1.1\n        else:\n            priorities[i] *= 0.9\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:07:33", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.05\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = 0.5\n        if i % 2 == 0:\n            priorities[i] *= 1.2\n        else:\n            priorities[i] *= 0.8\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.3:\n                priorities[i] = 0.2\n            elif ratio < 0.5:\n                priorities[i] = 0.4\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            elif ratio < 1.0:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n        if i % 3 == 0:\n            priorities[i] *= 1.5\n        elif i % 3 == 1:\n            priorities[i] *= 1.2\n        else:\n            priorities[i] *= 0.8\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:07:36", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.05\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = 0.5\n        if i % 2 == 0:\n            priorities[i] *= 1.2\n        else:\n            priorities[i] *= 0.8\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.3:\n                priorities[i] = 0.2\n            elif ratio < 0.6:\n                priorities[i] = 0.5\n            elif ratio < 0.9:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n        \n        if i % 3 == 0:\n            priorities[i] *= 1.3\n        elif i % 3 == 1:\n            priorities[i] *= 1.1\n        \n        if i < len(bins) // 2:\n            priorities[i] += 0.1\n        else:\n            priorities[i] -= 0.1\n        \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:07:46", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.5\n        elif priorities[i] < 1.0:\n            priorities[i] += 0.5\n        else:\n            priorities[i] += 1.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    # Brand new logic\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    # Brand new logic\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:07:52", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.5\n        elif priorities[i] < 1.0:\n            priorities[i] += 0.5\n        else:\n            priorities[i] += 1.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    # Brand new logic\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    # Additional complex logic\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:07:56", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.5\n        elif priorities[i] < 1.0:\n            priorities[i] += 0.5\n        else:\n            priorities[i] += 1.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    # Brand new logic\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    # More complex logic\n    for j in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    priorities -= np.min(priorities)\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:08:01", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.5\n        elif priorities[i] < 1.0:\n            priorities[i] += 0.5\n        else:\n            priorities[i] += 1.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    # Brand new logic\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 1.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:08:20", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n        if priorities[i] > 0.8:\n            priorities[i] *= 1.2\n        elif 0.6 < priorities[i] <= 0.8:\n            priorities[i] *= 1.1\n        else:\n            priorities[i] *= 0.9\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n        if priorities[i] > 0.8:\n            priorities[i] *= 1.2\n        elif 0.6 < priorities[i] <= 0.8:\n            priorities[i] *= 1.1\n        else:\n            priorities[i] *= 0.9\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of priority calculation.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 3 == 0:\n            priorities[i] += 0.2\n        elif i % 3 == 1:\n            priorities[i] -= 0.15\n        else:\n            priorities[i] += 0.3\n\n        if priorities[i] > 0.8:\n            priorities[i] *= 1.2\n        elif 0.6 < priorities[i] <= 0.8:\n            priorities[i] *= 1.1\n        else:\n            priorities[i] *= 0.9\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:08:24", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n        if priorities[i] > 0.8:\n            priorities[i] *= 1.2\n        elif 0.6 < priorities[i] <= 0.8:\n            priorities[i] *= 1.1\n        else:\n            priorities[i] *= 0.9\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n        if priorities[i] > 0.8:\n            priorities[i] *= 1.2\n        elif 0.6 < priorities[i] <= 0.8:\n            priorities[i] *= 1.1\n        else:\n            priorities[i] *= 0.9\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(i % 3 + 1):\n                priorities[i] -= 0.05\n\n        if priorities[i] > 0.8:\n            priorities[i] *= 1.2\n        elif 0.6 < priorities[i] <= 0.8:\n            priorities[i] *= 1.1\n        else:\n            priorities[i] *= 0.9\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:08:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n        if priorities[i] > 0.8:\n            priorities[i] *= 1.2\n        elif 0.6 < priorities[i] <= 0.8:\n            priorities[i] *= 1.1\n        else:\n            priorities[i] *= 0.9\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n        if priorities[i] > 0.8:\n            priorities[i] *= 1.2\n        elif 0.6 < priorities[i] <= 0.8:\n            priorities[i] *= 1.1\n        else:\n            priorities[i] *= 0.9\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 3 == 0:\n            for j in range(4):\n                priorities[i] += 0.05\n        elif i % 3 == 1:\n            priorities[i] -= 0.1\n        elif i % 3 == 2:\n            priorities[i] += 0.1\n\n        if priorities[i] > 0.8:\n            priorities[i] *= 1.2\n        elif 0.6 < priorities[i] <= 0.8:\n            priorities[i] *= 1.1\n        else:\n            priorities[i] *= 0.9\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:08:32", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n        if priorities[i] > 0.8:\n            priorities[i] *= 1.2\n        elif 0.6 < priorities[i] <= 0.8:\n            priorities[i] *= 1.1\n        else:\n            priorities[i] *= 0.9\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n        if priorities[i] > 0.8:\n            priorities[i] *= 1.2\n        elif 0.6 < priorities[i] <= 0.8:\n            priorities[i] *= 1.1\n        else:\n            priorities[i] *= 0.9\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-40 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-25 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 1))) + 0.6\n\n        if i % 3 == 0:\n            priorities[i] += 0.1\n        elif i % 3 == 1:\n            priorities[i] -= 0.05\n        else:\n            priorities[i] += 0.2\n\n        if priorities[i] > 0.8:\n            priorities[i] *= 1.1\n        elif 0.6 < priorities[i] <= 0.8:\n            priorities[i] *= 1.05\n        else:\n            priorities[i] *= 0.95\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:08:45", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.3:\n                    priorities[index] = 0.9\n                elif priority >= 0.3 and priority < 0.6:\n                    priorities[index] = 0.7\n                elif priority >= 0.6 and priority < 0.9:\n                    priorities[index] = 0.5\n                else:\n                    priorities[index] = 0.3\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.1\n                else:\n                    priorities[index] = 0.0\n        if item % 2 == 0:\n            priorities[index] += 0.2\n        else:\n            priorities[index] -= 0.2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.2:\n                    priorities[index] = 0.9\n                elif priority >= 0.2 and priority < 0.4:\n                    priorities[index] = 0.8\n                elif priority >= 0.4 and priority < 0.6:\n                    priorities[index] = 0.7\n                elif priority >= 0.6 and priority < 0.8:\n                    priorities[index] = 0.6\n                elif priority >= 0.8 and priority < 1.0:\n                    priorities[index] = 0.5\n                else:\n                    priorities[index] = 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(input_data: np.ndarray) -> np.ndarray:\n    output_data = np.zeros_like(input_data)\n    \n    for i in range(len(input_data)):\n        if input_data[i] < 0:\n            output_data[i] = 0\n        elif input_data[i] >= 0 and input_data[i] < 5:\n            output_data[i] = input_data[i] * 2\n        elif input_data[i] >= 5 and input_data[i] < 10:\n            output_data[i] = input_data[i] * 3\n        else:\n            output_data[i] = input_data[i] * 5\n            \n    for i in range(1, len(output_data)):\n        if output_data[i] % 2 == 0:\n            output_data[i] = output_data[i] + i\n        else:\n            output_data[i] = output_data[i] - i\n    \n    return output_data", "strategy": []}
{"timestamp": "2025-04-27 07:08:48", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.3:\n                    priorities[index] = 0.9\n                elif priority >= 0.3 and priority < 0.6:\n                    priorities[index] = 0.7\n                elif priority >= 0.6 and priority < 0.9:\n                    priorities[index] = 0.5\n                else:\n                    priorities[index] = 0.3\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.1\n                else:\n                    priorities[index] = 0.0\n        if item % 2 == 0:\n            priorities[index] += 0.2\n        else:\n            priorities[index] -= 0.2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.2:\n                    priorities[index] = 0.9\n                elif priority >= 0.2 and priority < 0.4:\n                    priorities[index] = 0.8\n                elif priority >= 0.4 and priority < 0.6:\n                    priorities[index] = 0.7\n                elif priority >= 0.6 and priority < 0.8:\n                    priorities[index] = 0.6\n                elif priority >= 0.8 and priority < 1.0:\n                    priorities[index] = 0.5\n                else:\n                    priorities[index] = 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.2:\n                    priorities[index] = 0.9\n                elif priority >= 0.2 and priority < 0.4:\n                    priorities[index] = 0.8\n                elif priority >= 0.4 and priority < 0.6:\n                    priorities[index] = 0.7\n                elif priority >= 0.6 and priority < 0.8:\n                    priorities[index] = 0.6\n                elif priority >= 0.8 and priority < 1.0:\n                    priorities[index] = 0.5\n                else:\n                    priorities[index] = 0.3\n        \n        if bin_capacity % 2 == 0:\n            priorities[index] += 0.1\n        \n        if bin_capacity % 5 == 0:\n            priorities[index] += 0.2\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:08:51", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.3:\n                    priorities[index] = 0.9\n                elif priority >= 0.3 and priority < 0.6:\n                    priorities[index] = 0.7\n                elif priority >= 0.6 and priority < 0.9:\n                    priorities[index] = 0.5\n                else:\n                    priorities[index] = 0.3\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.1\n                else:\n                    priorities[index] = 0.0\n        if item % 2 == 0:\n            priorities[index] += 0.2\n        else:\n            priorities[index] -= 0.2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.2:\n                    priorities[index] = 0.9\n                elif priority >= 0.2 and priority < 0.4:\n                    priorities[index] = 0.8\n                elif priority >= 0.4 and priority < 0.6:\n                    priorities[index] = 0.7\n                elif priority >= 0.6 and priority < 0.8:\n                    priorities[index] = 0.6\n                elif priority >= 0.8 and priority < 1.0:\n                    priorities[index] = 0.5\n                else:\n                    priorities[index] = 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.2:\n                    priorities[index] = 0.9\n                elif priority >= 0.2 and priority < 0.4:\n                    priorities[index] = 0.8\n                elif priority >= 0.4 and priority < 0.6:\n                    priorities[index] = 0.7\n                elif priority >= 0.6 and priority < 0.8:\n                    priorities[index] = 0.6\n                elif priority >= 0.8 and priority < 1.0:\n                    priorities[index] = 0.5\n                else:\n                    priorities[index] = 0.3\n\n    for i in range(len(bins)):\n        if bins[i] % 2 == 0:\n            priorities[i] += 0.1\n        else:\n            priorities[i] -= 0.1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:08:55", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.3:\n                    priorities[index] = 0.9\n                elif priority >= 0.3 and priority < 0.6:\n                    priorities[index] = 0.7\n                elif priority >= 0.6 and priority < 0.9:\n                    priorities[index] = 0.5\n                else:\n                    priorities[index] = 0.3\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.1\n                else:\n                    priorities[index] = 0.0\n        if item % 2 == 0:\n            priorities[index] += 0.2\n        else:\n            priorities[index] -= 0.2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.2:\n                    priorities[index] = 0.9\n                elif priority >= 0.2 and priority < 0.4:\n                    priorities[index] = 0.8\n                elif priority >= 0.4 and priority < 0.6:\n                    priorities[index] = 0.7\n                elif priority >= 0.6 and priority < 0.8:\n                    priorities[index] = 0.6\n                elif priority >= 0.8 and priority < 1.0:\n                    priorities[index] = 0.5\n                else:\n                    priorities[index] = 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v3(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v2`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.2:\n                    priorities[index] = 0.9\n                elif priority >= 0.2 and priority < 0.4:\n                    priorities[index] = 0.8\n                elif priority >= 0.4 and priority < 0.6:\n                    priorities[index] = 0.7\n                elif priority >= 0.6 and priority < 0.8:\n                    priorities[index] = 0.6\n                elif priority >= 0.8 and priority < 1.0:\n                    priorities[index] = 0.5\n                else:\n                    priorities[index] = 0.4\n                    \n                if bin_capacity % 2 != 0:\n                    priorities[index] += 0.1\n                else:\n                    priorities[index] -= 0.1\n                \n                if item % 3 == 0:\n                    priorities[index] += 0.2\n                elif item % 3 == 1:\n                    priorities[index] -= 0.2\n                else:\n                    priorities[index] += 0.1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:09:04", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:09:09", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                if j % 2 == 0:\n                    priorities[i] += 0.1\n                else:\n                    priorities[i] -= 0.05\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:09:12", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 3 == 0:\n            priorities[i] += 0.3\n        elif i % 3 == 1:\n            priorities[i] -= 0.2\n        elif i % 3 == 2:\n            priorities[i] += 0.1\n        else:\n            priorities[i] -= 0.05\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:09:15", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.25\n        elif i % 4 == 1:\n            priorities[i] -= 0.1\n        elif i % 4 == 2:\n            priorities[i] += 0.15\n        else:\n            for j in range(3):\n                priorities[i] -= 0.05\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(data)\n    \n    for i in range(len(data)):\n        if data[i] < 0:\n            result[i] = data[i] * 2\n        elif data[i] >= 0 and data[i] < 5:\n            result[i] = data[i] + 5\n        elif data[i] >= 5 and data[i] < 10:\n            result[i] = data[i] ** 2\n        else:\n            result[i] = data[i] - 10\n    \n    for i in range(1, len(result)):\n        if result[i] < result[i-1]:\n            result[i] += result[i-1]\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 07:09:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n\n    if item > max_bin_capacity * 0.75:\n        for j in range(len(bins)):\n            if bins[j] == max_bin_capacity:\n                priorities[j] *= 1.5\n    elif item < min_bin_capacity * 0.25:\n        for k in range(len(bins)):\n            if bins[k] == min_bin_capacity:\n                priorities[k] *= 0.5\n\n    for m in range(len(bins)):\n        if bins[m] % 2 == 0:\n            priorities[m] += 0.1\n        elif bins[m] % 3 == 0:\n            priorities[m] += 0.2\n        else:\n            priorities[m] += 0.05\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 3 * bins[i]:\n            priorities[i] *= 2.0\n        elif item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 2.0:\n            priorities[i] = 2.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 4 * bins[i]:\n            priorities[i] *= 2.5\n        elif item > 3 * bins[i]:\n            priorities[i] *= 2.0\n        elif item > 2 * bins[i]:\n            priorities[i] *= 1.8\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.4\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.2\n\n        if bins[i] % 7 == 0:\n            priorities[i] += 0.3\n        elif bins[i] % 5 == 0:\n            priorities[i] += 0.25\n        elif bins[i] % 3 == 0:\n            priorities[i] += 0.2\n        else:\n            priorities[i] += 0.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 3.0:\n            priorities[i] = 3.0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:09:31", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n\n    if item > max_bin_capacity * 0.75:\n        for j in range(len(bins)):\n            if bins[j] == max_bin_capacity:\n                priorities[j] *= 1.5\n    elif item < min_bin_capacity * 0.25:\n        for k in range(len(bins)):\n            if bins[k] == min_bin_capacity:\n                priorities[k] *= 0.5\n\n    for m in range(len(bins)):\n        if bins[m] % 2 == 0:\n            priorities[m] += 0.1\n        elif bins[m] % 3 == 0:\n            priorities[m] += 0.2\n        else:\n            priorities[m] += 0.05\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 3 * bins[i]:\n            priorities[i] *= 2.0\n        elif item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 2.0:\n            priorities[i] = 2.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.8\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.4\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.2\n        elif item >= bins[i]:\n            priorities[i] *= 1.0\n\n        if item % 2 == 0:\n            priorities[i] += 0.1\n        elif item % 3 == 0:\n            priorities[i] += 0.2\n\n        if bins[i] % 2 == 0:\n            priorities[i] += 0.1\n        elif bins[i] % 3 == 0:\n            priorities[i] += 0.2\n        else:\n            priorities[i] += 0.05\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 2.0:\n            priorities[i] = 2.0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:09:34", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n\n    if item > max_bin_capacity * 0.75:\n        for j in range(len(bins)):\n            if bins[j] == max_bin_capacity:\n                priorities[j] *= 1.5\n    elif item < min_bin_capacity * 0.25:\n        for k in range(len(bins)):\n            if bins[k] == min_bin_capacity:\n                priorities[k] *= 0.5\n\n    for m in range(len(bins)):\n        if bins[m] % 2 == 0:\n            priorities[m] += 0.1\n        elif bins[m] % 3 == 0:\n            priorities[m] += 0.2\n        else:\n            priorities[m] += 0.05\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 3 * bins[i]:\n            priorities[i] *= 2.0\n        elif item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 2.0:\n            priorities[i] = 2.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 3 * bins[i]:\n            priorities[i] *= 2.0\n        elif item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 2.0:\n            priorities[i] = 2.0\n        \n        if item % 2 == 0:\n            priorities[i] += 0.1\n        else:\n            priorities[i] -= 0.1\n        \n        if bins[i] % 2 == 0:\n            priorities[i] *= 1.1\n        else:\n            priorities[i] *= 0.9\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:09:37", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n\n    if item > max_bin_capacity * 0.75:\n        for j in range(len(bins)):\n            if bins[j] == max_bin_capacity:\n                priorities[j] *= 1.5\n    elif item < min_bin_capacity * 0.25:\n        for k in range(len(bins)):\n            if bins[k] == min_bin_capacity:\n                priorities[k] *= 0.5\n\n    for m in range(len(bins)):\n        if bins[m] % 2 == 0:\n            priorities[m] += 0.1\n        elif bins[m] % 3 == 0:\n            priorities[m] += 0.2\n        else:\n            priorities[m] += 0.05\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 3 * bins[i]:\n            priorities[i] *= 2.0\n        elif item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 2.0:\n            priorities[i] = 2.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    if item < np.mean(bins):\n        for i in range(len(bins)):\n            if bins[i] % 2 == 0:\n                priorities[i] = item / (bins[i] + 1)\n            else:\n                priorities[i] = item / (bins[i] + 2)\n    else:\n        for i in range(len(bins)):\n            if bins[i] % 2 == 0:\n                priorities[i] = item / (bins[i] - 1)\n            else:\n                priorities[i] = item / (bins[i] - 2)\n                \n            if priorities[i] < 0.1:\n                priorities[i] = 0.1\n            elif priorities[i] > 0.9:\n                priorities[i] = 0.9\n    \n    for j in range(len(bins)):\n        if bins[j] % 3 == 0:\n            priorities[j] *= 1.2\n        elif bins[j] % 5 == 0:\n            priorities[j] *= 1.5\n        else:\n            priorities[j] *= 1.1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:09:49", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.2:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.2 and utilization_ratio < 0.4:\n                priority_score = 0.8 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.4 and utilization_ratio < 0.7:\n                priority_score = 0.6 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.7 and utilization_ratio < 0.9:\n                priority_score = 0.4 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.2 / (1 + utilization_ratio)\n                \n            if remaining_space >= 7:\n                priority_score *= 1.3\n            elif remaining_space >= 4:\n                priority_score *= 1.15\n            \n            if bins[i] >= 20:\n                priority_score *= 1.5\n            elif bins[i] >= 12:\n                priority_score *= 1.25\n            elif bins[i] >= 6:\n                priority_score *= 1.1\n                \n            if item < 6:\n                priority_score += 0.3\n            elif item >= 6 and item < 12:\n                priority_score += 0.15\n            elif item >= 12 and item < 20:\n                priority_score += 0.1\n                \n            if remaining_space > 0.6*bins[i]:\n                priority_score += 0.2\n            elif remaining_space <= 0.6*bins[i] and remaining_space > 0.35*bins[i]:\n                priority_score += 0.1\n            \n            if item % 2 == 0:\n                priority_score += 0.1\n            if bins[i] % 2 == 0:\n                priority_score += 0.1\n            \n            priorities[i] = priority_score\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:09:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "import numpy as np\n\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            if bins[i] % 2 == 0:\n                priority_score += 0.2\n            elif bins[i] % 3 == 0:\n                priority_score += 0.1\n            elif bins[i] % 5 == 0:\n                priority_score += 0.05\n            \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:09:59", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n\n            if bins[i] % 2 == 0:\n                priority_score += 0.05\n            else:\n                priority_score -= 0.05\n            \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:10:04", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            if bins[i] % 2 == 0:\n                priority_score += 0.3\n            elif bins[i] % 2 != 0:\n                priority_score -= 0.2\n            \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:10:16", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more improved version of `priority_v2`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.2:\n                    priorities[index] = 0.9\n                elif priority >= 0.2 and priority < 0.4:\n                    priorities[index] = 0.8\n                elif priority >= 0.4 and priority < 0.6:\n                    priorities[index] = 0.7\n                elif priority >= 0.6 and priority < 0.8:\n                    priorities[index] = 0.6\n                elif priority >= 0.8 and priority < 1.0:\n                    priorities[index] = 0.5\n                else:\n                    priorities[index] = 0.4\n                    \n                if bin_capacity % 2 != 0:\n                    priorities[index] += 0.1\n                else:\n                    priorities[index] -= 0.1\n                \n                if item % 3 == 0:\n                    priorities[index] += 0.2\n                elif item % 3 == 1:\n                    priorities[index] -= 0.2\n                else:\n                    priorities[index] += 0.1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Ultimate version of priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                priorities[index] = priority if priority > 0 else 0\n            else:\n                priorities[index] = 0.1 * (item - bin_capacity)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.1:\n                    priorities[index] = 0.9\n                elif priority >= 0.1 and priority < 0.3:\n                    priorities[index] = 0.8\n                elif priority >= 0.3 and priority < 0.5:\n                    priorities[index] = 0.7\n                elif priority >= 0.5 and priority < 0.7:\n                    priorities[index] = 0.6\n                elif priority >= 0.7 and priority < 0.9:\n                    priorities[index] = 0.5\n                else:\n                    priorities[index] = 0.4\n                    \n                if bin_capacity % 2 != 0:\n                    priorities[index] += 0.1\n                else:\n                    priorities[index] -= 0.1\n                \n                if item % 3 == 0:\n                    priorities[index] += 0.2\n                elif item % 3 == 1:\n                    priorities[index] -= 0.2\n                else:\n                    priorities[index] += 0.1\n            else:\n                priorities[index] = 0.1 * (item - bin_capacity)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:10:20", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more improved version of `priority_v2`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.2:\n                    priorities[index] = 0.9\n                elif priority >= 0.2 and priority < 0.4:\n                    priorities[index] = 0.8\n                elif priority >= 0.4 and priority < 0.6:\n                    priorities[index] = 0.7\n                elif priority >= 0.6 and priority < 0.8:\n                    priorities[index] = 0.6\n                elif priority >= 0.8 and priority < 1.0:\n                    priorities[index] = 0.5\n                else:\n                    priorities[index] = 0.4\n                    \n                if bin_capacity % 2 != 0:\n                    priorities[index] += 0.1\n                else:\n                    priorities[index] -= 0.1\n                \n                if item % 3 == 0:\n                    priorities[index] += 0.2\n                elif item % 3 == 1:\n                    priorities[index] -= 0.2\n                else:\n                    priorities[index] += 0.1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Ultimate version of priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                priorities[index] = priority if priority > 0 else 0\n            else:\n                priorities[index] = 0.1 * (item - bin_capacity)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Complex and creative version of priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.2:\n                    priorities[index] = 0.9\n                elif priority >= 0.2 and priority < 0.5:\n                    priorities[index] = 0.8\n                elif priority >= 0.5 and priority < 0.8:\n                    priorities[index] = 0.7\n                else:\n                    priorities[index] = 0.6\n                \n                if bin_capacity % 2 == 0:\n                    priorities[index] += 0.1\n                else:\n                    priorities[index] -= 0.1\n                \n                if item % 3 == 0:\n                    priorities[index] += 0.2\n                elif item % 3 == 1:\n                    priorities[index] -= 0.2\n                else:\n                    priorities[index] += 0.1\n            \n            else:\n                priorities[index] = 0.1 * (item - bin_capacity)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:10:22", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more improved version of `priority_v2`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.2:\n                    priorities[index] = 0.9\n                elif priority >= 0.2 and priority < 0.4:\n                    priorities[index] = 0.8\n                elif priority >= 0.4 and priority < 0.6:\n                    priorities[index] = 0.7\n                elif priority >= 0.6 and priority < 0.8:\n                    priorities[index] = 0.6\n                elif priority >= 0.8 and priority < 1.0:\n                    priorities[index] = 0.5\n                else:\n                    priorities[index] = 0.4\n                    \n                if bin_capacity % 2 != 0:\n                    priorities[index] += 0.1\n                else:\n                    priorities[index] -= 0.1\n                \n                if item % 3 == 0:\n                    priorities[index] += 0.2\n                elif item % 3 == 1:\n                    priorities[index] -= 0.2\n                else:\n                    priorities[index] += 0.1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Ultimate version of priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                priorities[index] = priority if priority > 0 else 0\n            else:\n                priorities[index] = 0.1 * (item - bin_capacity)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray) -> np.ndarray:\n    result = np.zeros_like(data)\n    \n    for i in range(len(data)):\n        if data[i] % 2 == 0:\n            result[i] = data[i] * 2\n        elif data[i] % 3 == 0:\n            result[i] = data[i] // 3\n        else:\n            result[i] = data[i] + 10\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 07:10:25", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more improved version of `priority_v2`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.2:\n                    priorities[index] = 0.9\n                elif priority >= 0.2 and priority < 0.4:\n                    priorities[index] = 0.8\n                elif priority >= 0.4 and priority < 0.6:\n                    priorities[index] = 0.7\n                elif priority >= 0.6 and priority < 0.8:\n                    priorities[index] = 0.6\n                elif priority >= 0.8 and priority < 1.0:\n                    priorities[index] = 0.5\n                else:\n                    priorities[index] = 0.4\n                    \n                if bin_capacity % 2 != 0:\n                    priorities[index] += 0.1\n                else:\n                    priorities[index] -= 0.1\n                \n                if item % 3 == 0:\n                    priorities[index] += 0.2\n                elif item % 3 == 1:\n                    priorities[index] -= 0.2\n                else:\n                    priorities[index] += 0.1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Ultimate version of priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                priorities[index] = priority if priority > 0 else 0\n            else:\n                priorities[index] = 0.1 * (item - bin_capacity)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "import numpy as np\n\n\ndef advanced_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.2:\n                    priorities[index] = 0.9\n                elif priority >= 0.2 and priority < 0.4:\n                    priorities[index] = 0.8\n                elif priority >= 0.4 and priority < 0.6:\n                    priorities[index] = 0.7\n                elif priority >= 0.6 and priority < 0.8:\n                    priorities[index] = 0.6\n                elif priority >= 0.8 and priority < 1.0:\n                    priorities[index] = 0.5\n                else:\n                    priorities[index] = 0.4\n\n                if bin_capacity % 2 != 0:\n                    priorities[index] += 0.1\n                else:\n                    priorities[index] -= 0.1\n\n                if item % 3 == 0:\n                    priorities[index] += 0.2\n                elif item % 3 == 1:\n                    priorities[index] -= 0.2\n                else:\n                    priorities[index] += 0.1\n            else:\n                priorities[index] = 0.1 * (item - bin_capacity)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:10:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.3:\n            priorities[i] = np.power(np.log(item + 1) + np.log(bins[i] + 1), 2)\n        elif ratios[i] >= 0.3 and ratios[i] < 0.6:\n            priorities[i] = np.tan(np.sqrt(item)) + np.tan(np.sqrt(bins[i]))\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.exp(item) + np.exp(bins[i])\n        else:\n            priorities[i] = np.arctan(item) + np.arctan(bins[i])\n\n    for j in range(len(bins)):\n        if priorities[j] < 30:\n            priorities[j] *= 1.5\n        elif priorities[j] >= 30 and priorities[j] < 50:\n            priorities[j] *= 2\n        elif priorities[j] >= 50 and priorities[j] < 70:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:10:38", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.5:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        else:\n            priorities[i] = np.exp(np.sqrt(item * bins[i])) + np.log(item + bins[i])\n    \n    for j in range(len(bins)):\n        if priorities[j] < 5:\n            priorities[j] *= 1.5\n        elif priorities[j] >= 5 and priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 15:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 15:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:10:42", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.25:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2) + np.sqrt(item * bins[i])\n        elif ratios[i] >= 0.25 and ratios[i] < 0.5:\n            priorities[i] = np.tan(item) + np.tan(bins[i]) * np.sqrt(item)\n        elif ratios[i] >= 0.5 and ratios[i] < 0.75:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1) / np.sqrt(item)\n        else:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i])) - np.cosh(ratios[i])\n    \n    for j in range(len(bins)):\n        if priorities[j] < 15:\n            priorities[j] *= 2\n        elif priorities[j] >= 15 and priorities[j] < 30:\n            priorities[j] += 5\n        elif priorities[j] >= 30 and priorities[j] < 45:\n            priorities[j] -= 3\n        else:\n            priorities[j] = np.log(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 3 == 0:\n            priorities[k] += item * 2\n        elif priorities[k] % 3 == 1:\n            priorities[k] -= item / 2\n        else:\n            priorities[k] += np.sqrt(item)\n        \n        if item > 15:\n            priorities[k] *= 1.8\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:10:48", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n\n    return final_priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:11:10", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    # Brand new logic\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    # Brand new logic\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    # Additional complex logic\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 1.0\n        elif priorities[i] < 2.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:11:16", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    # Brand new logic\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    # Brand new logic\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        elif priorities[i] < 2.0:\n            priorities[i] += 0.5\n        else:\n            priorities[i] -= 0.75\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.5:\n            priorities[i] *= 1.5\n        else:\n            priorities[i] /= 2.0\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:11:22", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    # Brand new logic\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    # Brand new logic\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    # Brand new logic\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if i % 2 == 0:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:11:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    # Brand new logic\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    # Additional custom logic\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    # Brand new logic\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:11:45", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        else:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        else:\n            priorities[j] /= 2\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if item > 5:\n            final_priorities[m] = priorities[m] * 1.1\n        else:\n            final_priorities[m] = priorities[m] * 0.9\n    \n    return final_priorities", "strategy": []}
{"timestamp": "2025-04-27 07:11:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities", "strategy": []}
{"timestamp": "2025-04-27 07:11:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.3:\n            priorities[i] = np.power(np.cos(item) + np.sin(bins[i]), 2)\n        elif ratios[i] >= 0.3 and ratios[i] < 0.6:\n            priorities[i] = np.tanh(item) + np.sinh(bins[i])\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.log(item * bins[i] + 1)\n        else:\n            priorities[i] = np.cos(np.exp(ratios[i])) * np.tan(np.sqrt(ratios[i])) - np.log(ratios[i] + 2)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 15:\n            priorities[j] *= 2.5\n        elif priorities[j] >= 15 and priorities[j] < 25:\n            priorities[j] *= 4\n        elif priorities[j] >= 25 and priorities[j] < 35:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.cbrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 3 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 3\n        \n        if item > 15:\n            priorities[k] *= 1.7\n        else:\n            priorities[k] = np.exp2(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:4]:\n            final_priorities[m] = priorities[m] * 1.4\n        else:\n            final_priorities[m] = priorities[m] * 0.6\n    \n    return final_priorities", "strategy": []}
{"timestamp": "2025-04-27 07:12:00", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n\n    upper_threshold = np.percentile(final_priorities, 75)\n    lower_threshold = np.percentile(final_priorities, 25)\n\n    for n in range(len(bins)):\n        if final_priorities[n] > upper_threshold:\n            final_priorities[n] *= 1.1\n        elif final_priorities[n] < lower_threshold:\n            final_priorities[n] *= 0.9\n\n    return final_priorities", "strategy": []}
{"timestamp": "2025-04-27 07:12:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_function(input_data):\n    # your complex and creative code logic here\n    result = []\n    \n    for data in input_data:\n        if data > 10:\n            result.append(data * 2)\n        elif data > 5:\n            result.append(data * 1.5)\n        else:\n            result.append(data)\n            \n    return result\n```", "strategy": []}
{"timestamp": "2025-04-27 07:12:40", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if bins[i] % 2 == 0:\n                priority_score += 0.1\n            else:\n                priority_score -= 0.1\n                \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:12:46", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if bins[i] % 2 == 0:\n                priority_score *= 1.1\n            \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:12:51", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif 0.1 <= utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif 0.3 <= utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif 0.6 <= utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif 5 <= item < 10:\n                priority_score += 0.1\n            elif 10 <= item < 15:\n                priority_score += 0.05\n                \n            if bins[i] >= 20:\n                priority_score *= 1.5\n            elif bins[i] >= 25:\n                priority_score *= 1.7\n            elif bins[i] >= 30:\n                priority_score *= 1.9\n            elif bins[i] >= 35:\n                priority_score *= 2.0\n                \n            priorities[i] = priority_score\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:13:01", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    min_bin_capacity = np.min(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0\n        elif item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n            \n        if priorities[i] > 0.8:\n            priorities[i] += 0.2\n        elif priorities[i] > 0.5:\n            priorities[i] += 0.15\n        elif priorities[i] > 0.3:\n            priorities[i] += 0.1\n        else:\n            priorities[i] += 0.05\n                \n        if bins[i] == min_bin_capacity:\n            priorities[i] *= 1.2\n        elif bins[i] == max_bin_capacity:\n            priorities[i] *= 0.8\n        else:\n            priorities[i] *= 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    min_bin_capacity = np.min(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0\n        elif item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n            \n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n        \n        if priorities[i] > 0.8:\n            priorities[i] += 0.2\n        elif priorities[i] > 0.5:\n            priorities[i] += 0.15\n        elif priorities[i] > 0.3:\n            priorities[i] += 0.1\n        else:\n            priorities[i] += 0.05\n                \n        if bins[i] == min_bin_capacity:\n            priorities[i] *= 1.2\n        elif bins[i] == max_bin_capacity:\n            priorities[i] *= 0.8\n        else:\n            priorities[i] *= 1.0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:13:05", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    min_bin_capacity = np.min(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0\n        elif item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n            \n        if priorities[i] > 0.8:\n            priorities[i] += 0.2\n        elif priorities[i] > 0.5:\n            priorities[i] += 0.15\n        elif priorities[i] > 0.3:\n            priorities[i] += 0.1\n        else:\n            priorities[i] += 0.05\n                \n        if bins[i] == min_bin_capacity:\n            priorities[i] *= 1.2\n        elif bins[i] == max_bin_capacity:\n            priorities[i] *= 0.8\n        else:\n            priorities[i] *= 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if bins[i] % 2 == 0:\n            priorities[i] += 0.1\n        else:\n            priorities[i] -= 0.1\n\n        if i % 2 == 0:\n            priorities[i] *= 1.2\n        else:\n            priorities[i] *= 0.8\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:13:09", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    min_bin_capacity = np.min(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0\n        elif item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n            \n        if priorities[i] > 0.8:\n            priorities[i] += 0.2\n        elif priorities[i] > 0.5:\n            priorities[i] += 0.15\n        elif priorities[i] > 0.3:\n            priorities[i] += 0.1\n        else:\n            priorities[i] += 0.05\n                \n        if bins[i] == min_bin_capacity:\n            priorities[i] *= 1.2\n        elif bins[i] == max_bin_capacity:\n            priorities[i] *= 0.8\n        else:\n            priorities[i] *= 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0\n        elif item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n            \n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.3\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > bins[i]:\n            priorities[i] *= 1.1\n        else:\n            priorities[i] *= 1.05\n        \n        if bins[i] % 2 == 0:\n            priorities[i] += 0.2\n        elif bins[i] % 3 == 0:\n            priorities[i] += 0.1\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:13:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    min_bin_capacity = np.min(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0\n        elif item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n            \n        if priorities[i] > 0.8:\n            priorities[i] += 0.2\n        elif priorities[i] > 0.5:\n            priorities[i] += 0.15\n        elif priorities[i] > 0.3:\n            priorities[i] += 0.1\n        else:\n            priorities[i] += 0.05\n                \n        if bins[i] == min_bin_capacity:\n            priorities[i] *= 1.2\n        elif bins[i] == max_bin_capacity:\n            priorities[i] *= 0.8\n        else:\n            priorities[i] *= 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    min_bin_capacity = np.min(bins)\n    max_bin_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0\n        elif item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n            \n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n        \n        if priorities[i] > 0.8:\n            priorities[i] += 0.2\n        elif priorities[i] > 0.5:\n            priorities[i] += 0.15\n        elif priorities[i] > 0.3:\n            priorities[i] += 0.1\n        else:\n            priorities[i] += 0.05\n            \n        if bins[i] == min_bin_capacity:\n            priorities[i] *= 1.2\n        elif bins[i] == max_bin_capacity:\n            priorities[i] *= 0.8\n        else:\n            priorities[i] *= 1.0\n        \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:13:26", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Enhanced version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n            if item > 10:\n                priorities[i] += 0.5\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n            if item > 5:\n                priorities[i] -= 0.3\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n                \n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if count == 4:\n                    priorities[i] += 1.0\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if count == 3:\n                    priorities[i] -= 0.5\n                else:\n                    priorities[i] += 0.1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n            if item <= 20:\n                priorities[i] += 0.2\n            else:\n                priorities[i] += 0.5\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n            if item > 5:\n                priorities[i] -= 0.1\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n                \n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if count == 6:\n                    priorities[i] += 0.8\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if count == 4:\n                    priorities[i] -= 0.5\n                else:\n                    priorities[i] += 0.2\n            else:\n                priorities[i] = 0.9 * count + item / bins[i] + 0.3\n                if count == 3:\n                    priorities[i] -= 0.3\n                elif count == 5:\n                    priorities[i] += 0.4\n                \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n            if item <= 20:\n                priorities[i] += 0.2\n            elif item > 20 and item <= 40:\n                priorities[i] += 0.5\n            else:\n                priorities[i] += 0.8\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n            if item > 5 and item <= 10:\n                priorities[i] -= 0.1\n            elif item > 10:\n                priorities[i] -= 0.3\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n                \n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if count == 6:\n                    priorities[i] += 0.8\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if count == 4:\n                    priorities[i] -= 0.5\n                else:\n                    priorities[i] += 0.2\n            else:\n                priorities[i] = 0.9 * count + item / bins[i] + 0.3\n                if count == 3:\n                    priorities[i] -= 0.3\n                elif count == 5:\n                    priorities[i] += 0.4\n                else:\n                    priorities[i] += 0.1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:13:31", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Enhanced version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n            if item > 10:\n                priorities[i] += 0.5\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n            if item > 5:\n                priorities[i] -= 0.3\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n                \n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if count == 4:\n                    priorities[i] += 1.0\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if count == 3:\n                    priorities[i] -= 0.5\n                else:\n                    priorities[i] += 0.1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n            if item <= 20:\n                priorities[i] += 0.2\n            else:\n                priorities[i] += 0.5\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n            if item > 5:\n                priorities[i] -= 0.1\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n                \n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if count == 6:\n                    priorities[i] += 0.8\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if count == 4:\n                    priorities[i] -= 0.5\n                else:\n                    priorities[i] += 0.2\n            else:\n                priorities[i] = 0.9 * count + item / bins[i] + 0.3\n                if count == 3:\n                    priorities[i] -= 0.3\n                elif count == 5:\n                    priorities[i] += 0.4\n                \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Ultimate version of priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n            if item <= 30:\n                priorities[i] += 0.3\n            else:\n                priorities[i] += 0.7\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.6 * item / bins[i] + 0.3\n            if item > 10:\n                priorities[i] -= 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n                \n            if count % 4 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.4\n                if count == 8:\n                    priorities[i] += 1.0\n            elif count % 4 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.4\n                if count == 5:\n                    priorities[i] -= 0.6\n                else:\n                    priorities[i] += 0.3\n            elif count % 4 == 2:\n                priorities[i] = 0.9 * count + item / bins[i] + 0.4\n                if count == 6:\n                    priorities[i] -= 0.4\n                elif count == 10:\n                    priorities[i] -= 0.2\n                else:\n                    priorities[i] += 0.5\n            else:\n                priorities[i] = 0.5 * count + item / bins[i] + 0.4\n                if count == 7:\n                    priorities[i] += 0.8\n                \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:13:37", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Enhanced version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n            if item > 10:\n                priorities[i] += 0.5\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n            if item > 5:\n                priorities[i] -= 0.3\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n                \n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if count == 4:\n                    priorities[i] += 1.0\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if count == 3:\n                    priorities[i] -= 0.5\n                else:\n                    priorities[i] += 0.1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n            if item <= 20:\n                priorities[i] += 0.2\n            else:\n                priorities[i] += 0.5\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n            if item > 5:\n                priorities[i] -= 0.1\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n                \n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if count == 6:\n                    priorities[i] += 0.8\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if count == 4:\n                    priorities[i] -= 0.5\n                else:\n                    priorities[i] += 0.2\n            else:\n                priorities[i] = 0.9 * count + item / bins[i] + 0.3\n                if count == 3:\n                    priorities[i] -= 0.3\n                elif count == 5:\n                    priorities[i] += 0.4\n                \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"An even more enhanced version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n            if item <= 20:\n                priorities[i] += 0.2\n            elif item > 20 and item <= 50:\n                priorities[i] += 0.5\n            else:\n                priorities[i] += 1.0\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n            if item > 5 and item <= 15:\n                priorities[i] -= 0.1\n            elif item > 15:\n                priorities[i] += 0.3\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n                \n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if count == 6:\n                    priorities[i] += 0.8\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if count == 4:\n                    priorities[i] -= 0.5\n                else:\n                    priorities[i] += 0.2\n            else:\n                priorities[i] = 0.9 * count + item / bins[i] + 0.3\n                if count == 3:\n                    priorities[i] -= 0.3\n                elif count == 5:\n                    priorities[i] += 0.4\n                else:\n                    priorities[i] += 0.1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:13:42", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Enhanced version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n            if item > 10:\n                priorities[i] += 0.5\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n            if item > 5:\n                priorities[i] -= 0.3\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n                \n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if count == 4:\n                    priorities[i] += 1.0\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if count == 3:\n                    priorities[i] -= 0.5\n                else:\n                    priorities[i] += 0.1\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n            if item <= 20:\n                priorities[i] += 0.2\n            else:\n                priorities[i] += 0.5\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n            if item > 5:\n                priorities[i] -= 0.1\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n                \n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if count == 6:\n                    priorities[i] += 0.8\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if count == 4:\n                    priorities[i] -= 0.5\n                else:\n                    priorities[i] += 0.2\n            else:\n                priorities[i] = 0.9 * count + item / bins[i] + 0.3\n                if count == 3:\n                    priorities[i] -= 0.3\n                elif count == 5:\n                    priorities[i] += 0.4\n                \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n            if item <= 20:\n                priorities[i] += 0.2\n            elif item <= 40:\n                priorities[i] += 0.5\n            else:\n                priorities[i] += 0.8\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n            if item > 5:\n                priorities[i] -= 0.1\n            if item > 30:\n                priorities[i] -= 0.3\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n                \n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if count == 4:\n                    priorities[i] += 0.8\n            elif count % 2 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if count == 3:\n                    priorities[i] -= 0.5\n                else:\n                    priorities[i] += 0.2\n            else:\n                priorities[i] = 0.9 * count + item / bins[i] + 0.3\n                if count == 5:\n                    priorities[i] -= 0.3\n                elif count == 7:\n                    priorities[i] += 0.4\n                \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:13:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            if bins[i] % 2 == 0:\n                priority_score *= 1.1\n            else:\n                priority_score *= 0.9\n                \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:13:58", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            if priority_score > 1.5:\n                priority_score = 1.5\n            elif priority_score < 0.1:\n                priority_score = 0.1\n                \n            priorities[i] = priority_score\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:14:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n            \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            if bins[i] % 2 == 0:\n                priority_score += 0.1\n            else:\n                priority_score -= 0.1\n                \n            priorities[i] = priority_score\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:14:07", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            if bins[i] % 2 == 0:\n                priority_score += 0.1\n            else:\n                priority_score -= 0.1\n                \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:14:18", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.2\n        elif priorities[i] >= 0.5:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i] + 0.1\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority_index = np.argmax(priorities)\n    min_priority_index = np.argmin(priorities)\n    \n    for i in range(len(priorities)):\n        if i == max_priority_index:\n            priorities[i] = priorities[i] * 1.1\n        elif i == min_priority_index:\n            priorities[i] = priorities[i] * 0.9\n        else:\n            priorities[i] = priorities[i] * 1.05\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    total_bins = len(bins)\n    max_priority_index = np.argmax(priorities)\n    min_priority_index = np.argmin(priorities)\n    \n    for i in range(len(priorities)):\n        if i == max_priority_index:\n            priorities[i] = priorities[i] * 1.2\n        elif i == min_priority_index:\n            priorities[i] = priorities[i] * 0.8\n        else:\n            if i < total_bins // 2:\n                priorities[i] = priorities[i] * 1.1\n            else:\n                priorities[i] = priorities[i] * 0.9\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:14:20", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.2\n        elif priorities[i] >= 0.5:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i] + 0.1\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority_index = np.argmax(priorities)\n    min_priority_index = np.argmin(priorities)\n    \n    for i in range(len(priorities)):\n        if i == max_priority_index:\n            priorities[i] = priorities[i] * 1.1\n        elif i == min_priority_index:\n            priorities[i] = priorities[i] * 0.9\n        else:\n            priorities[i] = priorities[i] * 1.05\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority_index = np.argmax(priorities)\n    min_priority_index = np.argmin(priorities)\n    \n    for i in range(len(priorities)):\n        if i == max_priority_index:\n            priorities[i] = priorities[i] + 0.1\n        elif i == min_priority_index:\n            priorities[i] = priorities[i] - 0.1\n        elif priorities[i] >= 0.5:\n            priorities[i] = priorities[i] - 0.05\n        else:\n            priorities[i] = priorities[i] + 0.05\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:14:23", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.2\n        elif priorities[i] >= 0.5:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i] + 0.1\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority_index = np.argmax(priorities)\n    min_priority_index = np.argmin(priorities)\n    \n    for i in range(len(priorities)):\n        if i == max_priority_index:\n            priorities[i] = priorities[i] * 1.1\n        elif i == min_priority_index:\n            priorities[i] = priorities[i] * 0.9\n        else:\n            priorities[i] = priorities[i] * 1.05\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority_index = np.argmax(priorities)\n    min_priority_index = np.argmin(priorities)\n    \n    for i in range(len(priorities)):\n        if i == max_priority_index:\n            priorities[i] = priorities[i] * 1.2\n        elif i == min_priority_index:\n            priorities[i] = priorities[i] * 0.8\n        else:\n            priorities[i] = priorities[i] * 1.1\n    \n    total_priority = np.sum(priorities)\n    \n    for i in range(len(priorities)):\n        priorities[i] = priorities[i] / total_priority\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:14:26", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.2\n        elif priorities[i] >= 0.5:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i] + 0.1\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority_index = np.argmax(priorities)\n    min_priority_index = np.argmin(priorities)\n    \n    for i in range(len(priorities)):\n        if i == max_priority_index:\n            priorities[i] = priorities[i] * 1.1\n        elif i == min_priority_index:\n            priorities[i] = priorities[i] * 0.9\n        else:\n            priorities[i] = priorities[i] * 1.05\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority_index = np.argmax(priorities)\n    min_priority_index = np.argmin(priorities)\n    \n    for i in range(len(priorities)):\n        if i == max_priority_index:\n            priorities[i] = priorities[i] * 1.2\n        elif i == min_priority_index:\n            priorities[i] = priorities[i] * 0.8\n        elif i % 2 == 0:\n            priorities[i] = priorities[i] * 1.1\n        else:\n            priorities[i] = priorities[i] * 0.9\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:14:40", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if bins[i] < 5:\n                priority_score += 0.1\n            elif bins[i] >= 5 and bins[i] < 10:\n                priority_score += 0.05\n            \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.2:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.2 and utilization_ratio < 0.5:\n                priority_score = 0.6 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.5 and utilization_ratio < 0.7:\n                priority_score = 0.4 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.7 and utilization_ratio < 0.9:\n                priority_score = 0.2 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.3\n            elif remaining_space >= 3:\n                priority_score *= 1.2\n            \n            if bins[i] >= 20:\n                priority_score *= 1.5\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.1\n                \n            if item < 5:\n                priority_score += 0.3\n            elif item >= 5 and item < 10:\n                priority_score += 0.2\n            elif item >= 10 and item < 15:\n                priority_score += 0.1\n                \n            if bins[i] < 5:\n                priority_score += 0.2\n            elif bins[i] >= 5 and bins[i] < 10:\n                priority_score += 0.1\n                \n            if item % 2 == 0:\n                priority_score += 0.1\n                \n            if bins[i] % 2 == 0:\n                priority_score += 0.2\n                \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:14:45", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if bins[i] < 5:\n                priority_score += 0.1\n            elif bins[i] >= 5 and bins[i] < 10:\n                priority_score += 0.05\n            \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n\n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n\n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n\n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n\n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n\n            if bins[i] < 5:\n                priority_score += 0.1\n            elif bins[i] >= 5 and bins[i] < 10:\n                priority_score += 0.05\n\n            if utilization_ratio < 0.2:\n                priority_score *= 1.1\n            elif utilization_ratio >= 0.6:\n                priority_score *= 0.9\n\n            priorities[i] = priority_score\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:14:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if bins[i] < 5:\n                priority_score += 0.1\n            elif bins[i] >= 5 and bins[i] < 10:\n                priority_score += 0.05\n            \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if bins[i] < 5:\n                priority_score += 0.1\n            elif bins[i] >= 5 and bins[i] < 10:\n                priority_score += 0.05\n            \n            # Additional complex logic here\n            if item % 2 == 0 or bins[i] % 2 == 0:\n                priority_score += 0.3\n            elif item % 3 == 0 and bins[i] % 3 == 0:\n                priority_score += 0.5\n            elif item % 5 == 0 or bins[i] % 5 == 0:\n                priority_score += 0.4\n            else:\n                priority_score += 0.1\n                \n            priorities[i] = priority_score\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:14:55", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if bins[i] < 5:\n                priority_score += 0.1\n            elif bins[i] >= 5 and bins[i] < 10:\n                priority_score += 0.05\n            \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.05:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.05 and utilization_ratio < 0.2:\n                priority_score = 0.8 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.2 and utilization_ratio < 0.4:\n                priority_score = 0.6 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.4 and utilization_ratio < 0.6:\n                priority_score = 0.4 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.2 / (1 + utilization_ratio)\n                \n            if remaining_space >= 7:\n                priority_score *= 1.3\n            elif remaining_space >= 4:\n                priority_score *= 1.15\n            \n            if bins[i] >= 20:\n                priority_score *= 1.5\n            elif bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.2\n                \n            if item < 7:\n                priority_score += 0.3\n            elif item >= 7 and item < 12:\n                priority_score += 0.15\n            elif item >= 12 and item < 17:\n                priority_score += 0.1\n                \n            if bins[i] < 7:\n                priority_score += 0.2\n            elif bins[i] >= 7 and bins[i] < 12:\n                priority_score += 0.1\n            \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:15:08", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n\n    return final_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n            priorities[i] = np.abs(np.tan(priorities[i]))\n            \n        if bins[i] % 2 == 0:\n            priorities[i] += item\n        else:\n            priorities[i] -= item / 2\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for j in range(len(bins)):\n        if priorities[j] in sorted_priorities[:4]:\n            final_priorities[j] = priorities[j] * 1.5\n        else:\n            final_priorities[j] = np.sqrt(priorities[j]) * 0.9\n    \n    return final_priorities", "strategy": []}
{"timestamp": "2025-04-27 07:15:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n\n    return final_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    # Additional complex logic here\n    for n in range(len(bins)):\n        if final_priorities[n] < 50:\n            final_priorities[n] += np.sqrt(final_priorities[n])\n        elif final_priorities[n] >= 50 and final_priorities[n] < 100:\n            final_priorities[n] -= np.log(final_priorities[n])\n        elif final_priorities[n] >= 100 and final_priorities[n] < 150:\n            final_priorities[n] = np.sin(final_priorities[n]) + np.cos(final_priorities[n])\n        else:\n            final_priorities[n] = np.exp(np.tan(final_priorities[n]))\n    \n    return final_priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:15:18", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n\n    return final_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] = np.floor(priorities[j])\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] = np.ceil(priorities[j])\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] = np.around(priorities[j], decimals=1)\n        else:\n            priorities[j] = np.trunc(priorities[j])\n\n    for k in range(len(bins)):\n        if k % 2 == 0:\n            priorities[k] = np.square(priorities[k])\n        else:\n            priorities[k] = np.cbrt(priorities[k])\n\n        if item > 10:\n            priorities[k] *= 2\n        else:\n            priorities[k] = np.exp2(priorities[k])\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:15:23", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n\n    return final_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n\n    return final_priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:15:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > bin_capacity * 0.7:\n                priorities[index] = 0.9\n            elif remaining_capacity > bin_capacity * 0.4:\n                priorities[index] = 0.7\n            else:\n                priority = 1 / remaining_capacity\n                priorities[index] = priority if priority > 0 else 0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > bin_capacity * 0.8:\n                priorities[index] = 0.9\n            elif remaining_capacity > bin_capacity * 0.6:\n                priorities[index] = 0.8\n            elif remaining_capacity > bin_capacity * 0.4:\n                priorities[index] = 0.7\n            elif remaining_capacity > bin_capacity * 0.2:\n                priorities[index] = 0.6\n            else:\n                priority = 1 / remaining_capacity\n                priorities[index] = max(priority, 0)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:15:52", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > bin_capacity * 0.7:\n                priorities[index] = 0.9\n            elif remaining_capacity > bin_capacity * 0.4:\n                priorities[index] = 0.7\n            else:\n                priority = 1 / remaining_capacity\n                priorities[index] = priority if priority > 0 else 0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > bin_capacity * 0.7:\n                priorities[index] = 0.9\n            elif remaining_capacity > bin_capacity * 0.4:\n                priorities[index] = 0.7\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.5\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.3\n                else:\n                    priorities[index] = 0.1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:15:56", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > bin_capacity * 0.7:\n                priorities[index] = 0.9\n            elif remaining_capacity > bin_capacity * 0.4:\n                priorities[index] = 0.7\n            else:\n                priority = 1 / remaining_capacity\n                priorities[index] = priority if priority > 0 else 0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > bin_capacity * 0.7:\n                priorities[index] = 0.9\n            elif remaining_capacity > bin_capacity * 0.4:\n                priorities[index] = 0.7\n            else:\n                priority = 1 / remaining_capacity\n                priorities[index] = priority if priority > 0 else 0\n                \n                if priority < 0.5:\n                    priorities[index] *= 0.8\n                else:\n                    priorities[index] *= 0.6\n                    \n                if item > bin_capacity * 1.5:\n                    priorities[index] *= 0.5\n                elif item > bin_capacity * 2:\n                    priorities[index] *= 0.3\n                else:\n                    priorities[index] *= 0.4\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:15:59", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[index] = 0.3\n                    else:\n                        priorities[index] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[index] = 0.2\n                else:\n                    priorities[index] = 0.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > bin_capacity * 0.7:\n                priorities[index] = 0.9\n            elif remaining_capacity > bin_capacity * 0.4:\n                priorities[index] = 0.7\n            else:\n                priority = 1 / remaining_capacity\n                priorities[index] = priority if priority > 0 else 0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > bin_capacity * 0.8:\n                priorities[index] = 0.9\n            elif remaining_capacity > bin_capacity * 0.6:\n                priorities[index] = 0.7\n            elif remaining_capacity > bin_capacity * 0.4:\n                priorities[index] = 0.5\n            elif remaining_capacity > bin_capacity * 0.2:\n                priorities[index] = 0.3\n            else:\n                priority = 1 / remaining_capacity\n                priorities[index] = priority if priority > 0 else 0\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:16:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5 and item < 3 * bins[i]:\n            priorities[i] = 1.5\n        elif item >= 3 * bins[i] and item < 4 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 3.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        ratio = item / bins[i]\n\n        if ratio < 0.5:\n            priorities[i] = 0.5\n        elif ratio >= 0.5 and ratio < 1.0:\n            priorities[i] = (1 + ratio) / 2\n        elif ratio >= 1.0 and ratio < 1.5:\n            priorities[i] = (1 + ratio) / 2.5\n        elif ratio >= 1.5 and ratio < 2.0:\n            priorities[i] = (1 + ratio) / 3\n        elif ratio >= 2.0 and ratio < 3.0:\n            priorities[i] = (1 + ratio) / 4\n        else:\n            priorities[i] = 1.0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:16:10", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5 and item < 3 * bins[i]:\n            priorities[i] = 1.5\n        elif item >= 3 * bins[i] and item < 4 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 3.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5 and item < 3 * bins[i]:\n            priorities[i] = 1.5\n        elif item >= 3 * bins[i] and item < 4 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 3.0\n\n        if bins[i] % 2 == 0:\n            priorities[i] *= 0.8\n        elif bins[i] % 3 == 0:\n            priorities[i] *= 0.5\n        else:\n            priorities[i] *= 1.0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:16:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5 and item < 3 * bins[i]:\n            priorities[i] = 1.5\n        elif item >= 3 * bins[i] and item < 4 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 3.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5 and item < 3 * bins[i]:\n            priorities[i] = 1.5\n        elif item >= 3 * bins[i] and item < 4 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 3.0\n\n        if bins[i] % 2 == 0:\n            priorities[i] += 0.1\n        else:\n            priorities[i] -= 0.1\n\n        if bins[i] % 3 == 0:\n            priorities[i] *= 1.2\n        elif bins[i] % 5 == 0:\n            priorities[i] *= 1.5\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:16:17", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5 and item < 3 * bins[i]:\n            priorities[i] = 1.5\n        elif item >= 3 * bins[i] and item < 4 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 3.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            if item < 0.5 * bins[i]:\n                priorities[i] = 0.3\n            elif item >= 0.5 * bins[i] and item < bins[i]:\n                priorities[i] = 0.5\n        elif priorities[i] > 1.5 and item < 3 * bins[i]:\n            if item < 2 * bins[i]:\n                priorities[i] = 1.7\n            elif item >= 2 * bins[i] and item < 2.5 * bins[i]:\n                priorities[i] = 1.9\n            elif item >= 2.5 * bins[i] and item < 3 * bins[i]:\n                priorities[i] = 1.95\n        elif item >= 3 * bins[i] and item < 4 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 3.0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:16:26", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-20 * (ratio - 0.3))) + 0.2\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.5))) + 0.3\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.7))) + 0.4\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 0.9))) + 0.5\n\n        if i % 3 == 0:\n            priorities[i] += 0.1\n        else:\n            for j in range(5):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:16:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n            if i % 3 == 0:\n                priorities[i] *= 1.1\n            else:\n                priorities[i] /= 1.2\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:16:34", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n        if i > 10:\n            priorities[i] *= 1.5\n        elif i > 5:\n            priorities[i] *= 1.2\n        else:\n            priorities[i] *= 0.8\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:16:38", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n        \n        if ratio < 0.3:\n            priorities[i] *= 1.2\n        else:\n            priorities[i] *= 0.8\n        \n        if i % 3 == 0:\n            priorities[i] = np.clip(priorities[i], 0.2, 0.8)\n        else:\n            priorities[i] = np.clip(priorities[i], 0.4, 0.9)\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:16:52", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.25:\n                priorities[i] = 0.3\n            elif ratio >= 0.25 and ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 0.75:\n                priorities[i] = 0.7\n            else:\n                priorities[i] = 0.9\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.25:\n                priorities[i] = 0.3\n            elif ratio >= 0.25 and ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 0.75:\n                priorities[i] = 0.7\n            else:\n                priorities[i] = 0.9\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            ratio = item / bins[i]\n            \n            if ratio < 0.1:\n                priorities[i] = 0.1\n            elif ratio >= 0.1 and ratio < 0.2:\n                priorities[i] = 0.2\n            elif ratio >= 0.2 and ratio < 0.3:\n                priorities[i] = 0.3\n            elif ratio >= 0.3 and ratio < 0.4:\n                priorities[i] = 0.4\n            elif ratio >= 0.4 and ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.7:\n                priorities[i] = 0.7\n            elif ratio >= 0.7 and ratio < 0.8:\n                priorities[i] = 0.8\n            elif ratio >= 0.8 and ratio < 0.9:\n                priorities[i] = 0.9\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:16:55", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.25:\n                priorities[i] = 0.3\n            elif ratio >= 0.25 and ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 0.75:\n                priorities[i] = 0.7\n            else:\n                priorities[i] = 0.9\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.25:\n                priorities[i] = 0.3\n            elif ratio >= 0.25 and ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 0.75:\n                priorities[i] = 0.7\n            else:\n                priorities[i] = 0.9\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef advanced_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio >= 0.2 and ratio < 0.4:\n                priorities[i] = 0.3\n            elif ratio >= 0.4 and ratio < 0.6:\n                priorities[i] = 0.5\n            elif ratio >= 0.6 and ratio < 0.8:\n                priorities[i] = 0.7\n            else:\n                priorities[i] = 0.9\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:16:58", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.25:\n                priorities[i] = 0.3\n            elif ratio >= 0.25 and ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 0.75:\n                priorities[i] = 0.7\n            else:\n                priorities[i] = 0.9\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.25:\n                priorities[i] = 0.3\n            elif ratio >= 0.25 and ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 0.75:\n                priorities[i] = 0.7\n            else:\n                priorities[i] = 0.9\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.1:\n                priorities[i] = 0.2\n            elif ratio >= 0.1 and ratio < 0.3:\n                priorities[i] = 0.4\n            elif ratio >= 0.3 and ratio < 0.5:\n                priorities[i] = 0.6\n            elif ratio >= 0.5 and ratio < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:17:01", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.25:\n                priorities[i] = 0.3\n            elif ratio >= 0.25 and ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 0.75:\n                priorities[i] = 0.7\n            else:\n                priorities[i] = 0.9\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.25:\n                priorities[i] = 0.3\n            elif ratio >= 0.25 and ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 0.75:\n                priorities[i] = 0.7\n            else:\n                priorities[i] = 0.9\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.1:\n                priorities[i] = 0.2\n            elif ratio >= 0.1 and ratio < 0.3:\n                priorities[i] = 0.4\n            elif ratio >= 0.3 and ratio < 0.5:\n                priorities[i] = 0.6\n            elif ratio >= 0.5 and ratio < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:17:12", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for k in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < k:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] -= 0.5\n        elif priorities[i] < 2.0:\n            priorities[i] += 1.0\n        else:\n            priorities[i] += 1.5\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:17:18", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if item > 25 and i % 4 == 0:\n            priorities[i] += 1.5\n        elif item < 10 and i % 3 == 0:\n            priorities[i] -= 0.75\n        else:\n            priorities[i] += 1.25\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:17:24", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:17:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:17:49", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.1\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.2\n            if item % 2 == 0:\n                priorities[i] += 0.1\n            if item > 5:\n                priorities[i] += 0.3\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < 0.5 * bins[i]:\n                priorities[i] = (item / bins[i]) * (1 - 0.1 * i)\n            elif item > 1.5 * bins[i]:\n                priorities[i] = (bins[i] / item) * (1 + 0.05 * i)\n            else:\n                if bins[i] % 2 == 0:\n                    priorities[i] = (item * bins[i] / (item + bins[i])) + 0.2\n                else:\n                    priorities[i] = (item * bins[i] / (item + bins[i])) - 0.1\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < 0.5 * bins[i]:\n                priorities[i] = (item / bins[i]) * (1 - 0.1 * i)\n            elif item > 1.5 * bins[i]:\n                priorities[i] = (bins[i] / item) * (1 + 0.05 * i)\n            else:\n                if bins[i] % 2 == 0:\n                    priorities[i] = (item * bins[i] / (item + bins[i])) + 0.2\n                else:\n                    priorities[i] = (item * bins[i] / (item + bins[i])) - 0.1\n                if item % 5 == 0:\n                    priorities[i] += 0.4\n                elif item % 3 == 0:\n                    priorities[i] += 0.2\n                if bins[i] > 10:\n                    priorities[i] += 0.2\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:17:51", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.1\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.2\n            if item % 2 == 0:\n                priorities[i] += 0.1\n            if item > 5:\n                priorities[i] += 0.3\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < 0.5 * bins[i]:\n                priorities[i] = (item / bins[i]) * (1 - 0.1 * i)\n            elif item > 1.5 * bins[i]:\n                priorities[i] = (bins[i] / item) * (1 + 0.05 * i)\n            else:\n                if bins[i] % 2 == 0:\n                    priorities[i] = (item * bins[i] / (item + bins[i])) + 0.2\n                else:\n                    priorities[i] = (item * bins[i] / (item + bins[i])) - 0.1\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < 0.5 * bins[i]:\n                priorities[i] = (item / bins[i]) * (1 - 0.1 * i)\n            elif item > 1.5 * bins[i]:\n                priorities[i] = (bins[i] / item) * (1 + 0.05 * i)\n            else:\n                if bins[i] % 2 == 0:\n                    priorities[i] = (item * bins[i] / (item + bins[i])) + 0.2\n                else:\n                    priorities[i] = (item * bins[i] / (item + bins[i])) - 0.1\n                if item % 2 == 0:\n                    priorities[i] += 0.1\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:17:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.1\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.2\n            if item % 2 == 0:\n                priorities[i] += 0.1\n            if item > 5:\n                priorities[i] += 0.3\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < 0.5 * bins[i]:\n                priorities[i] = (item / bins[i]) * (1 - 0.1 * i)\n            elif item > 1.5 * bins[i]:\n                priorities[i] = (bins[i] / item) * (1 + 0.05 * i)\n            else:\n                if bins[i] % 2 == 0:\n                    priorities[i] = (item * bins[i] / (item + bins[i])) + 0.2\n                else:\n                    priorities[i] = (item * bins[i] / (item + bins[i])) - 0.1\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < 0.5 * bins[i]:\n                priorities[i] = (item / bins[i]) * (1 - 0.1 * i)\n            elif item > 1.5 * bins[i]:\n                priorities[i] = (bins[i] / item) * (1 + 0.05 * i)\n            else:\n                if bins[i] % 2 == 0:\n                    if item % 2 == 0:\n                        priorities[i] = (item * bins[i] / (item + bins[i])) + 0.2\n                    else:\n                        priorities[i] = (item * bins[i] / (item + bins[i])) - 0.1\n                else:\n                    if item > 10:\n                        priorities[i] = (item - bins[i]) / item\n                    else:\n                        priorities[i] = (item + bins[i]) / item\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:17:58", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.1\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.2\n            if item % 2 == 0:\n                priorities[i] += 0.1\n            if item > 5:\n                priorities[i] += 0.3\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < 0.5 * bins[i]:\n                priorities[i] = (item / bins[i]) * (1 - 0.1 * i)\n            elif item > 1.5 * bins[i]:\n                priorities[i] = (bins[i] / item) * (1 + 0.05 * i)\n            else:\n                if bins[i] % 2 == 0:\n                    priorities[i] = (item * bins[i] / (item + bins[i])) + 0.2\n                else:\n                    priorities[i] = (item * bins[i] / (item + bins[i])) - 0.1\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.1\n        else:\n            if item % 2 == 0:\n                priorities[i] = 0.2\n            else:\n                priorities[i] = 0.1\n            if bins[i] > item:\n                priorities[i] += 0.2\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.1\n            ratio = item / bins[i]\n            if ratio < 0.2:\n                priorities[i] += 0.1\n            elif ratio < 0.5:\n                priorities[i] += 0.3\n            elif ratio < 0.8:\n                priorities[i] += 0.5\n            else:\n                priorities[i] += 0.8\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:18:07", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Further improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            remaining_space = bins[i] - item\n            if remaining_space <= 0.1 * bins[i]:\n                priorities[i] = 0.2\n            elif remaining_space > 0.1 * bins[i] and remaining_space <= 0.3 * bins[i]:\n                priorities[i] = 0.4\n            elif remaining_space > 0.3 * bins[i] and remaining_space <= 0.5 * bins[i]:\n                priorities[i] = 0.6\n            elif remaining_space > 0.5 * bins[i] and remaining_space <= 0.7 * bins[i]:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.25:\n                priorities[i] = 0.3\n            elif ratio >= 0.25 and ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 0.75:\n                priorities[i] = 0.7\n            else:\n                priorities[i] = 0.9\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            remaining_space_ratio = (item - bins[i]) / bins[i]\n            if remaining_space_ratio < 0.1:\n                priorities[i] = 0.3\n            elif remaining_space_ratio >= 0.1 and remaining_space_ratio < 0.3:\n                priorities[i] = 0.5\n            elif remaining_space_ratio >= 0.3 and remaining_space_ratio < 0.5:\n                priorities[i] = 0.7\n            else:\n                priority = 0.9\n                for j in range(1, int(remaining_space_ratio) + 1):\n                    priority -= 0.1\n                priorities[i] = priority\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:18:10", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Further improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            remaining_space = bins[i] - item\n            if remaining_space <= 0.1 * bins[i]:\n                priorities[i] = 0.2\n            elif remaining_space > 0.1 * bins[i] and remaining_space <= 0.3 * bins[i]:\n                priorities[i] = 0.4\n            elif remaining_space > 0.3 * bins[i] and remaining_space <= 0.5 * bins[i]:\n                priorities[i] = 0.6\n            elif remaining_space > 0.5 * bins[i] and remaining_space <= 0.7 * bins[i]:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.25:\n                priorities[i] = 0.3\n            elif ratio >= 0.25 and ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 0.75:\n                priorities[i] = 0.7\n            else:\n                priorities[i] = 0.9\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "import numpy as np\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.25:\n                priorities[i] = 0.3\n            elif ratio >= 0.25 and ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 0.75:\n                priorities[i] = 0.7\n            else:\n                priorities[i] = 0.9\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:18:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Further improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            remaining_space = bins[i] - item\n            if remaining_space <= 0.1 * bins[i]:\n                priorities[i] = 0.2\n            elif remaining_space > 0.1 * bins[i] and remaining_space <= 0.3 * bins[i]:\n                priorities[i] = 0.4\n            elif remaining_space > 0.3 * bins[i] and remaining_space <= 0.5 * bins[i]:\n                priorities[i] = 0.6\n            elif remaining_space > 0.5 * bins[i] and remaining_space <= 0.7 * bins[i]:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.25:\n                priorities[i] = 0.3\n            elif ratio >= 0.25 and ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 0.75:\n                priorities[i] = 0.7\n            else:\n                priorities[i] = 0.9\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            remaining_space = bins[i] - item\n            if remaining_space <= 0.1 * bins[i]:\n                priorities[i] = 0.2\n            elif remaining_space > 0.1 * bins[i] and remaining_space <= 0.3 * bins[i]:\n                priorities[i] = 0.4\n            elif remaining_space > 0.3 * bins[i] and remaining_space <= 0.5 * bins[i]:\n                priorities[i] = 0.6\n            elif remaining_space > 0.5 * bins[i] and remaining_space <= 0.7 * bins[i]:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:18:16", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Further improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            remaining_space = bins[i] - item\n            if remaining_space <= 0.1 * bins[i]:\n                priorities[i] = 0.2\n            elif remaining_space > 0.1 * bins[i] and remaining_space <= 0.3 * bins[i]:\n                priorities[i] = 0.4\n            elif remaining_space > 0.3 * bins[i] and remaining_space <= 0.5 * bins[i]:\n                priorities[i] = 0.6\n            elif remaining_space > 0.5 * bins[i] and remaining_space <= 0.7 * bins[i]:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.25:\n                priorities[i] = 0.3\n            elif ratio >= 0.25 and ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 0.75:\n                priorities[i] = 0.7\n            else:\n                priorities[i] = 0.9\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            remaining_space = item - bins[i]\n            if remaining_space < 0.2 * item:\n                priorities[i] = 0.3\n            elif remaining_space >= 0.2 * item and remaining_space < 0.4 * item:\n                priorities[i] = 0.5\n            elif remaining_space >= 0.4 * item and remaining_space < 0.6 * item:\n                priorities[i] = 0.7\n            else:\n                priorities[i] = 0.9\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.25:\n                priorities[i] = 0.2\n            elif ratio >= 0.25 and ratio < 0.5:\n                priorities[i] = 0.4\n            elif ratio >= 0.5 and ratio < 0.75:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:18:29", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:18:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n            \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n    \n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n    \n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n       \n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n    \n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n    \n    priorities *= 1.1  # Added multiplier for all priorities\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:18:40", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            priority_val = 0.0\n            if remaining_capacity > 0:\n                priority_val = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priority_val = 2.0\n\n            if i % 2 == 0:\n                priority_val *= 1.5\n\n            if item % 2 == 0:\n                priority_val += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priority_val += 1.0\n\n            if item % 3 == 0:\n                priority_val *= 2.0\n\n            if i > 0:\n                priority_val += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priority_val += 2.0\n\n            if i % 3 == 0:\n                priority_val -= 0.5\n\n            if item % 5 == 0:\n                priority_val += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priority_val -= 0.25\n                elif i % 4 == 1:\n                    priority_val += 0.5\n                elif i % 4 == 2:\n                    priority_val -= 0.75\n                else:\n                    priority_val += 1.0\n\n            priorities[i] = priority_val\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:18:45", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n    \n    for i in range(len(priorities)):\n        if i % 2 == 0:\n            priorities[i] += 0.5\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 3 == 0:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:19:01", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    if bins[i] % 2 == 0:\n                        priorities[i] = item / bins[i] + 0.2\n                    elif bins[i] % 3 == 0:\n                        priorities[i] = item / bins[i] + 0.3\n                    else:\n                        priorities[i] = item / bins[i] + 0.5\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.5\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                remaining_space = bins[i] - item\n                if remaining_space < item * 0.2:\n                    priorities[i] = 0.1\n                elif remaining_space < item * 0.5:\n                    priorities[i] = 0.3\n                else:\n                    priorities[i] = 0.5\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    if bins[i] % 2 == 0:\n                        priorities[i] = item / bins[i] + 0.2\n                    elif bins[i] % 3 == 0:\n                        priorities[i] = item / bins[i] + 0.3\n                    else:\n                        priorities[i] = item / bins[i] + 0.5\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:19:04", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    if bins[i] % 2 == 0:\n                        priorities[i] = item / bins[i] + 0.2\n                    elif bins[i] % 3 == 0:\n                        priorities[i] = item / bins[i] + 0.3\n                    else:\n                        priorities[i] = item / bins[i] + 0.5\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.5\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.2\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.1:\n                priorities[i] = 0.1\n            elif 0.1 <= ratio < 0.3:\n                priorities[i] = 0.3\n            elif 0.3 <= ratio < 0.5:\n                priorities[i] = 0.5\n            elif 0.5 <= ratio < 0.7:\n                priorities[i] = 0.7\n            elif 0.7 <= ratio < 0.9:\n                priorities[i] = 0.9\n            else:\n                priorities[i] = 1.0\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:19:07", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    if bins[i] % 2 == 0:\n                        priorities[i] = item / bins[i] + 0.2\n                    elif bins[i] % 3 == 0:\n                        priorities[i] = item / bins[i] + 0.3\n                    else:\n                        priorities[i] = item / bins[i] + 0.5\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.5\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\n\ndef priority_complex(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.5\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n\n    # Additional logic\n    for j in range(len(bins)):\n        if bins[j] == 0:\n            priorities[j] = 0.0\n        elif bins[j] % item == 0:\n            priorities[j] += 0.5\n        elif item % bins[j] == 0:\n            priorities[j] += 0.3\n        else:\n            priorities[j] -= 0.2\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:19:10", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    if bins[i] % 2 == 0:\n                        priorities[i] = item / bins[i] + 0.2\n                    elif bins[i] % 3 == 0:\n                        priorities[i] = item / bins[i] + 0.3\n                    else:\n                        priorities[i] = item / bins[i] + 0.5\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.5\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.5\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                if item % 2 == 0 and bins[i] % 2 == 0:\n                    priorities[i] = 0.7\n                elif item % 3 == 0 and bins[i] % 3 == 0:\n                    priorities[i] = 0.75\n                else:\n                    priorities[i] = 0.8\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:19:18", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = (max_capacity - remaining_capacity) / max_capacity\n                priorities[index] = min(1.0, max(0, priority))\n            else:\n                priorities[index] = 0.2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"More complex version of the priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.4:\n                    priorities[i] = 0.9\n                elif priority >= 0.4 and priority < 0.7:\n                    priorities[i] = 0.7\n                elif priority >= 0.7 and priority < 1.0:\n                    priorities[i] = 0.5\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[i] = 0.2\n                    else:\n                        priorities[i] = 0.3\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[i] = 0.1\n                else:\n                    priorities[i] = 0.0\n                    \n                if priorities[i] == 0.0:\n                    for j in range(i+1, len(bins)):\n                        if bins[j] >= item:\n                            priorities[j] = 0.6\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.4:\n                    priorities[i] = 0.9\n                elif priority >= 0.4 and priority < 0.7:\n                    priorities[i] = 0.7\n                elif priority >= 0.7 and priority < 1.0:\n                    priorities[i] = 0.5\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[i] = 0.2\n                    else:\n                        priorities[i] = 0.3\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[i] = 0.1\n                else:\n                    priorities[i] = 0.0\n                    \n                if priorities[i] == 0.0:\n                    for j in range(i+1, len(bins)):\n                        if bins[j] >= item:\n                            priorities[j] = 0.6\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:19:21", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = (max_capacity - remaining_capacity) / max_capacity\n                priorities[index] = min(1.0, max(0, priority))\n            else:\n                priorities[index] = 0.2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"More complex version of the priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.4:\n                    priorities[i] = 0.9\n                elif priority >= 0.4 and priority < 0.7:\n                    priorities[i] = 0.7\n                elif priority >= 0.7 and priority < 1.0:\n                    priorities[i] = 0.5\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[i] = 0.2\n                    else:\n                        priorities[i] = 0.3\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[i] = 0.1\n                else:\n                    priorities[i] = 0.0\n                    \n                if priorities[i] == 0.0:\n                    for j in range(i+1, len(bins)):\n                        if bins[j] >= item:\n                            priorities[j] = 0.6\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.4:\n                    priorities[i] = 0.9\n                elif priority >= 0.4 and priority < 0.7:\n                    priorities[i] = 0.7\n                else:\n                    priorities[i] = 0.5\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[i] = 0.1\n                else:\n                    priorities[i] = 0.0\n                    \n                if priorities[i] == 0.0:\n                    for j in range(i+1, len(bins)):\n                        if bins[j] >= item:\n                            priorities[j] = 0.6\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:19:25", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = (max_capacity - remaining_capacity) / max_capacity\n                priorities[index] = min(1.0, max(0, priority))\n            else:\n                priorities[index] = 0.2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"More complex version of the priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.4:\n                    priorities[i] = 0.9\n                elif priority >= 0.4 and priority < 0.7:\n                    priorities[i] = 0.7\n                elif priority >= 0.7 and priority < 1.0:\n                    priorities[i] = 0.5\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[i] = 0.2\n                    else:\n                        priorities[i] = 0.3\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[i] = 0.1\n                else:\n                    priorities[i] = 0.0\n                    \n                if priorities[i] == 0.0:\n                    for j in range(i+1, len(bins)):\n                        if bins[j] >= item:\n                            priorities[j] = 0.6\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more complex version of the priority function with additional conditions.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.4:\n                    priorities[i] = 0.9\n                elif priority >= 0.4 and priority < 0.7:\n                    priorities[i] = 0.7\n                elif priority >= 0.7 and priority < 1.0:\n                    priorities[i] = 0.5\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[i] = 0.2\n                    else:\n                        priorities[i] = 0.3\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[i] = 0.1\n                else:\n                    priorities[i] = 0.0\n                    \n                    if priorities[i] == 0.0:\n                        for j in range(i+1, len(bins)):\n                            if bins[j] >= item:\n                                priorities[j] = 0.6\n                            else:\n                                priorities[j] = 0.4\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:19:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    max_capacity = np.max(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = (max_capacity - remaining_capacity) / max_capacity\n                priorities[index] = min(1.0, max(0, priority))\n            else:\n                priorities[index] = 0.2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"More complex version of the priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.4:\n                    priorities[i] = 0.9\n                elif priority >= 0.4 and priority < 0.7:\n                    priorities[i] = 0.7\n                elif priority >= 0.7 and priority < 1.0:\n                    priorities[i] = 0.5\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[i] = 0.2\n                    else:\n                        priorities[i] = 0.3\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[i] = 0.1\n                else:\n                    priorities[i] = 0.0\n                    \n                if priorities[i] == 0.0:\n                    for j in range(i+1, len(bins)):\n                        if bins[j] >= item:\n                            priorities[j] = 0.6\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"More complex and improved version of the priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.4:\n                    priorities[i] = 0.9\n                elif priority >= 0.4 and priority < 0.7:\n                    priorities[i] = 0.7\n                elif priority >= 0.7 and priority < 1.0:\n                    priorities[i] = 0.5\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[i] = 0.2\n                    else:\n                        priorities[i] = 0.3\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[i] = 0.1\n                else:\n                    priorities[i] = 0.0\n                    \n                if priorities[i] == 0.0:\n                    for j in range(i+1, len(bins)):\n                        if bins[j] >= item:\n                            priorities[j] = 0.6\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:19:37", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version with more complex logic.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if item >= bins[i] * 0.8:\n                priorities[i] = count + item / bins[i] + 0.3\n            elif item >= bins[i] * 0.5:\n                priorities[i] = count + item / bins[i] + 0.4\n            else:\n                priorities[i] = count + item / bins[i] + 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n                \n            if bins[i] % 5 == 0:\n                priorities[i] *= 1.5\n            elif bins[i] % 3 == 0:\n                priorities[i] *= 1.2\n            else:\n                priorities[i] *= 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more complex and creative version of the priority function.\"\"\"\n    \n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if item % 2 == 0:\n                priorities[i] = item / bins[i] + 0.1\n            else:\n                priorities[i] = item / bins[i] + 0.2\n        elif bins[i] >= item / 2:\n            if item % 3 == 0:\n                priorities[i] = 0.5 * item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.5 * item / bins[i] + 0.4\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n                \n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n                \n            if bins[i] % 5 == 0:\n                priorities[i] *= 1.5\n            elif bins[i] % 3 == 0:\n                priorities[i] *= 1.4\n            else:\n                priorities[i] *= 1.2\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:19:41", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version with more complex logic.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if item >= bins[i] * 0.8:\n                priorities[i] = count + item / bins[i] + 0.3\n            elif item >= bins[i] * 0.5:\n                priorities[i] = count + item / bins[i] + 0.4\n            else:\n                priorities[i] = count + item / bins[i] + 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n                \n            if bins[i] % 5 == 0:\n                priorities[i] *= 1.5\n            elif bins[i] % 3 == 0:\n                priorities[i] *= 1.2\n            else:\n                priorities[i] *= 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Another improved version with even more complex logic.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n\n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n\n            if bins[i] % 5 == 0:\n                priorities[i] *= 1.5\n            elif bins[i] % 3 == 0:\n                priorities[i] *= 1.2\n            else:\n                priorities[i] *= 1.0\n\n            if item % 2 == 0:\n                priorities[i] += 0.5\n            elif item % 3 == 0:\n                priorities[i] += 0.3\n            else:\n                priorities[i] += 0.1\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:19:45", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version with more complex logic.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if item >= bins[i] * 0.8:\n                priorities[i] = count + item / bins[i] + 0.3\n            elif item >= bins[i] * 0.5:\n                priorities[i] = count + item / bins[i] + 0.4\n            else:\n                priorities[i] = count + item / bins[i] + 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n                \n            if bins[i] % 5 == 0:\n                priorities[i] *= 1.5\n            elif bins[i] % 3 == 0:\n                priorities[i] *= 1.2\n            else:\n                priorities[i] *= 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n                \n            if bins[i] % 5 == 0:\n                priorities[i] *= 1.5\n            elif bins[i] % 3 == 0:\n                priorities[i] *= 1.2\n            else:\n                priorities[i] *= 1.0\n                \n            if item > 20:\n                priorities[i] += 2.0\n            elif item > 10:\n                priorities[i] += 1.0\n            else:\n                priorities[i] += 0.5\n                \n            if item % 2 == 0:\n                priorities[i] *= 1.2\n            elif item % 3 == 0:\n                priorities[i] *= 1.5\n            else:\n                priorities[i] *= 1.0\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:19:49", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version with more complex logic.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if item >= bins[i] * 0.8:\n                priorities[i] = count + item / bins[i] + 0.3\n            elif item >= bins[i] * 0.5:\n                priorities[i] = count + item / bins[i] + 0.4\n            else:\n                priorities[i] = count + item / bins[i] + 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n                \n            if bins[i] % 5 == 0:\n                priorities[i] *= 1.5\n            elif bins[i] % 3 == 0:\n                priorities[i] *= 1.2\n            else:\n                priorities[i] *= 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Another improved version with even more complex logic.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n                \n            if bins[i] % 5 == 0:\n                priorities[i] *= 1.5\n            elif bins[i] % 3 == 0:\n                priorities[i] *= 1.2\n            else:\n                priorities[i] *= 1.0\n                \n            if item % 2 == 0:\n                priorities[i] *= 1.7\n            elif item % 3 == 0:\n                priorities[i] *= 1.4\n            else:\n                priorities[i] *= 1.1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:20:00", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.2\n            elif item + bins[i] > 100:\n                priorities[i] -= 0.1\n            else:\n                priorities[i] += 0.3\n            \n            if item > bins[i] + 50:\n                priorities[i] *= 1.7\n            elif item > bins[i] + 30:\n                priorities[i] *= 1.4\n            elif item > bins[i] + 20:\n                priorities[i] *= 1.2\n            \n            if item % bins[i] == 1:\n                priorities[i] += 0.1\n            elif item + bins[i] > 150:\n                priorities[i] -= 0.2\n            else:\n                priorities[i] += 0.4\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.3\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n                \n            if item % 2 == 0:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.1\n                \n            if item > 3 * np.median(bins):\n                priorities[i] += 0.4\n            elif item < np.min(bins):\n                priorities[i] -= 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.3\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n                \n            if item % 2 == 0:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.1\n                \n            if item > 3 * np.median(bins):\n                priorities[i] += 0.4\n            elif item < np.min(bins):\n                priorities[i] -= 0.3\n                \n            if item % 5 == 0:\n                priorities[i] += 0.2\n            elif item % 3 == 0:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.1\n            \n            if item > 2 * np.max(bins):\n                priorities[i] += 0.5\n            elif item < 0.5 * np.min(bins):\n                priorities[i] -= 0.5\n                \n            if item % 4 == 0:\n                priorities[i] += 0.3\n            else:\n                priorities[i] -= 0.4\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:20:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.2\n            elif item + bins[i] > 100:\n                priorities[i] -= 0.1\n            else:\n                priorities[i] += 0.3\n            \n            if item > bins[i] + 50:\n                priorities[i] *= 1.7\n            elif item > bins[i] + 30:\n                priorities[i] *= 1.4\n            elif item > bins[i] + 20:\n                priorities[i] *= 1.2\n            \n            if item % bins[i] == 1:\n                priorities[i] += 0.1\n            elif item + bins[i] > 150:\n                priorities[i] -= 0.2\n            else:\n                priorities[i] += 0.4\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.3\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n                \n            if item % 2 == 0:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.1\n                \n            if item > 3 * np.median(bins):\n                priorities[i] += 0.4\n            elif item < np.min(bins):\n                priorities[i] -= 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.3\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n                \n            if item % 2 == 0:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.1\n                \n            if item > 3 * np.median(bins):\n                priorities[i] += 0.4\n            elif item < np.min(bins):\n                priorities[i] -= 0.3\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:20:07", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.2\n            elif item + bins[i] > 100:\n                priorities[i] -= 0.1\n            else:\n                priorities[i] += 0.3\n            \n            if item > bins[i] + 50:\n                priorities[i] *= 1.7\n            elif item > bins[i] + 30:\n                priorities[i] *= 1.4\n            elif item > bins[i] + 20:\n                priorities[i] *= 1.2\n            \n            if item % bins[i] == 1:\n                priorities[i] += 0.1\n            elif item + bins[i] > 150:\n                priorities[i] -= 0.2\n            else:\n                priorities[i] += 0.4\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.3\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n                \n            if item % 2 == 0:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.1\n                \n            if item > 3 * np.median(bins):\n                priorities[i] += 0.4\n            elif item < np.min(bins):\n                priorities[i] -= 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.3\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n                \n            if item % 2 == 0:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.1\n                \n            if item > 3 * np.median(bins):\n                priorities[i] += 0.4\n            elif item < np.min(bins):\n                priorities[i] -= 0.3\n            \n            if bins[i] > 50:\n                priorities[i] *= 1.2\n            else:\n                priorities[i] /= 1.2\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:20:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.2\n            elif item + bins[i] > 100:\n                priorities[i] -= 0.1\n            else:\n                priorities[i] += 0.3\n            \n            if item > bins[i] + 50:\n                priorities[i] *= 1.7\n            elif item > bins[i] + 30:\n                priorities[i] *= 1.4\n            elif item > bins[i] + 20:\n                priorities[i] *= 1.2\n            \n            if item % bins[i] == 1:\n                priorities[i] += 0.1\n            elif item + bins[i] > 150:\n                priorities[i] -= 0.2\n            else:\n                priorities[i] += 0.4\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.3\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n                \n            if item % 2 == 0:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.1\n                \n            if item > 3 * np.median(bins):\n                priorities[i] += 0.4\n            elif item < np.min(bins):\n                priorities[i] -= 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.3\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n                \n            if item % 2 == 0:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.1\n                \n            if item > 3 * np.median(bins):\n                priorities[i] += 0.4\n            elif item < np.min(bins):\n                priorities[i] -= 0.3\n            \n            if item < np.percentile(bins, 25):\n                priorities[i] -= 0.1\n            elif item > np.percentile(bins, 75):\n                priorities[i] += 0.2\n            \n            if i % 2 == 0:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.1\n            \n            if item > bins[i] * 2.5:\n                priorities[i] *= 1.8\n            elif item > bins[i] * 2:\n                priorities[i] *= 1.6\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:20:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n        \n    for l in range(len(bins)):\n        if priorities[l] > 100:\n            priorities[l] = np.log(priorities[l])\n        elif priorities[l] <= 100 and priorities[l] > 50:\n            priorities[l] = np.sqrt(priorities[l])\n        else:\n            priorities[l] = np.power(priorities[l], 2)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:20:39", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.5:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.5 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            for _ in range(int(item)):\n                priorities[i] += np.sin(_) * np.cos(bins[i])\n        else:\n            for _ in range(int(bins[i])):\n                priorities[i] += np.tan(item + _)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if bins[k] < 5:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:20:42", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif 0.2 <= ratios[i] < 0.6:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        else:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        \n        if priorities[i] < 5:\n            priorities[i] = np.sqrt(priorities[i])\n        elif priorities[i] >= 5 and priorities[i] < 10:\n            priorities[i] = np.cbrt(priorities[i])\n    \n    for j in range(len(bins)):\n        if priorities[j] % 2 == 0:\n            priorities[j] -= item / 2\n        else:\n            priorities[j] += item * 1.5\n        \n        if item > 5:\n            priorities[j] *= 2\n        else:\n            priorities[j] = np.exp(priorities[j])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:20:47", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n        \n        priorities[k] = np.clip(priorities[k], a_min=0, a_max=100)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:21:23", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more advanced version of `priority` function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.1\n            elif item % bins[i] == 1:\n                priorities[i] -= 0.1\n                \n            if item - bins[i] >= 10:\n                priorities[i] += 0.2\n            elif item - bins[i] <= 5:\n                priorities[i] -= 0.2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.1\n            elif item % bins[i] == 1:\n                priorities[i] -= 0.1\n                \n            if item - bins[i] >= 10:\n                priorities[i] += 0.2\n            elif item - bins[i] <= 5:\n                priorities[i] -= 0.2\n                \n            if bins[i] % 2 == 0:\n                priorities[i] += 0.2\n            else:\n                priorities[i] -= 0.2\n                \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:21:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more advanced version of `priority` function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.1\n            elif item % bins[i] == 1:\n                priorities[i] -= 0.1\n                \n            if item - bins[i] >= 10:\n                priorities[i] += 0.2\n            elif item - bins[i] <= 5:\n                priorities[i] -= 0.2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more advanced version of `priority` function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.1\n            elif item % bins[i] == 1:\n                priorities[i] -= 0.1\n                \n            if item - bins[i] >= 10:\n                priorities[i] += 0.2\n            elif item - bins[i] <= 5:\n                priorities[i] -= 0.2\n            \n            if bins[i] < 10:\n                priorities[i] += 0.1\n            elif bins[i] >= 10 and bins[i] < 20:\n                priorities[i] += 0.2\n            elif bins[i] >= 20 and bins[i] < 30:\n                priorities[i] += 0.3\n            else:\n                priorities[i] += 0.5\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:21:32", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more advanced version of `priority` function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.1\n            elif item % bins[i] == 1:\n                priorities[i] -= 0.1\n                \n            if item - bins[i] >= 10:\n                priorities[i] += 0.2\n            elif item - bins[i] <= 5:\n                priorities[i] -= 0.2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = item / bins[i]\n            \n            if item % 2 == 0:\n                priorities[i] += 0.1\n            elif item % 3 == 0:\n                priorities[i] += 0.2\n            elif item % 5 == 0:\n                priorities[i] += 0.3\n            else:\n                priorities[i] += 0.4\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.1\n            elif item % bins[i] == 1:\n                priorities[i] -= 0.1\n                \n            if item - bins[i] >= 10:\n                priorities[i] += 0.2\n            elif item - bins[i] <= 5:\n                priorities[i] -= 0.2\n                \n            if item % 2 == 0:\n                priorities[i] -= 0.3\n            elif item % 3 == 0:\n                priorities[i] -= 0.4\n            else:\n                priorities[i] -= 0.5\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:21:36", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more advanced version of `priority` function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.1\n            elif item % bins[i] == 1:\n                priorities[i] -= 0.1\n                \n            if item - bins[i] >= 10:\n                priorities[i] += 0.2\n            elif item - bins[i] <= 5:\n                priorities[i] -= 0.2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.1\n            elif item % bins[i] == 1:\n                priorities[i] -= 0.1\n                \n            if item - bins[i] >= 10:\n                priorities[i] += 0.2\n            elif item - bins[i] <= 5:\n                priorities[i] -= 0.2\n                \n            if item > 50 and bins[i] > 20:\n                priorities[i] += 0.3\n            elif item < 30 or bins[i] < 10:\n                priorities[i] -= 0.3\n                \n            if item % 5 == 0 and bins[i] % 3 == 0:\n                priorities[i] += 0.4\n            elif item % 2 == 0 or bins[i] % 5 == 0:\n                priorities[i] -= 0.4\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:21:49", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.3\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.1\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n            \n            if item % 3 == 0:\n                priorities[i] += 0.5\n            \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.1\n            elif item % bins[i] == 1:\n                priorities[i] -= 0.1\n                \n            if item - bins[i] >= 10:\n                priorities[i] += 0.2\n            elif item - bins[i] <= 5:\n                priorities[i] -= 0.2\n                \n            if bins[i] % 2 == 0:\n                priorities[i] += 0.2\n            else:\n                priorities[i] -= 0.2\n                \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"More complex version of the priority calculation function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.3\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.1\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n            \n            if item % 3 == 0:\n                priorities[i] += 0.5\n            \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n                \n            if item < bins[i] * 0.3:\n                priorities[i] -= 0.2\n            elif item < bins[i] * 0.5:\n                priorities[i] -= 0.1\n            elif item > bins[i] * 0.7:\n                priorities[i] += 0.1\n            elif item > bins[i] * 0.9:\n                priorities[i] += 0.3\n                \n            if item % bins[i] == 0:\n                priorities[i] += 0.2\n            elif item % bins[i] == 1:\n                priorities[i] -= 0.1\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:21:53", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.3\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.1\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n            \n            if item % 3 == 0:\n                priorities[i] += 0.5\n            \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.1\n            elif item % bins[i] == 1:\n                priorities[i] -= 0.1\n                \n            if item - bins[i] >= 10:\n                priorities[i] += 0.2\n            elif item - bins[i] <= 5:\n                priorities[i] -= 0.2\n                \n            if bins[i] % 2 == 0:\n                priorities[i] += 0.2\n            else:\n                priorities[i] -= 0.2\n                \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n            \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n            \n            if item % 2 == 0:\n                priorities[i] += 0.3\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.1\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n            \n            if item % 3 == 0:\n                priorities[i] += 0.5\n            \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n            \n            if item - bins[i] >= 10:\n                priorities[i] += 0.3\n            elif item - bins[i] <= 5:\n                priorities[i] -= 0.1\n                \n            if bins[i] % 2 == 0:\n                priorities[i] += 0.3\n            else:\n                priorities[i] -= 0.3\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:21:57", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.3\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.1\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n            \n            if item % 3 == 0:\n                priorities[i] += 0.5\n            \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.1\n            elif item % bins[i] == 1:\n                priorities[i] -= 0.1\n                \n            if item - bins[i] >= 10:\n                priorities[i] += 0.2\n            elif item - bins[i] <= 5:\n                priorities[i] -= 0.2\n                \n            if bins[i] % 2 == 0:\n                priorities[i] += 0.2\n            else:\n                priorities[i] -= 0.2\n                \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.1\n            elif item % bins[i] == 1:\n                priorities[i] -= 0.1\n                \n            if item - bins[i] >= 10:\n                priorities[i] += 0.2\n            elif item - bins[i] <= 5:\n                priorities[i] -= 0.2\n                \n            if bins[i] % 2 == 0:\n                priorities[i] += 0.2\n            else:\n                priorities[i] -= 0.2\n                \n            if item > np.mean(bins):\n                priorities[i] += 0.15\n            elif item < np.median(bins):\n                priorities[i] -= 0.1\n                \n            if bins[i] > np.mean(bins):\n                priorities[i] += 0.1\n            elif bins[i] < np.median(bins):\n                priorities[i] -= 0.05\n                \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:22:02", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.3\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.1\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n            \n            if item % 3 == 0:\n                priorities[i] += 0.5\n            \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.1\n            elif item % bins[i] == 1:\n                priorities[i] -= 0.1\n                \n            if item - bins[i] >= 10:\n                priorities[i] += 0.2\n            elif item - bins[i] <= 5:\n                priorities[i] -= 0.2\n                \n            if bins[i] % 2 == 0:\n                priorities[i] += 0.2\n            else:\n                priorities[i] -= 0.2\n                \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.3\n                \n            if item > 100 and bins[i] > 50:\n                priorities[i] += 0.7\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.median(bins):\n                priorities[i] += 0.1\n            elif item < np.mean(bins):\n                priorities[i] -= 0.2\n            \n            if item % 3 == 0:\n                priorities[i] += 0.5\n                \n            if item - bins[i] >= 20:\n                priorities[i] += 0.4\n            elif item - bins[i] <= 10:\n                priorities[i] -= 0.4\n                \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:22:17", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n        if i % 3 == 0:\n            priorities[i] *= 1.5\n            for k in range(4):\n                if i % (k + 3) == 0:\n                    priorities[i] -= 0.07 * k\n                else:\n                    priorities[i] += 0.03 * k\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:22:20", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.15:\n            priorities[i] = 1 / (1 + np.exp(-35 * (ratio - 0.15))) + 0.1\n        elif ratio >= 0.15 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-18 * (ratio - 0.35))) + 0.3\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-12 * (ratio - 0.55))) + 0.4\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-7 * (ratio - 0.75))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 1))) + 0.6\n\n        if i % 3 == 0:\n            priorities[i] += 0.4\n        else:\n            for j in range(6):\n                if i % (j + 3) == 0:\n                    priorities[i] -= 0.06 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:22:24", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.3:\n            priorities[i] = 1 / (1 + np.exp(-20 * (ratio - 0.3))) + 0.2\n        elif ratio >= 0.3 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.4))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-3 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 4 == 0:\n            priorities[i] += 0.4\n        else:\n            for j in range(6, 1, -1):\n                if i % j == 0:\n                    priorities[i] -= 0.08 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:22:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-40 * (ratio - 0.2))) + 0.1\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-25 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-20 * (ratio - 0.5))) + 0.5\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.7))) + 0.7\n        else:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.9))) + 0.9\n\n        if i % 3 == 0:\n            priorities[i] += 0.2\n        else:\n            for j in range(4):\n                if i % (j + 1) == 0:\n                    priorities[i] -= 0.03 * j\n                else:\n                    priorities[i] += 0.01 * j\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:22:44", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n    avg_priority = np.mean(priorities)\n    \n    for j in range(len(bins)):\n        if priorities[j] > avg_priority:\n            priorities[j] *= 1.5\n        elif priorities[j] < avg_priority:\n            priorities[j] *= 0.9\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.3\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n                \n            if item % 2 == 0:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.1\n                \n            if item > 3 * np.median(bins):\n                priorities[i] += 0.4\n            elif item < np.min(bins):\n                priorities[i] -= 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if item % 2 == 0:\n                priorities[i] = item / bins[i] + 1\n            else:\n                priorities[i] = item / bins[i] + 0.5\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.7\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.7\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.3\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.9\n                \n            if item > np.mean(bins):\n                priorities[i] += 0.5\n            elif item < np.median(bins):\n                priorities[i] -= 0.4\n            \n            if item % 3 == 0:\n                priorities[i] += 0.2\n            else:\n                priorities[i] -= 0.2\n                \n            if item > 2 * np.median(bins):\n                priorities[i] += 0.6\n            elif item < np.min(bins):\n                priorities[i] -= 0.5\n            \n            if item == np.max(bins):\n                priorities[i] += 1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:22:48", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n    avg_priority = np.mean(priorities)\n    \n    for j in range(len(bins)):\n        if priorities[j] > avg_priority:\n            priorities[j] *= 1.5\n        elif priorities[j] < avg_priority:\n            priorities[j] *= 0.9\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.3\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n                \n            if item % 2 == 0:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.1\n                \n            if item > 3 * np.median(bins):\n                priorities[i] += 0.4\n            elif item < np.min(bins):\n                priorities[i] -= 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n                \n            if item > np.mean(bins):\n                priorities[i] += 0.3\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n                \n            if item % 2 == 0:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.1\n                \n            if item > 3 * np.median(bins):\n                priorities[i] += 0.4\n            elif item < np.min(bins):\n                priorities[i] -= 0.3\n            \n            if item >= bins[i]:\n                priorities[i] *= 1.5\n            else:\n                priorities[i] *= 0.7\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:22:52", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n    avg_priority = np.mean(priorities)\n    \n    for j in range(len(bins)):\n        if priorities[j] > avg_priority:\n            priorities[j] *= 1.5\n        elif priorities[j] < avg_priority:\n            priorities[j] *= 0.9\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.3\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n                \n            if item % 2 == 0:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.1\n                \n            if item > 3 * np.median(bins):\n                priorities[i] += 0.4\n            elif item < np.min(bins):\n                priorities[i] -= 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n            else:\n                priorities[i] += 0.1 if item % 2 == 0 else -0.1\n                \n            if item > np.mean(bins):\n                priorities[i] += 0.3\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n                \n            if item > 3 * np.median(bins):\n                priorities[i] += 0.4\n            elif item < np.min(bins):\n                priorities[i] -= 0.3\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n                \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:22:57", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n    avg_priority = np.mean(priorities)\n    \n    for j in range(len(bins)):\n        if priorities[j] > avg_priority:\n            priorities[j] *= 1.5\n        elif priorities[j] < avg_priority:\n            priorities[j] *= 0.9\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.3\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n                \n            if item % 2 == 0:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.1\n                \n            if item > 3 * np.median(bins):\n                priorities[i] += 0.4\n            elif item < np.min(bins):\n                priorities[i] -= 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.3\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n                \n            if item % 2 == 0:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.1\n                \n            if item > 3 * np.median(bins):\n                priorities[i] += 0.4\n            elif item < np.min(bins):\n                priorities[i] -= 0.3\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.1\n            else:\n                priorities[i] *= 0.9\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:23:39", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n\n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.3:\n            priorities[i] = np.power(np.sin(item) - np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.3 and ratios[i] < 0.6:\n            priorities[i] = np.tan(item) * np.tan(bins[i])\n        elif ratios[i] >= 0.6:\n            priorities[-i] = np.log1p(item*bins[i])\n\n    for j in range(len(bins)):\n        if priorities[j] < 15:\n            priorities[j] *= 3\n        elif priorities[j] >= 15 and priorities[j] < 25:\n            priorities[j] *= 4\n        elif priorities[j] >= 25 and priorities[j] < 35:\n            priorities[j] /= 3\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 3 == 0:\n            priorities[k] += item / 2\n        else:\n            priorities[k] -= item / 3\n\n        if item > 15:\n            priorities[k] *= 1.2\n        else:\n            priorities[k] = np.exp2(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:4]:\n            final_priorities[m] = priorities[m] * 1.3\n        else:\n            final_priorities[m] = priorities[m] * 0.7\n\n    return final_priorities", "strategy": []}
{"timestamp": "2025-04-27 07:23:44", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n\n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if item > 5 and bins[j] > 10:\n            priorities[j] *= 2\n        elif item < 5 and bins[j] < 10:\n            priorities[j] *= 3\n        else:\n            priorities[j] /= 2\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n        if item > 15:\n            priorities[k] *= 1.6\n        elif item < 5:\n            priorities[k] = np.exp(priorities[k] ** 2)\n        else:\n            priorities[k] = np.square(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:4]:\n            final_priorities[m] = priorities[m] * 1.4\n        else:\n            final_priorities[m] = priorities[m] * 0.6\n\n    return final_priorities", "strategy": []}
{"timestamp": "2025-04-27 07:23:48", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n\n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.3:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.3 and ratios[i] < 0.5:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.5 and ratios[i] < 0.7:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.7 and ratios[i] < 0.9:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 15:\n            priorities[j] *= 2\n        elif priorities[j] >= 15 and priorities[j] < 25:\n            priorities[j] *= 3\n        elif priorities[j] >= 25 and priorities[j] < 35:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 3 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 3\n\n        if item > 15:\n            priorities[k] *= 1.7\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:4]:\n            final_priorities[m] = priorities[m] * 1.3\n        else:\n            final_priorities[m] = priorities[m] * 0.7\n\n    return final_priorities", "strategy": []}
{"timestamp": "2025-04-27 07:23:52", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n\n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.3:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 3)\n        elif ratios[i] >= 0.3 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.sqrt(item) + np.sqrt(bins[i])) * np.exp(np.abs(item - bins[i]))\n        elif ratios[i] >= 0.6 and ratios[i] < 0.9:\n            priorities[i] = np.arcsin(np.sqrt(np.abs(item - bins[i])))\n        else:\n            priorities[i] = np.cosh(np.log(np.power(item, 2)) + np.tanh(bins[i]))\n\n    for j in range(len(bins)):\n        if priorities[j] < 15:\n            priorities[j] *= 1.2\n        elif priorities[j] >= 15 and priorities[j] < 25:\n            priorities[j] -= 5\n        elif priorities[j] >= 25 and priorities[j] < 35:\n            priorities[j] **= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 3 == 0:\n            priorities[k] += item * 1.5\n        else:\n            priorities[k] -= item * 0.5\n\n        if item > 8:\n            priorities[k] *= 1.8\n        else:\n            priorities[k] = np.log(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:4]:\n            final_priorities[m] = np.square(priorities[m]) + 10\n        else:\n            final_priorities[m] = priorities[m] - 5\n\n    return final_priorities", "strategy": []}
{"timestamp": "2025-04-27 07:24:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for k in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < k:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.75\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:24:32", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n                    \n            if remaining_capacity % 2 == 0:\n                priorities[i] *= 1.25\n                \n            if item < 3:\n                priorities[i] -= 0.5\n            \n            if item > 15 and i % 2 == 0:\n                priorities[i] += 1.0\n                \n            if item % 7 == 0:\n                priorities[i] += 2.5\n                \n            if i % 5 == 0:\n                priorities[i] -= 1.0\n                \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:24:38", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for k in range(3):\n        for i in range(len(priorities)):\n            if item * k >= bins[i]:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.75\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:24:44", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:25:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if bins[i] < 5:\n                priority_score += 0.1\n            elif bins[i] >= 5 and bins[i] < 10:\n                priority_score += 0.05\n            \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if bins[i] < 5:\n                priority_score += 0.1\n            elif bins[i] >= 5 and bins[i] < 10:\n                priority_score += 0.05\n            \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif 0.1 <= utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif 0.3 <= utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif 0.6 <= utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif 3 <= remaining_space < 5:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif 10 <= bins[i] < 15:\n                priority_score *= 1.3\n            elif 5 <= bins[i] < 10:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif 5 <= item < 10:\n                priority_score += 0.1\n            elif 10 <= item < 15:\n                priority_score += 0.05\n                \n            if bins[i] < 5:\n                priority_score += 0.1\n            elif 5 <= bins[i] < 10:\n                priority_score += 0.05\n            \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:25:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if bins[i] < 5:\n                priority_score += 0.1\n            elif bins[i] >= 5 and bins[i] < 10:\n                priority_score += 0.05\n            \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if bins[i] < 5:\n                priority_score += 0.1\n            elif bins[i] >= 5 and bins[i] < 10:\n                priority_score += 0.05\n            \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n            \n            if bins[i] % 2 == 0 and item % 2 == 0:\n                priority_score *= 1.1\n            elif bins[i] % 2 != 0 and item % 2 != 0:\n                priority_score *= 1.2\n            \n            for j in range(int(item)):\n                priority_score *= 1.02\n            \n            if item % 10 == 0:\n                priority_score += 0.5\n            \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:25:11", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if bins[i] < 5:\n                priority_score += 0.1\n            elif bins[i] >= 5 and bins[i] < 10:\n                priority_score += 0.05\n            \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if bins[i] < 5:\n                priority_score += 0.1\n            elif bins[i] >= 5 and bins[i] < 10:\n                priority_score += 0.05\n            \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if bins[i] < 5:\n                priority_score += 0.1\n            elif bins[i] >= 5 and bins[i] < 10:\n                priority_score += 0.05\n                \n            if bins[i] % 2 == 0:\n                priority_score *= 1.1\n            elif bins[i] % 3 == 0:\n                priority_score *= 1.2\n            elif bins[i] % 5 == 0:\n                priority_score *= 1.3\n            \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:25:16", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if bins[i] < 5:\n                priority_score += 0.1\n            elif bins[i] >= 5 and bins[i] < 10:\n                priority_score += 0.05\n            \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if bins[i] < 5:\n                priority_score += 0.1\n            elif bins[i] >= 5 and bins[i] < 10:\n                priority_score += 0.05\n            \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n\n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n\n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n\n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n\n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n\n            if bins[i] < 5:\n                priority_score += 0.1\n            elif bins[i] >= 5 and bins[i] < 10:\n                priority_score += 0.05\n\n            if remaining_space % 2 == 0:\n                priority_score *= 1.1\n\n            if bins[i] % 2 != 0:\n                priority_score += 0.1\n\n            if item % 3 == 0:\n                priority_score += 0.2\n\n            priorities[i] = priority_score\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:25:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n                    \n            for j in range(5):\n                if priorities[i] < j:\n                    priorities[i] -= 0.25\n                else:\n                    priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:25:36", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:25:42", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:25:47", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            priority_score = 0\n\n            if remaining_capacity > 0:\n                priority_score = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priority_score = 2.0\n\n            if i % 2 == 0:\n                priority_score *= 1.5\n\n            if item % 2 == 0:\n                priority_score += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priority_score += 1.0\n\n            if item % 3 == 0:\n                priority_score *= 2.0\n\n            if i > 0:\n                priority_score += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priority_score += 2.0\n\n            if i % 3 == 0:\n                priority_score -= 0.5\n\n            if item % 5 == 0:\n                priority_score += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priority_score -= 0.25\n                elif i % 4 == 1:\n                    priority_score += 0.5\n                elif i % 4 == 2:\n                    priority_score -= 0.75\n                else:\n                    priority_score += 1.0\n\n            priorities[i] = priority_score\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:26:09", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n\n    if item > max_bin_capacity * 0.75:\n        for j in range(len(bins)):\n            if bins[j] == max_bin_capacity:\n                priorities[j] *= 1.5\n    elif item < min_bin_capacity * 0.25:\n        for k in range(len(bins)):\n            if bins[k] == min_bin_capacity:\n                priorities[k] *= 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority_index = np.argmax(priorities)\n    min_priority_index = np.argmin(priorities)\n    \n    for i in range(len(priorities)):\n        if i == max_priority_index:\n            priorities[i] = priorities[i] * 1.1\n        elif i == min_priority_index:\n            priorities[i] = priorities[i] * 0.9\n        else:\n            priorities[i] = priorities[i] * 1.05\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i] * 0.5:\n            priorities[i] = item / bins[i]\n        elif item < bins[i] * 0.75:\n            priorities[i] = item / (bins[i] + 100)\n        else:\n            priorities[i] = 1.0\n    \n    max_priority_index = np.argmax(priorities)\n    min_priority_index = np.argmin(priorities)\n    \n    if len(bins) > 5:\n        for i in range(len(priorities)):\n            if i % 2 == 0:\n                priorities[i] = priorities[i] * 1.1\n            else:\n                priorities[i] = priorities[i] * 0.9\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:26:12", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n\n    if item > max_bin_capacity * 0.75:\n        for j in range(len(bins)):\n            if bins[j] == max_bin_capacity:\n                priorities[j] *= 1.5\n    elif item < min_bin_capacity * 0.25:\n        for k in range(len(bins)):\n            if bins[k] == min_bin_capacity:\n                priorities[k] *= 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority_index = np.argmax(priorities)\n    min_priority_index = np.argmin(priorities)\n    \n    for i in range(len(priorities)):\n        if i == max_priority_index:\n            priorities[i] = priorities[i] * 1.1\n        elif i == min_priority_index:\n            priorities[i] = priorities[i] * 0.9\n        else:\n            priorities[i] = priorities[i] * 1.05\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority_index = np.argmax(priorities)\n    min_priority_index = np.argmin(priorities)\n    \n    for i in range(len(priorities)):\n        if i == max_priority_index:\n            priorities[i] = priorities[i] * 1.2\n        elif i == min_priority_index:\n            priorities[i] = priorities[i] * 0.8\n        elif bins[i] % 2 == 0:\n            priorities[i] = priorities[i] * 1.1\n        else:\n            priorities[i] = priorities[i] * 0.9\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:26:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n\n    if item > max_bin_capacity * 0.75:\n        for j in range(len(bins)):\n            if bins[j] == max_bin_capacity:\n                priorities[j] *= 1.5\n    elif item < min_bin_capacity * 0.25:\n        for k in range(len(bins)):\n            if bins[k] == min_bin_capacity:\n                priorities[k] *= 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority_index = np.argmax(priorities)\n    min_priority_index = np.argmin(priorities)\n    \n    for i in range(len(priorities)):\n        if i == max_priority_index:\n            priorities[i] = priorities[i] * 1.1\n        elif i == min_priority_index:\n            priorities[i] = priorities[i] * 0.9\n        else:\n            priorities[i] = priorities[i] * 1.05\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority_index = np.argmax(priorities)\n    min_priority_index = np.argmin(priorities)\n    \n    for i in range(len(priorities)):\n        if i == max_priority_index:\n            priorities[i] = priorities[i] * 1.15\n        elif i == min_priority_index:\n            priorities[i] = priorities[i] * 0.85\n        else:\n            priorities[i] = priorities[i] * (1 + (0.05 * i))\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:26:17", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n\n    if item > max_bin_capacity * 0.75:\n        for j in range(len(bins)):\n            if bins[j] == max_bin_capacity:\n                priorities[j] *= 1.5\n    elif item < min_bin_capacity * 0.25:\n        for k in range(len(bins)):\n            if bins[k] == min_bin_capacity:\n                priorities[k] *= 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority_index = np.argmax(priorities)\n    min_priority_index = np.argmin(priorities)\n    \n    for i in range(len(priorities)):\n        if i == max_priority_index:\n            priorities[i] = priorities[i] * 1.1\n        elif i == min_priority_index:\n            priorities[i] = priorities[i] * 0.9\n        else:\n            priorities[i] = priorities[i] * 1.05\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i] * 0.5:\n            priorities[i] = item / bins[i]\n        elif item > bins[i] * 0.8:\n            priorities[i] = 1.0\n        else:\n            priorities[i] = 0.75 * item / bins[i]\n    \n    total_capacity = np.sum(bins)\n    avg_bin_capacity = total_capacity / len(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] > avg_bin_capacity:\n            priorities[i] *= 1.1\n        elif bins[i] < avg_bin_capacity:\n            priorities[i] *= 0.9\n        else:\n            priorities[i] *= 1.0\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:26:29", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n\n    upper_threshold = np.percentile(final_priorities, 75)\n    lower_threshold = np.percentile(final_priorities, 25)\n\n    for n in range(len(bins)):\n        if final_priorities[n] > upper_threshold:\n            final_priorities[n] *= 1.1\n        elif final_priorities[n] < lower_threshold:\n            final_priorities[n] *= 0.9\n\n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.1:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2) * 1.5\n        elif ratios[i] >= 0.1 and ratios[i] < 0.3:\n            priorities[i] = np.tan(item) + np.tan(bins[i]) * 1.2\n        elif ratios[i] >= 0.3 and ratios[i] < 0.5:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1) * 0.8\n        elif ratios[i] >= 0.5 and ratios[i] < 0.7:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i])) * 1.4\n        else:\n            priorities[i] = (np.cosh(np.exp(ratios[i])) + np.tanh(np.sqrt(ratios[i]))) - np.log(ratios[i] + 1) * 1.6\n\n    for j in range(len(bins)):\n        if priorities[j] < 15:\n            priorities[j] *= 1.3\n        elif priorities[j] >= 15 and priorities[j] < 25:\n            priorities[j] *= 1.5\n        elif priorities[j] >= 25 and priorities[j] < 35:\n            priorities[j] /= 1.2\n        else:\n            priorities[j] = np.sqrt(priorities[j]) * 1.8\n\n    for k in range(len(bins)):\n        if priorities[k] % 3 == 0:\n            priorities[k] += item * 1.2\n        else:\n            priorities[k] -= item / 3\n\n        if item > 12:\n            priorities[k] *= 1.7\n        else:\n            priorities[k] = np.exp(priorities[k]) * 1.3\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:5]:\n            final_priorities[m] = priorities[m] * 1.1\n        else:\n            final_priorities[m] = priorities[m] * 0.9\n\n    upper_threshold = np.percentile(final_priorities, 80)\n    lower_threshold = np.percentile(final_priorities, 20)\n\n    for n in range(len(bins)):\n        if final_priorities[n] > upper_threshold:\n            final_priorities[n] *= 1.08\n        elif final_priorities[n] < lower_threshold:\n            final_priorities[n] *= 0.92\n\n    return final_priorities", "strategy": []}
{"timestamp": "2025-04-27 07:26:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n\n    upper_threshold = np.percentile(final_priorities, 75)\n    lower_threshold = np.percentile(final_priorities, 25)\n\n    for n in range(len(bins)):\n        if final_priorities[n] > upper_threshold:\n            final_priorities[n] *= 1.1\n        elif final_priorities[n] < lower_threshold:\n            final_priorities[n] *= 0.9\n\n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n\n    upper_threshold = np.percentile(final_priorities, 75)\n    lower_threshold = np.percentile(final_priorities, 25)\n\n    for n in range(len(bins)):\n        if final_priorities[n] > upper_threshold:\n            final_priorities[n] *= 1.1\n        elif final_priorities[n] < lower_threshold:\n            final_priorities[n] *= 0.9\n\n    normalized_priorities = (final_priorities - np.min(final_priorities)) / (np.max(final_priorities) - np.min(final_priorities))\n\n    return normalized_priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:26:41", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n\n    upper_threshold = np.percentile(final_priorities, 75)\n    lower_threshold = np.percentile(final_priorities, 25)\n\n    for n in range(len(bins)):\n        if final_priorities[n] > upper_threshold:\n            final_priorities[n] *= 1.1\n        elif final_priorities[n] < lower_threshold:\n            final_priorities[n] *= 0.9\n\n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n\n    upper_threshold = np.percentile(final_priorities, 75)\n    lower_threshold = np.percentile(final_priorities, 25)\n\n    for n in range(len(bins)):\n        if final_priorities[n] > upper_threshold:\n            final_priorities[n] *= 1.1\n        elif final_priorities[n] < lower_threshold:\n            final_priorities[n] *= 0.9\n\n    for p in range(len(bins)):\n        if final_priorities[p] < 5:\n            final_priorities[p] = final_priorities[p] + np.cos(final_priorities[p])\n        else:\n            final_priorities[p] = final_priorities[p] * np.sin(final_priorities[p])\n\n    return final_priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:26:46", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n\n    upper_threshold = np.percentile(final_priorities, 75)\n    lower_threshold = np.percentile(final_priorities, 25)\n\n    for n in range(len(bins)):\n        if final_priorities[n] > upper_threshold:\n            final_priorities[n] *= 1.1\n        elif final_priorities[n] < lower_threshold:\n            final_priorities[n] *= 0.9\n\n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n\n    upper_threshold = np.percentile(final_priorities, 75)\n    lower_threshold = np.percentile(final_priorities, 25)\n\n    for n in range(len(bins)):\n        if final_priorities[n] > upper_threshold:\n            final_priorities[n] *= 1.1\n        elif final_priorities[n] < lower_threshold:\n            final_priorities[n] *= 0.9\n\n    return final_priorities\n", "strategy": []}
{"timestamp": "2025-04-27 07:27:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif 0.1 <= utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif 0.3 <= utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif 0.6 <= utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif 3 <= remaining_space < 5:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif 10 <= bins[i] < 15:\n                priority_score *= 1.3\n            elif 5 <= bins[i] < 10:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif 5 <= item < 10:\n                priority_score += 0.1\n            elif 10 <= item < 15:\n                priority_score += 0.05\n                \n            if bins[i] < 5:\n                priority_score += 0.1\n            elif 5 <= bins[i] < 10:\n                priority_score += 0.05\n            \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.05:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif 0.05 <= utilization_ratio < 0.2:\n                priority_score = 0.8 / (1 + utilization_ratio)\n            elif 0.2 <= utilization_ratio < 0.4:\n                priority_score = 0.6 / (1 + utilization_ratio)\n            elif 0.4 <= utilization_ratio < 0.6:\n                priority_score = 0.4 / (1 + utilization_ratio)\n            elif 0.6 <= utilization_ratio < 0.8:\n                priority_score = 0.2 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 3:\n                priority_score *= 1.2\n            elif 1 <= remaining_space < 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 20:\n                priority_score *= 1.5\n            elif 15 <= bins[i] < 20:\n                priority_score *= 1.3\n            elif 10 <= bins[i] < 15:\n                priority_score *= 1.1\n                \n            if item < 5:\n                priority_score += 0.3\n            elif 5 <= item < 10:\n                priority_score += 0.2\n            elif 10 <= item < 15:\n                priority_score += 0.1\n                \n            if bins[i] < 5:\n                priority_score += 0.2\n            elif 5 <= bins[i] < 10:\n                priority_score += 0.1\n            \n            priorities[i] = priority_score\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:27:40", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif 0.1 <= utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif 0.3 <= utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif 0.6 <= utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif 3 <= remaining_space < 5:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif 10 <= bins[i] < 15:\n                priority_score *= 1.3\n            elif 5 <= bins[i] < 10:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif 5 <= item < 10:\n                priority_score += 0.1\n            elif 10 <= item < 15:\n                priority_score += 0.05\n                \n            if bins[i] < 5:\n                priority_score += 0.1\n            elif 5 <= bins[i] < 10:\n                priority_score += 0.05\n            \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif 0.1 <= utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif 0.3 <= utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif 0.6 <= utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif 3 <= remaining_space < 5:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif 10 <= bins[i] < 15:\n                priority_score *= 1.3\n            elif 5 <= bins[i] < 10:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif 5 <= item < 10:\n                priority_score += 0.1\n            elif 10 <= item < 15:\n                priority_score += 0.05\n                \n            if bins[i] < 5:\n                priority_score += 0.1\n            elif 5 <= bins[i] < 10:\n                priority_score += 0.05\n                \n            if utilization_ratio < 0.2 and item >= 5:\n                priority_score *= 1.1\n            elif 0.2 <= utilization_ratio < 0.4 and item >= 10:\n                priority_score *= 1.2\n            elif utilization_ratio >= 0.4 and item >= 15:\n                priority_score *= 1.3\n                \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:27:44", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif 0.1 <= utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif 0.3 <= utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif 0.6 <= utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif 3 <= remaining_space < 5:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif 10 <= bins[i] < 15:\n                priority_score *= 1.3\n            elif 5 <= bins[i] < 10:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif 5 <= item < 10:\n                priority_score += 0.1\n            elif 10 <= item < 15:\n                priority_score += 0.05\n                \n            if bins[i] < 5:\n                priority_score += 0.1\n            elif 5 <= bins[i] < 10:\n                priority_score += 0.05\n            \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif 0.1 <= utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif 0.3 <= utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif 0.6 <= utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif 3 <= remaining_space < 5:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif 10 <= bins[i] < 15:\n                priority_score *= 1.3\n            elif 5 <= bins[i] < 10:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif 5 <= item < 10:\n                priority_score += 0.1\n            elif 10 <= item < 15:\n                priority_score += 0.05\n                \n            if bins[i] < 5:\n                priority_score += 0.1\n            elif 5 <= bins[i] < 10:\n                priority_score += 0.05\n                \n            if remaining_space > item:\n                priority_score *= 1.1\n            else:\n                priority_score *= 0.9\n                \n            priorities[i] = priority_score\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:27:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif 0.1 <= utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif 0.3 <= utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif 0.6 <= utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif 3 <= remaining_space < 5:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif 10 <= bins[i] < 15:\n                priority_score *= 1.3\n            elif 5 <= bins[i] < 10:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif 5 <= item < 10:\n                priority_score += 0.1\n            elif 10 <= item < 15:\n                priority_score += 0.05\n                \n            if bins[i] < 5:\n                priority_score += 0.1\n            elif 5 <= bins[i] < 10:\n                priority_score += 0.05\n            \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif 0.1 <= utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif 0.3 <= utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif 0.6 <= utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif 3 <= remaining_space < 5:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif 10 <= bins[i] < 15:\n                priority_score *= 1.3\n            elif 5 <= bins[i] < 10:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif 5 <= item < 10:\n                priority_score += 0.1\n            elif 10 <= item < 15:\n                priority_score += 0.05\n                \n            if bins[i] < 5:\n                priority_score += 0.1\n            elif 5 <= bins[i] < 10:\n                priority_score += 0.05\n                \n            if utilization_ratio < 0.2 and remaining_space > 5:\n                priority_score *= 1.2\n            elif utilization_ratio < 0.4 and remaining_space > 3:\n                priority_score *= 1.1\n            elif utilization_ratio < 0.6 and bins[i] > 10:\n                priority_score *= 1.3\n                \n            priorities[i] = priority_score\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:28:01", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.05:\n                priorities[i] = 0.1\n            elif priority_diff >= 0.05 and priority_diff < 0.2:\n                priorities[i] = 0.3\n            elif priority_diff >= 0.2 and priority_diff < 0.4:\n                priorities[i] = 0.5\n            elif priority_diff >= 0.4 and priority_diff < 0.6:\n                priorities[i] = 0.7\n            elif priority_diff >= 0.6 and priority_diff < 0.8:\n                priorities[i] = 0.9\n            else:\n                priorities[i] = 0.95\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n                \n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.15:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.15 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.45:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.45 and priority_diff < 0.6:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n\n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:28:05", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.05:\n                priorities[i] = 0.1\n            elif priority_diff >= 0.05 and priority_diff < 0.2:\n                priorities[i] = 0.3\n            elif priority_diff >= 0.2 and priority_diff < 0.4:\n                priorities[i] = 0.5\n            elif priority_diff >= 0.4 and priority_diff < 0.6:\n                priorities[i] = 0.7\n            elif priority_diff >= 0.6 and priority_diff < 0.8:\n                priorities[i] = 0.9\n            else:\n                priorities[i] = 0.95\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n                \n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n                \n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n        \n    final_priorities = np.zeros_like(priorities)\n    for k in range(len(priorities)):\n        if priorities[k] >= 0.5:\n            final_priorities[k] = priorities[k] * 1.5\n        else:\n            final_priorities[k] = priorities[k] * 0.5\n            \n    return final_priorities", "strategy": []}
{"timestamp": "2025-04-27 07:28:08", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.05:\n                priorities[i] = 0.1\n            elif priority_diff >= 0.05 and priority_diff < 0.2:\n                priorities[i] = 0.3\n            elif priority_diff >= 0.2 and priority_diff < 0.4:\n                priorities[i] = 0.5\n            elif priority_diff >= 0.4 and priority_diff < 0.6:\n                priorities[i] = 0.7\n            elif priority_diff >= 0.6 and priority_diff < 0.8:\n                priorities[i] = 0.9\n            else:\n                priorities[i] = 0.95\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n                \n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.05:\n                priorities[i] = 0.1\n            elif priority_diff >= 0.05 and priority_diff < 0.25:\n                priorities[i] = 0.3\n            elif priority_diff >= 0.25 and priority_diff < 0.45:\n                priorities[i] = 0.5\n            elif priority_diff >= 0.45 and priority_diff < 0.65:\n                priorities[i] = 0.7\n            elif priority_diff >= 0.65 and priority_diff < 0.85:\n                priorities[i] = 0.9\n            else:\n                priorities[i] = 0.95\n                \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:28:12", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.05:\n                priorities[i] = 0.1\n            elif priority_diff >= 0.05 and priority_diff < 0.2:\n                priorities[i] = 0.3\n            elif priority_diff >= 0.2 and priority_diff < 0.4:\n                priorities[i] = 0.5\n            elif priority_diff >= 0.4 and priority_diff < 0.6:\n                priorities[i] = 0.7\n            elif priority_diff >= 0.6 and priority_diff < 0.8:\n                priorities[i] = 0.9\n            else:\n                priorities[i] = 0.95\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n                \n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n                \n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:28:22", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.3:\n                    priorities[index] = 0.9\n                elif priority >= 0.3 and priority < 0.6:\n                    priorities[index] = 0.7\n                elif priority >= 0.6 and priority < 0.9:\n                    priorities[index] = 0.5\n                else:\n                    if item % 2 == 0:\n                        priorities[index] = 0.4\n                    else:\n                        priorities[index] = 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 2:\n                    priorities[i] = 0.8\n                elif priority > 1:\n                    priorities[i] = 0.6\n                else:\n                    priorities[i] = 0.4\n            else:\n                max_priority = max(priorities)\n                for j, priority in enumerate(priorities):\n                    if priority == max_priority:\n                        priorities[j] = 0.2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 2:\n                    priorities[i] = 0.8\n                elif priority > 1:\n                    priorities[i] = 0.6\n                else:\n                    priorities[i] = 0.4\n            else:\n                max_priority = max(priorities)\n                for j, priority in enumerate(priorities):\n                    if priority == max_priority:\n                        if j % 2 == 0:\n                            priorities[j] = 0.5\n                        else:\n                            priorities[j] = 0.3\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:28:24", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.3:\n                    priorities[index] = 0.9\n                elif priority >= 0.3 and priority < 0.6:\n                    priorities[index] = 0.7\n                elif priority >= 0.6 and priority < 0.9:\n                    priorities[index] = 0.5\n                else:\n                    if item % 2 == 0:\n                        priorities[index] = 0.4\n                    else:\n                        priorities[index] = 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 2:\n                    priorities[i] = 0.8\n                elif priority > 1:\n                    priorities[i] = 0.6\n                else:\n                    priorities[i] = 0.4\n            else:\n                max_priority = max(priorities)\n                for j, priority in enumerate(priorities):\n                    if priority == max_priority:\n                        priorities[j] = 0.2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    max_bin_capacity = max(bins)\n\n    if item > max_bin_capacity:\n        remaining_capacity = bins - item\n        max_capacity_bin_index = np.argmax(remaining_capacity)\n        priorities[max_capacity_bin_index] = 1.0\n    else:\n        for i, bin_capacity in enumerate(bins):\n            if item <= bin_capacity:\n                priorities[i] = 1.0\n            else:\n                diff_capacity = item - bin_capacity\n                if diff_capacity % 2 == 0:\n                    priorities[i] = 0.8\n                else:\n                    priorities[i] = 0.6\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:28:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.3:\n                    priorities[index] = 0.9\n                elif priority >= 0.3 and priority < 0.6:\n                    priorities[index] = 0.7\n                elif priority >= 0.6 and priority < 0.9:\n                    priorities[index] = 0.5\n                else:\n                    if item % 2 == 0:\n                        priorities[index] = 0.4\n                    else:\n                        priorities[index] = 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 2:\n                    priorities[i] = 0.8\n                elif priority > 1:\n                    priorities[i] = 0.6\n                else:\n                    priorities[i] = 0.4\n            else:\n                max_priority = max(priorities)\n                for j, priority in enumerate(priorities):\n                    if priority == max_priority:\n                        priorities[j] = 0.2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 3:\n                    priorities[i] = 0.9\n                elif priority > 2:\n                    priorities[i] = 0.7\n                elif priority > 1:\n                    priorities[i] = 0.5\n                else:\n                    priorities[i] = 0.3\n            else:\n                max_priority = max(priorities)\n                for j, priority in enumerate(priorities):\n                    if priority == max_priority:\n                        priorities[j] = 0.1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:28:31", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.3:\n                    priorities[index] = 0.9\n                elif priority >= 0.3 and priority < 0.6:\n                    priorities[index] = 0.7\n                elif priority >= 0.6 and priority < 0.9:\n                    priorities[index] = 0.5\n                else:\n                    if item % 2 == 0:\n                        priorities[index] = 0.4\n                    else:\n                        priorities[index] = 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 2:\n                    priorities[i] = 0.8\n                elif priority > 1:\n                    priorities[i] = 0.6\n                else:\n                    priorities[i] = 0.4\n            else:\n                max_priority = max(priorities)\n                for j, priority in enumerate(priorities):\n                    if priority == max_priority:\n                        priorities[j] = 0.2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 2:\n                    priorities[i] = 0.8\n                elif priority > 1:\n                    priorities[i] = 0.6\n                else:\n                    priorities[i] = 0.4\n            else:\n                max_capacity_bin_index = np.argmax(bins)\n                max_capacity_bin_priority = priorities[max_capacity_bin_index]\n                \n                if max_capacity_bin_priority < 0.5:\n                    for j in range(len(priorities)):\n                        if priorities[j] < 0.5:\n                            priorities[j] = 0.3\n                else:\n                    for j in range(len(priorities)):\n                        priorities[j] = 0.1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:28:42", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.2\n            elif item + bins[i] > 100:\n                priorities[i] -= 0.1\n            else:\n                priorities[i] += 0.3\n            \n            if item > bins[i] + 50:\n                priorities[i] *= 1.7\n            elif item > bins[i] + 30:\n                priorities[i] *= 1.4\n            elif item > bins[i] + 20:\n                priorities[i] *= 1.2\n            \n            if item % bins[i] == 1:\n                priorities[i] += 0.1\n            elif item + bins[i] > 150:\n                priorities[i] -= 0.2\n            else:\n                priorities[i] += 0.4\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.3\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.1\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n            \n            if item % 3 == 0:\n                priorities[i] += 0.5\n            \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.3\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.1\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n            \n            if item % 3 == 0:\n                priorities[i] += 0.5\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.7\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.4\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.2\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:28:46", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.2\n            elif item + bins[i] > 100:\n                priorities[i] -= 0.1\n            else:\n                priorities[i] += 0.3\n            \n            if item > bins[i] + 50:\n                priorities[i] *= 1.7\n            elif item > bins[i] + 30:\n                priorities[i] *= 1.4\n            elif item > bins[i] + 20:\n                priorities[i] *= 1.2\n            \n            if item % bins[i] == 1:\n                priorities[i] += 0.1\n            elif item + bins[i] > 150:\n                priorities[i] -= 0.2\n            else:\n                priorities[i] += 0.4\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.3\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.1\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n            \n            if item % 3 == 0:\n                priorities[i] += 0.5\n            \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"More complex version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.3\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.1\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n            \n            if item % 3 == 0:\n                priorities[i] += 0.5\n            \n            if item % 5 == 0 and bins[i] % 2 == 0:\n                priorities[i] -= 0.4\n            elif item % 7 == 0 or bins[i] % 3 == 0:\n                priorities[i] += 0.6\n        \n        if item * 2.5 > np.var(bins):\n            priorities[i] *= 1.8\n        elif item * 1.5 < np.std(bins):\n            priorities[i] *= 0.7\n        \n        if item in bins:\n            priorities[i] += 0.2\n        else:\n            priorities[i] -= 0.1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:28:51", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.2\n            elif item + bins[i] > 100:\n                priorities[i] -= 0.1\n            else:\n                priorities[i] += 0.3\n            \n            if item > bins[i] + 50:\n                priorities[i] *= 1.7\n            elif item > bins[i] + 30:\n                priorities[i] *= 1.4\n            elif item > bins[i] + 20:\n                priorities[i] *= 1.2\n            \n            if item % bins[i] == 1:\n                priorities[i] += 0.1\n            elif item + bins[i] > 150:\n                priorities[i] -= 0.2\n            else:\n                priorities[i] += 0.4\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.3\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.1\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n            \n            if item % 3 == 0:\n                priorities[i] += 0.5\n            \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.3\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.1\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n            \n            if item % 3 == 0:\n                priorities[i] += 0.5\n            \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n            elif priorities[i] < 0.0:\n                priorities[i] = 0.0\n            \n            if item > 3 * bins[i]:\n                priorities[i] *= 1.8\n            elif item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n                \n            if item < bins[i] * 0.1:\n                priorities[i] *= 0.7\n            elif item < bins[i] * 0.3:\n                priorities[i] *= 0.9\n            elif item < bins[i] * 0.5:\n                priorities[i] *= 1.1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:28:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.2\n            elif item + bins[i] > 100:\n                priorities[i] -= 0.1\n            else:\n                priorities[i] += 0.3\n            \n            if item > bins[i] + 50:\n                priorities[i] *= 1.7\n            elif item > bins[i] + 30:\n                priorities[i] *= 1.4\n            elif item > bins[i] + 20:\n                priorities[i] *= 1.2\n            \n            if item % bins[i] == 1:\n                priorities[i] += 0.1\n            elif item + bins[i] > 150:\n                priorities[i] -= 0.2\n            else:\n                priorities[i] += 0.4\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.3\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.1\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n            \n            if item % 3 == 0:\n                priorities[i] += 0.5\n            \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n            \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.3\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.1\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n            \n            if item % 3 == 0:\n                priorities[i] += 0.5\n            \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:29:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    priorities[index] = 0.5\n            else:\n                if bin_capacity > 0:\n                    priority = 1 / bin_capacity\n                    priorities[index] = priority if priority > 0 else 0.1\n                else:\n                    priorities[index] = 0.2 * item\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 2:\n                    priorities[i] = 0.8\n                elif priority > 1:\n                    priorities[i] = 0.6\n                else:\n                    priorities[i] = 0.4\n            else:\n                max_capacity_bin_index = np.argmax(bins)\n                max_capacity_bin_priority = priorities[max_capacity_bin_index]\n                \n                if max_capacity_bin_priority < 0.5:\n                    for j in range(len(priorities)):\n                        if priorities[j] < 0.5:\n                            priorities[j] = 0.3\n                else:\n                    for j in range(len(priorities)):\n                        priorities[j] = 0.1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 2:\n                    priorities[i] = 0.8\n                elif priority > 1:\n                    priorities[i] = 0.6\n                else:\n                    priorities[i] = 0.4\n            else:\n                max_capacity_bin_index = np.argmax(bins)\n                max_capacity_bin_priority = priorities[max_capacity_bin_index]\n                \n                if max_capacity_bin_priority < 0.5:\n                    for j in range(len(priorities)):\n                        if priorities[j] < 0.5:\n                            priorities[j] = 0.3\n                else:\n                    for j in range(len(priorities)):\n                        if priorities[j] >= 0.5:\n                            priorities[j] = 0.9\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:29:39", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    priorities[index] = 0.5\n            else:\n                if bin_capacity > 0:\n                    priority = 1 / bin_capacity\n                    priorities[index] = priority if priority > 0 else 0.1\n                else:\n                    priorities[index] = 0.2 * item\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 2:\n                    priorities[i] = 0.8\n                elif priority > 1:\n                    priorities[i] = 0.6\n                else:\n                    priorities[i] = 0.4\n            else:\n                max_capacity_bin_index = np.argmax(bins)\n                max_capacity_bin_priority = priorities[max_capacity_bin_index]\n                \n                if max_capacity_bin_priority < 0.5:\n                    for j in range(len(priorities)):\n                        if priorities[j] < 0.5:\n                            priorities[j] = 0.3\n                else:\n                    for j in range(len(priorities)):\n                        priorities[j] = 0.1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    if item > np.max(bins):\n        for i in range(len(priorities)):\n            priorities[i] = 0.0\n        return priorities\n\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 2:\n                    priorities[i] = 0.8\n                elif priority > 1:\n                    priorities[i] = 0.6\n                else:\n                    priorities[i] = 0.4\n            else:\n                max_capacity_bin_index = np.argmax(bins)\n                max_capacity_bin_priority = priorities[max_capacity_bin_index]\n                \n                if max_capacity_bin_priority < 0.5:\n                    for j in range(len(priorities)):\n                        if priorities[j] < 0.5:\n                            priorities[j] = 0.3\n                else:\n                    for j in range(len(priorities)):\n                        priorities[j] = 0.1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:29:43", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    priorities[index] = 0.5\n            else:\n                if bin_capacity > 0:\n                    priority = 1 / bin_capacity\n                    priorities[index] = priority if priority > 0 else 0.1\n                else:\n                    priorities[index] = 0.2 * item\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 2:\n                    priorities[i] = 0.8\n                elif priority > 1:\n                    priorities[i] = 0.6\n                else:\n                    priorities[i] = 0.4\n            else:\n                max_capacity_bin_index = np.argmax(bins)\n                max_capacity_bin_priority = priorities[max_capacity_bin_index]\n                \n                if max_capacity_bin_priority < 0.5:\n                    for j in range(len(priorities)):\n                        if priorities[j] < 0.5:\n                            priorities[j] = 0.3\n                else:\n                    for j in range(len(priorities)):\n                        priorities[j] = 0.1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 1.5:\n                    priorities[i] = 0.9\n                elif priority > 1:\n                    priorities[i] = 0.7\n                else:\n                    priorities[i] = 0.5\n            else:\n                max_capacity_bin_index = np.argmax(bins)\n                max_capacity_bin_priority = priorities[max_capacity_bin_index]\n                \n                if max_capacity_bin_priority < 0.6:\n                    for j in range(len(priorities)):\n                        if priorities[j] < 0.6:\n                            priorities[j] = priorities[j] + 0.1\n                else:\n                    for j in range(len(priorities)):\n                        priorities[j] = priorities[j] - 0.1 if priorities[j] > 0 else 0.1\n                        \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:29:46", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.9\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.7\n                else:\n                    priorities[index] = 0.5\n            else:\n                if bin_capacity > 0:\n                    priority = 1 / bin_capacity\n                    priorities[index] = priority if priority > 0 else 0.1\n                else:\n                    priorities[index] = 0.2 * item\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 2:\n                    priorities[i] = 0.8\n                elif priority > 1:\n                    priorities[i] = 0.6\n                else:\n                    priorities[i] = 0.4\n            else:\n                max_capacity_bin_index = np.argmax(bins)\n                max_capacity_bin_priority = priorities[max_capacity_bin_index]\n                \n                if max_capacity_bin_priority < 0.5:\n                    for j in range(len(priorities)):\n                        if priorities[j] < 0.5:\n                            priorities[j] = 0.3\n                else:\n                    for j in range(len(priorities)):\n                        priorities[j] = 0.1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 2:\n                    priorities[i] = 0.8\n                elif priority > 1:\n                    priorities[i] = 0.6\n                else:\n                    priorities[i] = 0.4\n            else:\n                max_capacity_bin_index = np.argmax(bins)\n                max_capacity_bin_priority = priorities[max_capacity_bin_index]\n                \n                if max_capacity_bin_priority < 0.5:\n                    for j in range(len(priorities)):\n                        if priorities[j] < 0.5:\n                            priorities[j] = 0.3\n                else:\n                    for j in range(len(priorities)):\n                        priorities[j] = 0.1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:30:01", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:30:07", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "import numpy as np\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:30:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:30:20", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:30:40", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n                \n            if bins[i] % 5 == 0:\n                priorities[i] *= 1.5\n            elif bins[i] % 3 == 0:\n                priorities[i] *= 1.2\n            else:\n                priorities[i] *= 1.0\n                \n            if item > 20:\n                priorities[i] += 2.0\n            elif item > 10:\n                priorities[i] += 1.0\n            else:\n                priorities[i] += 0.5\n                \n            if item % 2 == 0:\n                priorities[i] *= 1.2\n            elif item % 3 == 0:\n                priorities[i] *= 1.5\n            else:\n                priorities[i] *= 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n                \n            if bins[i] % 5 == 0:\n                priorities[i] *= 1.5\n            elif bins[i] % 3 == 0:\n                priorities[i] *= 1.2\n            else:\n                priorities[i] *= 1.0\n                \n            if item > 20:\n                priorities[i] += 2.0\n            elif item > 10:\n                priorities[i] += 1.0\n            else:\n                priorities[i] += 0.5\n                \n            if item % 2 == 0:\n                priorities[i] *= 1.2\n            elif item % 3 == 0:\n                priorities[i] *= 1.5\n            else:\n                priorities[i] *= 1.0\n            \n            if bins[i] % 7 == 0:\n                priorities[i] *= 2.0\n            elif bins[i] % 11 == 0:\n                priorities[i] *= 1.8\n            else:\n                priorities[i] *= 1.0\n        \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:30:45", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n                \n            if bins[i] % 5 == 0:\n                priorities[i] *= 1.5\n            elif bins[i] % 3 == 0:\n                priorities[i] *= 1.2\n            else:\n                priorities[i] *= 1.0\n                \n            if item > 20:\n                priorities[i] += 2.0\n            elif item > 10:\n                priorities[i] += 1.0\n            else:\n                priorities[i] += 0.5\n                \n            if item % 2 == 0:\n                priorities[i] *= 1.2\n            elif item % 3 == 0:\n                priorities[i] *= 1.5\n            else:\n                priorities[i] *= 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n                \n            if bins[i] % 5 == 0:\n                priorities[i] *= 1.5\n            elif bins[i] % 3 == 0:\n                priorities[i] *= 1.2\n            else:\n                priorities[i] *= 1.0\n                \n            if item > 20:\n                priorities[i] += 2.0\n            elif item > 10:\n                priorities[i] += 1.0\n            else:\n                priorities[i] += 0.5\n                \n            if item % 2 == 0:\n                priorities[i] *= 1.2\n            elif item % 3 == 0:\n                priorities[i] *= 1.5\n            else:\n                priorities[i] *= 1.0\n            \n            if count == 5:\n                priorities[i] += 2.0\n            elif count == 4:\n                priorities[i] -= 0.8\n            else:\n                priorities[i] += 0.3\n                \n            if item > 15:\n                priorities[i] += 1.5\n            elif item > 7:\n                priorities[i] += 0.8\n            else:\n                priorities[i] += 0.3\n                 \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:30:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n                \n            if bins[i] % 5 == 0:\n                priorities[i] *= 1.5\n            elif bins[i] % 3 == 0:\n                priorities[i] *= 1.2\n            else:\n                priorities[i] *= 1.0\n                \n            if item > 20:\n                priorities[i] += 2.0\n            elif item > 10:\n                priorities[i] += 1.0\n            else:\n                priorities[i] += 0.5\n                \n            if item % 2 == 0:\n                priorities[i] *= 1.2\n            elif item % 3 == 0:\n                priorities[i] *= 1.5\n            else:\n                priorities[i] *= 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n                \n            if bins[i] % 5 == 0:\n                priorities[i] *= 1.5\n            elif bins[i] % 3 == 0:\n                priorities[i] *= 1.2\n            else:\n                priorities[i] *= 1.0\n                \n            if item > 20:\n                priorities[i] += 2.0\n            elif item > 10:\n                priorities[i] += 1.0\n            else:\n                priorities[i] += 0.5\n                \n            if item % 2 == 0:\n                priorities[i] *= 1.2\n            elif item % 3 == 0:\n                priorities[i] *= 1.5\n            else:\n                priorities[i] *= 1.0\n            \n            if bins[i] > 100 and item < 30:\n                priorities[i] += 2.0\n            elif bins[i] < 50 or item > 25:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n                \n            if item % 7 == 0 and bins[i] % 2 != 0:\n                priorities[i] *= 1.3\n            elif item % 7 != 0 and bins[i] % 2 == 0:\n                priorities[i] *= 1.1\n            else:\n                priorities[i] *= 1.0\n                \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:30:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n                \n            if bins[i] % 5 == 0:\n                priorities[i] *= 1.5\n            elif bins[i] % 3 == 0:\n                priorities[i] *= 1.2\n            else:\n                priorities[i] *= 1.0\n                \n            if item > 20:\n                priorities[i] += 2.0\n            elif item > 10:\n                priorities[i] += 1.0\n            else:\n                priorities[i] += 0.5\n                \n            if item % 2 == 0:\n                priorities[i] *= 1.2\n            elif item % 3 == 0:\n                priorities[i] *= 1.5\n            else:\n                priorities[i] *= 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0.1\n        elif item <= bins[i] / 2:\n            priorities[i] = item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            \n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n            \n            if bins[i] % 5 == 0:\n                priorities[i] *= 1.5\n            elif bins[i] % 3 == 0:\n                priorities[i] *= 1.2\n            else:\n                priorities[i] *= 1.0\n            \n            if item > 20:\n                priorities[i] += 2.0\n            elif item > 10:\n                priorities[i] += 1.0\n            else:\n                priorities[i] += 0.5\n            \n            if item % 2 == 0:\n                priorities[i] *= 1.2\n            elif item % 3 == 0:\n                priorities[i] *= 1.5\n            else:\n                priorities[i] *= 1.0\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:31:02", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 2:\n                    priorities[i] = 0.8\n                elif priority > 1:\n                    priorities[i] = 0.6\n                else:\n                    priorities[i] = 0.4\n            else:\n                max_capacity_bin_index = np.argmax(bins)\n                max_capacity_bin_priority = priorities[max_capacity_bin_index]\n                \n                if max_capacity_bin_priority < 0.5:\n                    for j in range(len(priorities)):\n                        if priorities[j] < 0.5:\n                            priorities[j] = 0.3\n                else:\n                    for j in range(len(priorities)):\n                        priorities[j] = 0.1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    max_bin_capacity = max(bins)\n\n    if item > max_bin_capacity:\n        remaining_capacity = bins - item\n        max_capacity_bin_index = np.argmax(remaining_capacity)\n        priorities[max_capacity_bin_index] = 1.0\n    else:\n        for i, bin_capacity in enumerate(bins):\n            if item <= bin_capacity:\n                priorities[i] = 1.0\n            else:\n                diff_capacity = item - bin_capacity\n                if diff_capacity % 2 == 0:\n                    priorities[i] = 0.8\n                else:\n                    priorities[i] = 0.6\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if item > 2 * bin_capacity:\n                priorities[i] = 0.1\n            elif remaining_capacity % 2 == 0:\n                priorities[i] = 0.8\n            else:\n                partial_capacity_sum = 0\n                for j, partial_bin_capacity in enumerate(bins):\n                    partial_capacity_sum += partial_bin_capacity\n                    if partial_capacity_sum >= item:\n                        priorities[j] = 0.6\n                        break\n                if partial_capacity_sum < item:\n                    priorities[np.argmin(bins)] = 0.4\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:31:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 2:\n                    priorities[i] = 0.8\n                elif priority > 1:\n                    priorities[i] = 0.6\n                else:\n                    priorities[i] = 0.4\n            else:\n                max_capacity_bin_index = np.argmax(bins)\n                max_capacity_bin_priority = priorities[max_capacity_bin_index]\n                \n                if max_capacity_bin_priority < 0.5:\n                    for j in range(len(priorities)):\n                        if priorities[j] < 0.5:\n                            priorities[j] = 0.3\n                else:\n                    for j in range(len(priorities)):\n                        priorities[j] = 0.1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    max_bin_capacity = max(bins)\n\n    if item > max_bin_capacity:\n        remaining_capacity = bins - item\n        max_capacity_bin_index = np.argmax(remaining_capacity)\n        priorities[max_capacity_bin_index] = 1.0\n    else:\n        for i, bin_capacity in enumerate(bins):\n            if item <= bin_capacity:\n                priorities[i] = 1.0\n            else:\n                diff_capacity = item - bin_capacity\n                if diff_capacity % 2 == 0:\n                    priorities[i] = 0.8\n                else:\n                    priorities[i] = 0.6\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    if item < np.median(bins):\n        for i, bin_capacity in enumerate(bins):\n            if item <= bin_capacity:\n                priorities[i] = 1.0\n    else:\n        for i, bin_capacity in enumerate(bins):\n            if item > bin_capacity:\n                priorities[i] = 0.2\n            else:\n                remaining_capacity = bin_capacity - item\n                if remaining_capacity % 2 == 0:\n                    priorities[i] = 0.7\n                else:\n                    priorities[i] = 0.5\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:31:09", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 2:\n                    priorities[i] = 0.8\n                elif priority > 1:\n                    priorities[i] = 0.6\n                else:\n                    priorities[i] = 0.4\n            else:\n                max_capacity_bin_index = np.argmax(bins)\n                max_capacity_bin_priority = priorities[max_capacity_bin_index]\n                \n                if max_capacity_bin_priority < 0.5:\n                    for j in range(len(priorities)):\n                        if priorities[j] < 0.5:\n                            priorities[j] = 0.3\n                else:\n                    for j in range(len(priorities)):\n                        priorities[j] = 0.1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    max_bin_capacity = max(bins)\n\n    if item > max_bin_capacity:\n        remaining_capacity = bins - item\n        max_capacity_bin_index = np.argmax(remaining_capacity)\n        priorities[max_capacity_bin_index] = 1.0\n    else:\n        for i, bin_capacity in enumerate(bins):\n            if item <= bin_capacity:\n                priorities[i] = 1.0\n            else:\n                diff_capacity = item - bin_capacity\n                if diff_capacity % 2 == 0:\n                    priorities[i] = 0.8\n                else:\n                    priorities[i] = 0.6\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    max_bin_capacity = max(bins)\n\n    if item > max_bin_capacity:\n        remaining_capacity = bins - item\n        max_capacity_bin_index = np.argmax(remaining_capacity)\n        priorities[max_capacity_bin_index] = 1.0\n    else:\n        for i, bin_capacity in enumerate(bins):\n            if item <= bin_capacity:\n                priorities[i] = 1.0\n            else:\n                diff_capacity = item - bin_capacity\n                if diff_capacity % 2 == 0:\n                    priorities[i] = 0.8\n                elif diff_capacity % 3 == 0:\n                    priorities[i] = 0.6\n                elif diff_capacity % 5 == 0:\n                    priorities[i] = 0.4\n                else:\n                    priorities[i] = 0.2\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:31:12", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority > 2:\n                    priorities[i] = 0.8\n                elif priority > 1:\n                    priorities[i] = 0.6\n                else:\n                    priorities[i] = 0.4\n            else:\n                max_capacity_bin_index = np.argmax(bins)\n                max_capacity_bin_priority = priorities[max_capacity_bin_index]\n                \n                if max_capacity_bin_priority < 0.5:\n                    for j in range(len(priorities)):\n                        if priorities[j] < 0.5:\n                            priorities[j] = 0.3\n                else:\n                    for j in range(len(priorities)):\n                        priorities[j] = 0.1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    max_bin_capacity = max(bins)\n\n    if item > max_bin_capacity:\n        remaining_capacity = bins - item\n        max_capacity_bin_index = np.argmax(remaining_capacity)\n        priorities[max_capacity_bin_index] = 1.0\n    else:\n        for i, bin_capacity in enumerate(bins):\n            if item <= bin_capacity:\n                priorities[i] = 1.0\n            else:\n                diff_capacity = item - bin_capacity\n                if diff_capacity % 2 == 0:\n                    priorities[i] = 0.8\n                else:\n                    priorities[i] = 0.6\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    max_bin_capacity = max(bins)\n\n    if item > max_bin_capacity:\n        remaining_capacity = bins - item\n        max_capacity_bin_index = np.argmax(remaining_capacity)\n        priorities[max_capacity_bin_index] = 1.0\n    else:\n        for i, bin_capacity in enumerate(bins):\n            if item <= bin_capacity:\n                priorities[i] = 1.0\n            else:\n                diff_capacity = item - bin_capacity\n                if diff_capacity % 2 == 0:\n                    priorities[i] = 0.8\n                else:\n                    priorities[i] = 0.6\n                    if i % 2 == 0:\n                        priorities[i] = 0.9\n                    else:\n                        priorities[i] = 0.7\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:31:24", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(bins)):\n        if priorities[j] == max_priority:\n            priorities[j] *= 1.2\n        elif priorities[j] == min_priority:\n            priorities[j] *= 0.8\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n                \n            if item > bins[i] * 1.2:\n                priorities[i] -= 0.3\n            elif item < bins[i] * 0.7:\n                priorities[i] += 0.2\n                \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n                \n            if item > bins[i] * 1.2:\n                priorities[i] -= 0.3\n            elif item < bins[i] * 0.7:\n                priorities[i] += 0.2\n        \n        if i % 2 == 0:\n            priorities[i] += 0.1\n        elif i % 3 == 0:\n            priorities[i] -= 0.1\n        else:\n            priorities[i] += 0.05\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:31:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(bins)):\n        if priorities[j] == max_priority:\n            priorities[j] *= 1.2\n        elif priorities[j] == min_priority:\n            priorities[j] *= 0.8\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n                \n            if item > bins[i] * 1.2:\n                priorities[i] -= 0.3\n            elif item < bins[i] * 0.7:\n                priorities[i] += 0.2\n                \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if bins[i] % 2 == 0:\n                priorities[i] += 0.3\n            else:\n                priorities[i] -= 0.2\n                \n            if item % 2 == 0:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.1\n                \n            if bins[i] % 3 == 0:\n                priorities[i] += 0.4\n            else:\n                priorities[i] -= 0.3\n                \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:31:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(bins)):\n        if priorities[j] == max_priority:\n            priorities[j] *= 1.2\n        elif priorities[j] == min_priority:\n            priorities[j] *= 0.8\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n                \n            if item > bins[i] * 1.2:\n                priorities[i] -= 0.3\n            elif item < bins[i] * 0.7:\n                priorities[i] += 0.2\n                \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = item / bins[i]\n            if item < bins[i] * 0.5:\n                priorities[i] += 0.3\n            elif item < bins[i] * 0.8:\n                priorities[i] += 0.5\n            else:\n                priorities[i] += 0.7\n        else:\n            diff = item - bins[i]\n            if diff > bins[i]:\n                priorities[i] = 1.0\n            elif diff > bins[i] * 0.8:\n                priorities[i] += 0.6\n            elif diff > bins[i] * 0.5:\n                priorities[i] += 0.3\n            else:\n                priorities[i] += 0.1\n                \n            if item > bins[i] * 1.2:\n                priorities[i] -= 0.4\n            elif item > bins[i] * 1.5:\n                priorities[i] -= 0.6\n            else:\n                priorities[i] -= 0.2\n                \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:31:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(bins)):\n        if priorities[j] == max_priority:\n            priorities[j] *= 1.2\n        elif priorities[j] == min_priority:\n            priorities[j] *= 0.8\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n                \n            if item > bins[i] * 1.2:\n                priorities[i] -= 0.3\n            elif item < bins[i] * 0.7:\n                priorities[i] += 0.2\n                \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n                \n            if item > bins[i] * 1.2:\n                priorities[i] -= 0.3\n            elif item < bins[i] * 0.7:\n                priorities[i] += 0.2\n                \n            if item % bins[i] == 0:\n                priorities[i] += 0.3\n            elif item % bins[i] == 1:\n                priorities[i] -= 0.2\n            elif item % bins[i] == 2:\n                priorities[i] -= 0.1\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:31:46", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n            if item <= 20:\n                priorities[i] += 0.2\n            else:\n                priorities[i] += 0.5\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n            if item > 5:\n                priorities[i] -= 0.1\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n                \n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if count == 6:\n                    priorities[i] += 0.8\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if count == 4:\n                    priorities[i] -= 0.5\n                else:\n                    priorities[i] += 0.2\n            else:\n                priorities[i] = 0.9 * count + item / bins[i] + 0.3\n                if count == 3:\n                    priorities[i] -= 0.3\n                elif count == 5:\n                    priorities[i] += 0.4\n                else:\n                    priorities[i] += 0.1 if item > 10 else 0.05\n                \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n            if item <= 20:\n                priorities[i] += 0.2\n            else:\n                priorities[i] += 0.5\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n            if item > 5:\n                priorities[i] -= 0.1\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n                \n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if count == 6:\n                    priorities[i] += 0.8\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if count == 4:\n                    priorities[i] -= 0.5\n                else:\n                    priorities[i] += 0.2\n            else:\n                priorities[i] = 0.9 * count + item / bins[i] + 0.3\n                if count == 3:\n                    priorities[i] -= 0.3\n                elif count == 5:\n                    priorities[i] += 0.4\n                elif count == 7:\n                    priorities[i] -= 0.2\n                elif count == 9:\n                    priorities[i] += 0.7\n                \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n            if item <= 20:\n                priorities[i] += 0.2\n            else:\n                priorities[i] += 0.5\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n            if item > 5:\n                priorities[i] -= 0.1\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n                \n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if count == 6:\n                    priorities[i] += 0.8\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if count == 4:\n                    priorities[i] -= 0.5\n                else:\n                    priorities[i] += 0.2\n            else:\n                priorities[i] = 0.9 * count + item / bins[i] + 0.3\n                if count == 3:\n                    priorities[i] -= 0.3\n                elif count == 5:\n                    priorities[i] += 0.4\n                elif count == 7:\n                    priorities[i] -= 0.2\n                elif count == 9:\n                    priorities[i] += 0.7\n                else:\n                    priorities[i] += 0.1 if item > 10 else 0.05\n                \n                for j in range(count):\n                    priorities[i] += 0.1\n                    if item > 10:\n                        priorities[i] += 0.2\n                        if item % 2 == 0:\n                            priorities[i] -= 0.1\n                        else:\n                            priorities[i] += 0.1\n                    else:\n                        priorities[i] += 0.05\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:31:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n            if item <= 20:\n                priorities[i] += 0.2\n            else:\n                priorities[i] += 0.5\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n            if item > 5:\n                priorities[i] -= 0.1\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n                \n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if count == 6:\n                    priorities[i] += 0.8\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if count == 4:\n                    priorities[i] -= 0.5\n                else:\n                    priorities[i] += 0.2\n            else:\n                priorities[i] = 0.9 * count + item / bins[i] + 0.3\n                if count == 3:\n                    priorities[i] -= 0.3\n                elif count == 5:\n                    priorities[i] += 0.4\n                else:\n                    priorities[i] += 0.1 if item > 10 else 0.05\n                \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n            if item <= 20:\n                priorities[i] += 0.2\n            else:\n                priorities[i] += 0.5\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n            if item > 5:\n                priorities[i] -= 0.1\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n                \n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if count == 6:\n                    priorities[i] += 0.8\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if count == 4:\n                    priorities[i] -= 0.5\n                else:\n                    priorities[i] += 0.2\n            else:\n                priorities[i] = 0.9 * count + item / bins[i] + 0.3\n                if count == 3:\n                    priorities[i] -= 0.3\n                elif count == 5:\n                    priorities[i] += 0.4\n                elif count == 7:\n                    priorities[i] -= 0.2\n                elif count == 9:\n                    priorities[i] += 0.7\n                \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n            if item <= 20:\n                priorities[i] += 0.2\n            else:\n                priorities[i] += 0.5\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n            if item > 5:\n                priorities[i] -= 0.1\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n                \n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if count == 6:\n                    priorities[i] += 0.8\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if count == 4:\n                    priorities[i] -= 0.5\n                else:\n                    priorities[i] += 0.2\n            else:\n                priorities[i] = 0.9 * count + item / bins[i] + 0.3\n                if count == 3:\n                    priorities[i] -= 0.3\n                elif count == 5:\n                    priorities[i] += 0.4\n                elif count == 7:\n                    priorities[i] -= 0.2\n                elif count == 9:\n                    priorities[i] += 0.7\n                else:\n                    priorities[i] += 0.1 if item > 10 else 0.05\n            \n            priorities[i] = max(min(priorities[i], 2.0), 0.0)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:31:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n            if item <= 20:\n                priorities[i] += 0.2\n            else:\n                priorities[i] += 0.5\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n            if item > 5:\n                priorities[i] -= 0.1\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n                \n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if count == 6:\n                    priorities[i] += 0.8\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if count == 4:\n                    priorities[i] -= 0.5\n                else:\n                    priorities[i] += 0.2\n            else:\n                priorities[i] = 0.9 * count + item / bins[i] + 0.3\n                if count == 3:\n                    priorities[i] -= 0.3\n                elif count == 5:\n                    priorities[i] += 0.4\n                else:\n                    priorities[i] += 0.1 if item > 10 else 0.05\n                \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n            if item <= 20:\n                priorities[i] += 0.2\n            else:\n                priorities[i] += 0.5\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n            if item > 5:\n                priorities[i] -= 0.1\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n                \n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if count == 6:\n                    priorities[i] += 0.8\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if count == 4:\n                    priorities[i] -= 0.5\n                else:\n                    priorities[i] += 0.2\n            else:\n                priorities[i] = 0.9 * count + item / bins[i] + 0.3\n                if count == 3:\n                    priorities[i] -= 0.3\n                elif count == 5:\n                    priorities[i] += 0.4\n                elif count == 7:\n                    priorities[i] -= 0.2\n                elif count == 9:\n                    priorities[i] += 0.7\n                \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n            if item <= 20:\n                priorities[i] += 0.2\n            else:\n                priorities[i] += 0.5\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n            if item > 5:\n                priorities[i] -= 0.1\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n                \n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if count == 6:\n                    priorities[i] += 0.8\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if count == 4:\n                    priorities[i] -= 0.5\n                else:\n                    priorities[i] += 0.2\n            else:\n                priorities[i] = 0.9 * count + item / bins[i] + 0.3\n                if count == 3:\n                    priorities[i] -= 0.3\n                elif count == 5:\n                    priorities[i] += 0.4\n                elif count == 7:\n                    priorities[i] -= 0.2\n                elif count == 9:\n                    priorities[i] += 0.7\n                else:\n                    priorities[i] += 0.1 if item > 10 else 0.05\n                \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:31:59", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n            if item <= 20:\n                priorities[i] += 0.2\n            else:\n                priorities[i] += 0.5\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n            if item > 5:\n                priorities[i] -= 0.1\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n                \n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if count == 6:\n                    priorities[i] += 0.8\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if count == 4:\n                    priorities[i] -= 0.5\n                else:\n                    priorities[i] += 0.2\n            else:\n                priorities[i] = 0.9 * count + item / bins[i] + 0.3\n                if count == 3:\n                    priorities[i] -= 0.3\n                elif count == 5:\n                    priorities[i] += 0.4\n                else:\n                    priorities[i] += 0.1 if item > 10 else 0.05\n                \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n            if item <= 20:\n                priorities[i] += 0.2\n            else:\n                priorities[i] += 0.5\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n            if item > 5:\n                priorities[i] -= 0.1\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n                \n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if count == 6:\n                    priorities[i] += 0.8\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if count == 4:\n                    priorities[i] -= 0.5\n                else:\n                    priorities[i] += 0.2\n            else:\n                priorities[i] = 0.9 * count + item / bins[i] + 0.3\n                if count == 3:\n                    priorities[i] -= 0.3\n                elif count == 5:\n                    priorities[i] += 0.4\n                elif count == 7:\n                    priorities[i] -= 0.2\n                elif count == 9:\n                    priorities[i] += 0.7\n                \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n            if item <= 20:\n                priorities[i] += 0.2\n            else:\n                priorities[i] += 0.5\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n            if item > 5:\n                priorities[i] -= 0.1\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n\n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n                if count == 6:\n                    priorities[i] += 0.8\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                if count == 4:\n                    priorities[i] -= 0.5\n                else:\n                    priorities[i] += 0.2\n            else:\n                priorities[i] = 0.9 * count + item / bins[i] + 0.3\n                if count == 3:\n                    priorities[i] -= 0.3\n                elif count == 5:\n                    priorities[i] += 0.4\n                elif count == 7:\n                    priorities[i] -= 0.2\n                elif count == 9:\n                    priorities[i] += 0.7\n                else:\n                    priorities[i] += 0.1 if item > 10 else 0.05\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:32:12", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            if priority_score > 1.5:\n                priority_score = 1.5\n            elif priority_score < 0.1:\n                priority_score = 0.1\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if bins[i] < 5:\n                priority_score += 0.1\n            elif bins[i] >= 5 and bins[i] < 10:\n                priority_score += 0.05\n            \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if bins[i] < 5:\n                priority_score += 0.1\n            elif bins[i] >= 5 and bins[i] < 10:\n                priority_score += 0.05\n                \n            if utilization_ratio < 0.3 and remaining_space >= 3:\n                priority_score += 0.1\n            elif utilization_ratio >= 0.3 and remaining_space >= 5:\n                priority_score += 0.15\n            elif utilization_ratio >= 0.6 and remaining_space >= 10:\n                priority_score += 0.2\n                \n            if remaining_space < 2:\n                priority_score -= 0.1\n            elif remaining_space < 1:\n                priority_score -= 0.2\n            \n            priorities[i] = priority_score\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:32:17", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            if priority_score > 1.5:\n                priority_score = 1.5\n            elif priority_score < 0.1:\n                priority_score = 0.1\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if bins[i] < 5:\n                priority_score += 0.1\n            elif bins[i] >= 5 and bins[i] < 10:\n                priority_score += 0.05\n            \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n            \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n            \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if bins[i] < 5:\n                priority_score += 0.1\n            elif bins[i] >= 5 and bins[i] < 10:\n                priority_score += 0.05\n            \n            if utilization_ratio < 0.5:\n                priority_score *= 1.1\n            elif utilization_ratio >= 0.5 and utilization_ratio < 0.7:\n                priority_score *= 1.2\n            elif utilization_ratio >= 0.7 and utilization_ratio < 0.9:\n                priority_score *= 1.3\n            else:\n                priority_score *= 1.4\n            \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:32:21", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            if priority_score > 1.5:\n                priority_score = 1.5\n            elif priority_score < 0.1:\n                priority_score = 0.1\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if bins[i] < 5:\n                priority_score += 0.1\n            elif bins[i] >= 5 and bins[i] < 10:\n                priority_score += 0.05\n            \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if bins[i] < 5:\n                priority_score += 0.1\n            elif bins[i] >= 5 and bins[i] < 10:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            \n            if bins[i] < 3:\n                priority_score -= 0.1\n            elif bins[i] < 5:\n                priority_score -= 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:32:26", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            if priority_score > 1.5:\n                priority_score = 1.5\n            elif priority_score < 0.1:\n                priority_score = 0.1\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if bins[i] < 5:\n                priority_score += 0.1\n            elif bins[i] >= 5 and bins[i] < 10:\n                priority_score += 0.05\n            \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if bins[i] < 5:\n                priority_score += 0.1\n            elif bins[i] >= 5 and bins[i] < 10:\n                priority_score += 0.05\n                \n            if bins[i] % 2 == 0:\n                priority_score += 0.05\n            elif bins[i] % 3 == 0:\n                priority_score += 0.1\n            elif bins[i] % 5 == 0:\n                priority_score += 0.15\n                \n            if item % 2 == 0:\n                priority_score += 0.05\n            elif item % 3 == 0:\n                priority_score += 0.1\n            elif item % 5 == 0:\n                priority_score += 0.15\n            \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:32:41", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    \n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n                \n            if i > 0 and i < len(bins) - 1:\n                if priorities[i-1] < priorities[i] > priorities[i+1]:\n                    priorities[i] += 1.0\n                else:\n                    priorities[i] -= 0.5\n                \n            if i % 5 == 0:\n                for j in range(i+1, len(bins), 3):\n                    priorities[j] += 1.0\n                \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:32:47", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:32:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(10):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:33:00", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:33:32", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5 and item < 3 * bins[i]:\n            priorities[i] = 1.5\n        elif item >= 3 * bins[i] and item < 4 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 3.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5 and item < 3 * bins[i]:\n            priorities[i] = 1.5\n        elif item >= 3 * bins[i] and item < 4 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 3.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n            \n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5 and item < 3 * bins[i]:\n            priorities[i] = 1.5\n        elif item >= 3 * bins[i] and item < 4 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 3.0\n            \n        if i % 2 == 0:\n            priorities[i] *= 0.8\n        elif i % 3 == 0:\n            priorities[i] *= 0.5\n        else:\n            priorities[i] *= 0.9\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:33:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5 and item < 3 * bins[i]:\n            priorities[i] = 1.5\n        elif item >= 3 * bins[i] and item < 4 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 3.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5 and item < 3 * bins[i]:\n            priorities[i] = 1.5\n        elif item >= 3 * bins[i] and item < 4 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 3.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n        # Additional complex logic\n        if item > 1.8 * bins[i]:\n            priorities[i] *= 1.3\n        elif item > 1.4 * bins[i]:\n            priorities[i] *= 1.1\n        elif item > 1.1 * bins[i]:\n            priorities[i] *= 1.05\n        \n        if priorities[i] < 0.7:\n            priorities[i] = 0.7\n        elif priorities[i] > 1.4 and item < 2.5 * bins[i]:\n                priorities[i] = 1.4\n        elif item >= 2.5 * bins[i] and item < 3.5 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 3.5 * bins[i]:\n            priorities[i] = 2.5\n        \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:33:38", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5 and item < 3 * bins[i]:\n            priorities[i] = 1.5\n        elif item >= 3 * bins[i] and item < 4 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 3.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5 and item < 3 * bins[i]:\n            priorities[i] = 1.5\n        elif item >= 3 * bins[i] and item < 4 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 3.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            if item <= 0.5 * bins[i]:\n                priorities[i] = 0.1\n            else:\n                priorities[i] = 0.5\n        elif priorities[i] > 1.5 and item < 3 * bins[i]:\n            priorities[i] = 1.5\n        elif item >= 3 * bins[i] and item < 4 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 3.0\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:33:42", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5 and item < 3 * bins[i]:\n            priorities[i] = 1.5\n        elif item >= 3 * bins[i] and item < 4 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 3.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5 and item < 3 * bins[i]:\n            priorities[i] = 1.5\n        elif item >= 3 * bins[i] and item < 4 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 3.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n            \n        if item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n        \n        if item >= 4 * bins[i]:\n            priorities[i] = 3.0\n        elif item >= 3 * bins[i]:\n            priorities[i] = 2.0\n        elif priorities[i] < 1.5 and item >= 2 * bins[i]:\n            priorities[i] = 1.5\n        elif priorities[i] < 1.2 and item >= 1.5 * bins[i]:\n            priorities[i] = 1.2\n        elif priorities[i] < 1.0 and item >= bins[i]:\n            priorities[i] = 1.0\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:33:51", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.05\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priority_ratio = item / bins[i]\n                priorities[i] = 1 - priority_ratio if priority_ratio < 0.5 else priority_ratio\n            else:\n                priority_ratio = bins[i] / item\n                priorities[i] = 1 - priority_ratio if priority_ratio < 0.5 else priority_ratio\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.1\n            if bins[i] - item > 5:\n                priorities[i] *= 1.1\n            else:\n                priorities[i] = priorities[i] / 2\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priority_ratio = item / bins[i]\n                priorities[i] = 1 - priority_ratio if priority_ratio < 0.5 else priority_ratio\n            else:\n                priority_ratio = bins[i] / item\n                priorities[i] = 1 - priority_ratio if priority_ratio < 0.5 else priority_ratio\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.15\n            if item < 0.5 * bins[i]:\n                priorities[i] *= 1.2\n            elif item < 0.8 * bins[i]:\n                priorities[i] *= 1.1\n            else:\n                priorities[i] = priorities[i] / 2\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:33:55", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.05\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priority_ratio = item / bins[i]\n                priorities[i] = 1 - priority_ratio if priority_ratio < 0.5 else priority_ratio\n            else:\n                priority_ratio = bins[i] / item\n                priorities[i] = 1 - priority_ratio if priority_ratio < 0.5 else priority_ratio\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.1\n            if bins[i] - item > 5:\n                priorities[i] *= 1.1\n            else:\n                priorities[i] = priorities[i] / 2\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Complex version of priority calculation.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priority_ratio = item / bins[i]\n                priorities[i] = 1 - priority_ratio if priority_ratio < 0.5 else priority_ratio\n            else:\n                priority_ratio = bins[i] / item\n                priorities[i] = 1 - priority_ratio if priority_ratio < 0.5 else priority_ratio\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.1\n            if bins[i] - item > 5:\n                priorities[i] *= 1.1\n            else:\n                priorities[i] = priorities[i] / 2\n            \n            if priorities[i] > 0.7:\n                priorities[i] = 1.0\n            elif priorities[i] > 0.5:\n                priorities[i] += 0.2\n            elif priorities[i] > 0.3:\n                priorities[i] -= 0.1\n            else:\n                priorities[i] = 0.1\n        \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:33:58", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.05\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priority_ratio = item / bins[i]\n                priorities[i] = 1 - priority_ratio if priority_ratio < 0.5 else priority_ratio\n            else:\n                priority_ratio = bins[i] / item\n                priorities[i] = 1 - priority_ratio if priority_ratio < 0.5 else priority_ratio\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.1\n            if bins[i] - item > 5:\n                priorities[i] *= 1.1\n            else:\n                priorities[i] = priorities[i] / 2\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priority_ratio = item / bins[i]\n                if priority_ratio < 0.3:\n                    priorities[i] = 0.7\n                elif priority_ratio < 0.6:\n                    priorities[i] = 0.5\n                else:\n                    priorities[i] = 0.3\n            else:\n                priority_ratio = bins[i] / item\n                if priority_ratio < 0.3:\n                    priorities[i] = 0.7\n                elif priority_ratio < 0.6:\n                    priorities[i] = 0.5\n                else:\n                    priorities[i] = 0.3\n            if bins[i] % 3 == 0:\n                priorities[i] += 0.1\n            if bins[i] - item > 5:\n                priorities[i] *= 1.2\n            else:\n                priorities[i] = priorities[i] / 2\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:34:01", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.05\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priority_ratio = item / bins[i]\n                priorities[i] = 1 - priority_ratio if priority_ratio < 0.5 else priority_ratio\n            else:\n                priority_ratio = bins[i] / item\n                priorities[i] = 1 - priority_ratio if priority_ratio < 0.5 else priority_ratio\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.1\n            if bins[i] - item > 5:\n                priorities[i] *= 1.1\n            else:\n                priorities[i] = priorities[i] / 2\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priority_ratio = item / bins[i]\n                priorities[i] = 1 - priority_ratio if priority_ratio < 0.5 else priority_ratio\n            else:\n                priority_ratio = bins[i] / item\n                priorities[i] = 1 - priority_ratio if priority_ratio < 0.5 else priority_ratio\n            \n            if bins[i] % 2 == 0:\n                priorities[i] += 0.1\n            \n            if bins[i] - item > 5:\n                priorities[i] *= 1.1\n            else:\n                priorities[i] = priorities[i] / 2\n            \n            if item > 10 and bins[i] < 20:\n                priorities[i] -= 0.2\n            elif item > 20:\n                priorities[i] += 0.3\n            else:\n                priorities[i] = priorities[i]\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:34:11", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            if priority_score > 1.5:\n                priority_score = 1.5\n            elif priority_score < 0.1:\n                priority_score = 0.1\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            priority_score = 1 / (1 + utilization_ratio)\n            \n            if utilization_ratio < 0.1:\n                priority_score *= 1.5\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score *= 1.3\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score *= 1.1\n                \n            priority_score -= item / 10\n            \n            if bins[i] >= 10:\n                priority_score *= 1.4\n            elif bins[i] >= 7:\n                priority_score *= 1.2\n                \n            if remaining_space >= 3:\n                priority_score += 0.2\n            elif remaining_space >= 1:\n                priority_score += 0.1\n            \n            if item < 5:\n                priority_score += 0.1\n            elif item >= 5 and item < 10:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:34:17", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            if priority_score > 1.5:\n                priority_score = 1.5\n            elif priority_score < 0.1:\n                priority_score = 0.1\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            if priority_score > 1.5:\n                priority_score = 1.5\n            elif priority_score < 0.1:\n                priority_score = 0.1\n                \n            if bins[i] % 2 == 0:\n                priority_score *= 1.1\n            elif bins[i] % 3 == 0:\n                priority_score *= 1.2\n            \n            priorities[i] = priority_score\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:34:22", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            if priority_score > 1.5:\n                priority_score = 1.5\n            elif priority_score < 0.1:\n                priority_score = 0.1\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.3 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            if priority_score > 1.5:\n                priority_score = 1.5\n            elif priority_score < 0.1:\n                priority_score = 0.1\n                \n            if priority_score > 0.5 and utilization_ratio < 0.5:\n                priority_score = priority_score * 1.1\n            elif priority_score < 0.5 and utilization_ratio >= 0.5:\n                priority_score = priority_score * 0.9\n            \n            if priority_score > 1.0 and item < 8:\n                priority_score -= 0.2\n            \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:34:26", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            if priority_score > 1.5:\n                priority_score = 1.5\n            elif priority_score < 0.1:\n                priority_score = 0.1\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            if priority_score > 1.5:\n                priority_score = 1.5\n            elif priority_score < 0.1:\n                priority_score = 0.1\n                \n            priority_weight = 0.3 * bins[i] / item if item != 0 else 0\n            scaled_priority_score = priority_score * priority_weight\n            \n            priorities[i] = scaled_priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:34:37", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.3:\n                priorities[i] = 0.2\n            elif ratio < 0.5:\n                priorities[i] = 0.4\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            elif ratio < 1.0:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n        if i % 3 == 0:\n            priorities[i] *= 1.5\n        elif i % 3 == 1:\n            priorities[i] *= 1.2\n        else:\n            priorities[i] *= 0.8\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            if item < 0.5 * bins[i]:\n                priorities[i] = item / bins[i] * 0.75\n            elif item > 1.5 * bins[i]:\n                priorities[i] = bins[i] / item * 0.5\n            else:\n                if bins[i] % 2 == 0:\n                    priorities[i] = 0.8\n                else:\n                    priorities[i] = 0.6\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.3:\n                priorities[i] = 0.2\n            elif ratio < 0.5:\n                priorities[i] = 0.4\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            elif ratio < 1.0:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n            \n            if bins[i] % 3 == 0:\n                priorities[i] *= 1.5\n            elif bins[i] % 3 == 1:\n                priorities[i] *= 1.2\n            else:\n                priorities[i] *= 0.8\n                \n            if item > 1.2 * bins[i]:\n                priorities[i] *= 1.2\n            elif item < 0.8 * bins[i]:\n                priorities[i] *= 0.8\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:34:40", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.3:\n                priorities[i] = 0.2\n            elif ratio < 0.5:\n                priorities[i] = 0.4\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            elif ratio < 1.0:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n        if i % 3 == 0:\n            priorities[i] *= 1.5\n        elif i % 3 == 1:\n            priorities[i] *= 1.2\n        else:\n            priorities[i] *= 0.8\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            if item < 0.5 * bins[i]:\n                priorities[i] = item / bins[i] * 0.75\n            elif item > 1.5 * bins[i]:\n                priorities[i] = bins[i] / item * 0.5\n            else:\n                if bins[i] % 2 == 0:\n                    priorities[i] = 0.8\n                else:\n                    priorities[i] = 0.6\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            if item < 0.7 * bins[i]:\n                priorities[i] = item / bins[i] * 0.8\n            elif item > 1.3 * bins[i]:\n                priorities[i] = bins[i] / item * 0.6\n            else:\n                if bins[i] % 3 == 0:\n                    priorities[i] = 0.9\n                elif bins[i] % 3 == 1:\n                    priorities[i] = 0.7\n                else:\n                    priorities[i] = 0.5\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:34:43", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.3:\n                priorities[i] = 0.2\n            elif ratio < 0.5:\n                priorities[i] = 0.4\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            elif ratio < 1.0:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n        if i % 3 == 0:\n            priorities[i] *= 1.5\n        elif i % 3 == 1:\n            priorities[i] *= 1.2\n        else:\n            priorities[i] *= 0.8\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            if item < 0.5 * bins[i]:\n                priorities[i] = item / bins[i] * 0.75\n            elif item > 1.5 * bins[i]:\n                priorities[i] = bins[i] / item * 0.5\n            else:\n                if bins[i] % 2 == 0:\n                    priorities[i] = 0.8\n                else:\n                    priorities[i] = 0.6\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            if item < 0.3 * bins[i]:\n                priorities[i] = item / bins[i] * 0.5\n            elif item > 1.2 * bins[i]:\n                priorities[i] = bins[i] / item * 0.3\n            else:\n                if i % 2 == 0:\n                    priorities[i] = 0.7\n                else:\n                    priorities[i] = 0.8\n            if i == len(bins) - 1:\n                priorities[i] *= 1.2\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:34:46", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            ratio = item / bins[i]\n            if ratio < 0.3:\n                priorities[i] = 0.2\n            elif ratio < 0.5:\n                priorities[i] = 0.4\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            elif ratio < 1.0:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n        if i % 3 == 0:\n            priorities[i] *= 1.5\n        elif i % 3 == 1:\n            priorities[i] *= 1.2\n        else:\n            priorities[i] *= 0.8\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            if item < 0.5 * bins[i]:\n                priorities[i] = item / bins[i] * 0.75\n            elif item > 1.5 * bins[i]:\n                priorities[i] = bins[i] / item * 0.5\n            else:\n                if bins[i] % 2 == 0:\n                    priorities[i] = 0.8\n                else:\n                    priorities[i] = 0.6\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            if item < 0.3 * bins[i]:\n                priorities[i] = item / bins[i] * 0.9\n            elif item > 1.2 * bins[i]:\n                priorities[i] = bins[i] / item * 0.7\n            else:\n                if bins[i] % 3 == 0:\n                    priorities[i] = 0.8\n                elif bins[i] % 3 == 1:\n                    priorities[i] = 0.6\n                else:\n                    priorities[i] = 0.4\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:34:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-35 * (ratio - 0.2))) + 0.2\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-20 * (ratio - 0.3))) + 0.35\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.5))) + 0.4\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.7))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 1))) + 0.6\n\n        if i % 3 == 0:\n            priorities[i] += 0.25\n        else:\n            for j in range(10):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.03 * j\n                else:\n                    priorities[i] += 0.01 * j\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:35:00", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % 3 == 1:\n                    priorities[i] -= 0.1 * j\n                elif i % 4 == 1:\n                    priorities[i] += 0.05 * j\n                elif i % 5 == 1:\n                    priorities[i] -= 0.02 * j\n                else:\n                    priorities[i] += 0.01 * j\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:35:02", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(data: np.ndarray, threshold: float) -> np.ndarray:\n    result = np.zeros_like(data)\n    \n    for i in range(len(data)):\n        if data[i] < threshold:\n            for j in range(1, 6):\n                if i % j == 0:\n                    result[i] += 0.1 * j\n                else:\n                    result[i] -= 0.05 * j\n        elif data[i] >= threshold and data[i] < threshold * 2:\n            for j in range(1, 6):\n                if i % (j + 2) == 0:\n                    result[i] += 0.2 * j\n                else:\n                    result[i] -= 0.1 * j\n        else:\n            for j in range(1, 6):\n                if i % (j + 5) == 0:\n                    result[i] += 0.3 * j\n                else:\n                    result[i] -= 0.15 * j\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 07:35:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n                if j % 2 == 0:\n                    priorities[i] *= 1.1\n                else:\n                    priorities[i] /= 1.2\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:35:21", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-40 * (ratio - 0.2))) + 0.2\n        elif ratio >= 0.2 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-20 * (ratio - 0.4))) + 0.4\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.7))) + 0.5\n        elif ratio >= 0.8 and ratio < 0.95:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.9))) + 0.6\n        else:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 1))) + 0.7\n\n        if i % 3 == 0:\n            priorities[i] += 0.4\n        else:\n            for j in range(5):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:35:24", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:35:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n        if i % 3 == 0:\n            priorities[i] *= 1.1\n        elif i % 4 == 0:\n            priorities[i] *= 0.8\n        elif i % 6 == 0:\n            priorities[i] *= 1.5\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:35:32", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            for _ in range(3):\n                priorities[i] = np.log(1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4) * 2\n        elif ratio >= 0.7 and ratio < 0.9:\n            for _ in range(4):\n                priorities[i] = np.log(1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5) * 3\n        else:\n            for _ in range(5):\n                priorities[i] = np.log(1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6) * 4\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:35:47", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < 0.5 * bins[i]:\n                priorities[i] = (item / bins[i]) * (1 - 0.1 * i)\n            elif item > 1.5 * bins[i]:\n                priorities[i] = (bins[i] / item) * (1 + 0.05 * i)\n            else:\n                if bins[i] % 2 == 0:\n                    priorities[i] = (item * bins[i] / (item + bins[i])) + 0.2\n                else:\n                    priorities[i] = (item * bins[i] / (item + bins[i])) - 0.1\n                if item % 2 == 0:\n                    priorities[i] += 0.1\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n                if item % 2 == 0:\n                    priorities[i] += 0.2\n                else:\n                    priorities[i] -= 0.1\n                for j in range(2, int(bins[i] ** 0.5) + 1):\n                    if bins[i] % j == 0:\n                        priorities[i] += 0.1\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    if bins[i] % item < 0.5:\n                        priorities[i] = item / bins[i] + 0.2\n                    elif bins[i] % item < 0.8:\n                        priorities[i] = 0.8 - item / bins[i]\n                    else:\n                        priorities[i] = bins[i] - item / bins[i] + 0.4\n                for k in range(2, int(item ** 0.5) + 1):\n                    if item % k == 0:\n                        priorities[i] -= 0.05\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n                if item % 2 == 0:\n                    priorities[i] += 0.2\n                else:\n                    priorities[i] -= 0.1\n                for j in range(2, int(bins[i] ** 0.5) + 1):\n                    if bins[i] % j == 0:\n                        priorities[i] += 0.1\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    if bins[i] % item < 0.5:\n                        priorities[i] = item / bins[i] + 0.2\n                    elif bins[i] % item < 0.8:\n                        priorities[i] = 0.8 - item / bins[i]\n                    else:\n                        priorities[i] = bins[i] - item / bins[i] + 0.4\n                for k in range(2, int(item ** 0.5) + 1):\n                    if item % k == 0:\n                        priorities[i] -= 0.05\n                if item > 1.5 * bins[i] and bins[i] % 5 == 0:\n                    priorities[i] += 0.3\n                elif item < bins[i] * 0.5 and item % 3 == 0:\n                    priorities[i] -= 0.2\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:35:51", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < 0.5 * bins[i]:\n                priorities[i] = (item / bins[i]) * (1 - 0.1 * i)\n            elif item > 1.5 * bins[i]:\n                priorities[i] = (bins[i] / item) * (1 + 0.05 * i)\n            else:\n                if bins[i] % 2 == 0:\n                    priorities[i] = (item * bins[i] / (item + bins[i])) + 0.2\n                else:\n                    priorities[i] = (item * bins[i] / (item + bins[i])) - 0.1\n                if item % 2 == 0:\n                    priorities[i] += 0.1\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n                if item % 2 == 0:\n                    priorities[i] += 0.2\n                else:\n                    priorities[i] -= 0.1\n                for j in range(2, int(bins[i] ** 0.5) + 1):\n                    if bins[i] % j == 0:\n                        priorities[i] += 0.1\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    if bins[i] % item < 0.5:\n                        priorities[i] = item / bins[i] + 0.2\n                    elif bins[i] % item < 0.8:\n                        priorities[i] = 0.8 - item / bins[i]\n                    else:\n                        priorities[i] = bins[i] - item / bins[i] + 0.4\n                for k in range(2, int(item ** 0.5) + 1):\n                    if item % k == 0:\n                        priorities[i] -= 0.05\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n                if item % 2 == 0:\n                    priorities[i] += 0.2\n                else:\n                    priorities[i] -= 0.1\n                for j in range(2, int(bins[i] ** 0.5) + 1):\n                    if bins[i] % j == 0:\n                        priorities[i] += 0.1\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    if bins[i] % item < 0.5:\n                        priorities[i] = item / bins[i] + 0.2\n                    elif bins[i] % item < 0.8:\n                        priorities[i] = 0.8 - item / bins[i]\n                    else:\n                        priorities[i] = bins[i] - item / bins[i] + 0.4\n                for k in range(2, int(item ** 0.5) + 1):\n                    if item % k == 0:\n                        priorities[i] -= 0.05\n                if item % 2 == 0:\n                    priorities[i] += 0.1\n                for m in range(3, int(item ** 0.7) + 1):\n                    if item % m == 0:\n                        priorities[i] -= 0.07\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:35:56", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < 0.5 * bins[i]:\n                priorities[i] = (item / bins[i]) * (1 - 0.1 * i)\n            elif item > 1.5 * bins[i]:\n                priorities[i] = (bins[i] / item) * (1 + 0.05 * i)\n            else:\n                if bins[i] % 2 == 0:\n                    priorities[i] = (item * bins[i] / (item + bins[i])) + 0.2\n                else:\n                    priorities[i] = (item * bins[i] / (item + bins[i])) - 0.1\n                if item % 2 == 0:\n                    priorities[i] += 0.1\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n                if item % 2 == 0:\n                    priorities[i] += 0.2\n                else:\n                    priorities[i] -= 0.1\n                for j in range(2, int(bins[i] ** 0.5) + 1):\n                    if bins[i] % j == 0:\n                        priorities[i] += 0.1\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    if bins[i] % item < 0.5:\n                        priorities[i] = item / bins[i] + 0.2\n                    elif bins[i] % item < 0.8:\n                        priorities[i] = 0.8 - item / bins[i]\n                    else:\n                        priorities[i] = bins[i] - item / bins[i] + 0.4\n                for k in range(2, int(item ** 0.5) + 1):\n                    if item % k == 0:\n                        priorities[i] -= 0.05\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < 0.8 * bins[i]:\n                priorities[i] = (item / bins[i]) * (1 - 0.1 * i)\n                if item % 3 == 0:\n                    priorities[i] += 0.2\n                else:\n                    priorities[i] -= 0.1\n                for j in range(3, int(bins[i] ** 0.5) + 1):\n                    if bins[i] % j == 0:\n                        priorities[i] += 0.05\n            elif item > 1.2 * bins[i]:\n                priorities[i] = (bins[i] / item) * (1 + 0.05 * i)\n                for k in range(4, int(item ** 0.5) + 1):\n                    if item % k == 0:\n                        priorities[i] += 0.08\n            else:\n                priorities[i] = (item * bins[i] / (item + bins[i]))\n                for l in range(2, int(item ** 0.5) + 1):\n                    if item % l == 0:\n                        priorities[i] += 0.03\n                if bins[i] % 2 == 0:\n                    priorities[i] += 0.1\n                else:\n                    priorities[i] -= 0.05\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:35:59", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < 0.5 * bins[i]:\n                priorities[i] = (item / bins[i]) * (1 - 0.1 * i)\n            elif item > 1.5 * bins[i]:\n                priorities[i] = (bins[i] / item) * (1 + 0.05 * i)\n            else:\n                if bins[i] % 2 == 0:\n                    priorities[i] = (item * bins[i] / (item + bins[i])) + 0.2\n                else:\n                    priorities[i] = (item * bins[i] / (item + bins[i])) - 0.1\n                if item % 2 == 0:\n                    priorities[i] += 0.1\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i]\n                if item % 2 == 0:\n                    priorities[i] += 0.2\n                else:\n                    priorities[i] -= 0.1\n                for j in range(2, int(bins[i] ** 0.5) + 1):\n                    if bins[i] % j == 0:\n                        priorities[i] += 0.1\n            else:\n                if bins[i] % item == 0:\n                    priorities[i] = (bins[i] - item) / bins[i]\n                else:\n                    if bins[i] % item < 0.5:\n                        priorities[i] = item / bins[i] + 0.2\n                    elif bins[i] % item < 0.8:\n                        priorities[i] = 0.8 - item / bins[i]\n                    else:\n                        priorities[i] = bins[i] - item / bins[i] + 0.4\n                for k in range(2, int(item ** 0.5) + 1):\n                    if item % k == 0:\n                        priorities[i] -= 0.05\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item / bins[i] + 0.1\n                for j in range(2, int(bins[i] ** 0.5) + 1):\n                    if bins[i] % j == 0:\n                        priorities[i] += 0.05\n            else:\n                if item % 2 == 0:\n                    priorities[i] = bins[i] / item\n                    if bins[i] % item < 0.2:\n                        priorities[i] += 0.2\n                    elif bins[i] % item < 0.5:\n                        priorities[i] -= 0.1\n                    else:\n                        priorities[i] += 0.05\n                else:\n                    priorities[i] = item % bins[i] / bins[i]\n                    if item % bins[i] < 0.5:\n                        priorities[i] -= 0.15\n                    else:\n                        priorities[i] += 0.1\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:36:09", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more improved version of priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            remaining_space_ratio = (item - bins[i]) / bins[i]\n            if remaining_space_ratio < 0.1:\n                priorities[i] = 0.3\n            elif remaining_space_ratio >= 0.1 and remaining_space_ratio < 0.3:\n                priorities[i] = 0.5\n            elif remaining_space_ratio >= 0.3 and remaining_space_ratio < 0.5:\n                priorities[i] = 0.7\n            else:\n                priority = 0.9\n                for j in range(1, int(remaining_space_ratio) + 1):\n                    priority -= 0.1\n                priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            ratio = item / bins[i]\n            \n            if ratio < 0.1:\n                priorities[i] = 0.1\n            elif ratio >= 0.1 and ratio < 0.2:\n                priorities[i] = 0.2\n            elif ratio >= 0.2 and ratio < 0.3:\n                priorities[i] = 0.3\n            elif ratio >= 0.3 and ratio < 0.4:\n                priorities[i] = 0.4\n            elif ratio >= 0.4 and ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.7:\n                priorities[i] = 0.7\n            elif ratio >= 0.7 and ratio < 0.8:\n                priorities[i] = 0.8\n            elif ratio >= 0.8 and ratio < 0.9:\n                priorities[i] = 0.9\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            ratio = item / bins[i]\n            \n            if ratio < 0.1:\n                priorities[i] = 0.1\n            elif ratio >= 0.1 and ratio < 0.2:\n                priorities[i] = 0.2\n            elif ratio >= 0.2 and ratio < 0.3:\n                priorities[i] = 0.3\n            elif ratio >= 0.3 and ratio < 0.4:\n                priorities[i] = 0.4\n            elif ratio >= 0.4 and ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.7:\n                priorities[i] = 0.7\n            elif ratio >= 0.7 and ratio < 0.8:\n                priorities[i] = 0.8\n            elif ratio >= 0.8 and ratio < 0.9:\n                priorities[i] = 0.9\n            else:\n                priorities[i] = 1.0\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:36:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more improved version of priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            remaining_space_ratio = (item - bins[i]) / bins[i]\n            if remaining_space_ratio < 0.1:\n                priorities[i] = 0.3\n            elif remaining_space_ratio >= 0.1 and remaining_space_ratio < 0.3:\n                priorities[i] = 0.5\n            elif remaining_space_ratio >= 0.3 and remaining_space_ratio < 0.5:\n                priorities[i] = 0.7\n            else:\n                priority = 0.9\n                for j in range(1, int(remaining_space_ratio) + 1):\n                    priority -= 0.1\n                priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            ratio = item / bins[i]\n            \n            if ratio < 0.1:\n                priorities[i] = 0.1\n            elif ratio >= 0.1 and ratio < 0.2:\n                priorities[i] = 0.2\n            elif ratio >= 0.2 and ratio < 0.3:\n                priorities[i] = 0.3\n            elif ratio >= 0.3 and ratio < 0.4:\n                priorities[i] = 0.4\n            elif ratio >= 0.4 and ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.7:\n                priorities[i] = 0.7\n            elif ratio >= 0.7 and ratio < 0.8:\n                priorities[i] = 0.8\n            elif ratio >= 0.8 and ratio < 0.9:\n                priorities[i] = 0.9\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more sophisticated version of the priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            ratio = item / bins[i]\n            \n            if ratio < 0.1:\n                priorities[i] = 0.1\n            elif ratio >= 0.1 and ratio < 0.2:\n                priorities[i] = 0.2\n            elif ratio >= 0.2 and ratio < 0.3:\n                priorities[i] = 0.3\n            elif ratio >= 0.3 and ratio < 0.4:\n                priorities[i] = 0.4\n            elif ratio >= 0.4 and ratio < 0.5:\n                priorities[i] = 0.5\n            else:\n                priority = 1.0\n                for j in range(1, int(ratio) + 1):\n                    priority -= 0.1\n                priorities[i] = priority\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:36:17", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more improved version of priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            remaining_space_ratio = (item - bins[i]) / bins[i]\n            if remaining_space_ratio < 0.1:\n                priorities[i] = 0.3\n            elif remaining_space_ratio >= 0.1 and remaining_space_ratio < 0.3:\n                priorities[i] = 0.5\n            elif remaining_space_ratio >= 0.3 and remaining_space_ratio < 0.5:\n                priorities[i] = 0.7\n            else:\n                priority = 0.9\n                for j in range(1, int(remaining_space_ratio) + 1):\n                    priority -= 0.1\n                priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            ratio = item / bins[i]\n            \n            if ratio < 0.1:\n                priorities[i] = 0.1\n            elif ratio >= 0.1 and ratio < 0.2:\n                priorities[i] = 0.2\n            elif ratio >= 0.2 and ratio < 0.3:\n                priorities[i] = 0.3\n            elif ratio >= 0.3 and ratio < 0.4:\n                priorities[i] = 0.4\n            elif ratio >= 0.4 and ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.7:\n                priorities[i] = 0.7\n            elif ratio >= 0.7 and ratio < 0.8:\n                priorities[i] = 0.8\n            elif ratio >= 0.8 and ratio < 0.9:\n                priorities[i] = 0.9\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            ratio = item / bins[i]\n            \n            if ratio < 0.1:\n                priorities[i] = 0.1\n            elif ratio >= 0.1 and ratio < 0.2:\n                priorities[i] = 0.2\n            elif ratio >= 0.2 and ratio < 0.3:\n                priorities[i] = 0.3\n            elif ratio >= 0.3 and ratio < 0.4:\n                priorities[i] = 0.4\n            elif ratio >= 0.4 and ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.7:\n                priorities[i] = 0.7\n            elif ratio >= 0.7 and ratio < 0.8:\n                priorities[i] = 0.8\n            elif ratio >= 0.8 and ratio < 0.9:\n                priorities[i] = 0.9\n            else:\n                priorities[i] = 1.0\n                \n    for j in range(len(priorities)):\n        if priorities[j] > 0.5:\n            priorities[j] += 0.1\n        else:\n            priorities[j] -= 0.1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:36:21", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more improved version of priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            remaining_space_ratio = (item - bins[i]) / bins[i]\n            if remaining_space_ratio < 0.1:\n                priorities[i] = 0.3\n            elif remaining_space_ratio >= 0.1 and remaining_space_ratio < 0.3:\n                priorities[i] = 0.5\n            elif remaining_space_ratio >= 0.3 and remaining_space_ratio < 0.5:\n                priorities[i] = 0.7\n            else:\n                priority = 0.9\n                for j in range(1, int(remaining_space_ratio) + 1):\n                    priority -= 0.1\n                priorities[i] = priority\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            ratio = item / bins[i]\n            \n            if ratio < 0.1:\n                priorities[i] = 0.1\n            elif ratio >= 0.1 and ratio < 0.2:\n                priorities[i] = 0.2\n            elif ratio >= 0.2 and ratio < 0.3:\n                priorities[i] = 0.3\n            elif ratio >= 0.3 and ratio < 0.4:\n                priorities[i] = 0.4\n            elif ratio >= 0.4 and ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.7:\n                priorities[i] = 0.7\n            elif ratio >= 0.7 and ratio < 0.8:\n                priorities[i] = 0.8\n            elif ratio >= 0.8 and ratio < 0.9:\n                priorities[i] = 0.9\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        \n        else:\n            ratio = item / bins[i]\n            \n            if ratio < 0.1:\n                priorities[i] = 0.1\n            elif ratio >= 0.1 and ratio < 0.2:\n                priorities[i] = 0.2\n            elif ratio >= 0.2 and ratio < 0.3:\n                priorities[i] = 0.3\n            elif ratio >= 0.3 and ratio < 0.4:\n                priorities[i] = 0.4\n            elif ratio >= 0.4 and ratio < 0.5:\n                priorities[i] = 0.5\n            elif ratio >= 0.5 and ratio < 0.6:\n                priorities[i] = 0.6\n            elif ratio >= 0.6 and ratio < 0.7:\n                priorities[i] = 0.7\n            elif ratio >= 0.7 and ratio < 0.8:\n                priorities[i] = 0.8\n            elif ratio >= 0.8 and ratio < 0.9:\n                priorities[i] = 0.9\n            else:\n                priorities[i] = 1.0\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:36:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n            \n            if item % 10 == 0:\n                priorities[i] *= 1.8\n            elif item % 5 == 0:\n                priorities[i] *= 1.5\n            else:\n                priorities[i] *= 1.2\n            \n            if bins[i] % 2 == 0:\n                priorities[i] *= 2.0\n            elif bins[i] % 3 == 0:\n                priorities[i] *= 2.5\n            else:\n                priorities[i] *= 1.7\n            \n            if count >= 4 and item >= 10:\n                priorities[i] += 2.0\n            elif count <= 2 or item < 5:\n                priorities[i] -= 1.0\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                \n    sorted_priorities = np.sort(priorities)[::-1]\n    max_val = sorted_priorities[0]\n    for j in range(len(priorities)):\n        if priorities[j] == max_val:\n            priorities[j] += 0.5\n        elif 0.5 * max_val <= priorities[j] <= max_val - 0.5:\n            priorities[j] += 0.3\n        else:\n            priorities[j] -= 0.2\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                \n    sorted_priorities = np.sort(priorities)[::-1]\n    max_val = sorted_priorities[0]\n    for j in range(len(priorities)):\n        if priorities[j] == max_val:\n            priorities[j] += 0.5\n        elif 0.5 * max_val <= priorities[j] <= max_val - 0.5:\n            priorities[j] += 0.3\n        else:\n            priorities[j] -= 0.2\n        \n    final_priorities = np.zeros_like(bins)\n    for k in range(len(priorities)):\n        if priorities[k] > 1.5:\n            final_priorities[k] = 2 * priorities[k]\n        elif 1 < priorities[k] <= 1.5:\n            final_priorities[k] = 1.5 * priorities[k]\n        else:\n            final_priorities[k] = 1.2 * priorities[k]\n        \n    return final_priorities", "strategy": []}
{"timestamp": "2025-04-27 07:36:34", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n            \n            if item % 10 == 0:\n                priorities[i] *= 1.8\n            elif item % 5 == 0:\n                priorities[i] *= 1.5\n            else:\n                priorities[i] *= 1.2\n            \n            if bins[i] % 2 == 0:\n                priorities[i] *= 2.0\n            elif bins[i] % 3 == 0:\n                priorities[i] *= 2.5\n            else:\n                priorities[i] *= 1.7\n            \n            if count >= 4 and item >= 10:\n                priorities[i] += 2.0\n            elif count <= 2 or item < 5:\n                priorities[i] -= 1.0\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                \n    sorted_priorities = np.sort(priorities)[::-1]\n    max_val = sorted_priorities[0]\n    for j in range(len(priorities)):\n        if priorities[j] == max_val:\n            priorities[j] += 0.5\n        elif 0.5 * max_val <= priorities[j] <= max_val - 0.5:\n            priorities[j] += 0.3\n        else:\n            priorities[j] -= 0.2\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Ultra improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                \n    sorted_priorities = np.sort(priorities)[::-1]\n    max_val = sorted_priorities[0]\n    for j in range(len(priorities)):\n        if priorities[j] == max_val:\n            priorities[j] += 0.5\n                \n    avg = np.mean(priorities)\n    for k in range(len(priorities)):\n        if 0.5 * max_val < priorities[k] < 0.8 * max_val:\n            priorities[k] += 0.3\n        elif priorities[k] > avg:\n            priorities[k] -= 0.1\n        else:\n            priorities[k] += 0.2\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:36:38", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n            \n            if item % 10 == 0:\n                priorities[i] *= 1.8\n            elif item % 5 == 0:\n                priorities[i] *= 1.5\n            else:\n                priorities[i] *= 1.2\n            \n            if bins[i] % 2 == 0:\n                priorities[i] *= 2.0\n            elif bins[i] % 3 == 0:\n                priorities[i] *= 2.5\n            else:\n                priorities[i] *= 1.7\n            \n            if count >= 4 and item >= 10:\n                priorities[i] += 2.0\n            elif count <= 2 or item < 5:\n                priorities[i] -= 1.0\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                \n    sorted_priorities = np.sort(priorities)[::-1]\n    max_val = sorted_priorities[0]\n    for j in range(len(priorities)):\n        if priorities[j] == max_val:\n            priorities[j] += 0.5\n        elif 0.5 * max_val <= priorities[j] <= max_val - 0.5:\n            priorities[j] += 0.3\n        else:\n            priorities[j] -= 0.2\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                \n            if count > 2 and item > 10:\n                priorities[i] += 1.5\n            elif count < 2 or item <= 5:\n                priorities[i] -= 0.5\n                \n            if item % 10 == 0:\n                priorities[i] *= 2.0\n            elif item % 5 == 0:\n                priorities[i] *= 1.7\n            else:\n                priorities[i] *= 1.3\n                \n            if bins[i] % 2 == 0:\n                priorities[i] *= 1.5\n            elif bins[i] % 3 == 0:\n                priorities[i] *= 1.8\n            else:\n                priorities[i] *= 1.2\n                \n            if count >= 4 and item >= 10:\n                priorities[i] += 2.0\n            elif count <= 2 or item < 5:\n                priorities[i] -= 1.0\n            \n    sorted_priorities = np.sort(priorities)[::-1]\n    max_val = sorted_priorities[0]\n    for j in range(len(priorities)):\n        if priorities[j] == max_val:\n            priorities[j] += 0.7\n        elif 0.5 * max_val <= priorities[j] <= max_val - 0.5:\n            priorities[j] += 0.4\n        else:\n            priorities[j] -= 0.3\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:36:42", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n            \n            if item % 10 == 0:\n                priorities[i] *= 1.8\n            elif item % 5 == 0:\n                priorities[i] *= 1.5\n            else:\n                priorities[i] *= 1.2\n            \n            if bins[i] % 2 == 0:\n                priorities[i] *= 2.0\n            elif bins[i] % 3 == 0:\n                priorities[i] *= 2.5\n            else:\n                priorities[i] *= 1.7\n            \n            if count >= 4 and item >= 10:\n                priorities[i] += 2.0\n            elif count <= 2 or item < 5:\n                priorities[i] -= 1.0\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                \n    sorted_priorities = np.sort(priorities)[::-1]\n    max_val = sorted_priorities[0]\n    for j in range(len(priorities)):\n        if priorities[j] == max_val:\n            priorities[j] += 0.5\n        elif 0.5 * max_val <= priorities[j] <= max_val - 0.5:\n            priorities[j] += 0.3\n        else:\n            priorities[j] -= 0.2\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n                \n    sorted_priorities = np.sort(priorities)[::-1]\n    max_val = sorted_priorities[0]\n    for j in range(len(priorities)):\n        if priorities[j] == max_val:\n            priorities[j] += 0.5\n        elif 0.5 * max_val <= priorities[j] <= max_val - 0.5:\n            priorities[j] += 0.3\n        else:\n            priorities[j] -= 0.2\n            \n    return np.clip(priorities, 0, 5)", "strategy": []}
{"timestamp": "2025-04-27 07:37:02", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if i % 2 == 0:\n            priorities[i] = np.sqrt(priorities[i]) * 2.0\n        else:\n            priorities[i] = np.cbrt(priorities[i]) * 2.5\n\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:37:09", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:37:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:37:21", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    # Insert more complex logic here\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:37:45", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(bins)):\n            if i % 2 == 0:\n                if priorities[i] < 0.5:\n                    priorities[i] -= 0.4\n                elif priorities[i] < 1.5:\n                    priorities[i] += 0.8\n                else:\n                    priorities[i] += 1.0\n            else:\n                if priorities[i] < 0.5:\n                    priorities[i] -= 0.2\n                elif priorities[i] < 1.5:\n                    priorities[i] += 1.0\n                else:\n                    priorities[i] += 1.5\n\n    for j in range(5):\n        for i in range(len(bins)):\n            if i % 3 == 0:\n                if j % 2 == 0:\n                    if priorities[i] < j:\n                        priorities[i] -= 0.3\n                    else:\n                        priorities[i] += 0.6\n                else:\n                    if priorities[i] < j:\n                        priorities[i] -= 0.2\n                    else:\n                        priorities[i] += 0.4\n            else:\n                priorities[i] -= 0.1\n\n    if item > 20:\n        for i in range(len(bins)):\n            if i % 4 == 0:\n                priorities[i] -= 0.4\n            elif i % 4 == 1:\n                priorities[i] += 0.7\n            elif i % 4 == 2:\n                priorities[i] -= 0.8\n            else:\n                priorities[i] += 1.1\n\n    for i in range(len(bins)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:37:51", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:37:56", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n                    \n            if item < 30 and i % 5 == 0:\n                priorities[i] -= 0.5\n            elif item >= 30 and i % 5 == 0:\n                priorities[i] += 0.5\n            else:\n                priorities[i] -= 0.25\n                \n            for j in range(1, 4):\n                if item % j == 0:\n                    priorities[i] += 0.5 * j\n                \n            if item > 25:\n                priorities[i] *= 1.25\n                \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:38:00", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        remaining_capacity = bins[i] - item\n        if remaining_capacity < 0:\n            priorities[i] = -1.0\n        else:\n            priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            priorities[i] *= 1.1 if i % 3 == 0 else 1.0\n            priorities[i] += 0.25 if item % 2 == 0 else 0.0\n            priorities[i] += 1.0 if item > 10 and remaining_capacity < 10 else 0.0\n            priorities[i] *= 2.0 if item % 3 == 0 else 1.0\n            priorities[i] += priorities[i - 1] / 3 if i > 0 else 0.0\n            priorities[i] += 2.0 if item > 20 and bins[i] >= item * 2 else 0.0\n            priorities[i] -= 0.5 if i % 2 != 0 else 0.0\n            priorities[i] += 1.5 if item % 5 == 0 else 0.0\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n            if item % 2 == 0:\n                priorities[i] -= 0.5\n            if item > 25:\n                priorities[i] += 3.0\n            if item < 5:\n                priorities[i] -= 0.5\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:38:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            if priority_score > 1.5:\n                priority_score = 1.5\n            elif priority_score < 0.1:\n                priority_score = 0.1\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            if priority_score > 1.5:\n                priority_score = 1.5\n            elif priority_score < 0.1:\n                priority_score = 0.1\n                \n            if bins[i] % 2 == 0:\n                priority_score *= 1.1\n            else:\n                priority_score *= 0.9\n                \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:38:32", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            if priority_score > 1.5:\n                priority_score = 1.5\n            elif priority_score < 0.1:\n                priority_score = 0.1\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1.2 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.9 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.3 / (1 + utilization_ratio)\n                \n            priority_score *= 1.1 + (1 - utilization_ratio)\n            \n            if remaining_space >= 5:\n                priority_score *= 1.3\n            elif remaining_space >= 3:\n                priority_score *= 1.2\n            \n            if bins[i] >= 15:\n                priority_score *= 1.5\n            elif bins[i] >= 10:\n                priority_score *= 1.4\n            elif bins[i] >= 5:\n                priority_score *= 1.3\n                \n            if item < 5:\n                priority_score += 0.3\n            elif item >= 5 and item < 10:\n                priority_score += 0.2\n            elif item >= 10 and item < 15:\n                priority_score += 0.1\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.15\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.1\n                \n            if priority_score > 1.6:\n                priority_score = 1.6\n            elif priority_score < 0.05:\n                priority_score = 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:38:37", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            if priority_score > 1.5:\n                priority_score = 1.5\n            elif priority_score < 0.1:\n                priority_score = 0.1\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            if priority_score > 1.5:\n                priority_score = 1.5\n            elif priority_score < 0.1:\n                priority_score = 0.1\n                \n            if item % 2 == 0:\n                priority_score += 0.05\n            elif item % 3 == 0:\n                priority_score -= 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:38:42", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            if priority_score > 1.5:\n                priority_score = 1.5\n            elif priority_score < 0.1:\n                priority_score = 0.1\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            if priority_score > 1.5:\n                priority_score = 1.5\n            elif priority_score < 0.1:\n                priority_score = 0.1\n                \n            # Custom conditions based on item and bin sizes\n            if bins[i] % 2 == 0:\n                priority_score *= 1.1\n            if item % 3 == 0:\n                priority_score += 0.2\n                \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:38:56", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:39:02", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:39:08", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n                \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:39:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:39:33", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"More complex and improved version of the priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.4:\n                    priorities[i] = 0.9\n                elif priority >= 0.4 and priority < 0.7:\n                    priorities[i] = 0.7\n                elif priority >= 0.7 and priority < 1.0:\n                    priorities[i] = 0.5\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[i] = 0.2\n                    else:\n                        priorities[i] = 0.3\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[i] = 0.1\n                else:\n                    priorities[i] = 0.0\n                    \n                if priorities[i] == 0.0:\n                    for j in range(i+1, len(bins)):\n                        if bins[j] >= item:\n                            priorities[j] = 0.6\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Ultimate version of priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                priorities[index] = priority if priority > 0 else 0\n            else:\n                priorities[index] = 0.1 * (item - bin_capacity)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.2:\n                    priorities[i] = 0.9\n                elif priority >= 0.2 and priority < 0.5:\n                    priorities[i] = 0.7\n                elif priority >= 0.5 and priority < 0.8:\n                    priorities[i] = 0.5\n                else:\n                    if item > bin_capacity * 1.5:\n                        priorities[i] = 0.2\n                    else:\n                        priorities[i] = 0.3\n            else:\n                if item >= bin_capacity * 1.5:\n                    priorities[i] = 0.1\n                else:\n                    priorities[i] = 0.0\n                \n                if priorities[i] == 0.0:\n                    for j in range(i+1, len(bins)):\n                        if bins[j] >= item:\n                            priorities[j] = 0.6\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:39:36", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"More complex and improved version of the priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.4:\n                    priorities[i] = 0.9\n                elif priority >= 0.4 and priority < 0.7:\n                    priorities[i] = 0.7\n                elif priority >= 0.7 and priority < 1.0:\n                    priorities[i] = 0.5\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[i] = 0.2\n                    else:\n                        priorities[i] = 0.3\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[i] = 0.1\n                else:\n                    priorities[i] = 0.0\n                    \n                if priorities[i] == 0.0:\n                    for j in range(i+1, len(bins)):\n                        if bins[j] >= item:\n                            priorities[j] = 0.6\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Ultimate version of priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                priorities[index] = priority if priority > 0 else 0\n            else:\n                priorities[index] = 0.1 * (item - bin_capacity)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"An even more complex and enhanced version of the priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.4:\n                    priorities[i] = 0.9\n                elif priority >= 0.4 and priority < 0.7:\n                    priorities[i] = 0.7\n                elif priority >= 0.7 and priority < 1.0:\n                    priorities[i] = 0.5\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[i] = 0.2\n                    else:\n                        priorities[i] = 0.3\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[i] = 0.1\n                else:\n                    priorities[i] = 0.0\n                    \n                if priorities[i] == 0.0:\n                    for j in range(i+1, len(bins)):\n                        if bins[j] >= item:\n                            priorities[j] = 0.6\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:39:39", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"More complex and improved version of the priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.4:\n                    priorities[i] = 0.9\n                elif priority >= 0.4 and priority < 0.7:\n                    priorities[i] = 0.7\n                elif priority >= 0.7 and priority < 1.0:\n                    priorities[i] = 0.5\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[i] = 0.2\n                    else:\n                        priorities[i] = 0.3\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[i] = 0.1\n                else:\n                    priorities[i] = 0.0\n                    \n                if priorities[i] == 0.0:\n                    for j in range(i+1, len(bins)):\n                        if bins[j] >= item:\n                            priorities[j] = 0.6\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Ultimate version of priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                priorities[index] = priority if priority > 0 else 0\n            else:\n                priorities[index] = 0.1 * (item - bin_capacity)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priorities[index] = 0.9 if remaining_capacity >= 2 * item else 0.7\n            else:\n                priorities[index] = 0.5 if bin_capacity / item >= 0.5 else 0.3\n                \n                if priorities[index] == 0.5:\n                    for j in range(index+1, len(bins)):\n                        if bins[j] >= item:\n                            priorities[j] = 0.6\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:39:42", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"More complex and improved version of the priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.4:\n                    priorities[i] = 0.9\n                elif priority >= 0.4 and priority < 0.7:\n                    priorities[i] = 0.7\n                elif priority >= 0.7 and priority < 1.0:\n                    priorities[i] = 0.5\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[i] = 0.2\n                    else:\n                        priorities[i] = 0.3\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[i] = 0.1\n                else:\n                    priorities[i] = 0.0\n                    \n                if priorities[i] == 0.0:\n                    for j in range(i+1, len(bins)):\n                        if bins[j] >= item:\n                            priorities[j] = 0.6\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Ultimate version of priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                priorities[index] = priority if priority > 0 else 0\n            else:\n                priorities[index] = 0.1 * (item - bin_capacity)\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.4:\n                    priorities[i] = 0.9\n                elif priority >= 0.4 and priority < 0.7:\n                    priorities[i] = 0.7\n                elif priority >= 0.7 and priority < 1.0:\n                    priorities[i] = 0.5\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[i] = 0.2\n                    else:\n                        priorities[i] = 0.3\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[i] = 0.1\n                else:\n                    priorities[i] = 0.0\n                    \n                if priorities[i] == 0.0:\n                    for j in range(i+1, len(bins)):\n                        if bins[j] >= item:\n                            priorities[j] = 0.6\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:39:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:40:00", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:40:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:40:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:40:32", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count > 2:\n                priorities[i] = count + item / bins[i] + 0.5\n            elif count == 1:\n                priorities[i] = count + item / bins[i] + 0.4\n            else:\n                priorities[i] = count + item / bins[i] + 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            if count > 5:\n                priorities[i] = 0.9 * count + item / bins[i] + 0.4\n            elif count == 3:\n                priorities[i] = 0.6 * count + item / bins[i] + 0.2\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:40:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count > 2:\n                priorities[i] = count + item / bins[i] + 0.5\n            elif count == 1:\n                priorities[i] = count + item / bins[i] + 0.4\n            else:\n                priorities[i] = count + item / bins[i] + 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            if count > 3:\n                priorities[i] += 0.4\n            elif item > 0.3 * bins[i]:\n                priorities[i] -= 0.1\n            if item < 0.1:\n                priorities[i] += 0.2\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:40:38", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count > 2:\n                priorities[i] = count + item / bins[i] + 0.5\n            elif count == 1:\n                priorities[i] = count + item / bins[i] + 0.4\n            else:\n                priorities[i] = count + item / bins[i] + 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                if item > bins[i] / 3:\n                    priorities[i] = 0.7 * count + item / bins[i] + 0.4\n                else:\n                    priorities[i] = 0.7 * count + item / bins[i] + 0.3\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:40:41", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count > 2:\n                priorities[i] = count + item / bins[i] + 0.5\n            elif count == 1:\n                priorities[i] = count + item / bins[i] + 0.4\n            else:\n                priorities[i] = count + item / bins[i] + 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more advanced version of priority calculation.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.4\n            else:\n                priorities[i] = 0.6 * count + item / bins[i] + 0.5\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:40:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n                \n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.05:\n                priorities[i] = 0.1\n            elif priority_diff >= 0.05 and priority_diff < 0.2:\n                priorities[i] = 0.3\n            elif priority_diff >= 0.2 and priority_diff < 0.4:\n                priorities[i] = 0.5\n            elif priority_diff >= 0.4 and priority_diff < 0.6:\n                priorities[i] = 0.7\n            elif priority_diff >= 0.6 and priority_diff < 0.8:\n                priorities[i] = 0.9\n            else:\n                priorities[i] = 0.95\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v2`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.05:\n                priorities[i] = 0.1\n            elif priority_diff >= 0.05 and priority_diff < 0.2:\n                priorities[i] = 0.3\n            elif priority_diff >= 0.2 and priority_diff < 0.4:\n                priorities[i] = 0.5\n            elif priority_diff >= 0.4 and priority_diff < 0.6:\n                priorities[i] = 0.7\n            elif priority_diff >= 0.6 and priority_diff < 0.8:\n                priorities[i] = 0.9\n            else:\n                priorities[i] = 0.95\n    \n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:40:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n                \n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.05:\n                priorities[i] = 0.1\n            elif priority_diff >= 0.05 and priority_diff < 0.2:\n                priorities[i] = 0.3\n            elif priority_diff >= 0.2 and priority_diff < 0.4:\n                priorities[i] = 0.5\n            elif priority_diff >= 0.4 and priority_diff < 0.6:\n                priorities[i] = 0.7\n            elif priority_diff >= 0.6 and priority_diff < 0.8:\n                priorities[i] = 0.9\n            else:\n                priorities[i] = 0.95\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.05:\n                priorities[i] = 0.1\n            elif priority_diff >= 0.05 and priority_diff < 0.2:\n                priorities[i] = 0.3\n            elif priority_diff >= 0.2 and priority_diff < 0.4:\n                priorities[i] = 0.5\n            elif priority_diff >= 0.4 and priority_diff < 0.6:\n                priorities[i] = 0.7\n            elif priority_diff >= 0.6 and priority_diff < 0.8:\n                priorities[i] = 0.9\n            else:\n                priorities[i] = 0.95\n            \n            if bins[i] % 2 == 0:\n                priorities[i] *= 1.1\n            else:\n                priorities[i] *= 0.9\n                \n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:40:58", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n                \n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.05:\n                priorities[i] = 0.1\n            elif priority_diff >= 0.05 and priority_diff < 0.2:\n                priorities[i] = 0.3\n            elif priority_diff >= 0.2 and priority_diff < 0.4:\n                priorities[i] = 0.5\n            elif priority_diff >= 0.4 and priority_diff < 0.6:\n                priorities[i] = 0.7\n            elif priority_diff >= 0.6 and priority_diff < 0.8:\n                priorities[i] = 0.9\n            else:\n                priorities[i] = 0.95\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.05:\n                priorities[i] = 0.1\n            elif priority_diff >= 0.05 and priority_diff < 0.2:\n                priorities[i] = 0.3\n            elif priority_diff >= 0.2 and priority_diff < 0.4:\n                priorities[i] = 0.5\n            elif priority_diff >= 0.4 and priority_diff < 0.6:\n                priorities[i] = 0.7\n            elif priority_diff >= 0.6 and priority_diff < 0.8:\n                priorities[i] = 0.9\n            else:\n                priorities[i] = 0.95\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        elif priorities[j] == min_priority:\n            priorities[j] = 0.0\n        else:\n            priorities[j] = (priorities[j] - min_priority) / (max_priority - min_priority)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:41:01", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n                \n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.05:\n                priorities[i] = 0.1\n            elif priority_diff >= 0.05 and priority_diff < 0.2:\n                priorities[i] = 0.3\n            elif priority_diff >= 0.2 and priority_diff < 0.4:\n                priorities[i] = 0.5\n            elif priority_diff >= 0.4 and priority_diff < 0.6:\n                priorities[i] = 0.7\n            elif priority_diff >= 0.6 and priority_diff < 0.8:\n                priorities[i] = 0.9\n            else:\n                priorities[i] = 0.95\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.1\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.3\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.5\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.7\n            elif priority_diff >= 0.7 and priority_diff < 0.9:\n                priorities[i] = 0.9\n            else:\n                priorities[i] = 0.95\n                \n            # Additional complexity\n            if bins[i] % 2 == 0:\n                priorities[i] *= 1.1\n            if bins[i] % 3 == 0:\n                priorities[i] *= 1.2\n            if bins[i] % 5 == 0:\n                priorities[i] *= 1.3\n                \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:41:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.1:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.1 and ratios[i] < 0.3:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.3 and ratios[i] < 0.5:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.5 and ratios[i] < 0.7:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 15:\n            priorities[j] *= 2\n        elif priorities[j] >= 15 and priorities[j] < 25:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 3 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 3\n        \n        if item > 5:\n            priorities[k] /= 2\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:2]:\n            final_priorities[m] = priorities[m] * 1.5\n        else:\n            final_priorities[m] = priorities[m] * 0.7\n    \n    return final_priorities", "strategy": []}
{"timestamp": "2025-04-27 07:41:19", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.1:\n            priorities[i] = np.sin(item) * np.cos(bins[i])\n        elif ratios[i] >= 0.1 and ratios[i] < 0.3:\n            priorities[i] = np.sin(item) + np.exp(bins[i])\n        elif ratios[i] >= 0.3 and ratios[i] < 0.5:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1) * np.sqrt(item)\n        elif ratios[i] >= 0.5 and ratios[i] < 0.7:\n            priorities[i] = np.power(item, 2) - np.tan(bins[i])\n        elif ratios[i] >= 0.7 and ratios[i] < 0.9:\n            priorities[i] = np.cosh(item) * np.tanh(bins[i])\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 5:\n            priorities[j] *= 2\n        elif priorities[j] >= 5 and priorities[j] < 10:\n            priorities[j] *= 3\n        elif priorities[j] >= 10 and priorities[j] < 15:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 15:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:4]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:41:23", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:41:29", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n\n    return final_priorities", "strategy": []}
{"timestamp": "2025-04-27 07:41:59", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n    priorities = np.clip(priorities, 0, 1)  # Clip values to be within 0 and 1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:42:02", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n        if i % 2 == 0:\n            priorities[i] *= 1.5\n        else:\n            priorities[i] += 0.5\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:42:07", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n        if ratio < 0.3:\n            priorities[i] *= 1.2\n        elif ratio >= 0.3 and ratio < 0.6:\n            priorities[i] *= 1.5\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] *= 1.7\n        else:\n            priorities[i] *= 2\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:42:10", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = np.log(1 + ratio) + 0.1\n        elif ratio >= 0.2 and ratio < 0.6:\n            priorities[i] = np.log(1 + ratio) + 0.3\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = np.log(1 + ratio) + 0.5\n        else:\n            priorities[i] = np.log(1 + ratio) + 0.7\n\n        for j in range(1, 11):\n            if i % j == 0:\n                priorities[i] += 0.1 * j\n            elif i % (j + 2) == 0:\n                priorities[i] -= 0.05 * j\n            elif i % (j + 3) == 0:\n                priorities[i] += 0.07 * j\n            else:\n                priorities[i] += 0.03 * j\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:42:26", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more advanced version of priority calculation.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.4\n            else:\n                priorities[i] = 0.6 * count + item / bins[i] + 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more advanced version of priority calculation.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.4\n            else:\n                priorities[i] = 0.6 * count + item / bins[i] + 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "import numpy as np\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more advanced version of priority calculation.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.4\n            elif count % 3 == 2:\n                priorities[i] = 0.6 * count + item / bins[i] + 0.5\n            else:\n                priorities[i] = 0.5 * count + item / bins[i] + 0.6\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:42:29", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more advanced version of priority calculation.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.4\n            else:\n                priorities[i] = 0.6 * count + item / bins[i] + 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more advanced version of priority calculation.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.4\n            else:\n                priorities[i] = 0.6 * count + item / bins[i] + 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v3(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.4\n            elif count % 3 == 2:\n                priorities[i] = 0.9 * count + item / bins[i] + 0.6\n            else:\n                priorities[i] = 0.6 * count + item / bins[i] + 0.5\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:42:32", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more advanced version of priority calculation.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.4\n            else:\n                priorities[i] = 0.6 * count + item / bins[i] + 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more advanced version of priority calculation.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.4\n            else:\n                priorities[i] = 0.6 * count + item / bins[i] + 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more advanced version of priority calculation.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.4\n            else:\n                priorities[i] = 0.6 * count + item / bins[i] + 0.5\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:42:36", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Even more advanced version of priority calculation.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.4\n            else:\n                priorities[i] = 0.6 * count + item / bins[i] + 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more advanced version of priority calculation.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.4\n            else:\n                priorities[i] = 0.6 * count + item / bins[i] + 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 3 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            elif count % 3 == 1:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.4\n            else:\n                priorities[i] = 0.6 * count + item / bins[i] + 0.5\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:42:45", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5 and item < 3 * bins[i]:\n            priorities[i] = 1.5\n        elif item >= 3 * bins[i] and item < 4 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 3.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.1\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i] + 0.05\n            \n    sorted_priorities = sorted(priorities, reverse=True)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == sorted_priorities[0]:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == sorted_priorities[-1]:\n            priorities[i] = priorities[i] - 0.2\n        else:\n            priorities[i] = priorities[i] + 0.1\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.1\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i] + 0.05\n    \n    for i in range(len(priorities)):\n        if item > 2 * bins[i]:\n            priorities[i] += 0.2\n        elif item > bins[i]:\n            priorities[i] += 0.1\n          \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:42:48", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5 and item < 3 * bins[i]:\n            priorities[i] = 1.5\n        elif item >= 3 * bins[i] and item < 4 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 3.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.1\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i] + 0.05\n            \n    sorted_priorities = sorted(priorities, reverse=True)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == sorted_priorities[0]:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == sorted_priorities[-1]:\n            priorities[i] = priorities[i] - 0.2\n        else:\n            priorities[i] = priorities[i] + 0.1\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.1\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i] + 0.05\n            \n    sorted_priorities = sorted(priorities, reverse=True)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == sorted_priorities[0]:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == sorted_priorities[-1]:\n            priorities[i] = priorities[i] - 0.2\n        else:\n            priorities[i] = priorities[i] + 0.1\n            \n    modified_priorities = np.clip(priorities, 0.0, 1.0)\n    \n    return modified_priorities", "strategy": []}
{"timestamp": "2025-04-27 07:42:51", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5 and item < 3 * bins[i]:\n            priorities[i] = 1.5\n        elif item >= 3 * bins[i] and item < 4 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 3.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.1\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i] + 0.05\n            \n    sorted_priorities = sorted(priorities, reverse=True)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == sorted_priorities[0]:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == sorted_priorities[-1]:\n            priorities[i] = priorities[i] - 0.2\n        else:\n            priorities[i] = priorities[i] + 0.1\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i] + 0.1\n            \n    sorted_bins_idx = np.argsort(bins)\n    \n    for i in range(len(sorted_bins_idx)):\n        if item < bins[sorted_bins_idx[i]]:\n            priorities[sorted_bins_idx[i]] = priorities[sorted_bins_idx[i]] + 0.1\n        elif item >= 2 * bins[sorted_bins_idx[i]]:\n            priorities[sorted_bins_idx[i]] = priorities[sorted_bins_idx[i]] * 1.5\n        else:\n            priorities[sorted_bins_idx[i]] = priorities[sorted_bins_idx[i]] + 0.05\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:42:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5 and item < 3 * bins[i]:\n            priorities[i] = 1.5\n        elif item >= 3 * bins[i] and item < 4 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 3.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.1\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i] + 0.05\n            \n    sorted_priorities = sorted(priorities, reverse=True)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == sorted_priorities[0]:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == sorted_priorities[-1]:\n            priorities[i] = priorities[i] - 0.2\n        else:\n            priorities[i] = priorities[i] + 0.1\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.1\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i] + 0.05\n            \n    sorted_priorities = sorted(priorities, reverse=True)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == sorted_priorities[0]:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == sorted_priorities[-1]:\n            priorities[i] = priorities[i] - 0.2\n        else:\n            priorities[i] = priorities[i] + 0.1\n    \n    for i in range(len(priorities)):\n        if i % 2 == 0:\n            priorities[i] *= 1.2\n        else:\n            priorities[i] *= 0.8\n    \n    return priorities\n", "strategy": []}
{"timestamp": "2025-04-27 07:43:20", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n                    \n            if i % 5 == 0:\n                priorities[i] += 1.0\n            elif i % 5 == 1:\n                priorities[i] -= 0.5\n            elif i % 5 == 2:\n                priorities[i] += 0.75\n            elif i % 5 == 3:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:43:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:43:33", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:43:38", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i-1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n    for _ in range(4):\n        for i in range(len(priorities)):\n            if priorities[i] < 1.0:\n                priorities[i] *= 1.25\n            elif priorities[i] < 2.0:\n                priorities[i] -= 0.75\n            else:\n                priorities[i] += 0.5\n\n    for j in range(6):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.75\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n            elif i % 3 == 1:\n                priorities[i] += 0.75\n            else:\n                priorities[i] -= 1.0\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:43:58", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n        if i % 2 == 0:\n            priorities[i] *= 1.5\n        else:\n            priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n        if i % 2 == 0:\n            priorities[i] *= 1.5\n        else:\n            priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n            else:\n                priorities[i] += 0.5\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:44:02", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n        if i % 2 == 0:\n            priorities[i] *= 1.5\n        else:\n            priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n        if i % 2 == 0:\n            priorities[i] *= 1.5\n        else:\n            priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n        if i % 2 == 0:\n            priorities[i] *= 1.5\n        else:\n            priorities[i] += 0.5\n\n        if ratio > 0.9:\n            priorities[i] = np.exp(ratio) - np.log(ratio) + 0.8\n        elif ratio < 0.3:\n            priorities[i] = np.tan(ratio) * 0.4\n        else:\n            priorities[i] = np.cosh(ratio) * 0.2\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:44:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n        if i % 2 == 0:\n            priorities[i] *= 1.5\n        else:\n            priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n        if i % 2 == 0:\n            priorities[i] *= 1.5\n        else:\n            priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-40 * (ratio - 0.2))) + 0.2\n        elif ratio >= 0.2 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-20 * (ratio - 0.4))) + 0.4\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.7))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 1))) + 0.6\n\n        if i % 6 == 0:\n            priorities[i] += 0.4\n        else:\n            for j in range(8):\n                if i % (j + 3) == 0:\n                    priorities[i] -= 0.06 * j\n                elif i % (j + 4) == 0:\n                    priorities[i] += 0.08 * j\n                else:\n                    priorities[i] += 0.04 * j\n\n        if i % 3 == 0:\n            priorities[i] *= 1.6\n        else:\n            priorities[i] += 0.7\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:44:10", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n        if i % 2 == 0:\n            priorities[i] *= 1.5\n        else:\n            priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n        if i % 2 == 0:\n            priorities[i] *= 1.5\n        else:\n            priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-40 * (ratio - 0.2))) + 0.2\n        elif ratio >= 0.2 and ratio < 0.4:\n            priorities[i] = 1 / (1 + np.exp(-20 * (ratio - 0.35))) + 0.35\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.5))) + 0.4\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.7))) + 0.6\n        else:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 1))) + 0.8\n\n        if i % 4 == 0:\n            priorities[i] += 0.4\n        else:\n            for j in range(5):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.07 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.1 * j\n                else:\n                    priorities[i] += 0.05 * j\n\n        if i % 3 == 0:\n            priorities[i] *= 2.0\n        else:\n            priorities[i] += 0.7\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:44:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 2.0\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.2\n        else:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.4:\n            priorities[i] = 0.4\n        elif priorities[i] > 2.0:\n            priorities[i] = 2.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.2\n        elif priorities[i] >= 0.5:\n            priorities[i] = priorities[i] + 0.1\n        else:\n            priorities[i] = priorities[i] - 0.1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if priorities[i] < 0.5:\n            priorities[i] += 0.1\n        elif priorities[i] >= 0.5 and priorities[i] < 0.8:\n            priorities[i] += 0.2\n        else:\n            priorities[i] += 0.3\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 2.0\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.2\n        else:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.4:\n            priorities[i] = 0.4\n        elif priorities[i] > 2.0:\n            priorities[i] = 2.0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:44:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 2.0\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.2\n        else:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.4:\n            priorities[i] = 0.4\n        elif priorities[i] > 2.0:\n            priorities[i] = 2.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.2\n        elif priorities[i] >= 0.5:\n            priorities[i] = priorities[i] + 0.1\n        else:\n            priorities[i] = priorities[i] - 0.1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.2\n        elif priorities[i] >= 0.5:\n            priorities[i] = priorities[i] + 0.1\n        else:\n            priorities[i] = priorities[i] - 0.1\n        \n    for i in range(len(priorities)):\n        if i % 2 == 0:\n            priorities[i] = priorities[i] * 1.1\n        else:\n            priorities[i] = priorities[i] * 0.9\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:44:33", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 2.0\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.2\n        else:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.4:\n            priorities[i] = 0.4\n        elif priorities[i] > 2.0:\n            priorities[i] = 2.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.2\n        elif priorities[i] >= 0.5:\n            priorities[i] = priorities[i] + 0.1\n        else:\n            priorities[i] = priorities[i] - 0.1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i] / 2:\n            priorities[i] = item / bins[i]\n        elif item < bins[i]:\n            priorities[i] = 0.8\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 2.0\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.2\n        else:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.3:\n            priorities[i] = 0.3\n        elif priorities[i] > 2.5:\n            priorities[i] = 2.5\n            \n        if bins[i] % 2 == 0:\n            priorities[i] += 0.1\n        elif bins[i] % 3 == 0:\n            priorities[i] -= 0.1\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:44:36", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 2.0\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.2\n        else:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.4:\n            priorities[i] = 0.4\n        elif priorities[i] > 2.0:\n            priorities[i] = 2.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.2\n        elif priorities[i] >= 0.5:\n            priorities[i] = priorities[i] + 0.1\n        else:\n            priorities[i] = priorities[i] - 0.1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority_function(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.2\n        elif 0.5 <= priorities[i] < max_priority:\n            priorities[i] = priorities[i] + 0.1\n        elif min_priority < priorities[i] < 0.5:\n            priorities[i] = priorities[i] - 0.1\n        elif priorities[i] < min_priority:\n            priorities[i] = min_priority\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:44:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if bins[i] < 5:\n                priority_score += 0.1\n            elif bins[i] >= 5 and bins[i] < 10:\n                priority_score += 0.05\n            \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            if bins[i] % 2 == 0:\n                priority_score += 0.1\n            elif bins[i] % 3 == 0:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:44:57", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if bins[i] < 5:\n                priority_score += 0.1\n            elif bins[i] >= 5 and bins[i] < 10:\n                priority_score += 0.05\n            \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            if item % 2 == 0:\n                priority_score += 0.3\n            elif item % 3 == 0:\n                priority_score += 0.2\n                \n            if bins[i] % 2 == 0:\n                priority_score += 0.2\n            elif bins[i] % 3 == 0:\n                priority_score += 0.1\n            \n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:45:02", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if bins[i] < 5:\n                priority_score += 0.1\n            elif bins[i] >= 5 and bins[i] < 10:\n                priority_score += 0.05\n            \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            # Additional complex logic based on item and bin size\n            if item % 2 == 0:\n                priority_score += 0.1\n            if bins[i] % 2 == 0:\n                priority_score += 0.05\n            if item > 10 and bins[i] > 10:\n                priority_score *= 1.2\n\n            priorities[i] = priority_score\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:45:06", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if bins[i] < 5:\n                priority_score += 0.1\n            elif bins[i] >= 5 and bins[i] < 10:\n                priority_score += 0.05\n            \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            priorities[i] = priority_score\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        else:\n            remaining_space = bins[i] - item\n            utilization_ratio = remaining_space / bins[i]\n            \n            if utilization_ratio < 0.1:\n                priority_score = 1 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.1 and utilization_ratio < 0.3:\n                priority_score = 0.7 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.3 and utilization_ratio < 0.6:\n                priority_score = 0.5 / (1 + utilization_ratio)\n            elif utilization_ratio >= 0.6 and utilization_ratio < 0.8:\n                priority_score = 0.3 / (1 + utilization_ratio)\n            else:\n                priority_score = 0.1 / (1 + utilization_ratio)\n                \n            if remaining_space >= 5:\n                priority_score *= 1.2\n            elif remaining_space >= 3:\n                priority_score *= 1.1\n            \n            if bins[i] >= 15:\n                priority_score *= 1.4\n            elif bins[i] >= 10:\n                priority_score *= 1.3\n            elif bins[i] >= 5:\n                priority_score *= 1.2\n                \n            if item < 5:\n                priority_score += 0.2\n            elif item >= 5 and item < 10:\n                priority_score += 0.1\n            elif item >= 10 and item < 15:\n                priority_score += 0.05\n                \n            if remaining_space > 0.5*bins[i]:\n                priority_score += 0.1\n            elif remaining_space <= 0.5*bins[i] and remaining_space > 0.3*bins[i]:\n                priority_score += 0.05\n                \n            if item % 2 == 0:\n                priority_score += 0.1\n            elif item % 2 != 0:\n                priority_score += 0.05\n            \n            priorities[i] = priority_score\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:45:18", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.2\n            elif item + bins[i] > 100:\n                priorities[i] -= 0.1\n            else:\n                priorities[i] += 0.3\n                \n            if item + bins[i] < 50:\n                priorities[i] *= 1.2\n            elif item + bins[i] < 100:\n                priorities[i] *= 1.1\n            else:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.1\n            elif item % 3 == 0:\n                priorities[i] += 0.2\n            else:\n                priorities[i] -= 0.1\n                \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(bins)):\n        if priorities[j] == max_priority:\n            priorities[j] *= 1.2\n        elif priorities[j] == min_priority:\n            priorities[j] *= 0.8\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(bins)):\n        if priorities[j] == max_priority:\n            priorities[j] *= 1.1\n        elif priorities[j] == min_priority:\n            priorities[j] *= 0.9\n            \n        if item + bins[j] < 50:\n            priorities[j] *= 1.2\n        elif item + bins[j] < 100:\n            priorities[j] *= 1.1\n        else:\n            priorities[j] *= 1.5\n            \n        if item % 2 == 0:\n            priorities[j] += 0.1\n        elif item % 3 == 0:\n            priorities[j] += 0.2\n        else:\n            priorities[j] -= 0.1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:45:22", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.2\n            elif item + bins[i] > 100:\n                priorities[i] -= 0.1\n            else:\n                priorities[i] += 0.3\n                \n            if item + bins[i] < 50:\n                priorities[i] *= 1.2\n            elif item + bins[i] < 100:\n                priorities[i] *= 1.1\n            else:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.1\n            elif item % 3 == 0:\n                priorities[i] += 0.2\n            else:\n                priorities[i] -= 0.1\n                \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(bins)):\n        if priorities[j] == max_priority:\n            priorities[j] *= 1.2\n        elif priorities[j] == min_priority:\n            priorities[j] *= 0.8\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(bins)):\n        if priorities[j] == max_priority:\n            priorities[j] *= 1.2\n        elif priorities[j] == min_priority:\n            priorities[j] *= 0.8\n            \n    prime_numbers = [2, 3, 5, 7, 11, 13]\n    for k in range(len(bins)):\n        if item % prime_numbers[k] == 0:\n            priorities[k] += 0.3\n        elif item % (prime_numbers[k] * 2) == 0:\n            priorities[k] += 0.2\n        else:\n            priorities[k] -= 0.1\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:45:25", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.2\n            elif item + bins[i] > 100:\n                priorities[i] -= 0.1\n            else:\n                priorities[i] += 0.3\n                \n            if item + bins[i] < 50:\n                priorities[i] *= 1.2\n            elif item + bins[i] < 100:\n                priorities[i] *= 1.1\n            else:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.1\n            elif item % 3 == 0:\n                priorities[i] += 0.2\n            else:\n                priorities[i] -= 0.1\n                \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(bins)):\n        if priorities[j] == max_priority:\n            priorities[j] *= 1.2\n        elif priorities[j] == min_priority:\n            priorities[j] *= 0.8\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n    non_zero_count = np.count_nonzero(priorities)\n    sum_priorities = np.sum(priorities)\n    \n    for j in range(len(bins)):\n        if priorities[j] != 0:\n            priorities[j] += non_zero_count / sum_priorities\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:45:29", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.5 * bins[i]:\n                priorities[i] *= 1.3\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.1\n            \n            if item % bins[i] == 0:\n                priorities[i] += 0.2\n            elif item + bins[i] > 100:\n                priorities[i] -= 0.1\n            else:\n                priorities[i] += 0.3\n                \n            if item + bins[i] < 50:\n                priorities[i] *= 1.2\n            elif item + bins[i] < 100:\n                priorities[i] *= 1.1\n            else:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.1\n            elif item % 3 == 0:\n                priorities[i] += 0.2\n            else:\n                priorities[i] -= 0.1\n                \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(bins)):\n        if priorities[j] == max_priority:\n            priorities[j] *= 1.2\n        elif priorities[j] == min_priority:\n            priorities[j] *= 0.8\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(bins)):\n        if priorities[j] == max_priority:\n            priorities[j] *= 1.2\n        elif priorities[j] == min_priority:\n            priorities[j] *= 0.8\n    \n    for k in range(len(bins)):\n        if priorities[k] < 1.0:\n            priorities[k] = priorities[k] ** 2\n        else:\n            priorities[k] = priorities[k] ** 0.5\n            \n    sum_priorities = np.sum(priorities)\n    \n    for m in range(len(bins)):\n        priorities[m] = priorities[m] / sum_priorities\n        \n        if bins[m] % 2 == 0:\n            priorities[m] += 0.1\n        elif bins[m] % 3 == 0:\n            priorities[m] += 0.2\n        else:\n            priorities[m] -= 0.1\n            \n        if bins[m] + item > 100:\n            priorities[m] -= 0.3\n        elif bins[m] + item < 50:\n            priorities[m] += 0.3\n        \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:45:40", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            remaining_space = bins[i] - item\n            if remaining_space <= 0.1 * bins[i]:\n                priorities[i] = 0.2\n            elif remaining_space > 0.1 * bins[i] and remaining_space <= 0.3 * bins[i]:\n                priorities[i] = 0.4\n            elif remaining_space > 0.3 * bins[i] and remaining_space <= 0.5 * bins[i]:\n                priorities[i] = 0.6\n            elif remaining_space > 0.5 * bins[i] and remaining_space <= 0.7 * bins[i]:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n                \n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            if bins[i] < 0.5 * item:\n                priorities[i] = 0.2\n            elif bins[i] >= 0.5 * item and bins[i] < 0.7 * item:\n                priorities[i] = 0.4\n            elif bins[i] >= 0.7 * item and bins[i] < 0.9 * item:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n                \n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:45:44", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            remaining_space = bins[i] - item\n            if remaining_space <= 0.1 * bins[i]:\n                priorities[i] = 0.2\n            elif remaining_space > 0.1 * bins[i] and remaining_space <= 0.3 * bins[i]:\n                priorities[i] = 0.4\n            elif remaining_space > 0.3 * bins[i] and remaining_space <= 0.5 * bins[i]:\n                priorities[i] = 0.6\n            elif remaining_space > 0.5 * bins[i] and remaining_space <= 0.7 * bins[i]:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n                \n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            remaining_space = bins[i] - item\n            priority_diff = (item - bins[i]) / item\n            if remaining_space <= 0.1 * bins[i] or priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif remaining_space > 0.1 * bins[i] and remaining_space <= 0.3 * bins[i] or priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif remaining_space > 0.3 * bins[i] and remaining_space <= 0.5 * bins[i] or priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif remaining_space > 0.5 * bins[i] and remaining_space <= 0.7 * bins[i] or priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n                \n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:45:47", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            remaining_space = bins[i] - item\n            if remaining_space <= 0.1 * bins[i]:\n                priorities[i] = 0.2\n            elif remaining_space > 0.1 * bins[i] and remaining_space <= 0.3 * bins[i]:\n                priorities[i] = 0.4\n            elif remaining_space > 0.3 * bins[i] and remaining_space <= 0.5 * bins[i]:\n                priorities[i] = 0.6\n            elif remaining_space > 0.5 * bins[i] and remaining_space <= 0.7 * bins[i]:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n                \n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n                \n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:45:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            remaining_space = bins[i] - item\n            if remaining_space <= 0.1 * bins[i]:\n                priorities[i] = 0.2\n            elif remaining_space > 0.1 * bins[i] and remaining_space <= 0.3 * bins[i]:\n                priorities[i] = 0.4\n            elif remaining_space > 0.3 * bins[i] and remaining_space <= 0.5 * bins[i]:\n                priorities[i] = 0.6\n            elif remaining_space > 0.5 * bins[i] and remaining_space <= 0.7 * bins[i]:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n                \n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:46:01", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5:\n            priorities[i] = 1.5\n\n    priorities = np.where(bins < np.mean(bins), priorities * 1.2, priorities)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n\n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.2\n        else:\n            priorities[i] = priorities[i] + 0.1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    bin_mean = np.mean(bins)\n    bin_std = np.std(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if bins[i] < bin_mean - bin_std:\n            priorities[i] += 0.2\n        elif bins[i] > bin_mean + bin_std:\n            priorities[i] -= 0.2\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5:\n            priorities[i] = 1.5\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:46:04", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5:\n            priorities[i] = 1.5\n\n    priorities = np.where(bins < np.mean(bins), priorities * 1.2, priorities)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n\n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.2\n        else:\n            priorities[i] = priorities[i] + 0.1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n        \n        if priorities[i] < 0.5:\n            priorities[i] += 0.3\n        elif priorities[i] > 1.5:\n            priorities[i] -= 0.3\n        else:\n            priorities[i] += 0.1\n        \n        if bins[i] % 2 == 0:\n            priorities[i] *= 1.2\n        else:\n            priorities[i] *= 0.8\n        \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:46:08", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5:\n            priorities[i] = 1.5\n\n    priorities = np.where(bins < np.mean(bins), priorities * 1.2, priorities)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n\n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.2\n        else:\n            priorities[i] = priorities[i] + 0.1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n    average_bin_capacity = np.mean(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if bins[i] == max_bin_capacity:\n            priorities[i] = priorities[i] + 0.2\n        elif bins[i] == min_bin_capacity:\n            priorities[i] = priorities[i] - 0.2\n        else:\n            priorities[i] = priorities[i] + 0.1\n\n        if item > 1.5 * bins[i]:\n            priorities[i] *= 1.3\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > bins[i]:\n            priorities[i] *= 1.1\n\n    priorities = np.where(bins < average_bin_capacity, priorities * 1.2, priorities)\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:46:10", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5:\n            priorities[i] = 1.5\n\n    priorities = np.where(bins < np.mean(bins), priorities * 1.2, priorities)\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n\n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.2\n        else:\n            priorities[i] = priorities[i] + 0.1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if i % 2 == 0:\n            priorities[i] += 0.2\n        else:\n            priorities[i] -= 0.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5:\n            priorities[i] = 1.5\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:46:24", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.5\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.5\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.2\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.5\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.1:\n                priorities[i] = 0.1\n            elif ratio < 0.3:\n                priorities[i] = 0.3\n            elif ratio < 0.6:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.2\n            if item % 2 == 0:\n                priorities[i] += 0.1\n            if bins[i] % item == 0:\n                priorities[i] += 0.3\n            if item > 10:\n                priorities[i] += 0.4\n            if bins[i] % 5 == 0:\n                priorities[i] += 0.2\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:46:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.5\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.5\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.2\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.5\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n            \n            if bins[i] % 2 == 0:\n                priorities[i] += 0.2\n            else:\n                priorities[i] -= 0.1\n                \n            if item % 3 == 0:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.2\n                \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:46:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.5\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.5\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.2\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.5\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.1:\n                priorities[i] = 0.1\n            elif ratio < 0.3:\n                priorities[i] = 0.3\n            elif ratio < 0.6:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.2\n            for j in range(2, int(bins[i] / item) + 1):\n                if bins[i] % j == 0:\n                    priorities[i] += 0.1 / j\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:46:33", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.5\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.5\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.2\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif bins[i] < item:\n            priorities[i] = 0.5\n        else:\n            ratio = bins[i] / item\n            if ratio < 0.2:\n                priorities[i] = 0.1\n            elif ratio < 0.5:\n                priorities[i] = 0.3\n            elif ratio < 0.8:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.8\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.2\n            if item % 2 == 0:\n                priorities[i] += 0.1\n            if item > bins[i] * 0.6:\n                priorities[i] -= 0.4\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:46:44", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n        if i % 3 == 0:\n            priorities[i] *= 1.1\n        elif i % 4 == 0:\n            priorities[i] *= 0.8\n        elif i % 6 == 0:\n            priorities[i] *= 1.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\n\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-40 * (ratio - 0.2))) + 0.2\n        elif ratio >= 0.2 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-20 * (ratio - 0.4))) + 0.4\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.7))) + 0.5\n        elif ratio >= 0.8 and ratio < 0.95:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.9))) + 0.6\n        else:\n            priorities[i] = 1 / (1 + np.exp(-4 * (ratio - 1))) + 0.7\n\n        if i % 6 == 0:\n            priorities[i] += 0.4\n        else:\n            for j in range(6):\n                if i % (j + 3) == 0:\n                    priorities[i] -= 0.08 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n        if i % 4 == 0:\n            priorities[i] *= 1.2\n        elif i % 5 == 0:\n            priorities[i] *= 0.7\n        elif i % 7 == 0:\n            priorities[i] *= 1.4\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:46:48", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n        if i % 3 == 0:\n            priorities[i] *= 1.1\n        elif i % 4 == 0:\n            priorities[i] *= 0.8\n        elif i % 6 == 0:\n            priorities[i] *= 1.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n        if i % 3 == 0:\n            priorities[i] *= 1.1\n        elif i % 4 == 0:\n            priorities[i] *= 0.8\n        elif i % 6 == 0:\n            priorities[i] *= 1.5\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:46:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n        if i % 3 == 0:\n            priorities[i] *= 1.1\n        elif i % 4 == 0:\n            priorities[i] *= 0.8\n        elif i % 6 == 0:\n            priorities[i] *= 1.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_function(param1: int, param2: float, param3: str) -> str:\n    result = \"\"\n    \n    if param1 % 2 == 0:\n        for i in range(param1):\n            if i % 3 == 0 and i % 5 == 0:\n                result += param3 + \" \"\n            elif i % 3 == 0:\n                result += str(i) + \" \"\n            elif i % 5 == 0:\n                result += param3.upper() + \" \"\n            else:\n                result += str(i * param2) + \" \"\n    else:\n        for i in range(param1, 0, -1):\n            if i % 2 == 0:\n                result += param3.lower() + \" \"\n            elif i % 3 == 0:\n                result += str(i) + \" \"\n            else:\n                result += param3.upper() + \" \"\n    \n    return result\n```", "strategy": []}
{"timestamp": "2025-04-27 07:46:55", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n        if i % 3 == 0:\n            priorities[i] *= 1.1\n        elif i % 4 == 0:\n            priorities[i] *= 0.8\n        elif i % 6 == 0:\n            priorities[i] *= 1.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority_func(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n        if i % 3 == 0:\n            priorities[i] *= 1.1\n        elif i % 4 == 0:\n            priorities[i] *= 0.8\n        elif i % 6 == 0:\n            priorities[i] *= 1.5\n\n        priorities[i] = max(min(priorities[i], 1.0), 0.0)  # Ensure priority is within [0, 1]\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:47:11", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n\n    upper_threshold = np.percentile(final_priorities, 75)\n    lower_threshold = np.percentile(final_priorities, 25)\n\n    for n in range(len(bins)):\n        if final_priorities[n] > upper_threshold:\n            final_priorities[n] *= 1.1\n        elif final_priorities[n] < lower_threshold:\n            final_priorities[n] *= 0.9\n\n    normalized_priorities = (final_priorities - np.min(final_priorities)) / (np.max(final_priorities) - np.min(final_priorities))\n\n    return normalized_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.3:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.3 and ratios[i] < 0.6:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.6 and ratios[i] < 0.7:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.7 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 15:\n            priorities[j] *= 2\n        elif priorities[j] >= 15 and priorities[j] < 25:\n            priorities[j] *= 3\n        elif priorities[j] >= 25 and priorities[j] < 35:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 3 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 3\n\n        if item > 15:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.3\n        else:\n            final_priorities[m] = priorities[m] * 0.7\n\n    return final_priorities", "strategy": []}
{"timestamp": "2025-04-27 07:47:15", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n\n    upper_threshold = np.percentile(final_priorities, 75)\n    lower_threshold = np.percentile(final_priorities, 25)\n\n    for n in range(len(bins)):\n        if final_priorities[n] > upper_threshold:\n            final_priorities[n] *= 1.1\n        elif final_priorities[n] < lower_threshold:\n            final_priorities[n] *= 0.9\n\n    normalized_priorities = (final_priorities - np.min(final_priorities)) / (np.max(final_priorities) - np.min(final_priorities))\n\n    return normalized_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.3:\n            priorities[i] = np.cosh(np.exp(item)) + np.sinh(np.log(bins[i]))\n        elif ratios[i] >= 0.3 and ratios[i] < 0.6:\n            priorities[i] = np.tanh(item) + np.tanh(bins[i])\n        elif ratios[i] >= 0.6 and ratios[i] < 0.9:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 2)\n        else:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i])) * np.arcsin(np.cbrt(item))\n    \n    for j in range(len(bins)):\n        if priorities[j] < 15:\n            priorities[j] *= 1.5\n        elif priorities[j] >= 15 and priorities[j] < 25:\n            priorities[j] *= 2.5\n        elif priorities[j] >= 25 and priorities[j] < 35:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 3 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 3\n        \n        if item > 15:\n            priorities[k] *= 1.8\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:4]:\n            final_priorities[m] = priorities[m] * 1.3\n        else:\n            final_priorities[m] = priorities[m] * 0.7\n    \n    return final_priorities", "strategy": []}
{"timestamp": "2025-04-27 07:47:21", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n\n    upper_threshold = np.percentile(final_priorities, 75)\n    lower_threshold = np.percentile(final_priorities, 25)\n\n    for n in range(len(bins)):\n        if final_priorities[n] > upper_threshold:\n            final_priorities[n] *= 1.1\n        elif final_priorities[n] < lower_threshold:\n            final_priorities[n] *= 0.9\n\n    normalized_priorities = (final_priorities - np.min(final_priorities)) / (np.max(final_priorities) - np.min(final_priorities))\n\n    return normalized_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    upper_threshold = np.percentile(final_priorities, 75)\n    lower_threshold = np.percentile(final_priorities, 25)\n    \n    for n in range(len(bins)):\n        if final_priorities[n] > upper_threshold:\n            final_priorities[n] *= 1.1\n        elif final_priorities[n] < lower_threshold:\n            final_priorities[n] *= 0.9\n            \n        if final_priorities[n] > 50:\n            final_priorities[n] = np.log(final_priorities[n])\n    \n    return final_priorities", "strategy": []}
{"timestamp": "2025-04-27 07:47:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n\n    upper_threshold = np.percentile(final_priorities, 75)\n    lower_threshold = np.percentile(final_priorities, 25)\n\n    for n in range(len(bins)):\n        if final_priorities[n] > upper_threshold:\n            final_priorities[n] *= 1.1\n        elif final_priorities[n] < lower_threshold:\n            final_priorities[n] *= 0.9\n\n    normalized_priorities = (final_priorities - np.min(final_priorities)) / (np.max(final_priorities) - np.min(final_priorities))\n\n    return normalized_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n\n    upper_threshold = np.percentile(final_priorities, 75)\n    lower_threshold = np.percentile(final_priorities, 25)\n\n    for n in range(len(bins)):\n        if final_priorities[n] > upper_threshold:\n            final_priorities[n] *= 1.1\n        elif final_priorities[n] < lower_threshold:\n            final_priorities[n] *= 0.9\n\n    updated_priorities = np.zeros_like(final_priorities)\n    for p in range(len(bins)):\n        if final_priorities[p] > 50:\n            updated_priorities[p] = np.sqrt(final_priorities[p])\n        else:\n            updated_priorities[p] = np.log(final_priorities[p] + 1)\n\n    return updated_priorities", "strategy": []}
{"timestamp": "2025-04-27 07:48:08", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n        # Additional complex logic\n        if item > 1.8 * bins[i]:\n            priorities[i] *= 1.3\n        elif item > 1.4 * bins[i]:\n            priorities[i] *= 1.1\n        elif item > 1.1 * bins[i]:\n            priorities[i] *= 1.05\n        \n        if priorities[i] < 0.7:\n            priorities[i] = 0.7\n        elif priorities[i] > 1.4 and item < 2.5 * bins[i]:\n                priorities[i] = 1.4\n        elif item >= 2.5 * bins[i] and item < 3.5 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 3.5 * bins[i]:\n            priorities[i] = 2.5\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n            \n        if item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n        \n        if item >= 4 * bins[i]:\n            priorities[i] = 3.0\n        elif item >= 3 * bins[i]:\n            priorities[i] = 2.0\n        elif priorities[i] < 1.5 and item >= 2 * bins[i]:\n            priorities[i] = 1.5\n        elif priorities[i] < 1.2 and item >= 1.5 * bins[i]:\n            priorities[i] = 1.2\n        elif priorities[i] < 1.0 and item >= bins[i]:\n            priorities[i] = 1.0\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Further improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n            \n        if item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n        \n        if item >= 4 * bins[i]:\n            priorities[i] = 3.0\n        elif item >= 3 * bins[i]:\n            priorities[i] = 2.0\n        elif priorities[i] < 1.5 and item >= 2 * bins[i]:\n            priorities[i] = 1.5\n        elif priorities[i] < 1.2 and item >= 1.5 * bins[i]:\n            priorities[i] = 1.2\n        elif priorities[i] < 1.0 and item >= bins[i]:\n            priorities[i] = 1.0\n        \n        # Additional complex logic\n        if item >= 5 * bins[i]:\n            priorities[i] += 0.5\n        elif item >= 4 * bins[i]:\n            priorities[i] += 0.4\n        elif item >= 3 * bins[i]:\n            priorities[i] += 0.3\n        elif item >= 2 * bins[i]:\n            priorities[i] += 0.2\n        elif item >= 1.5 * bins[i]:\n            priorities[i] += 0.1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:48:11", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n        # Additional complex logic\n        if item > 1.8 * bins[i]:\n            priorities[i] *= 1.3\n        elif item > 1.4 * bins[i]:\n            priorities[i] *= 1.1\n        elif item > 1.1 * bins[i]:\n            priorities[i] *= 1.05\n        \n        if priorities[i] < 0.7:\n            priorities[i] = 0.7\n        elif priorities[i] > 1.4 and item < 2.5 * bins[i]:\n                priorities[i] = 1.4\n        elif item >= 2.5 * bins[i] and item < 3.5 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 3.5 * bins[i]:\n            priorities[i] = 2.5\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n            \n        if item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n        \n        if item >= 4 * bins[i]:\n            priorities[i] = 3.0\n        elif item >= 3 * bins[i]:\n            priorities[i] = 2.0\n        elif priorities[i] < 1.5 and item >= 2 * bins[i]:\n            priorities[i] = 1.5\n        elif priorities[i] < 1.2 and item >= 1.5 * bins[i]:\n            priorities[i] = 1.2\n        elif priorities[i] < 1.0 and item >= bins[i]:\n            priorities[i] = 1.0\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < 0.5 * bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n            \n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.3\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.2\n        \n        if item >= 5 * bins[i]:\n            priorities[i] = 3.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 2.5\n        elif priorities[i] < 1.8 and item >= 3 * bins[i]:\n            priorities[i] = 1.8\n        elif priorities[i] < 1.5 and item >= 2.5 * bins[i]:\n            priorities[i] = 1.5\n        elif priorities[i] < 1.3 and item >= 2 * bins[i]:\n            priorities[i] = 1.3\n        elif priorities[i] < 1.0 and item >= bins[i]:\n            priorities[i] = 1.0\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:48:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n        # Additional complex logic\n        if item > 1.8 * bins[i]:\n            priorities[i] *= 1.3\n        elif item > 1.4 * bins[i]:\n            priorities[i] *= 1.1\n        elif item > 1.1 * bins[i]:\n            priorities[i] *= 1.05\n        \n        if priorities[i] < 0.7:\n            priorities[i] = 0.7\n        elif priorities[i] > 1.4 and item < 2.5 * bins[i]:\n                priorities[i] = 1.4\n        elif item >= 2.5 * bins[i] and item < 3.5 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 3.5 * bins[i]:\n            priorities[i] = 2.5\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n            \n        if item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n        \n        if item >= 4 * bins[i]:\n            priorities[i] = 3.0\n        elif item >= 3 * bins[i]:\n            priorities[i] = 2.0\n        elif priorities[i] < 1.5 and item >= 2 * bins[i]:\n            priorities[i] = 1.5\n        elif priorities[i] < 1.2 and item >= 1.5 * bins[i]:\n            priorities[i] = 1.2\n        elif priorities[i] < 1.0 and item >= bins[i]:\n            priorities[i] = 1.0\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < 0.5 * bins[i]:\n            priorities[i] = item / bins[i]\n        elif item >= 0.5 * bins[i] and item < 0.8 * bins[i]:\n            priorities[i] = 0.8\n        elif item >= 0.8 * bins[i] and item < 1.2 * bins[i]:\n            priorities[i] = 1.2\n        elif item >= 1.2 * bins[i] and item < 1.6 * bins[i]:\n            priorities[i] = 1.6\n        elif item >= 1.6 * bins[i] and item < 2 * bins[i]:\n            priorities[i] = 2.0\n        else:\n            priorities[i] = 2.5\n        \n        if priorities[i] > 1.5 and item < 2 * bins[i]:\n            priorities[i] = 1.5\n        elif priorities[i] > 1.8 and item < 2.5 * bins[i]:\n            priorities[i] = 1.8\n            \n        if item >= 3 * bins[i]:\n            priorities[i] *= 1.5\n        \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:48:18", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n        # Additional complex logic\n        if item > 1.8 * bins[i]:\n            priorities[i] *= 1.3\n        elif item > 1.4 * bins[i]:\n            priorities[i] *= 1.1\n        elif item > 1.1 * bins[i]:\n            priorities[i] *= 1.05\n        \n        if priorities[i] < 0.7:\n            priorities[i] = 0.7\n        elif priorities[i] > 1.4 and item < 2.5 * bins[i]:\n                priorities[i] = 1.4\n        elif item >= 2.5 * bins[i] and item < 3.5 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 3.5 * bins[i]:\n            priorities[i] = 2.5\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n            \n        if item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n        \n        if item >= 4 * bins[i]:\n            priorities[i] = 3.0\n        elif item >= 3 * bins[i]:\n            priorities[i] = 2.0\n        elif priorities[i] < 1.5 and item >= 2 * bins[i]:\n            priorities[i] = 1.5\n        elif priorities[i] < 1.2 and item >= 1.5 * bins[i]:\n            priorities[i] = 1.2\n        elif priorities[i] < 1.0 and item >= bins[i]:\n            priorities[i] = 1.0\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n            \n        if item >= 5 * bins[i]:\n            priorities[i] = 4.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 3.0\n        elif item >= 3 * bins[i]:\n            priorities[i] = 2.5\n        elif item >= 2.5 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 2 * bins[i]:\n            priorities[i] = 1.5\n        elif item >= 1.5 * bins[i]:\n            priorities[i] = 1.3\n        elif item >= 1.2 * bins[i]:\n            priorities[i] = 1.1\n        elif item >= bins[i]:\n            priorities[i] = 1.05\n        else:\n            priorities[i] = 0.7\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:48:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n\n    return final_priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:48:36", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n\n    return final_priorities", "strategy": []}
{"timestamp": "2025-04-27 07:48:41", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    max_priority = np.max(final_priorities)\n    min_priority = np.min(final_priorities)\n    avg_priority = np.mean(final_priorities)\n\n    for n in range(len(bins)):\n        if final_priorities[n] == max_priority:\n            final_priorities[n] += item * 0.5\n        elif final_priorities[n] == min_priority:\n            final_priorities[n] -= item * 0.2\n        else:\n            final_priorities[n] = avg_priority\n    \n    return final_priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:48:46", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 15:\n            priorities[j] *= 2\n        elif priorities[j] >= 15 and priorities[j] < 25:\n            priorities[j] *= 4\n        elif priorities[j] >= 25 and priorities[j] < 35:\n            priorities[j] /= 3\n        else:\n            priorities[j] = np.cbrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 3 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 3\n        \n        if item > 15:\n            priorities[k] *= 1.8\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:4]:\n            final_priorities[m] = priorities[m] * 1.3\n        else:\n            final_priorities[m] = priorities[m] * 0.7\n    \n    return final_priorities", "strategy": []}
{"timestamp": "2025-04-27 07:49:18", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n                \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if i % 5 == 0:\n            priorities[i] -= 0.5\n        elif i % 5 == 1:\n            priorities[i] += 0.75\n        elif i % 5 == 2:\n            priorities[i] += 1.0\n        elif i % 5 == 3:\n            priorities[i] -= 1.25\n        else:\n            priorities[i] += 1.5\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:49:24", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n                \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:49:30", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n                \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:49:37", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n                \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n            if i % 5 == 0:\n                priorities[i] -= 0.33\n            elif i % 5 == 1:\n                priorities[i] += 0.66\n            elif i % 5 == 2:\n                priorities[i] -= 0.99\n            elif i % 5 == 3:\n                priorities[i] += 1.32\n            else:\n                priorities[i] -= 1.65\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:49:59", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n\n    if item > max_bin_capacity * 0.75:\n        for j in range(len(bins)):\n            if bins[j] == max_bin_capacity:\n                priorities[j] *= 1.5\n    elif item < min_bin_capacity * 0.25:\n        for k in range(len(bins)):\n            if bins[k] == min_bin_capacity:\n                priorities[k] *= 0.5\n\n    for m in range(len(bins)):\n        if bins[m] % 2 == 0:\n            priorities[m] += 0.1\n        elif bins[m] % 3 == 0:\n            priorities[m] += 0.2\n        else:\n            priorities[m] += 0.05\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            if item < 0.5 * bins[i]:\n                priorities[i] = 0.3\n            elif item >= 0.5 * bins[i] and item < bins[i]:\n                priorities[i] = 0.5\n        elif priorities[i] > 1.5 and item < 3 * bins[i]:\n            if item < 2 * bins[i]:\n                priorities[i] = 1.7\n            elif item >= 2 * bins[i] and item < 2.5 * bins[i]:\n                priorities[i] = 1.9\n            elif item >= 2.5 * bins[i] and item < 3 * bins[i]:\n                priorities[i] = 1.95\n        elif item >= 3 * bins[i] and item < 4 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 3.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.3\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            if item < 0.5 * bins[i]:\n                priorities[i] = 0.3\n            elif 0.5 * bins[i] <= item < bins[i]:\n                priorities[i] = 0.5\n        elif priorities[i] > 1.5 and item < 3 * bins[i]:\n            if item < 2 * bins[i]:\n                priorities[i] = 1.7\n            elif 2 * bins[i] <= item < 2.5 * bins[i]:\n                priorities[i] = 1.9\n            else:\n                priorities[i] = 2.0\n\n        for j in range(len(bins)):\n            if bins[j] % 2 == 0:\n                priorities[j] += 0.1\n            elif bins[j] % 3 == 0:\n                priorities[j] += 0.2\n            else:\n                priorities[j] += 0.05\n\n        if bins[i] % 5 == 0:\n            priorities[i] += 0.3\n        elif bins[i] % 7 == 0:\n            priorities[i] += 0.4\n        elif bins[i] % 11 == 0:\n            priorities[i] += 0.5\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:50:01", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n\n    if item > max_bin_capacity * 0.75:\n        for j in range(len(bins)):\n            if bins[j] == max_bin_capacity:\n                priorities[j] *= 1.5\n    elif item < min_bin_capacity * 0.25:\n        for k in range(len(bins)):\n            if bins[k] == min_bin_capacity:\n                priorities[k] *= 0.5\n\n    for m in range(len(bins)):\n        if bins[m] % 2 == 0:\n            priorities[m] += 0.1\n        elif bins[m] % 3 == 0:\n            priorities[m] += 0.2\n        else:\n            priorities[m] += 0.05\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            if item < 0.5 * bins[i]:\n                priorities[i] = 0.3\n            elif item >= 0.5 * bins[i] and item < bins[i]:\n                priorities[i] = 0.5\n        elif priorities[i] > 1.5 and item < 3 * bins[i]:\n            if item < 2 * bins[i]:\n                priorities[i] = 1.7\n            elif item >= 2 * bins[i] and item < 2.5 * bins[i]:\n                priorities[i] = 1.9\n            elif item >= 2.5 * bins[i] and item < 3 * bins[i]:\n                priorities[i] = 1.95\n        elif item >= 3 * bins[i] and item < 4 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 3.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 4 * bins[i]:\n            priorities[i] *= 2.0\n        elif item > 3 * bins[i]:\n            priorities[i] *= 1.8\n        elif item > 2 * bins[i]:\n            priorities[i] *= 1.5\n\n        if bins[i] % 2 == 0:\n            priorities[i] += 0.1\n        elif bins[i] % 3 == 0:\n            priorities[i] += 0.2\n        else:\n            priorities[i] += 0.05\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:50:05", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n\n    if item > max_bin_capacity * 0.75:\n        for j in range(len(bins)):\n            if bins[j] == max_bin_capacity:\n                priorities[j] *= 1.5\n    elif item < min_bin_capacity * 0.25:\n        for k in range(len(bins)):\n            if bins[k] == min_bin_capacity:\n                priorities[k] *= 0.5\n\n    for m in range(len(bins)):\n        if bins[m] % 2 == 0:\n            priorities[m] += 0.1\n        elif bins[m] % 3 == 0:\n            priorities[m] += 0.2\n        else:\n            priorities[m] += 0.05\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            if item < 0.5 * bins[i]:\n                priorities[i] = 0.3\n            elif item >= 0.5 * bins[i] and item < bins[i]:\n                priorities[i] = 0.5\n        elif priorities[i] > 1.5 and item < 3 * bins[i]:\n            if item < 2 * bins[i]:\n                priorities[i] = 1.7\n            elif item >= 2 * bins[i] and item < 2.5 * bins[i]:\n                priorities[i] = 1.9\n            elif item >= 2.5 * bins[i] and item < 3 * bins[i]:\n                priorities[i] = 1.95\n        elif item >= 3 * bins[i] and item < 4 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 3.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 3 * bins[i]:\n            priorities[i] *= 2.0\n        elif item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            if item < 0.5 * bins[i]:\n                priorities[i] = 0.3\n            elif item >= 0.5 * bins[i] and item < bins[i]:\n                priorities[i] = 0.5\n        elif priorities[i] > 1.5 and item < 4 * bins[i]:\n            if item < 2 * bins[i]:\n                priorities[i] = 1.7\n            elif item >= 2 * bins[i] and item < 3 * bins[i]:\n                priorities[i] = 1.9\n            elif item >= 3 * bins[i] and item < 4 * bins[i]:\n                priorities[i] = 1.95\n        elif item >= 4 * bins[i]:\n            priorities[i] = 2.0\n\n        for j in range(len(bins)):\n            if bins[j] % 2 == 0:\n                priorities[j] += 0.1\n            elif bins[j] % 3 == 0:\n                priorities[j] += 0.2\n            else:\n                priorities[j] += 0.05\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:50:10", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n    max_bin_capacity = np.max(bins)\n    min_bin_capacity = np.min(bins)\n\n    if item > max_bin_capacity * 0.75:\n        for j in range(len(bins)):\n            if bins[j] == max_bin_capacity:\n                priorities[j] *= 1.5\n    elif item < min_bin_capacity * 0.25:\n        for k in range(len(bins)):\n            if bins[k] == min_bin_capacity:\n                priorities[k] *= 0.5\n\n    for m in range(len(bins)):\n        if bins[m] % 2 == 0:\n            priorities[m] += 0.1\n        elif bins[m] % 3 == 0:\n            priorities[m] += 0.2\n        else:\n            priorities[m] += 0.05\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            if item < 0.5 * bins[i]:\n                priorities[i] = 0.3\n            elif item >= 0.5 * bins[i] and item < bins[i]:\n                priorities[i] = 0.5\n        elif priorities[i] > 1.5 and item < 3 * bins[i]:\n            if item < 2 * bins[i]:\n                priorities[i] = 1.7\n            elif item >= 2 * bins[i] and item < 2.5 * bins[i]:\n                priorities[i] = 1.9\n            elif item >= 2.5 * bins[i] and item < 3 * bins[i]:\n                priorities[i] = 1.95\n        elif item >= 3 * bins[i] and item < 4 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 3.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            if item < 0.5 * bins[i]:\n                priorities[i] = 0.3\n            elif item >= 0.5 * bins[i] and item < bins[i]:\n                priorities[i] = 0.5\n        elif priorities[i] > 1.5 and item < 3 * bins[i]:\n            if item < 2 * bins[i]:\n                priorities[i] = 1.7\n            elif item >= 2 * bins[i] and item < 2.5 * bins[i]:\n                priorities[i] = 1.9\n            elif item >= 2.5 * bins[i] and item < 3 * bins[i]:\n                priorities[i] = 1.95\n        elif item >= 3 * bins[i] and item < 4 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 3.0\n\n    min_bin_capacity = np.min(bins)\n    max_bin_capacity = np.max(bins)\n    min_capacity_count = np.count_nonzero(bins == min_bin_capacity)\n    max_capacity_count = np.count_nonzero(bins == max_bin_capacity)\n\n    for j in range(len(bins)):\n        if bins[j] % 2 == 0:\n            priorities[j] += 0.15\n        elif bins[j] % 3 == 0:\n            priorities[j] += 0.2\n        else:\n            priorities[j] += 0.1\n\n    if min_capacity_count == 1:\n        for k in range(len(bins)):\n            if bins[k] == min_bin_capacity:\n                priorities[k] += 0.5\n    elif min_capacity_count > 1:\n        priorities += 0.3 * min_capacity_count\n\n    if max_capacity_count == 1:\n        for m in range(len(bins)):\n            if bins[m] == max_bin_capacity:\n                priorities[m] += 0.8\n    elif max_capacity_count > 1:\n        priorities += 0.5 * max_capacity_count\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:51:16", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n            \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] += 0.5\n        elif priorities[j] == min_priority:\n            priorities[j] -= 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more enhanced version of priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            \n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count >= 2:\n                priorities[i] += 0.2\n            elif count == 1:\n                priorities[i] -= 0.1\n                \n            if item >= 5:\n                priorities[i] += 0.3\n            elif item < 3:\n                priorities[i] -= 0.2\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count >= 2:\n                priorities[i] += 0.2\n            elif count == 1:\n                priorities[i] -= 0.1\n                \n            if item >= 5:\n                priorities[i] += 0.3\n            elif item < 3:\n                priorities[i] -= 0.2\n            \n            if priorities[i] > 1.5:\n                priorities[i] = 1.5\n            elif priorities[i] < 0.1:\n                priorities[i] = 0.1\n            else:\n                priorities[i] += 0.1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:51:20", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n            \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] += 0.5\n        elif priorities[j] == min_priority:\n            priorities[j] -= 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more enhanced version of priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            \n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count >= 2:\n                priorities[i] += 0.2\n            elif count == 1:\n                priorities[i] -= 0.1\n                \n            if item >= 5:\n                priorities[i] += 0.3\n            elif item < 3:\n                priorities[i] -= 0.2\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            \n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count >= 2:\n                priorities[i] += 0.2\n            elif count == 1:\n                priorities[i] -= 0.1\n                \n            if item >= 5:\n                priorities[i] += 0.3\n            elif item < 3:\n                priorities[i] -= 0.2\n            \n            if bins[i] % 2 == 0:\n                priorities[i] *= 1.1\n            else:\n                priorities[i] *= 0.9\n                \n            for j in range(i):\n                if bins[i] > bins[j]:\n                    priorities[i] += 0.05\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:51:23", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n            \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] += 0.5\n        elif priorities[j] == min_priority:\n            priorities[j] -= 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more enhanced version of priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            \n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count >= 2:\n                priorities[i] += 0.2\n            elif count == 1:\n                priorities[i] -= 0.1\n                \n            if item >= 5:\n                priorities[i] += 0.3\n            elif item < 3:\n                priorities[i] -= 0.2\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n\n            if count >= 2:\n                priorities[i] += 0.2\n            elif count == 1:\n                priorities[i] -= 0.1\n\n            if item >= 5:\n                priorities[i] += 0.3\n            elif item < 3:\n                priorities[i] -= 0.2\n\n            if item % 2 == 0:\n                priorities[i] *= 1.1\n            else:\n                priorities[i] *= 0.9\n\n            if item > 10:\n                priorities[i] += 0.5\n\n            if bins[i] % 2 == 0:\n                priorities[i] *= 1.2\n            else:\n                priorities[i] *= 0.8\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:51:26", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            priorities[i] = count + item / bins[i] + 0.3\n            \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] += 0.5\n        elif priorities[j] == min_priority:\n            priorities[j] -= 0.5\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    \"\"\"Even more enhanced version of priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            \n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count >= 2:\n                priorities[i] += 0.2\n            elif count == 1:\n                priorities[i] -= 0.1\n                \n            if item >= 5:\n                priorities[i] += 0.3\n            elif item < 3:\n                priorities[i] -= 0.2\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            \n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count >= 2:\n                priorities[i] += 0.2\n            elif count == 1:\n                priorities[i] -= 0.1\n                \n            if item >= 5:\n                priorities[i] += 0.3\n            elif item < 3:\n                priorities[i] -= 0.2\n            \n            if np.sum(bins) <= 100:\n                priorities[i] += 0.5\n            else:\n                priorities[i] -= 0.2\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:51:34", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item * 2 / bins[i] + 0.2\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item * 1.5\n            else:\n                priorities[i] = 0.5\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priority_ratio = item / bins[i]\n                priorities[i] = 1 - priority_ratio if priority_ratio < 0.5 else priority_ratio\n            else:\n                priority_ratio = bins[i] / item\n                priorities[i] = 1 - priority_ratio if priority_ratio < 0.5 else priority_ratio\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.15\n            if item < 0.5 * bins[i]:\n                priorities[i] *= 1.2\n            elif item < 0.8 * bins[i]:\n                priorities[i] *= 1.1\n            else:\n                priorities[i] = priorities[i] / 2\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            if item < 0.3 * bins[i]:\n                priorities[i] = 0.5\n            elif item < 0.6 * bins[i]:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 0.9\n            if bins[i] % 3 == 0:\n                priorities[i] += 0.1\n            elif bins[i] % 2 == 0:\n                priorities[i] += 0.2\n            else:\n                priorities[i] += 0.3\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:51:37", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item * 2 / bins[i] + 0.2\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item * 1.5\n            else:\n                priorities[i] = 0.5\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priority_ratio = item / bins[i]\n                priorities[i] = 1 - priority_ratio if priority_ratio < 0.5 else priority_ratio\n            else:\n                priority_ratio = bins[i] / item\n                priorities[i] = 1 - priority_ratio if priority_ratio < 0.5 else priority_ratio\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.15\n            if item < 0.5 * bins[i]:\n                priorities[i] *= 1.2\n            elif item < 0.8 * bins[i]:\n                priorities[i] *= 1.1\n            else:\n                priorities[i] = priorities[i] / 2\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < 0.3 * bins[i]:\n                priorities[i] = 0.8\n            elif item < 0.6 * bins[i]:\n                priorities[i] = 0.6\n            elif item < 0.8 * bins[i]:\n                priorities[i] = 0.4\n            else:\n                priorities[i] = 0.2\n            \n            if bins[i] % 3 == 0:\n                priorities[i] += 0.1\n            if item % 2 == 0:\n                priorities[i] *= 0.8\n            if bins[i] < 6:\n                priorities[i] *= 1.5\n            else:\n                priorities[i] = priorities[i] / 2\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:51:40", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item * 2 / bins[i] + 0.2\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item * 1.5\n            else:\n                priorities[i] = 0.5\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priority_ratio = item / bins[i]\n                priorities[i] = 1 - priority_ratio if priority_ratio < 0.5 else priority_ratio\n            else:\n                priority_ratio = bins[i] / item\n                priorities[i] = 1 - priority_ratio if priority_ratio < 0.5 else priority_ratio\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.15\n            if item < 0.5 * bins[i]:\n                priorities[i] *= 1.2\n            elif item < 0.8 * bins[i]:\n                priorities[i] *= 1.1\n            else:\n                priorities[i] = priorities[i] / 2\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Another improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < 0.3 * bins[i]:\n                priorities[i] = 0.5\n            elif item < 0.6 * bins[i]:\n                priorities[i] = 0.8\n            else:\n                priority_ratio = item / bins[i]\n                if priority_ratio < 0.5:\n                    priorities[i] = 1 - priority_ratio\n                elif priority_ratio >= 0.5 and priority_ratio < 0.8:\n                    priorities[i] = priority_ratio * 1.2\n                else:\n                    priorities[i] = 0.9\n            if i % 2 == 0:\n                priorities[i] += 0.1\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:51:43", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Another improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priorities[i] = item * 2 / bins[i] + 0.2\n            elif item > bins[i]:\n                priorities[i] = bins[i] / item * 1.5\n            else:\n                priorities[i] = 0.5\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < bins[i]:\n                priority_ratio = item / bins[i]\n                priorities[i] = 1 - priority_ratio if priority_ratio < 0.5 else priority_ratio\n            else:\n                priority_ratio = bins[i] / item\n                priorities[i] = 1 - priority_ratio if priority_ratio < 0.5 else priority_ratio\n            if bins[i] % 2 == 0:\n                priorities[i] += 0.15\n            if item < 0.5 * bins[i]:\n                priorities[i] *= 1.2\n            elif item < 0.8 * bins[i]:\n                priorities[i] *= 1.1\n            else:\n                priorities[i] = priorities[i] / 2\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] == 0:\n            priorities[i] = 0.0\n        else:\n            if item < 0.3 * bins[i]:\n                priorities[i] = 0.8\n            elif item < 0.6 * bins[i]:\n                priorities[i] = 0.6\n            else:\n                priorities[i] = 0.4\n            if bins[i] % 3 == 0:\n                priorities[i] *= 1.2\n            if item % 2 == 0:\n                priorities[i] += 0.1\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:51:52", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n\n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.2\n        else:\n            priorities[i] = priorities[i] + 0.1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.2\n        elif priorities[i] >= 0.5:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i] + 0.1\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.2\n        elif priorities[i] >= 0.5:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i] + 0.1\n            \n    # Add additional logic here based on specific requirements or criteria\n    for i in range(len(priorities)):\n        if priorities[i] < 0.3:\n            priorities[i] = 0.3\n        elif priorities[i] > 0.8:\n            priorities[i] = 0.8\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:51:56", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n\n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.2\n        else:\n            priorities[i] = priorities[i] + 0.1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.2\n        elif priorities[i] >= 0.5:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i] + 0.1\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.3\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.1 * bins[i]:\n            priorities[i] *= 1.1\n        else:\n            priorities[i] = priorities[i]\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = max_priority + 0.2\n        elif priorities[i] == min_priority:\n            priorities[i] = min_priority - 0.2\n        elif 0.6 > priorities[i] > 0.3:\n            priorities[i] = priorities[i] + 0.1\n        else:\n            priorities[i] = priorities[i] - 0.1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:51:59", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n\n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.2\n        else:\n            priorities[i] = priorities[i] + 0.1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.2\n        elif priorities[i] >= 0.5:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i] + 0.1\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n            \n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n            \n        if item % 2 == 0:\n            priorities[i] += 0.1\n        elif item % 3 == 0:\n            priorities[i] -= 0.1\n            \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.2\n        elif priorities[i] >= 0.5:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i] + 0.1\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:52:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n\n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.2\n        else:\n            priorities[i] = priorities[i] + 0.1\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.2\n        elif priorities[i] >= 0.5:\n            priorities[i] = priorities[i] - 0.1\n        else:\n            priorities[i] = priorities[i] + 0.1\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    total_bins = len(bins)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] = priorities[i] + 0.2\n        elif priorities[i] == min_priority:\n            priorities[i] = priorities[i] - 0.2\n        elif i % 2 == 0 and priorities[i] >= 0.5:\n            priorities[i] = priorities[i] - 0.1\n        elif i % 2 != 0 or priorities[i] < 0.5:\n            priorities[i] = priorities[i] + 0.1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:52:17", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n                \n            if item > bins[i] * 1.2:\n                priorities[i] -= 0.3\n            elif item < bins[i] * 0.7:\n                priorities[i] += 0.2\n                \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n            if item > 1.5 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.3\n            else:\n                priorities[i] *= 1.1\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            if item > 2 * bins[i]:\n                priorities[i] *= 1.7\n            elif item > 1.7 * bins[i]:\n                priorities[i] *= 1.4\n            elif item > 1.3 * bins[i]:\n                priorities[i] *= 1.2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n            if item > 1.5 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.3\n            else:\n                priorities[i] *= 1.1\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            if item > 2 * bins[i]:\n                priorities[i] *= 1.7\n            elif item > 1.7 * bins[i]:\n                priorities[i] *= 1.4\n            elif item > 1.3 * bins[i]:\n                priorities[i] *= 1.2\n                \n            if item > bins[i] * 2:\n                priorities[i] += 0.3\n            if item < bins[i] * 0.5:\n                priorities[i] -= 0.1\n            elif item < bins[i] * 0.8:\n                priorities[i] -= 0.05\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n            elif priorities[i] < 0.5:\n                priorities[i] = 0.5\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:52:21", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n                \n            if item > bins[i] * 1.2:\n                priorities[i] -= 0.3\n            elif item < bins[i] * 0.7:\n                priorities[i] += 0.2\n                \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n            if item > 1.5 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.3\n            else:\n                priorities[i] *= 1.1\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            if item > 2 * bins[i]:\n                priorities[i] *= 1.7\n            elif item > 1.7 * bins[i]:\n                priorities[i] *= 1.4\n            elif item > 1.3 * bins[i]:\n                priorities[i] *= 1.2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n            if item > 1.5 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.3\n            else:\n                priorities[i] *= 1.1\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            if item > 2 * bins[i]:\n                priorities[i] *= 1.7\n            elif item > 1.7 * bins[i]:\n                priorities[i] *= 1.4\n            elif item > 1.3 * bins[i]:\n                priorities[i] *= 1.2\n                \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n                \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:52:24", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n                \n            if item > bins[i] * 1.2:\n                priorities[i] -= 0.3\n            elif item < bins[i] * 0.7:\n                priorities[i] += 0.2\n                \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n            if item > 1.5 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.3\n            else:\n                priorities[i] *= 1.1\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            if item > 2 * bins[i]:\n                priorities[i] *= 1.7\n            elif item > 1.7 * bins[i]:\n                priorities[i] *= 1.4\n            elif item > 1.3 * bins[i]:\n                priorities[i] *= 1.2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n            \n            if item > 1.6 * bins[i]:\n                priorities[i] *= 1.6\n            elif item > 1.3 * bins[i]:\n                priorities[i] *= 1.4\n            else:\n                priorities[i] *= 1.2\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 3:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if item > 2 * bins[i]:\n                priorities[i] *= 1.8\n            elif item > 1.6 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.3 * bins[i]:\n                priorities[i] *= 1.3\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:52:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            \n            if priorities[i] < 0.3:\n                priorities[i] += 0.2\n            elif priorities[i] < 0.6:\n                priorities[i] += 0.4\n            else:\n                priorities[i] += 0.6\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n                \n            if item > bins[i] * 1.2:\n                priorities[i] -= 0.3\n            elif item < bins[i] * 0.7:\n                priorities[i] += 0.2\n                \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n            if item > 1.5 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.3\n            else:\n                priorities[i] *= 1.1\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            if item > 2 * bins[i]:\n                priorities[i] *= 1.7\n            elif item > 1.7 * bins[i]:\n                priorities[i] *= 1.4\n            elif item > 1.3 * bins[i]:\n                priorities[i] *= 1.2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n            if item > 1.5 * bins[i]:\n                priorities[i] *= 1.5\n            elif item > 1.2 * bins[i]:\n                priorities[i] *= 1.3\n            else:\n                priorities[i] *= 1.1\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n            if item > 2 * bins[i]:\n                priorities[i] *= 1.7\n            elif item > 1.7 * bins[i]:\n                priorities[i] *= 1.4\n            elif item > 1.3 * bins[i]:\n                priorities[i] *= 1.2\n                \n            if item < 0.5 * bins[i]:\n                priorities[i] -= 0.3\n            elif item < 0.8 * bins[i]:\n                priorities[i] -= 0.1\n            else:\n                priorities[i] += 0.2\n                \n            if priorities[i] > 1.0:\n                priorities[i] = 1.0\n                \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:52:41", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n\n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n\n    return final_priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:52:46", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n\n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2) + np.sqrt(item * bins[i])\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i]) - np.log(item + bins[i] + 1)\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1) * np.sqrt(item) + np.power(bins[i], 2)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i])) + np.sqrt(item * bins[i] + 10)\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1) + np.power(item, 3)\n\n    for j in range(len(bins)):\n        if priorities[j] < 15:\n            priorities[j] *= 2\n        elif priorities[j] >= 15 and priorities[j] < 25:\n            priorities[j] *= 3\n        elif priorities[j] >= 25 and priorities[j] < 35:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.cbrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= bins[k] / 2\n\n        if item > 10:\n            priorities[k] *= 1.2\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    final_priorities = np.where(priorities < 20, priorities * 1.5, priorities * 0.8)\n\n    return final_priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:52:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n\n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n\n    final_priorities = np.clip(final_priorities, 0, 100)  # Clip values to be between 0 and 100\n\n    return final_priorities", "strategy": []}
{"timestamp": "2025-04-27 07:52:55", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n\n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "import numpy as np\n\n\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if ratios[m] < 0.3:\n            final_priorities[m] = priorities[m] * 1.5\n        elif ratios[m] >= 0.3 and ratios[m] < 0.6:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n\n    return final_priorities", "strategy": []}
{"timestamp": "2025-04-27 07:53:22", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n        if i % 3 == 0:\n            priorities[i] *= 1.1\n        elif i % 4 == 0:\n            priorities[i] *= 0.8\n        elif i % 6 == 0:\n            priorities[i] *= 1.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n    priorities = np.clip(priorities, 0, 1)  # Clip values to be within 0 and 1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.2:\n            priorities[i] = 1 / (1 + np.exp(-40 * (ratio - 0.2)))\n        elif ratio >= 0.2 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-20 * (ratio - 0.4))) + 0.2\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.7))) + 0.4\n        elif ratio >= 0.8 and ratio < 0.95:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.9))) + 0.6\n        else:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 1))) + 0.8\n\n        if i % 4 == 0:\n            priorities[i] += 0.2\n        else:\n            for j in range(6):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.1 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.12 * j\n                else:\n                    priorities[i] += 0.05 * j\n\n    priorities = np.clip(priorities, 0, 1)\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:53:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n        if i % 3 == 0:\n            priorities[i] *= 1.1\n        elif i % 4 == 0:\n            priorities[i] *= 0.8\n        elif i % 6 == 0:\n            priorities[i] *= 1.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n    priorities = np.clip(priorities, 0, 1)  # Clip values to be within 0 and 1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                elif i % (j + 4) == 0:\n                    priorities[i] -= 0.03 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n        if i % 3 == 0:\n            priorities[i] *= 1.1\n        elif i % 4 == 0:\n            priorities[i] *= 0.8\n        elif i % 6 == 0:\n            priorities[i] *= 1.5\n\n    priorities = np.clip(priorities, 0, 1)  # Clip values to be within 0 and 1\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:53:29", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n        if i % 3 == 0:\n            priorities[i] *= 1.1\n        elif i % 4 == 0:\n            priorities[i] *= 0.8\n        elif i % 6 == 0:\n            priorities[i] *= 1.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n    priorities = np.clip(priorities, 0, 1)  # Clip values to be within 0 and 1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(param1: int, param2: float, param3: str) -> bool:\n    result = False\n    \n    if param1 > 0:\n        for i in range(param1):\n            if i % 2 == 0:\n                if param2 < 10:\n                    result = not result\n                elif param2 >= 10 and param2 < 20:\n                    result = True\n                else:\n                    result = False\n            else:\n                if param3 == \"hello\":\n                    result = result and True\n                else:\n                    result = result or False\n    \n    return result", "strategy": []}
{"timestamp": "2025-04-27 07:53:34", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n        if i % 3 == 0:\n            priorities[i] *= 1.1\n        elif i % 4 == 0:\n            priorities[i] *= 0.8\n        elif i % 6 == 0:\n            priorities[i] *= 1.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n    priorities = np.clip(priorities, 0, 1)  # Clip values to be within 0 and 1\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                elif i % (j + 4) == 0:\n                    priorities[i] -= 0.06 * j\n                else:\n                    priorities[i] += 0.04 * j\n\n        if i % 3 == 0:\n            priorities[i] *= 1.1\n        elif i % 4 == 0:\n            priorities[i] *= 0.8\n        elif i % 6 == 0:\n            priorities[i] *= 1.5\n\n    priorities = np.clip(priorities, 0, 1)  # Clip values to be within 0 and 1\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:53:51", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.3\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n                \n            if item % 2 == 0:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.1\n                \n            if item > 3 * np.median(bins):\n                priorities[i] += 0.4\n            elif item < np.min(bins):\n                priorities[i] -= 0.3\n            \n            if item < np.percentile(bins, 25):\n                priorities[i] -= 0.1\n            elif item > np.percentile(bins, 75):\n                priorities[i] += 0.2\n            \n            if i % 2 == 0:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.1\n            \n            if item > bins[i] * 2.5:\n                priorities[i] *= 1.8\n            elif item > bins[i] * 2:\n                priorities[i] *= 1.6\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.3\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n                \n            if item % 2 == 0:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.1\n                \n            if item > 3 * np.median(bins):\n                priorities[i] += 0.4\n            elif item < np.min(bins):\n                priorities[i] -= 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.3\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n                \n            if item % 2 == 0:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.1\n                \n            if item > 3 * np.median(bins):\n                priorities[i] += 0.4\n            elif item < np.min(bins):\n                priorities[i] -= 0.3\n            \n            if item < np.percentile(bins, 25):\n                priorities[i] -= 0.1\n            elif item > np.percentile(bins, 75):\n                priorities[i] += 0.2\n            \n            if i % 2 == 0:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.1\n            \n            if item > bins[i] * 2.5:\n                priorities[i] *= 1.8\n            elif item > bins[i] * 2:\n                priorities[i] *= 1.6\n    \n    return priorities\n```  ", "strategy": []}
{"timestamp": "2025-04-27 07:53:56", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.3\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n                \n            if item % 2 == 0:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.1\n                \n            if item > 3 * np.median(bins):\n                priorities[i] += 0.4\n            elif item < np.min(bins):\n                priorities[i] -= 0.3\n            \n            if item < np.percentile(bins, 25):\n                priorities[i] -= 0.1\n            elif item > np.percentile(bins, 75):\n                priorities[i] += 0.2\n            \n            if i % 2 == 0:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.1\n            \n            if item > bins[i] * 2.5:\n                priorities[i] *= 1.8\n            elif item > bins[i] * 2:\n                priorities[i] *= 1.6\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.3\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n                \n            if item % 2 == 0:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.1\n                \n            if item > 3 * np.median(bins):\n                priorities[i] += 0.4\n            elif item < np.min(bins):\n                priorities[i] -= 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n                \n            if i % 2 == 0:\n                priorities[i] += 0.2\n            else:\n                priorities[i] -= 0.2\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.3\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n                \n            if item % 2 == 0:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.1\n                \n            if item > 3 * np.median(bins):\n                priorities[i] += 0.4\n            elif item < np.min(bins):\n                priorities[i] -= 0.3\n            \n            if item > np.max(bins) * 0.9:\n                priorities[i] += 0.5\n            elif item < np.min(bins) * 1.1:\n                priorities[i] -= 0.4\n        \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:54:00", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.3\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n                \n            if item % 2 == 0:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.1\n                \n            if item > 3 * np.median(bins):\n                priorities[i] += 0.4\n            elif item < np.min(bins):\n                priorities[i] -= 0.3\n            \n            if item < np.percentile(bins, 25):\n                priorities[i] -= 0.1\n            elif item > np.percentile(bins, 75):\n                priorities[i] += 0.2\n            \n            if i % 2 == 0:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.1\n            \n            if item > bins[i] * 2.5:\n                priorities[i] *= 1.8\n            elif item > bins[i] * 2:\n                priorities[i] *= 1.6\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.3\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n                \n            if item % 2 == 0:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.1\n                \n            if item > 3 * np.median(bins):\n                priorities[i] += 0.4\n            elif item < np.min(bins):\n                priorities[i] -= 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.3\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n                \n            if item % 2 == 0:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.1\n                \n            if item > 3 * np.median(bins):\n                priorities[i] += 0.4\n            elif item < np.min(bins):\n                priorities[i] -= 0.3\n            \n            if item < np.percentile(bins, 25):\n                priorities[i] -= 0.1\n            elif item > np.percentile(bins, 75):\n                priorities[i] += 0.2\n            \n            if i % 2 == 0:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.1\n            \n            if item > bins[i] * 2.5:\n                priorities[i] *= 1.8\n            elif item > bins[i] * 2:\n                priorities[i] *= 1.6\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:54:04", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.3\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n                \n            if item % 2 == 0:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.1\n                \n            if item > 3 * np.median(bins):\n                priorities[i] += 0.4\n            elif item < np.min(bins):\n                priorities[i] -= 0.3\n            \n            if item < np.percentile(bins, 25):\n                priorities[i] -= 0.1\n            elif item > np.percentile(bins, 75):\n                priorities[i] += 0.2\n            \n            if i % 2 == 0:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.1\n            \n            if item > bins[i] * 2.5:\n                priorities[i] *= 1.8\n            elif item > bins[i] * 2:\n                priorities[i] *= 1.6\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            if bins[i] % item == 0:\n                priorities[i] = item / bins[i] + 0.5\n            else:\n                priorities[i] = item / bins[i]\n                \n            if item >= bins[i] * 0.8:\n                priorities[i] *= 1.5\n            elif item <= bins[i] * 0.2:\n                priorities[i] *= 0.5\n        else:\n            diff = item - bins[i]\n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.2\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.8\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.3\n            elif item < np.median(bins):\n                priorities[i] -= 0.2\n                \n            if item % 2 == 0:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.1\n                \n            if item > 3 * np.median(bins):\n                priorities[i] += 0.4\n            elif item < np.min(bins):\n                priorities[i] -= 0.3\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\n# New and more complex Python function\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of priority function.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= np.max(bins):\n            priorities[i] = item / bins[i]\n            \n            if item > np.mean(bins):\n                priorities[i] += 0.1\n                \n            if item < np.median(bins):\n                priorities[i] -= 0.1\n                \n            if item % 2 == 0:\n                priorities[i] += 0.05\n            else:\n                priorities[i] -= 0.05\n                \n            if item > np.mean(bins) * 2:\n                priorities[i] *= 1.5\n            elif item > np.mean(bins) * 1.5:\n                priorities[i] *= 1.3\n        else:\n            diff = item - bins[i]\n            \n            if diff > bins[i] / 2:\n                priorities[i] = bins[i] / item\n            else:\n                priorities[i] = (bins[i] + diff) / item\n                \n            if diff > bins[i] * 0.4:\n                priorities[i] *= 1.1\n            elif diff < bins[i] * 0.1:\n                priorities[i] *= 0.9\n                \n            if item > np.median(bins) * 2.5:\n                priorities[i] += 0.2\n            elif item < np.min(bins):\n                priorities[i] -= 0.2\n                \n            if item < np.percentile(bins, 25):\n                priorities[i] -= 0.05\n            elif item > np.percentile(bins, 75):\n                priorities[i] += 0.1\n                \n            if i % 2 == 0:\n                priorities[i] += 0.05\n            else:\n                priorities[i] -= 0.05\n                \n            if item > bins[i] * 2.5:\n                priorities[i] *= 1.7\n            elif item > bins[i] * 2:\n                priorities[i] *= 1.4\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:54:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > bin_capacity * 0.8:\n                priorities[index] = 0.9\n            elif remaining_capacity > bin_capacity * 0.6:\n                priorities[index] = 0.7\n            elif remaining_capacity > bin_capacity * 0.4:\n                priorities[index] = 0.5\n            elif remaining_capacity > bin_capacity * 0.2:\n                priorities[index] = 0.3\n            else:\n                priority = 1 / remaining_capacity\n                priorities[index] = priority if priority > 0 else 0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > bin_capacity * 0.7:\n                priorities[index] = 0.9\n            elif remaining_capacity > bin_capacity * 0.4:\n                priorities[index] = 0.7\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.5\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.3\n                else:\n                    priorities[index] = 0.1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > bin_capacity * 0.8:\n                priorities[index] = 0.9\n            elif remaining_capacity > bin_capacity * 0.6:\n                priorities[index] = 0.7\n            elif remaining_capacity > bin_capacity * 0.4:\n                priorities[index] = 0.5\n            elif remaining_capacity > bin_capacity * 0.2:\n                priorities[index] = 0.3\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.5\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.3\n                else:\n                    priorities[index] = 0.1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:54:57", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > bin_capacity * 0.8:\n                priorities[index] = 0.9\n            elif remaining_capacity > bin_capacity * 0.6:\n                priorities[index] = 0.7\n            elif remaining_capacity > bin_capacity * 0.4:\n                priorities[index] = 0.5\n            elif remaining_capacity > bin_capacity * 0.2:\n                priorities[index] = 0.3\n            else:\n                priority = 1 / remaining_capacity\n                priorities[index] = priority if priority > 0 else 0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > bin_capacity * 0.7:\n                priorities[index] = 0.9\n            elif remaining_capacity > bin_capacity * 0.4:\n                priorities[index] = 0.7\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.5\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.3\n                else:\n                    priorities[index] = 0.1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > bin_capacity * 0.8:\n                priorities[index] = 0.9\n            elif remaining_capacity > bin_capacity * 0.6:\n                priorities[index] = 0.7\n            elif remaining_capacity > bin_capacity * 0.4:\n                priorities[index] = 0.5\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = priority\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.3\n                elif priority >= 1.0 and priority < 2.0:\n                    priorities[index] = 0.1\n                else:\n                    priorities[index] = 0.05\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:55:00", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > bin_capacity * 0.8:\n                priorities[index] = 0.9\n            elif remaining_capacity > bin_capacity * 0.6:\n                priorities[index] = 0.7\n            elif remaining_capacity > bin_capacity * 0.4:\n                priorities[index] = 0.5\n            elif remaining_capacity > bin_capacity * 0.2:\n                priorities[index] = 0.3\n            else:\n                priority = 1 / remaining_capacity\n                priorities[index] = priority if priority > 0 else 0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > bin_capacity * 0.7:\n                priorities[index] = 0.9\n            elif remaining_capacity > bin_capacity * 0.4:\n                priorities[index] = 0.7\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.5\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.3\n                else:\n                    priorities[index] = 0.1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > bin_capacity * 0.7:\n                priorities[index] = 0.9\n            elif remaining_capacity > bin_capacity * 0.4:\n                priorities[index] = 0.7\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.5\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.3\n                else:\n                    priorities[index] = 0.1\n                    \n            # Additional condition based on index\n            if index % 2 == 0:\n                priorities[index] *= 1.2\n            else:\n                priorities[index] *= 0.8\n                \n            # Additional condition based on bin_capacity\n            if bin_capacity > 100:\n                priorities[index] *= 1.5\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:55:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > bin_capacity * 0.8:\n                priorities[index] = 0.9\n            elif remaining_capacity > bin_capacity * 0.6:\n                priorities[index] = 0.7\n            elif remaining_capacity > bin_capacity * 0.4:\n                priorities[index] = 0.5\n            elif remaining_capacity > bin_capacity * 0.2:\n                priorities[index] = 0.3\n            else:\n                priority = 1 / remaining_capacity\n                priorities[index] = priority if priority > 0 else 0\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > bin_capacity * 0.7:\n                priorities[index] = 0.9\n            elif remaining_capacity > bin_capacity * 0.4:\n                priorities[index] = 0.7\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.5\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.3\n                else:\n                    priorities[index] = 0.1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > bin_capacity * 0.7:\n                priorities[index] = 0.9\n            elif remaining_capacity > bin_capacity * 0.4:\n                priorities[index] = 0.7\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.5:\n                    priorities[index] = 0.5\n                elif priority >= 0.5 and priority < 1.0:\n                    priorities[index] = 0.3\n                else:\n                    priorities[index] = 0.1\n                \n                if item > bin_capacity * 1.2:\n                    priorities[index] -= 0.2\n                elif item > bin_capacity * 1.5:\n                    priorities[index] -= 0.4\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:55:12", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.3:\n                    priorities[index] = 0.9\n                elif priority >= 0.3 and priority < 0.6:\n                    priorities[index] = 0.7\n                elif priority >= 0.6 and priority < 0.9:\n                    priorities[index] = 0.5\n                else:\n                    priorities[index] = 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.4:\n                    priorities[i] = 0.9\n                elif priority >= 0.4 and priority < 0.7:\n                    priorities[i] = 0.7\n                elif priority >= 0.7 and priority < 1.0:\n                    priorities[i] = 0.5\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[i] = 0.2\n                    else:\n                        priorities[i] = 0.3\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[i] = 0.1\n                else:\n                    priorities[i] = 0.0\n                    \n                if priorities[i] == 0.0:\n                    for j in range(i+1, len(bins)):\n                        if bins[j] >= item:\n                            priorities[j] = 0.6\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.4:\n                    priorities[i] = 0.9\n                elif priority >= 0.4 and priority < 0.7:\n                    priorities[i] = 0.7\n                elif priority >= 0.7 and priority < 1.0:\n                    priorities[i] = 0.5\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[i] = 0.2\n                    else:\n                        priorities[i] = 0.3\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[i] = 0.1\n                else:\n                    priorities[i] = 0.0\n                \n                if priorities[i] == 0.0:\n                    for j in range(i+1, len(bins)):\n                        if bins[j] >= item:\n                            priorities[j] = 0.6\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:55:15", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.3:\n                    priorities[index] = 0.9\n                elif priority >= 0.3 and priority < 0.6:\n                    priorities[index] = 0.7\n                elif priority >= 0.6 and priority < 0.9:\n                    priorities[index] = 0.5\n                else:\n                    priorities[index] = 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.4:\n                    priorities[i] = 0.9\n                elif priority >= 0.4 and priority < 0.7:\n                    priorities[i] = 0.7\n                elif priority >= 0.7 and priority < 1.0:\n                    priorities[i] = 0.5\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[i] = 0.2\n                    else:\n                        priorities[i] = 0.3\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[i] = 0.1\n                else:\n                    priorities[i] = 0.0\n                    \n                if priorities[i] == 0.0:\n                    for j in range(i+1, len(bins)):\n                        if bins[j] >= item:\n                            priorities[j] = 0.6\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.4:\n                    priorities[i] = 0.9\n                elif priority >= 0.4 and priority < 0.7:\n                    priorities[i] = 0.7\n                elif priority >= 0.7 and priority < 1.0:\n                    priorities[i] = 0.5\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[i] = 0.2\n                    else:\n                        priorities[i] = 0.3\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[i] = 0.1\n                else:\n                    priorities[i] = 0.0\n\n                if priorities[i] == 0.0:\n                    for j in range(i+1, len(bins)):\n                        if bins[j] >= item:\n                            priorities[j] = 0.6\n                            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:55:18", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.3:\n                    priorities[index] = 0.9\n                elif priority >= 0.3 and priority < 0.6:\n                    priorities[index] = 0.7\n                elif priority >= 0.6 and priority < 0.9:\n                    priorities[index] = 0.5\n                else:\n                    priorities[index] = 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.4:\n                    priorities[i] = 0.9\n                elif priority >= 0.4 and priority < 0.7:\n                    priorities[i] = 0.7\n                elif priority >= 0.7 and priority < 1.0:\n                    priorities[i] = 0.5\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[i] = 0.2\n                    else:\n                        priorities[i] = 0.3\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[i] = 0.1\n                else:\n                    priorities[i] = 0.0\n                    \n                if priorities[i] == 0.0:\n                    for j in range(i+1, len(bins)):\n                        if bins[j] >= item:\n                            priorities[j] = 0.6\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.4:\n                    priorities[i] = 0.9\n                elif priority >= 0.4 and priority < 0.7:\n                    priorities[i] = 0.7\n                elif priority >= 0.7 and priority < 1.0:\n                    priorities[i] = 0.5\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[i] = 0.2\n                    else:\n                        priorities[i] = 0.3\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[i] = 0.1\n                else:\n                    priorities[i] = 0.0\n                    \n                if priorities[i] == 0.0:\n                    for j in range(i+1, len(bins)):\n                        if bins[j] >= item:\n                            priorities[j] = 0.6\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:55:22", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for index, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[index] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity <= 0:\n                priorities[index] = 0\n            else:\n                priority = 1 / remaining_capacity\n                if priority < 0.3:\n                    priorities[index] = 0.9\n                elif priority >= 0.3 and priority < 0.6:\n                    priorities[index] = 0.7\n                elif priority >= 0.6 and priority < 0.9:\n                    priorities[index] = 0.5\n                else:\n                    priorities[index] = 0.3\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.4:\n                    priorities[i] = 0.9\n                elif priority >= 0.4 and priority < 0.7:\n                    priorities[i] = 0.7\n                elif priority >= 0.7 and priority < 1.0:\n                    priorities[i] = 0.5\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[i] = 0.2\n                    else:\n                        priorities[i] = 0.3\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[i] = 0.1\n                else:\n                    priorities[i] = 0.0\n                    \n                if priorities[i] == 0.0:\n                    for j in range(i+1, len(bins)):\n                        if bins[j] >= item:\n                            priorities[j] = 0.6\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bin_capacity - item\n            if remaining_capacity > 0:\n                priority = 1 / remaining_capacity\n                if priority < 0.4:\n                    priorities[i] = 0.9\n                elif priority >= 0.4 and priority < 0.7:\n                    priorities[i] = 0.7\n                elif priority >= 0.7 and priority < 1.0:\n                    priorities[i] = 0.5\n                else:\n                    if item > bin_capacity * 2:\n                        priorities[i] = 0.2\n                    else:\n                        priorities[i] = 0.3\n            else:\n                if item >= bin_capacity * 2:\n                    priorities[i] = 0.1\n                else:\n                    priorities[i] = 0.0\n                    \n                if priorities[i] == 0.0:\n                    for j in range(i+1, len(bins)):\n                        if bins[j] >= item:\n                            priorities[j] = 0.6\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:55:32", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n                \n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n        \n    final_priorities = np.zeros_like(priorities)\n    for k in range(len(priorities)):\n        if priorities[k] >= 0.5:\n            final_priorities[k] = priorities[k] * 1.5\n        else:\n            final_priorities[k] = priorities[k] * 0.5\n            \n    return final_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n                \n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n        \n    final_priorities = np.zeros_like(priorities)\n    for k in range(len(priorities)):\n        if priorities[k] >= 0.5:\n            final_priorities[k] = priorities[k] * 1.5\n        else:\n            final_priorities[k] = priorities[k] * 0.5\n            \n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n                \n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n        \n    final_priorities = np.zeros_like(priorities)\n    for k in range(len(priorities)):\n        if priorities[k] >= 0.5:\n            final_priorities[k] = priorities[k] * 1.5\n        else:\n            final_priorities[k] = priorities[k] * 0.5\n            \n    return final_priorities * 2.0 if np.sum(final_priorities) > 2.0 else final_priorities\n", "strategy": []}
{"timestamp": "2025-04-27 07:55:37", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n                \n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n        \n    final_priorities = np.zeros_like(priorities)\n    for k in range(len(priorities)):\n        if priorities[k] >= 0.5:\n            final_priorities[k] = priorities[k] * 1.5\n        else:\n            final_priorities[k] = priorities[k] * 0.5\n            \n    return final_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n                \n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n        \n    final_priorities = np.zeros_like(priorities)\n    for k in range(len(priorities)):\n        if priorities[k] >= 0.5:\n            final_priorities[k] = priorities[k] * 1.5\n        else:\n            final_priorities[k] = priorities[k] * 0.5\n            \n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n\n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n\n    final_priorities = np.zeros_like(priorities)\n    for k in range(len(priorities)):\n        if priorities[k] >= 0.5:\n            final_priorities[k] = priorities[k] * 1.5\n        else:\n            final_priorities[k] = priorities[k] * 0.5\n\n    for l in range(len(final_priorities)):\n        if bins[l] % 2 == 0:\n            final_priorities[l] = final_priorities[l] * 2\n        else:\n            final_priorities[l] = final_priorities[l] / 2\n            \n    return final_priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:55:40", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n                \n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n        \n    final_priorities = np.zeros_like(priorities)\n    for k in range(len(priorities)):\n        if priorities[k] >= 0.5:\n            final_priorities[k] = priorities[k] * 1.5\n        else:\n            final_priorities[k] = priorities[k] * 0.5\n            \n    return final_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n                \n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n        \n    final_priorities = np.zeros_like(priorities)\n    for k in range(len(priorities)):\n        if priorities[k] >= 0.5:\n            final_priorities[k] = priorities[k] * 1.5\n        else:\n            final_priorities[k] = priorities[k] * 0.5\n            \n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.2:\n                priorities[i] = 0.3\n            elif priority_diff >= 0.2 and priority_diff < 0.4:\n                priorities[i] = 0.5\n            elif priority_diff >= 0.4 and priority_diff < 0.6:\n                priorities[i] = 0.7\n            elif priority_diff >= 0.6 and priority_diff < 0.8:\n                priorities[i] = 0.9\n            else:\n                priorities[i] = 1.0\n                \n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n        \n    final_priorities = np.zeros_like(priorities)\n    for k in range(len(priorities)):\n        if priorities[k] >= 0.5:\n            final_priorities[k] = priorities[k] * 1.7\n        else:\n            final_priorities[k] = priorities[k] * 0.6\n            \n    return final_priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:55:44", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n                \n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n        \n    final_priorities = np.zeros_like(priorities)\n    for k in range(len(priorities)):\n        if priorities[k] >= 0.5:\n            final_priorities[k] = priorities[k] * 1.5\n        else:\n            final_priorities[k] = priorities[k] * 0.5\n            \n    return final_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n                \n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n        \n    final_priorities = np.zeros_like(priorities)\n    for k in range(len(priorities)):\n        if priorities[k] >= 0.5:\n            final_priorities[k] = priorities[k] * 1.5\n        else:\n            final_priorities[k] = priorities[k] * 0.5\n            \n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of the previous priority functions.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n                \n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n        \n    final_priorities = np.zeros_like(priorities)\n    for k in range(len(priorities)):\n        if priorities[k] >= 0.5:\n            final_priorities[k] = priorities[k] * 1.5\n        else:\n            final_priorities[k] = priorities[k] * 0.5\n            \n    # Additional complexity\n    for l in range(len(final_priorities)):\n        if l % 2 == 0:\n            final_priorities[l] *= 2\n        elif l % 3 == 0:\n            final_priorities[l] /= 2\n        else:\n            final_priorities[l] += 0.1\n    \n    return final_priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:55:57", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n\n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n\n    final_priorities = np.zeros_like(priorities)\n    for k in range(len(priorities)):\n        if priorities[k] >= 0.5:\n            final_priorities[k] = priorities[k] * 1.5\n        else:\n            final_priorities[k] = priorities[k] * 0.5\n\n    for l in range(len(final_priorities)):\n        if bins[l] % 2 == 0:\n            final_priorities[l] = final_priorities[l] * 2\n        else:\n            final_priorities[l] = final_priorities[l] / 2\n            \n    return final_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n\n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n\n    final_priorities = np.zeros_like(priorities)\n    for k in range(len(priorities)):\n        if priorities[k] >= 0.5:\n            final_priorities[k] = priorities[k] * 1.5\n        else:\n            final_priorities[k] = priorities[k] * 0.5\n\n    for l in range(len(final_priorities)):\n        if bins[l] % 2 == 0:\n            final_priorities[l] = final_priorities[l] * 2\n        else:\n            final_priorities[l] = final_priorities[l] / 2\n            \n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.2:\n                priorities[i] = 0.1\n            elif priority_diff >= 0.2 and priority_diff < 0.4:\n                priorities[i] = 0.3\n            elif priority_diff >= 0.4 and priority_diff < 0.6:\n                priorities[i] = 0.5\n            elif priority_diff >= 0.6 and priority_diff < 0.8:\n                priorities[i] = 0.7\n            else:\n                priorities[i] = 0.9\n\n    for j in range(len(priorities)):\n        if priorities[j] >= 0.5:\n            priorities[j] *= 1.2\n        else:\n            priorities[j] *= 0.8\n\n    for k in range(len(priorities)):\n        if item % 2 == 0:\n            priorities[k] += 0.1\n        else:\n            priorities[k] -= 0.1\n\n    max_priority = np.max(priorities)\n    for l in range(len(priorities)):\n        if priorities[l] == max_priority:\n            priorities[l] = 1.0\n        else:\n            priorities[l] = 0.0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:56:02", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n\n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n\n    final_priorities = np.zeros_like(priorities)\n    for k in range(len(priorities)):\n        if priorities[k] >= 0.5:\n            final_priorities[k] = priorities[k] * 1.5\n        else:\n            final_priorities[k] = priorities[k] * 0.5\n\n    for l in range(len(final_priorities)):\n        if bins[l] % 2 == 0:\n            final_priorities[l] = final_priorities[l] * 2\n        else:\n            final_priorities[l] = final_priorities[l] / 2\n            \n    return final_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n\n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n\n    final_priorities = np.zeros_like(priorities)\n    for k in range(len(priorities)):\n        if priorities[k] >= 0.5:\n            final_priorities[k] = priorities[k] * 1.5\n        else:\n            final_priorities[k] = priorities[k] * 0.5\n\n    for l in range(len(final_priorities)):\n        if bins[l] % 2 == 0:\n            final_priorities[l] = final_priorities[l] * 2\n        else:\n            final_priorities[l] = final_priorities[l] / 2\n            \n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.2:\n                priorities[i] = 0.1\n            elif priority_diff >= 0.2 and priority_diff < 0.4:\n                priorities[i] = 0.3\n            elif priority_diff >= 0.4 and priority_diff < 0.6:\n                priorities[i] = 0.5\n            elif priority_diff >= 0.6 and priority_diff < 0.8:\n                priorities[i] = 0.7\n            else:\n                priorities[i] = 0.9\n\n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n\n    final_priorities = np.zeros_like(priorities)\n    for k in range(len(priorities)):\n        if priorities[k] >= 0.5:\n            final_priorities[k] = priorities[k] * 1.25\n        else:\n            final_priorities[k] = priorities[k] * 0.75\n\n    for l in range(len(final_priorities)):\n        if bins[l] % 3 == 0:\n            final_priorities[l] = final_priorities[l] * 2\n        else:\n            final_priorities[l] = final_priorities[l] / 2\n           \n    return final_priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:56:07", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n\n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n\n    final_priorities = np.zeros_like(priorities)\n    for k in range(len(priorities)):\n        if priorities[k] >= 0.5:\n            final_priorities[k] = priorities[k] * 1.5\n        else:\n            final_priorities[k] = priorities[k] * 0.5\n\n    for l in range(len(final_priorities)):\n        if bins[l] % 2 == 0:\n            final_priorities[l] = final_priorities[l] * 2\n        else:\n            final_priorities[l] = final_priorities[l] / 2\n            \n    return final_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n\n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n\n    final_priorities = np.zeros_like(priorities)\n    for k in range(len(priorities)):\n        if priorities[k] >= 0.5:\n            final_priorities[k] = priorities[k] * 1.5\n        else:\n            final_priorities[k] = priorities[k] * 0.5\n\n    for l in range(len(final_priorities)):\n        if bins[l] % 2 == 0:\n            final_priorities[l] = final_priorities[l] * 2\n        else:\n            final_priorities[l] = final_priorities[l] / 2\n            \n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.1 * bins[i]\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.3 * bins[i]\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.5 * bins[i]\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.7 * bins[i]\n            else:\n                priorities[i] = 0.9 * bins[i]\n\n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n\n    final_priorities = np.zeros_like(priorities)\n    for k in range(len(priorities)):\n        if priorities[k] >= 0.5:\n            final_priorities[k] = priorities[k] ** 2\n        else:\n            final_priorities[k] = priorities[k] ** 3\n\n    for l in range(len(final_priorities)):\n        if item % 2 == 0:\n            final_priorities[l] = final_priorities[l] ** 2\n        else:\n            final_priorities[l] = final_priorities[l] / 2\n            \n    return final_priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:56:11", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n\n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n\n    final_priorities = np.zeros_like(priorities)\n    for k in range(len(priorities)):\n        if priorities[k] >= 0.5:\n            final_priorities[k] = priorities[k] * 1.5\n        else:\n            final_priorities[k] = priorities[k] * 0.5\n\n    for l in range(len(final_priorities)):\n        if bins[l] % 2 == 0:\n            final_priorities[l] = final_priorities[l] * 2\n        else:\n            final_priorities[l] = final_priorities[l] / 2\n            \n    return final_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n\n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n\n    final_priorities = np.zeros_like(priorities)\n    for k in range(len(priorities)):\n        if priorities[k] >= 0.5:\n            final_priorities[k] = priorities[k] * 1.5\n        else:\n            final_priorities[k] = priorities[k] * 0.5\n\n    for l in range(len(final_priorities)):\n        if bins[l] % 2 == 0:\n            final_priorities[l] = final_priorities[l] * 2\n        else:\n            final_priorities[l] = final_priorities[l] / 2\n            \n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            if bins[i] == 0:\n                priorities[i] = 0.0\n            elif bins[i] == item:\n                priorities[i] = 1.0\n            else:\n                priorities[i] = (item + bins[i]) / (2 * bins[i])\n        else:\n            priority_diff = (item - bins[i]) / item\n            if priority_diff < 0.1:\n                priorities[i] = 0.2\n            elif priority_diff >= 0.1 and priority_diff < 0.3:\n                priorities[i] = 0.4\n            elif priority_diff >= 0.3 and priority_diff < 0.5:\n                priorities[i] = 0.6\n            elif priority_diff >= 0.5 and priority_diff < 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = 1.0\n\n    max_priority = np.max(priorities)\n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] = 1.0\n        else:\n            priorities[j] = 0.0\n\n    final_priorities = np.zeros_like(priorities)\n    for k in range(len(priorities)):\n        if priorities[k] >= 0.5:\n            final_priorities[k] = priorities[k] * 1.5\n        else:\n            final_priorities[k] = priorities[k] * 0.5\n\n    for l in range(len(final_priorities)):\n        if bins[l] % 2 == 0:\n            if final_priorities[l] >= 0.5:\n                final_priorities[l] = final_priorities[l] * 1.6\n            else:\n                final_priorities[l] = final_priorities[l] * 1.2\n        else:\n            if final_priorities[l] >= 0.5:\n                final_priorities[l] = final_priorities[l] * 0.8\n            else:\n                final_priorities[l] = final_priorities[l] * 0.4\n                \n    return final_priorities", "strategy": []}
{"timestamp": "2025-04-27 07:56:24", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n        if i % 2 == 0:\n            priorities[i] *= 1.5\n        else:\n            priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_function(input_data: np.ndarray) -> np.ndarray:\n    output_data = np.zeros_like(input_data)\n\n    for i in range(len(input_data)):\n        if input_data[i] < 0.2:\n            output_data[i] = input_data[i] + 0.1\n        elif input_data[i] >= 0.2 and input_data[i] < 0.5:\n            output_data[i] = input_data[i] + 0.2\n        elif input_data[i] >= 0.5 and input_data[i] < 0.7:\n            output_data[i] = input_data[i] + 0.3\n        elif input_data[i] >= 0.7 and input_data[i] < 0.9:\n            output_data[i] = input_data[i] + 0.4\n        else:\n            output_data[i] = input_data[i] + 0.5\n\n        for j in range(1, 6):\n            if i % j == 0:\n                output_data[i] += 0.1 * j\n            elif i % (j + 2) == 0:\n                output_data[i] -= 0.05 * j\n\n        if i % 3 == 0:\n            output_data[i] *= 1.3\n        elif i % 5 == 0:\n            output_data[i] /= 1.5\n\n    return output_data\n```", "strategy": []}
{"timestamp": "2025-04-27 07:56:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n        if i % 2 == 0:\n            priorities[i] *= 1.5\n        else:\n            priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_function(input_data: np.ndarray) -> np.ndarray:\n    output_data = np.zeros_like(input_data)\n    \n    for i in range(len(input_data)):\n        if i % 2 == 0:\n            output_data[i] = input_data[i] * 1.5\n        else:\n            output_data[i] = input_data[i] + 0.5\n            \n        for j in range(1, 10):\n            if i % (j + 2) == 0:\n                output_data[i] -= 0.1 * j\n            elif i % (j + 3) == 0:\n                output_data[i] += 0.2 * j\n            else:\n                output_data[i] += 0.05 * j\n                \n        if input_data[i] < 0.5:\n            output_data[i] = np.sqrt(output_data[i])\n        elif input_data[i] >= 0.5 and input_data[i] < 1.5:\n            output_data[i] = np.cbrt(output_data[i])\n        else:\n            output_data[i] = np.square(output_data[i])\n    \n    return output_data", "strategy": []}
{"timestamp": "2025-04-27 07:56:31", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n        if i % 2 == 0:\n            priorities[i] *= 1.5\n        else:\n            priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n        \n        priorities[i] = np.clip(priorities[i], 0.1, 1.0)\n        priorities[i] = np.where(priorities[i] < 0.5, priorities[i] ** 2, priorities[i] ** 0.5)\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:56:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n        if i % 2 == 0:\n            priorities[i] *= 1.5\n        else:\n            priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n        if i % 2 == 0:\n            priorities[i] *= 1.5\n        else:\n            priorities[i] += 0.5\n\n        priorities[i] = max(0, min(1, priorities[i]))\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:56:45", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:56:52", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.2\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.3\n        else:\n            priorities[i] += 0.4\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:56:59", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    # Additional logic here\n    for i in range(5):\n        if i % 2 == 0:\n            priorities[i] += 0.5\n        else:\n            priorities[i] -= 0.5\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:57:05", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n                \n            if i % 2 == 0:\n                priorities[i] *= 1.5\n                \n            if item % 2 == 0:\n                priorities[i] += 0.25\n                \n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n                \n            if item % 3 == 0:\n                priorities[i] *= 2.0\n                \n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n                \n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n                \n            if i % 3 == 0:\n                priorities[i] -= 0.5\n                \n            if item % 5 == 0:\n                priorities[i] += 1.5\n                \n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n", "strategy": []}
{"timestamp": "2025-04-27 07:57:25", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n        if i % 3 == 0:\n            priorities[i] *= 1.1\n        elif i % 4 == 0:\n            priorities[i] *= 0.8\n        elif i % 6 == 0:\n            priorities[i] *= 1.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n            else:\n                priorities[i] += 0.5\n\n        if priorities[i] < 0.2:\n            priorities[i] = 0.2\n        elif priorities[i] > 0.8:\n            priorities[i] = 0.8\n\n        if i % 3 == 0:\n            priorities[i] = np.clip(priorities[i], 0.4, 0.7)\n        elif i % 4 == 0:\n            priorities[i] = np.clip(priorities[i], 0.1, 0.5)\n        elif i % 7 == 0:\n            priorities[i] = np.clip(priorities[i], 0.2, 0.6)\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:57:29", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n        if i % 3 == 0:\n            priorities[i] *= 1.1\n        elif i % 4 == 0:\n            priorities[i] *= 0.8\n        elif i % 6 == 0:\n            priorities[i] *= 1.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-35 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.4: \n            priorities[i] = 1 / (1 + np.exp(-20 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.4 and ratio < 0.6:\n            priorities[i] = 1 / (1 + np.exp(-12 * (ratio - 0.5))) + 0.5\n        elif ratio >= 0.6 and ratio < 0.8:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.7))) + 0.6\n        else:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 1))) + 0.7\n\n        if i % 5 == 0:\n            priorities[i] += 0.2\n        else:\n            for j in range(5):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.04 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.06 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n            if i % 2 == 0:\n                priorities[i] *= 1.7\n            else:\n                priorities[i] += 0.4\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:57:33", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n        if i % 3 == 0:\n            priorities[i] *= 1.1\n        elif i % 4 == 0:\n            priorities[i] *= 0.8\n        elif i % 6 == 0:\n            priorities[i] *= 1.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more complex version of `priority_v1`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.15:\n            priorities[i] = 1 / (1 + np.exp(-40 * (ratio - 0.2))) + 0.1\n        elif ratio >= 0.15 and ratio < 0.45:\n            priorities[i] = 1 / (1 + np.exp(-20 * (ratio - 0.3))) + 0.2\n        elif ratio >= 0.45 and ratio < 0.65:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.5))) + 0.3\n        elif ratio >= 0.65 and ratio < 0.85:\n            priorities[i] = 1 / (1 + np.exp(-8 * (ratio - 0.7))) + 0.4\n        else:\n            priorities[i] = 1 / (1 + np.exp(-3 * (ratio - 1))) + 0.5\n\n        if i % 6 == 0:\n            priorities[i] += 0.4\n        else:\n            for j in range(8):\n                if i % (j + 2) == 0:\n                    priorities[i] += 0.03 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] -= 0.04 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n            if i % 3 == 0:\n                priorities[i] *= 1.3\n            elif i % 5 == 0:\n                priorities[i] *= 0.9\n            elif i % 7 == 0:\n                priorities[i] *= 1.7\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:57:36", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                elif i % (j + 3) == 0:\n                    priorities[i] += 0.07 * j\n                else:\n                    priorities[i] += 0.03 * j\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n            else:\n                priorities[i] += 0.5\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i, ratio in enumerate(ratios):\n        if ratio < 0.1:\n            priorities[i] = 1 / (1 + np.exp(-30 * (ratio - 0.1))) + 0.1\n        elif ratio >= 0.1 and ratio < 0.5:\n            priorities[i] = 1 / (1 + np.exp(-15 * (ratio - 0.3))) + 0.3\n        elif ratio >= 0.5 and ratio < 0.7:\n            priorities[i] = 1 / (1 + np.exp(-10 * (ratio - 0.6))) + 0.4\n        elif ratio >= 0.7 and ratio < 0.9:\n            priorities[i] = 1 / (1 + np.exp(-5 * (ratio - 0.8))) + 0.5\n        else:\n            priorities[i] = 1 / (1 + np.exp(-2 * (ratio - 1))) + 0.6\n\n        if i % 5 == 0:\n            priorities[i] += 0.3\n        else:\n            for j in range(7):\n                if i % (j + 2) == 0:\n                    priorities[i] -= 0.05 * j\n                else:\n                    priorities[i] += 0.02 * j\n\n        if i % 3 == 0:\n            priorities[i] *= 1.1\n        elif i % 4 == 0:\n            priorities[i] *= 0.8\n        elif i % 6 == 0:\n            priorities[i] *= 1.5\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef complex_function(param1: int, param2: float, param3: str, param4: list) -> int:\n    result = 0\n    if param1 % 2 == 0:\n        for i in range(param1):\n            if i % 3 == 0:\n                result += i * param2\n            elif i % 5 == 0:\n                result -= i * param2\n            else:\n                result += i * param2 / 2\n\n    if param3 == \"Hello\":\n        for item in param4:\n            if isinstance(item, int):\n                result += item\n            elif isinstance(item, float):\n                result += int(item)\n            else:\n                continue\n    else:\n        return -1\n\n    return result\n```", "strategy": []}
{"timestamp": "2025-04-27 07:57:49", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.2\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.3\n        else:\n            priorities[i] += 0.4\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item <= 0:\n            raise ValueError(\"Item size must be greater than 0.\")\n        \n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.2\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.3\n        else:\n            priorities[i] += 0.4\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:58:00", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.2\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.3\n        else:\n            priorities[i] += 0.4\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.2\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.3\n        else:\n            priorities[i] += 0.4\n\n    for i in range(len(priorities)):\n        if item * 3 == bins[i]:\n            priorities[i] += 1.0\n        elif item * 2 == bins[i]:\n            priorities[i] += 0.75\n        elif item > 7 and item < 10:\n            priorities[i] -= 1.0\n\n        count = 0\n        for digit in str(int(item)):\n            if int(digit) % 2 == 0:\n                count += 1\n        priorities[i] += count * 0.5\n\n        if item > 25 and remaining_capacity < 5:\n            priorities[i] -= 1.5\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:58:08", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.2\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.3\n        else:\n            priorities[i] += 0.4\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n                if item % 2 == 0:\n                    priorities[i] += 0.25\n\n                if item % 3 == 0:\n                    priorities[i] *= 2.0\n\n                if i > 0:\n                    priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n                if item % 5 == 0:\n                    priorities[i] += 1.5\n\n                    if item > 15:\n                        if i % 4 == 0:\n                            priorities[i] -= 0.25\n                        elif i % 4 == 1:\n                            priorities[i] += 0.5\n                        elif i % 4 == 2:\n                            priorities[i] -= 0.75\n                        else:\n                            priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.2\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.3\n        else:\n            priorities[i] += 0.4\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:58:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    if item <= 0:\n        raise ValueError(\"Item size must be greater than 0.\")\n\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.2\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.3\n        else:\n            priorities[i] += 0.4\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if bins[i] < item:\n            priorities[i] = -1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 1.0 / (1.0 + remaining_capacity) + 0.5\n            else:\n                priorities[i] = 2.0\n\n            if i % 2 == 0:\n                priorities[i] *= 1.5\n\n            if item % 2 == 0:\n                priorities[i] += 0.25\n\n            if item > 5 and remaining_capacity < 10:\n                priorities[i] += 1.0\n\n            if item % 3 == 0:\n                priorities[i] *= 2.0\n\n            if i > 0:\n                priorities[i] += priorities[i - 1] / 3\n\n            if item > 10 and bins[i] >= item * 2:\n                priorities[i] += 2.0\n\n            if i % 3 == 0:\n                priorities[i] -= 0.5\n\n            if item % 5 == 0:\n                priorities[i] += 1.5\n\n            if item > 15:\n                if i % 4 == 0:\n                    priorities[i] -= 0.25\n                elif i % 4 == 1:\n                    priorities[i] += 0.5\n                elif i % 4 == 2:\n                    priorities[i] -= 0.75\n                else:\n                    priorities[i] += 1.0\n\n    for _ in range(3):\n        for i in range(len(priorities)):\n            if priorities[i] < 0.5:\n                priorities[i] -= 0.25\n            elif priorities[i] < 1.5:\n                priorities[i] += 0.75\n            else:\n                priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 1.0:\n            priorities[i] += 2.0\n        else:\n            priorities[i] -= 0.5\n\n    for j in range(5):\n        for i in range(len(priorities)):\n            if priorities[i] < j:\n                priorities[i] -= 0.25\n            else:\n                priorities[i] += 0.5\n\n    if item > 20:\n        for i in range(len(priorities)):\n            if i % 2 == 1:\n                priorities[i] -= 1.0\n            else:\n                priorities[i] += 0.5\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.25\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.75\n        else:\n            priorities[i] += 1.0\n\n    for i in range(len(priorities)):\n        if priorities[i] < 0.5:\n            priorities[i] -= 0.2\n        elif priorities[i] < 1.5:\n            priorities[i] += 0.3\n        else:\n            priorities[i] += 0.4\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:58:31", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n\n    return final_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] = np.power(priorities[j], 2)\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] = np.exp(priorities[j])\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] = np.log(priorities[j] + 1)\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities", "strategy": []}
{"timestamp": "2025-04-27 07:58:37", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n\n    return final_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    final_final_priorities = np.zeros_like(final_priorities)\n    \n    for n in range(len(bins)):\n        if final_priorities[n] < 15:\n            final_final_priorities[n] = final_priorities[n] + item\n        elif final_priorities[n] >= 15 and final_priorities[n] < 25:\n            final_final_priorities[n] = final_priorities[n] - item\n        else:\n            final_final_priorities[n] = final_priorities[n] * 1.1\n    \n    return final_final_priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:58:41", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n\n    return final_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) * np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.5:\n            priorities[i] = np.tanh(item) + np.tanh(bins[i])\n        elif ratios[i] >= 0.5 and ratios[i] < 0.7:\n            priorities[i] = np.log(np.square(item - bins[i]) + 1)\n        elif ratios[i] >= 0.7 and ratios[i] < 0.9:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i] + 1))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) + np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 2)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 15:\n            priorities[j] *= 1.8\n        elif priorities[j] >= 15 and priorities[j] < 25:\n            priorities[j] *= 2.5\n        elif priorities[j] >= 25 and priorities[j] < 35:\n            priorities[j] /= 1.5\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 3 == 0:\n            priorities[k] += item * 2\n        else:\n            priorities[k] -= item / 5\n        \n        if item > 15:\n            priorities[k] *= 1.8\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:4]:\n            final_priorities[m] = priorities[m] * 1.3\n        else:\n            final_priorities[m] = priorities[m] * 0.7\n    \n    return final_priorities", "strategy": []}
{"timestamp": "2025-04-27 07:58:46", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n\n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n\n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n\n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n\n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n\n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n\n    return final_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.2 and ratios[i] < 0.4:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 0.4 and ratios[i] < 0.6:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 0.6 and ratios[i] < 0.8:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 10:\n            priorities[j] *= 2\n        elif priorities[j] >= 10 and priorities[j] < 20:\n            priorities[j] *= 3\n        elif priorities[j] >= 20 and priorities[j] < 30:\n            priorities[j] /= 2\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 2 == 0:\n            priorities[k] += item\n        else:\n            priorities[k] -= item / 2\n        \n        if item > 10:\n            priorities[k] *= 1.5\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:3]:\n            final_priorities[m] = priorities[m] * 1.2\n        else:\n            final_priorities[m] = priorities[m] * 0.8\n    \n    return final_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.5:\n            priorities[i] = np.power(np.sin(item) + np.cos(bins[i]), 2)\n        elif ratios[i] >= 0.5 and ratios[i] < 1.0:\n            priorities[i] = np.tan(item) + np.tan(bins[i])\n        elif ratios[i] >= 1.0 and ratios[i] < 1.5:\n            priorities[i] = np.log(np.abs(item - bins[i]) + 1)\n        elif ratios[i] >= 1.5 and ratios[i] < 2.0:\n            priorities[i] = np.arctan(np.sqrt(item * bins[i]))\n        else:\n            priorities[i] = np.cosh(np.exp(ratios[i])) * np.tanh(np.sqrt(ratios[i])) - np.log(ratios[i] + 1)\n    \n    for j in range(len(bins)):\n        if priorities[j] < 15:\n            priorities[j] *= 3\n        elif priorities[j] >= 15 and priorities[j] < 30:\n            priorities[j] *= 4\n        elif priorities[j] >= 30 and priorities[j] < 45:\n            priorities[j] /= 3\n        else:\n            priorities[j] = np.sqrt(priorities[j])\n    \n    for k in range(len(bins)):\n        if priorities[k] % 3 == 0:\n            priorities[k] += item / 2\n        else:\n            priorities[k] -= item / 3\n        \n        if item > 15:\n            priorities[k] *= 1.8\n        else:\n            priorities[k] = np.exp(priorities[k])\n    \n    unique_priorities = np.unique(priorities)\n    sorted_priorities = np.sort(unique_priorities)[::-1]\n    final_priorities = np.zeros_like(priorities)\n    \n    for m in range(len(bins)):\n        if priorities[m] in sorted_priorities[:4]:\n            final_priorities[m] = priorities[m] * 1.4\n        else:\n            final_priorities[m] = priorities[m] * 0.9\n    \n    return final_priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:59:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            \n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count >= 2:\n                priorities[i] += 0.2\n            elif count == 1:\n                priorities[i] -= 0.1\n                \n            if item >= 5:\n                priorities[i] += 0.3\n            elif item < 3:\n                priorities[i] -= 0.2\n            \n            if bins[i] % 2 == 0:\n                priorities[i] *= 1.1\n            else:\n                priorities[i] *= 0.9\n                \n            for j in range(i):\n                if bins[i] > bins[j]:\n                    priorities[i] += 0.05\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n            for j in range(1, count):\n                priorities[i] += j * 0.1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 4:\n                priorities[i] += 1.5\n            elif count == 3:\n                priorities[i] -= 1.0\n            elif count == 2:\n                priorities[i] += 0.7\n            else:\n                priorities[i] += 0.2\n            \n            for j in range(1, count):\n                priorities[i] += j * 0.2\n            \n            if item >= 7:\n                priorities[i] += 0.5\n            else:\n                priorities[i] -= 0.3\n                \n            if item % 3 == 0:\n                priorities[i] *= 1.2\n            else:\n                priorities[i] *= 0.8\n                \n            for k in range(len(bins)):\n                if bins[k] % 3 == 0:\n                    priorities[i] += 0.1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:59:17", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            \n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count >= 2:\n                priorities[i] += 0.2\n            elif count == 1:\n                priorities[i] -= 0.1\n                \n            if item >= 5:\n                priorities[i] += 0.3\n            elif item < 3:\n                priorities[i] -= 0.2\n            \n            if bins[i] % 2 == 0:\n                priorities[i] *= 1.1\n            else:\n                priorities[i] *= 0.9\n                \n            for j in range(i):\n                if bins[i] > bins[j]:\n                    priorities[i] += 0.05\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n            for j in range(1, count):\n                priorities[i] += j * 0.1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n            for j in range(1, count):\n                priorities[i] += j * 0.1\n                \n            if item >= 10:\n                priorities[i] += 0.5\n            elif item < 5:\n                priorities[i] -= 0.3\n                \n            if bins[i] % 3 == 0:\n                priorities[i] *= 1.2\n            else:\n                priorities[i] *= 0.8\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:59:21", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            \n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count >= 2:\n                priorities[i] += 0.2\n            elif count == 1:\n                priorities[i] -= 0.1\n                \n            if item >= 5:\n                priorities[i] += 0.3\n            elif item < 3:\n                priorities[i] -= 0.2\n            \n            if bins[i] % 2 == 0:\n                priorities[i] *= 1.1\n            else:\n                priorities[i] *= 0.9\n                \n            for j in range(i):\n                if bins[i] > bins[j]:\n                    priorities[i] += 0.05\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n            for j in range(1, count):\n                priorities[i] += j * 0.1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 4:\n                priorities[i] += 1.5\n            elif count == 4:\n                priorities[i] -= 0.8\n            elif count == 3:\n                priorities[i] += 0.7\n            elif count == 2:\n                priorities[i] += 0.3\n            else:\n                priorities[i] -= 0.2\n                \n            for j in range(1, count):\n                priorities[i] += j * 0.2\n            priorities[i] *= 1.1\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:59:24", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            \n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count >= 2:\n                priorities[i] += 0.2\n            elif count == 1:\n                priorities[i] -= 0.1\n                \n            if item >= 5:\n                priorities[i] += 0.3\n            elif item < 3:\n                priorities[i] -= 0.2\n            \n            if bins[i] % 2 == 0:\n                priorities[i] *= 1.1\n            else:\n                priorities[i] *= 0.9\n                \n            for j in range(i):\n                if bins[i] > bins[j]:\n                    priorities[i] += 0.05\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if count > 3:\n                priorities[i] += 1.0\n            elif count == 2:\n                priorities[i] -= 0.5\n            else:\n                priorities[i] += 0.1\n            for j in range(1, count):\n                priorities[i] += j * 0.1\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + 0.1\n        elif bins[i] >= item / 2:\n            priorities[i] = 0.5 * item / bins[i] + 0.2\n        else:\n            count = 0\n            while item > bins[i]:\n                item -= bins[i]\n                count += 1\n            if count % 2 == 0:\n                priorities[i] = 0.8 * count + item / bins[i] + 0.3\n            else:\n                priorities[i] = 0.7 * count + item / bins[i] + 0.3\n            \n            if bins[i] % 2 == 0:\n                priorities[i] += 0.2\n            else:\n                priorities[i] -= 0.1\n            \n            if count > 4:\n                priorities[i] += 1.5\n            elif count == 3:\n                priorities[i] -= 0.7\n            elif count == 2:\n                priorities[i] += 0.3\n            elif count == 1:\n                priorities[i] += 0.1\n            else:\n                priorities[i] -= 0.2\n            \n            for j in range(i):\n                if bins[i] > bins[j]:\n                    priorities[i] += 0.05 * (i - j)\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:59:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            if item < 0.5 * bins[i]:\n                priorities[i] = 0.3\n            elif item >= 0.5 * bins[i] and item < bins[i]:\n                priorities[i] = 0.5\n        elif priorities[i] > 1.5 and item < 3 * bins[i]:\n            if item < 2 * bins[i]:\n                priorities[i] = 1.7\n            elif item >= 2 * bins[i] and item < 2.5 * bins[i]:\n                priorities[i] = 1.9\n            elif item >= 2.5 * bins[i] and item < 3 * bins[i]:\n                priorities[i] = 1.95\n        elif item >= 3 * bins[i] and item < 4 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 3.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5 and item < 3 * bins[i]:\n            priorities[i] = 1.5\n        elif item >= 3 * bins[i] and item < 4 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 3.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n        \n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.3\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n            \n        if priorities[i] < 0.5:\n            if item < 0.4 * bins[i]:\n                priorities[i] = 0.3\n            elif item >= 0.4 * bins[i] and item < 0.8 * bins[i]:\n                priorities[i] = 0.4\n            elif item >= 0.8 * bins[i] and item < bins[i]:\n                priorities[i] = 0.5\n        elif priorities[i] > 1.5:\n            if item < 3 * bins[i]:\n                if item < 2 * bins[i]:\n                    priorities[i] = 1.6\n                elif item >= 2 * bins[i] and item < 3 * bins[i]:\n                    priorities[i] = 1.8\n            elif item >= 3 * bins[i]:\n                priorities[i] *= 2.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 3.0\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:59:38", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            if item < 0.5 * bins[i]:\n                priorities[i] = 0.3\n            elif item >= 0.5 * bins[i] and item < bins[i]:\n                priorities[i] = 0.5\n        elif priorities[i] > 1.5 and item < 3 * bins[i]:\n            if item < 2 * bins[i]:\n                priorities[i] = 1.7\n            elif item >= 2 * bins[i] and item < 2.5 * bins[i]:\n                priorities[i] = 1.9\n            elif item >= 2.5 * bins[i] and item < 3 * bins[i]:\n                priorities[i] = 1.95\n        elif item >= 3 * bins[i] and item < 4 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 3.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5 and item < 3 * bins[i]:\n            priorities[i] = 1.5\n        elif item >= 3 * bins[i] and item < 4 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 3.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 3 * bins[i]:\n            priorities[i] *= 1.8\n        elif item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.3\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.2\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 2.0 and item < 5 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 5 * bins[i]:\n            priorities[i] = 2.5\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 07:59:42", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            if item < 0.5 * bins[i]:\n                priorities[i] = 0.3\n            elif item >= 0.5 * bins[i] and item < bins[i]:\n                priorities[i] = 0.5\n        elif priorities[i] > 1.5 and item < 3 * bins[i]:\n            if item < 2 * bins[i]:\n                priorities[i] = 1.7\n            elif item >= 2 * bins[i] and item < 2.5 * bins[i]:\n                priorities[i] = 1.9\n            elif item >= 2.5 * bins[i] and item < 3 * bins[i]:\n                priorities[i] = 1.95\n        elif item >= 3 * bins[i] and item < 4 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 3.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5 and item < 3 * bins[i]:\n            priorities[i] = 1.5\n        elif item >= 3 * bins[i] and item < 4 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 3.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v3(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            if item < 0.5 * bins[i]:\n                priorities[i] = 0.3\n            elif item >= 0.5 * bins[i] and item < bins[i]:\n                priorities[i] = 0.5\n        elif priorities[i] > 1.5 and item < 3 * bins[i]:\n            if item < 2 * bins[i]:\n                priorities[i] = 1.7\n            elif item >= 2 * bins[i] and item < 2.5 * bins[i]:\n                priorities[i] = 1.9\n            elif item >= 2.5 * bins[i] and item < 3 * bins[i]:\n                priorities[i] = 1.95\n        elif item >= 3 * bins[i] and item < 4 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 3.0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 07:59:45", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            if item < 0.5 * bins[i]:\n                priorities[i] = 0.3\n            elif item >= 0.5 * bins[i] and item < bins[i]:\n                priorities[i] = 0.5\n        elif priorities[i] > 1.5 and item < 3 * bins[i]:\n            if item < 2 * bins[i]:\n                priorities[i] = 1.7\n            elif item >= 2 * bins[i] and item < 2.5 * bins[i]:\n                priorities[i] = 1.9\n            elif item >= 2.5 * bins[i] and item < 3 * bins[i]:\n                priorities[i] = 1.95\n        elif item >= 3 * bins[i] and item < 4 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 3.0\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if priorities[i] < 0.5:\n            priorities[i] = 0.5\n        elif priorities[i] > 1.5 and item < 3 * bins[i]:\n            priorities[i] = 1.5\n        elif item >= 3 * bins[i] and item < 4 * bins[i]:\n            priorities[i] = 2.0\n        elif item >= 4 * bins[i]:\n            priorities[i] = 3.0\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1.0\n\n        if item > 2 * bins[i]:\n            priorities[i] *= 1.5\n        elif item > 1.5 * bins[i]:\n            priorities[i] *= 1.2\n        elif item > 1.2 * bins[i]:\n            priorities[i] *= 1.1\n\n        if item % 2 == 0:\n            priorities[i] += 0.5\n        else:\n            priorities[i] -= 0.5\n\n        if item < 0.25 * bins[i]:\n            priorities[i] = 0.1\n        elif item < 0.5 * bins[i]:\n            priorities[i] = 0.2\n        elif item < 0.75 * bins[i]:\n            priorities[i] = 0.3\n        elif item < bins[i]:\n            priorities[i] = 0.4\n        else:\n            priorities[i] = 1.0\n\n    return priorities\n```", "strategy": []}
