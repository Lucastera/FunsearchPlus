{"sample_order": 932, "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    def find_best_swap(current_index, remaining_space, bins, item, priorities):\n        best_swap = -1\n        max_priority_increase = -np.inf\n        for j in range(len(bins)):\n            if remaining_space[j] >= item:\n                new_priority = calculate_priority(item, bins[j])\n                priority_increase = new_priority - priorities[current_index]\n                if priority_increase > max_priority_increase:\n                    best_swap = j\n                    max_priority_increase = priority_increase\n        return best_swap\n    \n    def make_decision(current_index, remaining_space, bins, item, priorities):\n        if remaining_space[current_index] < 0:\n            best_swap = find_best_swap(current_index, remaining_space, bins, item, priorities)\n            if best_swap != -1:\n                priorities[current_index] = 0\n                priorities[best_swap] = 1\n    \n    calculate_priority = lambda item, bin_capacity: 1 + item / bin_capacity * 2 if item <= 0.5 * bin_capacity else 1 + item / bin_capacity if item <= 0.9 * bin_capacity else 1 + np.exp(item / bin_capacity)\n    \n    remaining_space = bins - item\n    priorities = np.array([calculate_priority(item, bin) for bin in bins])\n    sorted_indices = np.argsort(priorities)\n    \n    for i in sorted_indices:\n        if remaining_space[i] >= 0:\n            break\n        make_decision(i, remaining_space, bins, item, priorities)\n    \n    return priorities\n\n", "score": null}