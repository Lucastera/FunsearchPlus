{"timestamp": "2025-04-27 16:17:04", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]  # Priority based on item size compared to bin capacity\n        else:\n            priorities[i] = -1  # Priority is -1 if bin capacity is less than item size\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    # Normalize priorities to range [0, 1]\n    normalized_priorities = (priorities - min_priority) / (max_priority - min_priority)\n    \n    return normalized_priorities", "strategy": []}
{"timestamp": "2025-04-27 16:17:05", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = 1.0 / bins[i]\n        else:\n            priorities[i] = 0.5 / item\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:17:07", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = -np.log(item / bins[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 16:17:09", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = 1.0 / (bins[i] - item + 1)\n        else:\n            priorities[i] = -1.0\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:17:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(priorities)):\n        if item > bins[i]:\n            priorities[i] = -1.0\n        else:\n            ratios = item / bins[i]\n            log_ratios = np.log(ratios)\n            priorities[i] = -log_ratios\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:17:15", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0 + (bins[i] - item) / bins[i]\n        else:\n            priorities[i] = item / bins[i]\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 16:17:17", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            priorities[i] = item / bins[i]\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:17:19", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= 0:\n            priorities[i] = 0\n        elif item > bins[i]:\n            priorities[i] = -1\n        else:\n            priorities[i] = item / bins[i]\n    \n    return priorities\n", "strategy": []}
{"timestamp": "2025-04-27 16:17:21", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] >= 1.0:\n            priorities[i] = -np.log(ratios[i])\n        else:\n            priorities[i] = np.log(1 / ratios[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:17:22", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = np.inf\n        else:\n            priorities[i] = ratios[i]\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 16:17:24", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = -np.log(item / bins[i])\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:17:27", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = -1\n        else:\n            ratios = item / bins[i]\n            log_ratios = np.log(ratios)\n            priorities[i] = -log_ratios\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:17:29", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = bins[i] / item\n    \n    max_priority = np.max(priorities)\n    \n    for i in range(len(priorities)):\n        if priorities[i] == max_priority:\n            priorities[i] *= 2\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:17:31", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            priorities[i] = item / bins[i]\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:17:33", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item < bins[i] / 2:\n            priorities[i] = 1 / (item + 1)\n        elif item > bins[i]:\n            priorities[i] = np.exp(-item)\n        else:\n            priorities[i] = item / bins[i]\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:17:34", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    for i, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priorities[i] = 1.0 / item\n        else:\n            priorities[i] = 0.5 / item\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:17:38", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    \n    num_bins = len(bins)\n    priorities = np.zeros(num_bins)\n    \n    for i in range(num_bins):\n        if bins[i] >= item:\n            priorities[i] = -log_ratios[i] - 0.5\n        else:\n            priorities[i] = -log_ratios[i] + 0.5\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 16:17:41", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = -np.inf\n\n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    normalized_priorities = (priorities - min_priority) / (max_priority - min_priority)\n    \n    return normalized_priorities", "strategy": []}
{"timestamp": "2025-04-27 16:17:43", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i] - item\n            fill_percentage = item / bins[i]\n            priorities[i] = fill_percentage * (1 / remaining_capacity)\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:17:45", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    for bin_capacity in bins:\n        if item <= 0.5 * bin_capacity:\n            priority = 1 / item\n        elif item <= 0.8 * bin_capacity:\n            priority = 0.8 / item\n        else:\n            priority = 0.5 / item\n        priorities.append(priority)\n    \n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 16:17:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    total_capacity = np.sum(bins)\n    \n    for i in range(len(bins)):\n        remaining_capacity = total_capacity - np.sum(bins[:i])\n        if remaining_capacity == 0:\n            priorities[i] = np.inf\n        else:\n            priorities[i] = item / remaining_capacity\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:17:52", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = np.log(item / bins[i])\n        else:\n            priorities[i] = np.log(bins[i] / item)\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:17:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "import numpy as np\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for idx, bin_capacity in enumerate(bins):\n        if item <= bin_capacity:\n            priority = item / bin_capacity\n        else:\n            priority = item / np.sqrt(bin_capacity)\n        \n        priorities[idx] = priority\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:17:56", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i] - item\n            utilization_ratio = item / bins[i]\n            adjusted_priority = 1.0 / (1.0 + np.exp(-utilization_ratio))\n            priorities[i] = adjusted_priority\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:17:59", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    n_bins = len(bins)\n    priorities = np.zeros(n_bins)\n    \n    for i in range(n_bins):\n        if item <= bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = 1 / (item - bins[i])\n            \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 16:18:01", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = (bins[i] - item) / bins[i]\n        else:\n            priorities[i] = -1\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:18:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            priorities[i] = item / bins[i]\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 16:18:05", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    bin_ranges = bins - item\n    \n    for i in range(len(bins)):\n        if bin_ranges[i] > 0:\n            priorities[i] = 1 / bin_ranges[i]\n        else:\n            priorities[i] = np.inf\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 16:18:07", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item > bins[i]:\n            priorities[i] = 0\n        elif item == bins[i]:\n            priorities[i] = 1\n        else:\n            ratios = item / bins[i]\n            log_ratios = np.log(ratios)\n            priorities[i] = -log_ratios\n    return priorities\n", "strategy": []}
{"timestamp": "2025-04-27 16:18:10", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    if item > np.max(bins):\n        priorities = np.full_like(bins, -np.inf)\n    else:\n        for i in range(len(bins)):\n            if bins[i] >= item:\n                priorities[i] = -np.log(item / bins[i])\n            else:\n                priorities[i] = -np.inf\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:18:12", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item < 0.5 * bins[i]:\n            priorities[i] = 1.0 / (bins[i] - item)\n        elif item < 0.8 * bins[i]:\n            priorities[i] = 0.8 / (bins[i] - item)\n        else:\n            priorities[i] = 0.5 / (bins[i] - item)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 16:18:15", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = -1 * (item - bins[i])\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    normalized_priorities = (priorities - min_priority) / (max_priority - min_priority)\n    \n    return normalized_priorities", "strategy": []}
{"timestamp": "2025-04-27 16:18:19", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0 / bins[i]\n        else:\n            priorities[i] = 0.5\n        \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:18:21", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item > bin_capacity:\n            priority = 0\n        else:\n            priority = 1 / (bin_capacity - item + 1)\n        priorities.append(priority)\n    \n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 16:18:23", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if ratios[i] < 0.2:\n            priorities[i] = 2 * ratios[i]\n        elif ratios[i] >= 0.2 and ratios[i] < 0.5:\n            priorities[i] = 3 * ratios[i]\n        else:\n            priorities[i] = 5 * ratios[i]\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:18:26", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            priorities[i] = bins[i] / item\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:18:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            priority = bin_capacity - item\n        else:\n            priority = 0\n        priorities.append(priority)\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 16:18:31", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins, dtype=float)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity > 0:\n                priorities[i] = 0.5 + remaining_capacity / bins[i]\n            else:\n                priorities[i] = 0.1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 16:18:33", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = 1.0 / (bins[i] - item)\n        else:\n            priorities[i] = 0.0\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:18:35", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = 1 / (bins[i] - item + 1)\n        else:\n            priorities[i] = 1 / (item - bins[i] + 1)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:18:38", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i] - item\n            fill_percentage = item / bins[i]\n            priorities[i] = fill_percentage * (1 / remaining_capacity)\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i] - item\n            fill_percentage = item / bins[i]\n            priorities[i] = fill_percentage * (1 / remaining_capacity)\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] < item / 2:\n            priorities[i] = 0.5\n        else:\n            remaining_capacity = bins[i] - item\n            fill_percentage = item / bins[i]\n            if fill_percentage >= 0.7:\n                priorities[i] = 0.8\n            else:\n                priorities[i] = fill_percentage * (1 / remaining_capacity)\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:18:41", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i] - item\n            fill_percentage = item / bins[i]\n            priorities[i] = fill_percentage * (1 / remaining_capacity)\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i] - item\n            fill_percentage = item / bins[i]\n            priorities[i] = fill_percentage * (1 / remaining_capacity)\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i] - item\n            fill_percentage = item / bins[i]\n            \n            if fill_percentage <= 0.5:\n                priorities[i] = fill_percentage * (1 / remaining_capacity)\n            elif fill_percentage > 0.5 and fill_percentage <= 0.8:\n                priorities[i] = fill_percentage * 2 * (1 / remaining_capacity)\n            else:\n                priorities[i] = fill_percentage * 3 * (1 / remaining_capacity)\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:18:44", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i] - item\n            fill_percentage = item / bins[i]\n            priorities[i] = fill_percentage * (1 / remaining_capacity)\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i] - item\n            fill_percentage = item / bins[i]\n            priorities[i] = fill_percentage * (1 / remaining_capacity)\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i] - item\n            fill_percentage = item / bins[i]\n            if fill_percentage >= 0.5:\n                priorities[i] = fill_percentage * (1 / remaining_capacity) * 1.5\n            else:\n                priorities[i] = fill_percentage * (1 / remaining_capacity)\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:18:47", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i] - item\n            fill_percentage = item / bins[i]\n            priorities[i] = fill_percentage * (1 / remaining_capacity)\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i] - item\n            fill_percentage = item / bins[i]\n            priorities[i] = fill_percentage * (1 / remaining_capacity)\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    if item <= 0:\n        raise ValueError(\"Item size must be a positive number.\")\n\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i] - item\n            if remaining_capacity < 0:\n                priorities[i] = 0.0\n            else:\n                fill_percentage = item / bins[i]\n                if fill_percentage > 0.5:\n                    priorities[i] = fill_percentage * (1 / remaining_capacity)\n                else:\n                    priorities[i] = fill_percentage\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:18:51", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]  # Priority based on item size compared to bin capacity\n        else:\n            priorities[i] = -1  # Priority is -1 if bin capacity is less than item size\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    # Normalize priorities to range [0, 1]\n    normalized_priorities = (priorities - min_priority) / (max_priority - min_priority)\n    \n    return normalized_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]  # Priority based on item size compared to bin capacity\n        else:\n            priorities[i] = -1  # Priority is -1 if bin capacity is less than item size\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    # Normalize priorities to range [0, 1]\n    normalized_priorities = (priorities - min_priority) / (max_priority - min_priority)\n    \n    return normalized_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Even more improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]  # Priority based on item size compared to bin capacity\n        else:\n            priorities[i] = -1  # Priority is -1 if bin capacity is less than item size\n    \n    for i in range(len(bins)):\n        if priorities[i] > 0.5:\n            priorities[i] *= 2  # Double the priority if it's above 0.5\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    # Normalize priorities to range [0, 1]\n    normalized_priorities = (priorities - min_priority) / (max_priority - min_priority)\n    \n    return normalized_priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 16:18:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]  # Priority based on item size compared to bin capacity\n        else:\n            priorities[i] = -1  # Priority is -1 if bin capacity is less than item size\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    # Normalize priorities to range [0, 1]\n    normalized_priorities = (priorities - min_priority) / (max_priority - min_priority)\n    \n    return normalized_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]  # Priority based on item size compared to bin capacity\n        else:\n            priorities[i] = -1  # Priority is -1 if bin capacity is less than item size\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    # Normalize priorities to range [0, 1]\n    normalized_priorities = (priorities - min_priority) / (max_priority - min_priority)\n    \n    return normalized_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = (item + bins[i]) / (2 * bins[i])  # Adjusted priority formula\n        else:\n            priorities[i] = 0  # Priority is 0 if bin capacity is less than item size\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    # Normalize priorities to range [0, 1]\n    normalized_priorities = (priorities - min_priority) / (max_priority - min_priority)\n    \n    return normalized_priorities", "strategy": []}
{"timestamp": "2025-04-27 16:18:58", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]  # Priority based on item size compared to bin capacity\n        else:\n            priorities[i] = -1  # Priority is -1 if bin capacity is less than item size\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    # Normalize priorities to range [0, 1]\n    normalized_priorities = (priorities - min_priority) / (max_priority - min_priority)\n    \n    return normalized_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]  # Priority based on item size compared to bin capacity\n        else:\n            priorities[i] = -1  # Priority is -1 if bin capacity is less than item size\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    # Normalize priorities to range [0, 1]\n    normalized_priorities = (priorities - min_priority) / (max_priority - min_priority)\n    \n    return normalized_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0  # Priority is 0 if bin capacity is 0\n        elif bins[i] >= item:\n            priorities[i] = (item / bins[i]) * (1 if item > 0.5 * bins[i] else 0.5)  # Adjust priority based on item size compared to bin capacity\n        else:\n            priorities[i] = -1  # Priority is -1 if bin capacity is less than item size\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    # Normalize priorities to range [0, 1]\n    normalized_priorities = (priorities - min_priority) / (max_priority - min_priority)\n    \n    # Increase priority for bins with capacity more than item size if item is a high percentage of the bin capacity\n    for i in range(len(bins)):\n        if priorities[i] > 0 and item > 0.7 * bins[i]:\n            normalized_priorities[i] += 0.1  # Adjust priority for certain cases\n    \n    return normalized_priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 16:19:02", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]  # Priority based on item size compared to bin capacity\n        else:\n            priorities[i] = -1  # Priority is -1 if bin capacity is less than item size\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    # Normalize priorities to range [0, 1]\n    normalized_priorities = (priorities - min_priority) / (max_priority - min_priority)\n    \n    return normalized_priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]  # Priority based on item size compared to bin capacity\n        else:\n            priorities[i] = -1  # Priority is -1 if bin capacity is less than item size\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    # Normalize priorities to range [0, 1]\n    normalized_priorities = (priorities - min_priority) / (max_priority - min_priority)\n    \n    return normalized_priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i] + (bins[i] - item) * 0.1  # Adjusted priority based on item size and remaining space in bin\n        else:\n            priorities[i] = (item - bins[i]) * 0.2  # Penalty for bins with less capacity than item size\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    # Normalize priorities to range [0, 1]\n    normalized_priorities = (priorities - min_priority) / (max_priority - min_priority)\n    \n    return normalized_priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 16:19:05", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if item <= bins[i] / 2:\n            priorities[i] = 1.0\n        elif bins[i] / 2 < item <= bins[i]:\n            priorities[i] = 0.7\n        else:\n            priorities[i] = 0.5\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:19:07", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1 / (bins[i] - item + 1)\n        else:\n            priorities[i] = -1\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:19:10", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    \n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if ratios[i] >= 0.5:\n            priorities[i] = log_ratios[i] + 1\n        elif ratios[i] >= 0.3:\n            priorities[i] = log_ratios[i] + 0.5\n        else:\n            priorities[i] = log_ratios[i]\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 16:19:11", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    for idx, bin_capacity in enumerate(bins):\n        if bin_capacity >= item:\n            priority = 1 / bin_capacity\n        else:\n            priority = np.exp((item - bin_capacity) / (2 * bin_capacity))\n        priorities.append(priority)\n    return np.array(priorities)", "strategy": []}
