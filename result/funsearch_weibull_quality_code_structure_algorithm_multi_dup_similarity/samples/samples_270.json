{"sample_order": 270, "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    \"\"\"\n    Calculates the priority with which we want to add item to each bin, considering bin capacities and priorities.\n\n    Args:\n        item: Size of item to be added to the bins.\n        bins: Array of capacities for each bin.\n\n    Returns:\n        Array of the same size as bins with priority scores for each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    total_capacity = np.sum(bins)\n    \n    if item > total_capacity:\n        priorities[np.argmax(bins)] = 1.0\n        return priorities\n    \n    remaining_bins = bins.copy()\n    \n    # Assign priority based on available capacity in each bin\n    for i in range(len(bins)):\n        if remaining_bins[i] >= item:\n            priorities[i] = item / remaining_bins[i]\n            break\n        else:\n            priorities[i] = remaining_bins[i] / item\n            item -= remaining_bins[i]\n            remaining_bins[i] = 0\n            if item == 0:\n                break\n    \n    min_capacity_bin = np.argmin(bins)\n    max_capacity_bin = np.argmax(bins)\n    \n    # Adjust priorities based on the bin capacities\n    if priorities[min_capacity_bin] < 0.2:\n        priorities[min_capacity_bin] = 0.5 * priorities[min_capacity_bin]\n    \n    if priorities[max_capacity_bin] > 0.8:\n        priorities[max_capacity_bin] = 0.9 * priorities[max_capacity_bin]\n    \n    # Ensure that the sum of priorities is normalized to 1\n    sum_priorities = np.sum(priorities)\n    if sum_priorities == 0:\n        return np.zeros_like(bins)\n    else:\n        priorities /= sum_priorities\n    \n    return priorities\n\n", "score": null}