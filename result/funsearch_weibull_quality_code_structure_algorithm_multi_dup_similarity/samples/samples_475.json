{"sample_order": 475, "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    def calculate_priority_score(item, capacity):\n        return np.exp(-(item - capacity) ** 2)\n    \n    def update_remaining_capacity(remaining_capacity, bin_index, item):\n        remaining_capacity[bin_index] -= item\n    \n    priority_scores = np.zeros_like(bins)\n    remaining_capacity = bins.copy()\n    \n    for i in range(len(bins)):\n        if remaining_capacity[i] >= item:\n            priority_scores[i] = calculate_priority_score(item, bins[i])\n            update_remaining_capacity(remaining_capacity, i, item)\n            break\n        else:\n            priority_scores[i] = calculate_priority_score(remaining_capacity[i], bins[i])\n            update_remaining_capacity(remaining_capacity, i, remaining_capacity[i])\n            item -= remaining_capacity[i]\n    \n    # Additional logic to adjust priority scores based on future impact\n    for j in range(len(bins)):\n        future_impact = calculate_future_impact(item, remaining_capacity[j])\n        priority_scores[j] *= future_impact\n    \n    # Add preprocessing step to handle edge cases\n    if np.max(priority_scores) == 0:\n        priority_scores = np.ones_like(bins)\n    \n    return priority_scores\n\n", "score": null}