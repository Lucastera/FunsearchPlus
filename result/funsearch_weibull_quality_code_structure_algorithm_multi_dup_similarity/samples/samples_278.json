{"sample_order": 278, "function": "def priority(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    def preprocess_data(data: np.ndarray) -> np.ndarray:\n        # Normalize data\n        norm_data = (data - np.mean(data)) / np.std(data)\n\n        return norm_data\n\n    def calculate_distance(point1: np.ndarray, point2: np.ndarray) -> float:\n        # Euclidean distance calculation\n        return np.sqrt(np.sum((point1 - point2) ** 2))\n\n    def find_closest_point(data: np.ndarray, target: float) -> np.ndarray:\n        closest_point = None\n        min_distance = np.inf\n\n        for point in data:\n            distance = calculate_distance(point, np.array([target]))\n            if distance < min_distance:\n                min_distance = distance\n                closest_point = point\n\n        return closest_point\n\n    def process_data(data: np.ndarray, target: float) -> np.ndarray:\n        processed_data = []\n\n        for point in data:\n            if np.mean(point) > target:\n                processed_data.append(point * 2)\n            elif np.mean(point) < target:\n                processed_data.append(point / 2)\n            else:\n                processed_data.append(point)\n\n        return np.array(processed_data)\n\n    normalized_data = preprocess_data(data)\n    closest_point = find_closest_point(normalized_data, target)\n    processed_data = process_data(data, target)\n\n    return processed_data\n\n", "score": null}