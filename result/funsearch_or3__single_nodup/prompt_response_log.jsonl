{"timestamp": "2025-04-27 16:17:22", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            priority_score = (item - bins[i]) / bins[i]\n            priorities[i] = max(0, 1 - priority_score)\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 16:17:24", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i] - item\n            priority = 1 / np.exp(1 - abs(remaining_capacity / item))\n            priorities[i] = priority\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:17:26", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0 / bins[i]\n        else:\n            priorities[i] = -1.0 * (item - bins[i])\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 16:17:29", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    if len(bins) == 0:\n        return np.array([])\n\n    priorities = np.zeros(len(bins))\n    max_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            priorities[i] = bins[i] / max_capacity\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 16:17:34", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = 1.0 / (bins[i] - item)\n        else:\n            priorities[i] = 0.0\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:17:37", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = 1 / bins[i]\n        else:\n            priorities[i] = 1 / (item - bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:17:39", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(bins.shape)\n    for i in range(len(bins)):\n        ratio = item / bins[i]\n        if ratio < 0.5:\n            priorities[i] = 1.0\n        elif ratio < 1.0:\n            priorities[i] = 0.5\n        else:\n            priorities[i] = 0.1\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 16:17:42", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] > 0:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = np.inf\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 16:17:47", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = -np.log(item / bins[i])\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:17:49", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for i in range(len(bins)):\n        if item <= bins[i]/2:\n            priority = 1.0\n        elif bins[i]/2 < item <= bins[i]*0.75:\n            priority = 0.75\n        elif bins[i]*0.75 < item <= bins[i]:\n            priority = 0.5\n        else:\n            priority = 0.25\n            \n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 16:17:51", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = np.log(item / bins[i])\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:17:53", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Further improved version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_space = bins[i] - item\n            if remaining_space > 0:\n                priorities[i] = 1 / remaining_space\n            else:\n                priorities[i] = np.inf\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:17:59", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "import numpy as np\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = 1.0\n        else:\n            priorities[i] = 1 / (item - bins[i])\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:18:01", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    total_capacity = np.sum(bins)\n    priorities = []\n    for bin_capacity in bins:\n        if bin_capacity >= item:\n            priority = 1.0\n        else:\n            remaining_capacity = total_capacity - bin_capacity\n            priority = (item - bin_capacity) / remaining_capacity\n        priorities.append(priority)\n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 16:18:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] >= 1:\n            priorities[i] = 0\n        else:\n            priorities[i] = np.exp(-np.power((ratios[i] - 1), 2))\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 16:18:05", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n    \n    for i, ratio in enumerate(ratios):\n        if ratio < 0.5:\n            priorities[i] = 1.0 / (1 + np.exp(-10 * (ratio - 0.5)))\n        elif ratio < 1.0:\n            priorities[i] = 0.5 / (1 + np.exp(-5 * (ratio - 1.0))) + 0.5\n        else:\n            priorities[i] = 1.0 / (1 + np.exp(-2 * (ratio - 1.0)))\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 16:18:12", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = 1 / bins[i]\n        else:\n            priorities[i] = 1 / (item - bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] > 0:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = np.inf\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if item < 0:\n            priorities[i] = np.nan\n        elif bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] > item / 2:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = item - bins[i]\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:18:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = 1 / bins[i]\n        else:\n            priorities[i] = 1 / (item - bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] > 0:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = np.inf\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if item <= 0:\n            priorities[i] = np.inf\n        elif bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] > 0 and item > bins[i]/2:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = (item - bins[i]) / item\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:18:17", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = 1 / bins[i]\n        else:\n            priorities[i] = 1 / (item - bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] > 0:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = np.inf\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = bins[i]\n            remaining_items = item\n            priority = 0\n            \n            while remaining_capacity > 0 and remaining_items > 0:\n                if remaining_capacity >= remaining_items:\n                    priority += remaining_items / bins[i]\n                    remaining_items = 0\n                else:\n                    priority += remaining_capacity / bins[i]\n                    remaining_items -= remaining_capacity\n                    remaining_capacity = 0\n                \n                if remaining_items > 0:\n                    closest_bin_capacity = min([x for x in bins if x > 0], key=lambda x:abs(x - remaining_items))\n                    remaining_capacity = closest_bin_capacity\n\n            priorities[i] = priority\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:18:19", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = 1 / bins[i]\n        else:\n            priorities[i] = 1 / (item - bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] > 0:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = np.inf\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray, threshold: float) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] > 0 and bins[i] < threshold:\n            priorities[i] = item / bins[i]\n        elif bins[i] >= threshold:\n            priorities[i] = 0.5\n        else:\n            priorities[i] = np.inf\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:18:25", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    total_capacity = np.sum(bins)\n    priorities = []\n    for bin_capacity in bins:\n        if bin_capacity >= item:\n            priority = 1.0\n        else:\n            remaining_capacity = total_capacity - bin_capacity\n            priority = (item - bin_capacity) / remaining_capacity\n        priorities.append(priority)\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] >= 1:\n            priorities[i] = 0\n        else:\n            priorities[i] = np.exp(-np.power((ratios[i] - 1), 2))\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 1.0\n        elif item > bins[i]:\n            priorities[i] = np.exp(-np.power((item - bins[i]), 2) / bins[i])\n        else:\n            priorities[i] = np.log(item + 1) / np.log(bins[i] + 1)\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:18:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    total_capacity = np.sum(bins)\n    priorities = []\n    for bin_capacity in bins:\n        if bin_capacity >= item:\n            priority = 1.0\n        else:\n            remaining_capacity = total_capacity - bin_capacity\n            priority = (item - bin_capacity) / remaining_capacity\n        priorities.append(priority)\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] >= 1:\n            priorities[i] = 0\n        else:\n            priorities[i] = np.exp(-np.power((ratios[i] - 1), 2))\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    total_capacity = np.sum(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_capacity = total_capacity - bins[i]\n            if remaining_capacity == 0:\n                priorities[i] = 0\n            else:\n                priority = max(0, 1 - (item - bins[i]) / remaining_capacity)\n                priorities[i] = np.exp(-np.power((priority - 1), 2))\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:18:31", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    total_capacity = np.sum(bins)\n    priorities = []\n    for bin_capacity in bins:\n        if bin_capacity >= item:\n            priority = 1.0\n        else:\n            remaining_capacity = total_capacity - bin_capacity\n            priority = (item - bin_capacity) / remaining_capacity\n        priorities.append(priority)\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] >= 1:\n            priorities[i] = 0\n        else:\n            priorities[i] = np.exp(-np.power((ratios[i] - 1), 2))\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] >= 2:\n            priorities[i] = 0\n        elif 1 < ratios[i] < 2:\n            priorities[i] = np.exp(-np.power((ratios[i] - 1), 2))\n        else:\n            remaining_capacity = np.sum(bins) - bins[i]\n            priority = (item - bins[i]) / remaining_capacity\n            priorities[i] = np.sqrt(priority)\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:18:33", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    total_capacity = np.sum(bins)\n    priorities = []\n    for bin_capacity in bins:\n        if bin_capacity >= item:\n            priority = 1.0\n        else:\n            remaining_capacity = total_capacity - bin_capacity\n            priority = (item - bin_capacity) / remaining_capacity\n        priorities.append(priority)\n    return np.array(priorities)\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] >= 1:\n            priorities[i] = 0\n        else:\n            priorities[i] = np.exp(-np.power((ratios[i] - 1), 2))\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] >= 1:\n            priorities[i] = 0\n        elif ratios[i] < 0.5:\n            priorities[i] = np.exp(-np.power((ratios[i] - 1), 2))\n        else:\n            priorities[i] = np.log((2 * ratios[i] + 1) / 3)\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:18:38", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = 1 / bins[i]\n        else:\n            priorities[i] = 0.5 / bins[i]\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:18:41", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= 0:\n            priorities[i] = np.inf\n        elif item > bins[i]:\n            priorities[i] = -np.inf\n        else:\n            priorities[i] = bins[i] / item\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:18:42", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    \n    for bin_capacity in bins:\n        if item > bin_capacity:\n            priority = 0\n        else:\n            priority = (bin_capacity - item) / bin_capacity\n        \n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 16:18:44", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    for bin_capacity in bins:\n        if item > bin_capacity:\n            priority = 0\n        else:\n            remaining_capacity = bin_capacity - item\n            priority = remaining_capacity / bin_capacity\n        priorities.append(priority)\n    return np.array(priorities)", "strategy": []}
{"timestamp": "2025-04-27 16:18:50", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = 1 / bins[i]\n        else:\n            priorities[i] = 1 / (item - bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if item <= 0:\n            priorities[i] = np.inf\n        elif bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] > 0 and item > bins[i]/2:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = (item - bins[i]) / item\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n\n    for i in range(len(bins)):\n        if bins[i] == 0:\n            priorities[i] = 0.0\n        elif item <= 0:\n            priorities[i] = np.inf\n        elif bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] > 0 and item > bins[i]/2:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = (item - bins[i]) / item\n        \n        if i % 2 == 0:\n            priorities[i] *= 2\n        else:\n            priorities[i] *= 1.5\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:18:52", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = 1 / bins[i]\n        else:\n            priorities[i] = 1 / (item - bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if item <= 0:\n            priorities[i] = np.inf\n        elif bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] > 0 and item > bins[i]/2:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = (item - bins[i]) / item\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if item <= 0:\n            priorities[i] = np.inf\n        elif bins[i] >= item:\n            priorities[i] = 1.0\n        elif item < bins[i] / 2:\n            priorities[i] = item / bins[i]\n        else:\n            priority_sum = 0\n            for j in range(len(bins)):\n                if bins[j] > 0:\n                    priority_sum += bins[j]\n            priorities[i] = bins[i] / priority_sum\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:18:55", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = 1 / bins[i]\n        else:\n            priorities[i] = 1 / (item - bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if item <= 0:\n            priorities[i] = np.inf\n        elif bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] > 0 and item > bins[i]/2:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = (item - bins[i]) / item\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if item <= 0:\n            priorities[i] = np.inf\n        elif bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] > 0 and item > bins[i]/2:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = (item - bins[i]) / item\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] *= 2\n        elif priorities[j] == min_priority:\n            priorities[j] /= 2\n            \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:18:59", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = 1 / bins[i]\n        else:\n            priorities[i] = 1 / (item - bins[i])\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if item <= 0:\n            priorities[i] = np.inf\n        elif bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] > 0 and item > bins[i]/2:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = (item - bins[i]) / item\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if item <= 0:\n            priorities[i] = np.inf\n        elif bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] > item * 0.75:\n            priorities[i] = 0.8\n        elif bins[i] > item * 0.5:\n            priorities[i] = 0.6\n        elif bins[i] > item * 0.25:\n            priorities[i] = 0.4\n        else:\n            priorities[i] = 0.2\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:19:05", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = 1 / bins[i]\n        else:\n            priorities[i] = 0.5 / bins[i]\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = 1 / bins[i]\n        else:\n            priorities[i] = 0.5 / bins[i]\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = 1 / bins[i]\n        else:\n            priority = 0.5\n            for j in range(len(bins)):\n                if bins[j] >= item:\n                    priorities[j] = priority / bins[j]\n                    priority *= 0.7\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:19:08", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = 1 / bins[i]\n        else:\n            priorities[i] = 0.5 / bins[i]\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = 1 / bins[i]\n        else:\n            priorities[i] = 0.5 / bins[i]\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Enhanced version of `priority_v1`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = item / bins[i] if item > 0.5 * bins[i] else 1 / bins[i]\n        else:\n            priorities[i] = 0.5 / bins[i] if bins[i] < 0.75 * item else 0.25 / bins[i] if bins[i] > 1.25 * item else 0.4 / bins[i]\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:19:10", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = 1 / bins[i]\n        else:\n            priorities[i] = 0.5 / bins[i]\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = 1 / bins[i]\n        else:\n            priorities[i] = 0.5 / bins[i]\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = 1 / bins[i]\n        else:\n            priorities[i] = 0.5 / bins[i]\n            if item > 2 * bins[i]:\n                priorities[i] *= 2\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:19:13", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = 1 / bins[i]\n        else:\n            priorities[i] = 0.5 / bins[i]\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if item <= bins[i]:\n            priorities[i] = 1 / bins[i]\n        else:\n            priorities[i] = 0.5 / bins[i]\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    total_capacity = np.sum(bins)\n    max_capacity = np.max(bins)\n    \n    for i in range(len(bins)):\n        if item <= 0.5 * max_capacity:\n            priorities[i] = (bins[i] / total_capacity) + (1 / bins[i])\n        elif item <= max_capacity:\n            priorities[i] = (0.75 * bins[i] / total_capacity) + (1 / bins[i])\n        else:\n            priorities[i] = 0.5 / bins[i]\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:19:20", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] >= 2:\n            priorities[i] = 0\n        elif 1 < ratios[i] < 2:\n            priorities[i] = np.exp(-np.power((ratios[i] - 1), 2))\n        else:\n            remaining_capacity = np.sum(bins) - bins[i]\n            priority = (item - bins[i]) / remaining_capacity\n            priorities[i] = np.sqrt(priority)\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] >= 2:\n            priorities[i] = 0\n        elif 1 < ratios[i] < 2:\n            priorities[i] = np.exp(-np.power((ratios[i] - 1), 2))\n        else:\n            remaining_capacity = np.sum(bins) - bins[i]\n            priority = (item - bins[i]) / remaining_capacity\n            priorities[i] = np.sqrt(priority)\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] >= 2:\n            priorities[i] = 0\n        elif 1 < ratios[i] < 2:\n            priorities[i] = np.exp(-np.power((ratios[i] - 1), 2))\n        else:\n            remaining_capacity = np.sum(bins) - bins[i]\n            if remaining_capacity > item:\n                priorities[i] = 1 - (remaining_capacity - item) / remaining_capacity\n            else:\n                min_remaining = np.min(bins)\n                priorities[i] = np.sqrt((item - min_remaining) / remaining_capacity)\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:19:22", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] >= 2:\n            priorities[i] = 0\n        elif 1 < ratios[i] < 2:\n            priorities[i] = np.exp(-np.power((ratios[i] - 1), 2))\n        else:\n            remaining_capacity = np.sum(bins) - bins[i]\n            priority = (item - bins[i]) / remaining_capacity\n            priorities[i] = np.sqrt(priority)\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] >= 2:\n            priorities[i] = 0\n        elif 1 < ratios[i] < 2:\n            priorities[i] = np.exp(-np.power((ratios[i] - 1), 2))\n        else:\n            remaining_capacity = np.sum(bins) - bins[i]\n            priority = (item - bins[i]) / remaining_capacity\n            priorities[i] = np.sqrt(priority)\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] >= 2:\n            priorities[i] = 0\n        elif 1 < ratios[i] < 2:\n            priorities[i] = np.exp(-np.power((ratios[i] - 1), 2))\n        else:\n            remaining_capacity = np.sum(bins) - bins[i]\n            if remaining_capacity < item:\n                priorities[i] = 0\n            else:\n                if item < 0.3 * bins[i]:\n                    priorities[i] = 1 / ratios[i]\n                else:\n                    priorities[i] = np.sqrt(item / remaining_capacity)\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:19:25", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] >= 2:\n            priorities[i] = 0\n        elif 1 < ratios[i] < 2:\n            priorities[i] = np.exp(-np.power((ratios[i] - 1), 2))\n        else:\n            remaining_capacity = np.sum(bins) - bins[i]\n            priority = (item - bins[i]) / remaining_capacity\n            priorities[i] = np.sqrt(priority)\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] >= 2:\n            priorities[i] = 0\n        elif 1 < ratios[i] < 2:\n            priorities[i] = np.exp(-np.power((ratios[i] - 1), 2))\n        else:\n            remaining_capacity = np.sum(bins) - bins[i]\n            priority = (item - bins[i]) / remaining_capacity\n            priorities[i] = np.sqrt(priority)\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] >= 2:\n            priorities[i] = 0\n        elif 1 < ratios[i] < 2:\n            priorities[i] = np.exp(-np.power((ratios[i] - 1), 2))\n        else:\n            remaining_capacity = np.sum(bins) - bins[i]\n            if remaining_capacity > 0:\n                priority = (item - bins[i]) / remaining_capacity\n                priorities[i] = np.sqrt(priority)\n            else:\n                priorities[i] = 0\n\n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 16:19:28", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] >= 2:\n            priorities[i] = 0\n        elif 1 < ratios[i] < 2:\n            priorities[i] = np.exp(-np.power((ratios[i] - 1), 2))\n        else:\n            remaining_capacity = np.sum(bins) - bins[i]\n            priority = (item - bins[i]) / remaining_capacity\n            priorities[i] = np.sqrt(priority)\n\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] >= 2:\n            priorities[i] = 0\n        elif 1 < ratios[i] < 2:\n            priorities[i] = np.exp(-np.power((ratios[i] - 1), 2))\n        else:\n            remaining_capacity = np.sum(bins) - bins[i]\n            priority = (item - bins[i]) / remaining_capacity\n            priorities[i] = np.sqrt(priority)\n\n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def complex_priority(item: float, bins: np.ndarray) -> np.ndarray:\n    ratios = item / bins\n    priorities = np.zeros_like(bins)\n\n    for i in range(len(bins)):\n        if ratios[i] >= 2:\n            priorities[i] = 0\n        elif 1 < ratios[i] < 2:\n            priorities[i] = np.exp(-np.power((ratios[i] - 1), 2))\n        else:\n            remaining_capacity = np.sum(bins) - bins[i]\n            if remaining_capacity > 0:\n                priority = (item - bins[i]) / remaining_capacity\n                if priority > 0:\n                    priorities[i] = np.sqrt(priority)\n                else:\n                    priorities[i] = 0\n            else:\n                priorities[i] = 0\n\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:19:36", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if item <= 0:\n            priorities[i] = np.inf\n        elif bins[i] >= item:\n            priorities[i] = 1.0\n        elif item < bins[i] / 2:\n            priorities[i] = item / bins[i]\n        else:\n            priority_sum = 0\n            for j in range(len(bins)):\n                if bins[j] > 0:\n                    priority_sum += bins[j]\n            priorities[i] = bins[i] / priority_sum\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if item <= 0:\n            priorities[i] = np.inf\n        elif bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] > 0 and item > bins[i]/2:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = (item - bins[i]) / item\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] *= 2\n        elif priorities[j] == min_priority:\n            priorities[j] /= 2\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    if np.all(bins == 0):\n        return priorities\n    \n    for i in range(len(bins)):\n        if item <= 0:\n            priorities[i] = np.inf\n        elif bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] > item and item < 0.5 * bins[i]:\n            priorities[i] = item / bins[i]\n        else:\n            priority_sum = 0\n            for j in range(len(bins)):\n                if bins[j] > bins[i] / 2:\n                    priority_sum += bins[j]\n            if priority_sum > 0:\n                priorities[i] = bins[i] / priority_sum\n            else:\n                priorities[i] = np.inf\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:19:39", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if item <= 0:\n            priorities[i] = np.inf\n        elif bins[i] >= item:\n            priorities[i] = 1.0\n        elif item < bins[i] / 2:\n            priorities[i] = item / bins[i]\n        else:\n            priority_sum = 0\n            for j in range(len(bins)):\n                if bins[j] > 0:\n                    priority_sum += bins[j]\n            priorities[i] = bins[i] / priority_sum\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if item <= 0:\n            priorities[i] = np.inf\n        elif bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] > 0 and item > bins[i]/2:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = (item - bins[i]) / item\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] *= 2\n        elif priorities[j] == min_priority:\n            priorities[j] /= 2\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if item <= 0:\n            priorities[i] = np.inf\n        elif bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            priority_sum = 0\n            for j in range(len(bins)):\n                if bins[j] > 0:\n                    priority_sum += bins[j]\n            \n            if item > priority_sum:\n                priorities[i] = item / priority_sum\n            else:\n                priorities[i] = bins[i] / priority_sum\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for k in range(len(priorities)):\n        if priorities[k] == max_priority:\n            priorities[k] = max_priority * 1.5\n        elif priorities[k] == min_priority:\n            priorities[k] = min_priority * 0.75\n    \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:19:42", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if item <= 0:\n            priorities[i] = np.inf\n        elif bins[i] >= item:\n            priorities[i] = 1.0\n        elif item < bins[i] / 2:\n            priorities[i] = item / bins[i]\n        else:\n            priority_sum = 0\n            for j in range(len(bins)):\n                if bins[j] > 0:\n                    priority_sum += bins[j]\n            priorities[i] = bins[i] / priority_sum\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if item <= 0:\n            priorities[i] = np.inf\n        elif bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] > 0 and item > bins[i]/2:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = (item - bins[i]) / item\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] *= 2\n        elif priorities[j] == min_priority:\n            priorities[j] /= 2\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if item <= 0:\n            priorities[i] = np.inf\n        elif bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] > 0 and item > bins[i]/2:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = (item - bins[i]) / item\n    \n    for j in range(len(priorities)):\n        if priorities[j] < 0.5:\n            priorities[j] = priorities[j] * 1.5\n        elif priorities[j] > 0.8:\n            priorities[j] = priorities[j] * 1.2\n        else:\n            priorities[j] = priorities[j] ** 2\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 16:19:45", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if item <= 0:\n            priorities[i] = np.inf\n        elif bins[i] >= item:\n            priorities[i] = 1.0\n        elif item < bins[i] / 2:\n            priorities[i] = item / bins[i]\n        else:\n            priority_sum = 0\n            for j in range(len(bins)):\n                if bins[j] > 0:\n                    priority_sum += bins[j]\n            priorities[i] = bins[i] / priority_sum\n    \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if item <= 0:\n            priorities[i] = np.inf\n        elif bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] > 0 and item > bins[i]/2:\n            priorities[i] = item / bins[i]\n        else:\n            priorities[i] = (item - bins[i]) / item\n    \n    max_priority = np.max(priorities)\n    min_priority = np.min(priorities)\n    \n    for j in range(len(priorities)):\n        if priorities[j] == max_priority:\n            priorities[j] *= 2\n        elif priorities[j] == min_priority:\n            priorities[j] /= 2\n            \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if item <= 0:\n            priorities[i] = np.inf\n        elif bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] > 0 and item > bins[i]/2:\n            priorities[i] = item / bins[i]\n        else:\n            priority_sum = 0\n            for j in range(len(bins)):\n                priority_sum += bins[j]\n            priorities[i] = (bins[i] + item) / priority_sum\n            \n            for k in range(len(bins)):\n                priorities[k] *= bins[k] / priority_sum\n        \n        if priorities[i] > 2:\n            priorities[i] -= 1\n        \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 16:19:54", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if item <= 0:\n            priorities[i] = np.inf\n        elif bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] > 0 and item > bins[i]/2:\n            priorities[i] = item / bins[i]\n        else:\n            priority_sum = 0\n            for j in range(len(bins)):\n                priority_sum += bins[j]\n            priorities[i] = (bins[i] + item) / priority_sum\n            \n            for k in range(len(bins)):\n                priorities[k] *= bins[k] / priority_sum\n        \n        if priorities[i] > 2:\n            priorities[i] -= 1\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if item <= 0:\n            priorities[i] = np.inf\n        elif bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] > item * 0.75:\n            priorities[i] = 0.8\n        elif bins[i] > item * 0.5:\n            priorities[i] = 0.6\n        elif bins[i] > item * 0.25:\n            priorities[i] = 0.4\n        else:\n            priorities[i] = 0.2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if item <= 0:\n            priorities[i] = np.inf\n        elif bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            priority_sum = sum(bins)\n            avg_bin_capacity = priority_sum / len(bins)\n            \n            if bins[i] > item * 0.75:\n                priorities[i] = 0.8\n            elif bins[i] > item * 0.5:\n                priorities[i] = 0.6\n            elif bins[i] > item * 0.25:\n                priorities[i] = 0.4\n            elif bins[i] > avg_bin_capacity:\n                priorities[i] = 0.2\n            else:\n                priorities[i] = 0.1\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 16:19:56", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if item <= 0:\n            priorities[i] = np.inf\n        elif bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] > 0 and item > bins[i]/2:\n            priorities[i] = item / bins[i]\n        else:\n            priority_sum = 0\n            for j in range(len(bins)):\n                priority_sum += bins[j]\n            priorities[i] = (bins[i] + item) / priority_sum\n            \n            for k in range(len(bins)):\n                priorities[k] *= bins[k] / priority_sum\n        \n        if priorities[i] > 2:\n            priorities[i] -= 1\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if item <= 0:\n            priorities[i] = np.inf\n        elif bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] > item * 0.75:\n            priorities[i] = 0.8\n        elif bins[i] > item * 0.5:\n            priorities[i] = 0.6\n        elif bins[i] > item * 0.25:\n            priorities[i] = 0.4\n        else:\n            priorities[i] = 0.2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if item <= 0:\n            priorities[i] = np.inf\n        elif bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            priority_sum = sum(bins)\n            normalized_item = item / priority_sum\n            \n            if normalized_item >= 0.3:\n                priorities[i] = normalized_item\n            elif normalized_item >= 0.2:\n                priorities[i] = normalized_item * 0.8\n            elif normalized_item >= 0.1:\n                priorities[i] = normalized_item * 0.6\n            else:\n                priorities[i] = normalized_item * 0.4\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 16:20:00", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if item <= 0:\n            priorities[i] = np.inf\n        elif bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] > 0 and item > bins[i]/2:\n            priorities[i] = item / bins[i]\n        else:\n            priority_sum = 0\n            for j in range(len(bins)):\n                priority_sum += bins[j]\n            priorities[i] = (bins[i] + item) / priority_sum\n            \n            for k in range(len(bins)):\n                priorities[k] *= bins[k] / priority_sum\n        \n        if priorities[i] > 2:\n            priorities[i] -= 1\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if item <= 0:\n            priorities[i] = np.inf\n        elif bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] > item * 0.75:\n            priorities[i] = 0.8\n        elif bins[i] > item * 0.5:\n            priorities[i] = 0.6\n        elif bins[i] > item * 0.25:\n            priorities[i] = 0.4\n        else:\n            priorities[i] = 0.2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if item <= 0:\n            priorities[i] = np.inf\n        elif bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            priority_sum = sum(bins)\n            if priority_sum == 0:\n                priorities[i] = 0.0\n            else:\n                priorities[i] = (bins[i] + item) / priority_sum\n                \n                for j in range(len(bins)):\n                    if bins[j] > 0:\n                        priorities[j] *= bins[j] / priority_sum\n        \n        if priorities[i] > 1.5:\n            priorities[i] -= 0.5\n        elif priorities[i] < 0.5:\n            priorities[i] = np.sqrt(priorities[i])\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 16:20:03", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if item <= 0:\n            priorities[i] = np.inf\n        elif bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] > 0 and item > bins[i]/2:\n            priorities[i] = item / bins[i]\n        else:\n            priority_sum = 0\n            for j in range(len(bins)):\n                priority_sum += bins[j]\n            priorities[i] = (bins[i] + item) / priority_sum\n            \n            for k in range(len(bins)):\n                priorities[k] *= bins[k] / priority_sum\n        \n        if priorities[i] > 2:\n            priorities[i] -= 1\n        \n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if item <= 0:\n            priorities[i] = np.inf\n        elif bins[i] >= item:\n            priorities[i] = 1.0\n        elif bins[i] > item * 0.75:\n            priorities[i] = 0.8\n        elif bins[i] > item * 0.5:\n            priorities[i] = 0.6\n        elif bins[i] > item * 0.25:\n            priorities[i] = 0.4\n        else:\n            priorities[i] = 0.2\n    \n    return priorities\n\n\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v1`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\ndef priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros(len(bins))\n    \n    for i in range(len(bins)):\n        if item <= 0:\n            priorities[i] = np.inf\n        elif bins[i] >= item * 1.5:\n            priorities[i] = 1.0\n        elif bins[i] > item * 1.25:\n            priorities[i] = 0.8\n        elif bins[i] > item * 1.1:\n            priorities[i] = 0.6\n        elif bins[i] > item:\n            priorities[i] = 0.4\n        else:\n            priority_sum = 0\n            for j in range(len(bins)):\n                priority_sum += bins[j]\n            priorities[i] = (bins[i] + item) / priority_sum\n            \n            for k in range(len(bins)):\n                priorities[k] *= bins[k] / priority_sum\n            \n            if priorities[i] > 1.2:\n                priorities[i] -= 0.2\n    \n    return priorities\n```", "strategy": []}
{"timestamp": "2025-04-27 16:20:08", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    if item < 0:\n        priorities.fill(-1)\n    else:\n        for i in range(len(bins)):\n            if bins[i] < item:\n                priorities[i] = -1\n            else:\n                priorities[i] = item / bins[i]\n                \n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:20:10", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "```python\nimport numpy as np\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = []\n    for bin_capacity in bins:\n        if item <= bin_capacity:\n            priority = 1.0 / item\n        else:\n            priority = 1.0 / (item - bin_capacity)\n        \n        priorities.append(priority)\n    \n    return np.array(priorities)\n```", "strategy": []}
{"timestamp": "2025-04-27 16:20:12", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            remaining_space = bins[i] - item\n            priority_score = 1 / (1 + np.exp(-remaining_space))\n            priorities[i] = priority_score\n    return priorities", "strategy": []}
{"timestamp": "2025-04-27 16:20:14", "prompt": "\nimport numpy as np\n\n\ndef priority_v0(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Returns priority with which we want to add item to each bin.\n\n    Args:\n        item: Size of item to be added to the bin.\n        bins: Array of capacities for each bin.\n\n    Return:\n        Array of same size as bins with priority score of each bin.\n    \"\"\"\n    ratios = item / bins\n    log_ratios = np.log(ratios)\n    priorities = -log_ratios\n    return priorities\n\n\ndef priority_v1(item: float, bins: np.ndarray) -> np.ndarray:\n    \"\"\"Improved version of `priority_v0`.\"\"\"\n\n\nComplete a different and more complex Python function. Be creative and you can insert multiple if-else and for-loop in the code logic.Only output the Python code, no descriptions.", "response": "def priority_v2(item: float, bins: np.ndarray) -> np.ndarray:\n    priorities = np.zeros_like(bins)\n    \n    for i in range(len(bins)):\n        if bins[i] >= item:\n            priorities[i] = 1.0\n        else:\n            priorities[i] = item / bins[i]\n    \n    return priorities", "strategy": []}
